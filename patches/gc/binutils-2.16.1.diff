diff -Nbaur --exclude=*.info* binutils-2.16.1/bfd/doc/chew.c binutils-2.16.1-new/bfd/doc/chew.c
--- binutils-2.16.1/bfd/doc/chew.c	Thu Mar  3 11:41:02 2005
+++ binutils-2.16.1-new/bfd/doc/chew.c	Mon Jun 20 00:14:07 2005
@@ -91,6 +91,12 @@
 #define DEF_SIZE 5000
 #define STACK 50
 
+#ifdef __MINGW32__
+/* Prevent \r\n\ line endings */
+#include <fcntl.h>
+unsigned int _CRT_fmode = _O_BINARY;
+#endif
+
 int internal_wanted;
 int internal_mode;
 
diff -Nbaur --exclude=*.info* binutils-2.16.1/config.sub binutils-2.16.1-new/config.sub
--- binutils-2.16.1/config.sub	Wed Jan 19 00:34:56 2005
+++ binutils-2.16.1-new/config.sub	Mon Jun 20 00:14:07 2005
@@ -219,6 +219,10 @@
 		basic_machine=m68k-atari
 		os=-mint
 		;;
+	-gekko)
+		basic_machine=powerpc-eabi
+		os=-elf
+		;;
 esac
 
 # Decode aliases for certain CPU-COMPANY combinations.
diff -Nbaur --exclude=*.info* binutils-2.16.1/configure.in binutils-2.16.1-new/configure.in
--- binutils-2.16.1/configure.in	Sun Jun 12 20:33:06 2005
+++ binutils-2.16.1-new/configure.in	Mon Jun 20 00:53:42 2005
@@ -242,7 +242,7 @@
 
 # Some tools are only suitable for building in a "native" situation.
 # Remove these if host!=target.  
-native_only="autoconf automake libtool fileutils find gawk gettext gzip hello indent m4 rcs recode sed shellutils tar textutils uudecode wdiff gprof target-groff guile perl time ash bash bzip2 prms gnuserv target-gperf"
+native_only="autoconf automake libtool fileutils find gawk gettext gzip hello indent m4 rcs recode sed shellutils tar textutils uudecode wdiff target-groff guile perl time ash bash bzip2 prms gnuserv target-gperf"
 
 # Similarly, some are only suitable for cross toolchains.
 # Remove these if host=target.
diff -Nbaur --exclude=*.info* binutils-2.16.1/gas/config/tc-ppc.c binutils-2.16.1-new/gas/config/tc-ppc.c
--- binutils-2.16.1/gas/config/tc-ppc.c	Wed Mar  2 13:24:01 2005
+++ binutils-2.16.1-new/gas/config/tc-ppc.c	Mon Jun 20 00:14:07 2005
@@ -310,6 +310,7 @@
    sdr1           has the value 25
    srr0           has the value 26
    srr1           has the value 27
+   gqr0..7		  has the value 912..919
 
    The table is sorted. Suitable for searching by a binary search.  */
 
@@ -407,6 +408,15 @@
 
   { "fpscr", 0 },
 
+  { "gqr0", 912},
+  { "gqr1", 913},
+  { "gqr2", 914},
+  { "gqr3", 915},
+  { "gqr4", 916},
+  { "gqr5", 917},
+  { "gqr6", 918},
+  { "gqr7", 919},
+
   { "lr", 8 },     /* Link Register */
 
   { "pmr", 0 },
@@ -906,6 +916,9 @@
       ppc_cpu = (PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC
 		 | PPC_OPCODE_64 | PPC_OPCODE_POWER4);
     }
+	else if (strcmp (arg, "gekko") == 0)
+		ppc_cpu = PPC_OPCODE_CLASSIC | PPC_OPCODE_PPC | PPC_OPCODE_32 | PPC_OPCODE_GEKKO;
+
   /* -mcom means assemble for the common intersection between Power
      and PowerPC.  At present, we just allow the union, rather
      than the intersection.  */
@@ -1107,7 +1120,9 @@
 -me500, -me500x2	generate code for Motorola e500 core complex\n\
 -mspe			generate code for Motorola SPE instructions\n\
 -mregnames		Allow symbolic names for registers\n\
--mno-regnames		Do not allow symbolic names for registers\n"));
+-mno-regnames		Do not allow symbolic names for registers\n\
+-mspe			generate code for Motorola SPE instructions\n\
+-mgekko			generate code for PowerPC Gekko\n"));
 #ifdef OBJ_ELF
   fprintf (stream, _("\
 -mrelocatable		support for GCC's -mrelocatble option\n\
@@ -1150,6 +1165,8 @@
 	  else
 	    ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32;
 	}
+	  else if (strcmp(default_cpu, "gekko") == 0)
+		ppc_cpu = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_32 | PPC_OPCODE_GEKKO;
       else
 	as_fatal (_("Unknown default cpu = %s, os = %s"),
 		  default_cpu, default_os);
@@ -2570,6 +2587,26 @@
 	{
 	  endc = ')';
 	  need_paren = 0;
+	  if (opindex_ptr[1])
+	  {
+	    /* do check here if we have further opcodes */
+	    if (*str != endc && (endc != ',' || *str != '\0'))
+	    {
+	      as_bad(_("syntax error; found `%c' but expected `%c'"),*str,endc);
+	      break;
+	    }
+	    /* we have to move over whitespace ourselves */
+	    if (*str != '\0')
+	    {
+	      ++str;
+	      while (ISSPACE(*str))
+	      {
+		++str;
+	      }
+	    }
+	    /* now we're looking for the comma */
+	    endc = ',';
+	  }
 	}
       else if ((operand->flags & PPC_OPERAND_PARENS) != 0)
 	{
@@ -2588,6 +2625,8 @@
 	  break;
 	}
 
+      /* The call to expression should have advanced str past any
+	 whitespace.  */
       if (*str != '\0')
 	++str;
     }
diff -Nbaur --exclude=*.info* binutils-2.16.1/include/opcode/ppc.h binutils-2.16.1-new/include/opcode/ppc.h
--- binutils-2.16.1/include/opcode/ppc.h	Thu Sep  9 13:42:37 2004
+++ binutils-2.16.1-new/include/opcode/ppc.h	Mon Jun 20 00:14:07 2005
@@ -134,6 +134,9 @@
 /* Opcode is supported by machine check APU.  */
 #define PPC_OPCODE_RFMCI	  0x800000
 
+/* Opcode is only supported by the PowerPC Gekko processor.  */
+#define PPC_OPCODE_GEKKO    (040000000)
+
 /* A macro to extract the major opcode from an instruction.  */
 #define PPC_OP(i) (((i) >> 26) & 0x3f)
 
@@ -281,6 +284,10 @@
 /* This operand is for the DQ field in a DQ form instruction.  */
 #define PPC_OPERAND_DQ (0100000)
 
+/* This operand names a quantization register.  The disassembler
+   prints these with a leading 'gqr'.  */
+#define PPC_OPERAND_GQR (040000)
+
 /* The POWER and PowerPC assemblers use a few macros.  We keep them
    with the operands table for simplicity.  The macro table is an
    array of struct powerpc_macro.  */
diff -Nbaur --exclude=*.info* binutils-2.16.1/opcodes/ppc-dis.c binutils-2.16.1-new/opcodes/ppc-dis.c
--- binutils-2.16.1/opcodes/ppc-dis.c	Tue Mar 22 15:31:19 2005
+++ binutils-2.16.1-new/opcodes/ppc-dis.c	Mon Jun 20 00:14:07 2005
@@ -64,6 +64,13 @@
 	   && strstr (info->disassembler_options, "efs") != NULL)
     dialect |= PPC_OPCODE_EFS;
   else
+	if (info->disassembler_options
+	&& (strstr (info->disassembler_options, "gekko") == 0))
+	  {
+    dialect |= PPC_OPCODE_GEKKO;
+    dialect &= ~PPC_OPCODE_ALTIVEC;
+	  }
+  else
     dialect |= (PPC_OPCODE_403 | PPC_OPCODE_601 | PPC_OPCODE_CLASSIC
 		| PPC_OPCODE_COMMON | PPC_OPCODE_ALTIVEC);
 
@@ -239,6 +246,8 @@
 	    (*info->print_address_func) (memaddr + value, info);
 	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
 	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
+	  else if ((operand->flags & PPC_OPERAND_GQR) != 0)
+	    (*info->fprintf_func) (info->stream, "gqr%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_CR) == 0
 		   || (dialect & PPC_OPCODE_PPC) == 0)
 	    (*info->fprintf_func) (info->stream, "%ld", value);
@@ -304,4 +313,5 @@
   fprintf (stream, "  power4                   Disassemble the Power4 instructions\n");
   fprintf (stream, "  32                       Do not disassemble 64-bit instructions\n");
   fprintf (stream, "  64                       Allow disassembly of 64-bit instructions\n");
+  fprintf (stream, "  gekko                    Disassemble the Gamecube Gekko instructions\n");
 }
diff -Nbaur --exclude=*.info* binutils-2.16.1/opcodes/ppc-opc.c binutils-2.16.1-new/opcodes/ppc-opc.c
--- binutils-2.16.1/opcodes/ppc-opc.c	Tue Apr 19 18:09:56 2005
+++ binutils-2.16.1-new/opcodes/ppc-opc.c	Mon Jun 20 00:14:07 2005
@@ -93,6 +93,13 @@
 static unsigned long insert_ev8 (unsigned long, long, int, const char **);
 static long extract_ev8 (unsigned long, int, int *);
 
+static unsigned long insert_psq_gd (unsigned long, long, int, const char **);
+static long extract_psq_gd (unsigned long, int, int *);
+static unsigned long insert_psq_gx (unsigned long, long, int, const char **);
+static long extract_psq_gx (unsigned long, int, int *);
+
+
+
 /* The operands table.
 
    The fields are bits, shift, insert, extract, flags.
@@ -558,6 +565,25 @@
 #define MTMSRD_L WS + 1
   { 1, 16, NULL, NULL, PPC_OPERAND_OPTIONAL },
 
+  /* I Field in psq_ instructions */
+#define PSQ_DD MTMSRD_L + 1
+  { 12, 0, 0, 0, PPC_OPERAND_PARENS|PPC_OPERAND_SIGNED },
+
+  /* W Field in psq_ instructions */
+#define PSQ_WD PSQ_DD + 1
+  { 1, 15, 0, 0, 0 },
+
+  /* d Field in psq_ instructions */
+#define PSQ_GD PSQ_WD + 1
+  { 10, 12, insert_psq_gd, extract_psq_gd, PPC_OPERAND_GQR },
+
+  /* I Field in psq_ instructions A*/
+#define PSQ_WX PSQ_GD + 1
+  { 1, 10, 0, 0, 0 },
+
+  /* W Field in psq_ instructions */
+#define PSQ_GX PSQ_WX + 1
+  { 10, 7, insert_psq_gx, extract_psq_gx, PPC_OPERAND_GQR },
 };
 
 /* The functions used to insert and extract complicated operands.  */
@@ -1432,6 +1458,48 @@
   return ret;
 }
 
+static unsigned long
+insert_psq_gd (unsigned long insn,
+	       long value,
+	       int dialect ATTRIBUTE_UNUSED,
+	       const char **errmsg)
+{
+  if (value >= 912 && value <= 919)
+    value -= 912;
+  if (value < 0 || value > 7)
+    *errmsg = _("invalid quantization register");
+  return insn | ((value & 7) << 12);
+}
+
+static long
+extract_psq_gd (unsigned long insn,
+		int dialect ATTRIBUTE_UNUSED,
+		int *invalid ATTRIBUTE_UNUSED)
+{
+  return ((insn & 0x7000) >> 12);
+}
+
+static unsigned long
+insert_psq_gx (unsigned long insn,
+	       long value,
+	       int dialect ATTRIBUTE_UNUSED,
+	       const char **errmsg)
+{
+  if (value >= 912 && value <= 919)
+    value -= 912;
+  if (value < 0 || value > 7)
+    *errmsg = _("invalid quantization register");
+  return insn | ((value & 7) << 7);
+}
+
+static long
+extract_psq_gx (unsigned long insn,
+		int dialect ATTRIBUTE_UNUSED,
+		int *invalid ATTRIBUTE_UNUSED)
+{
+  return ((insn & 0x380) >> 7);
+}
+
 /* Macros used to form opcodes.  */
 
 /* The main opcode.  */
@@ -1715,6 +1783,10 @@
 #define XUC(op, xop)  (OP (op) | (((unsigned long)(xop)) & 0x1f))
 #define XUC_MASK      XUC(0x3f, 0x1f)
 
+/* A PSQ style load/store indexed */
+#define PSQX(op, xop) (OP (op) | (((unsigned long)(xop)) & 0x7f))
+#define PSQX_MASK     PSQX(0x3f,0x7f)
+
 /* The BO encodings used in extended conditional branch mnemonics.  */
 #define BODNZF	(0x0)
 #define BODNZFP	(0x1)
@@ -1805,6 +1877,7 @@
 #define PPCCHLK	PPC_OPCODE_CACHELCK
 #define PPCCHLK64	PPC_OPCODE_CACHELCK | PPC_OPCODE_BOOKE64
 #define PPCRFMCI	PPC_OPCODE_RFMCI
+#define PPCGEKKO	PPC_OPCODE_GEKKO
 
 /* The opcode table.
 
@@ -4612,6 +4685,99 @@
 
 { "fcfid",   XRC(63,846,0), XRA_MASK,	PPC64,		{ FRT, FRB } },
 { "fcfid.",  XRC(63,846,1), XRA_MASK,	PPC64,		{ FRT, FRB } },
+
+/* GEKKO specific stuff */
+{ "dcbz_l",   X(4,1014), XRT_MASK, PPCGEKKO, { RA, RB }},
+  
+{ "ps_abs",   XRC(4,264,0), XRA_MASK, PPCGEKKO, { FRT,FRB }},
+{ "ps_abs.",   XRC(4,264,1), XRA_MASK, PPCGEKKO, { FRT,FRB }},
+
+{ "ps_add",   A(4,21,0), AFRC_MASK, PPCGEKKO, { FRT, FRA, FRB }},
+{ "ps_add.",  A(4,21,1), AFRC_MASK, PPCGEKKO, { FRT, FRA, FRB }},
+
+{ "ps_cmpo0", X(4,32), X_MASK|(3<<21), PPCGEKKO, { BF, FRA, FRB }},
+{ "ps_cmpo1", X(4,96), X_MASK|(3<<21), PPCGEKKO, { BF, FRA, FRB }},
+
+{ "ps_cmpu0", X(4,0), X_MASK|(3<<21), PPCGEKKO, { BF, FRA, FRB }},
+{ "ps_cmpu1", X(4,64), X_MASK|(3<<21), PPCGEKKO, { BF, FRA, FRB }},
+
+{ "ps_div",   A(4,18,0), AFRC_MASK, PPCGEKKO, { FRT, FRA, FRB }},
+{ "ps_div.",  A(4,18,1), AFRC_MASK, PPCGEKKO, { FRT, FRA, FRB }},
+
+{ "ps_madd",   A(4,29,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_madd.",  A(4,29,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_madds0",   A(4,14,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_madds0.",  A(4,14,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_madds1",   A(4,15,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_madds1.",  A(4,15,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_merge00",   XRC(4,528,0), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+{ "ps_merge00.",  XRC(4,528,1), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+
+{ "ps_merge01",   XRC(4,560,0), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+{ "ps_merge01.",  XRC(4,560,1), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+
+{ "ps_merge10",   XRC(4,592,0), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+{ "ps_merge10.",  XRC(4,592,1), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+
+{ "ps_merge11",   XRC(4,624,0), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+{ "ps_merge11.",  XRC(4,624,1), X_MASK, PPCGEKKO, { FRT,FRA,FRB }},
+
+{ "ps_mr",   XRC(4,72,0), XRA_MASK, PPCGEKKO, { FRT, FRB }},
+{ "ps_mr.",  XRC(4,72,1), XRA_MASK, PPCGEKKO, { FRT, FRB }},
+
+{ "ps_msub",   A(4,28,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_msub.",  A(4,28,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_mul",   A(4,25,0), AFRB_MASK, PPCGEKKO, { FRT,FRA,FRC }},
+{ "ps_mul.",  A(4,25,1), AFRB_MASK, PPCGEKKO, { FRT,FRA,FRC }},
+
+{ "ps_muls0",   A(4,12,0), AFRB_MASK, PPCGEKKO, { FRT,FRA,FRC }},
+{ "ps_muls0.",  A(4,12,1), AFRB_MASK, PPCGEKKO, { FRT,FRA,FRC }},
+
+{ "ps_muls1",   A(4,13,0), AFRB_MASK, PPCGEKKO, { FRT,FRA,FRC }},
+{ "ps_muls1.",  A(4,13,1), AFRB_MASK, PPCGEKKO, { FRT,FRA,FRC }},
+
+{ "ps_nabs",   XRC(4,136,0), XRA_MASK, PPCGEKKO, { FRT, FRB }},
+{ "ps_nabs.",  XRC(4,136,1), XRA_MASK, PPCGEKKO, { FRT, FRB }},
+
+{ "ps_neg",   XRC(4,40,0), XRA_MASK, PPCGEKKO, { FRT, FRB }},
+{ "ps_neg.",  XRC(4,40,1), XRA_MASK, PPCGEKKO, { FRT, FRB }},
+
+{ "ps_nmadd",   A(4,31,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_nmadd.",  A(4,31,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_nmsub",   A(4,30,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_nmsub.",  A(4,30,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_res",   A(4,13,0), AFRAFRC_MASK, PPCGEKKO, { FRT,FRB }},
+{ "ps_res.",  A(4,13,1), AFRAFRC_MASK, PPCGEKKO, { FRT,FRB }},
+
+{ "ps_rsqrte",   A(4,26,0), AFRAFRC_MASK, PPCGEKKO, { FRT,FRB }},
+{ "ps_rsqrte.",  A(4,26,1), AFRAFRC_MASK, PPCGEKKO, { FRT,FRB }},
+
+{ "ps_sel",   A(4,23,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_sel.",  A(4,23,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_sub",   A(4,20,0), AFRC_MASK, PPCGEKKO, { FRT, FRA, FRB }},
+{ "ps_sub.",  A(4,20,1), AFRC_MASK, PPCGEKKO, { FRT, FRA, FRB }},
+
+{ "ps_sum0",   A(4,10,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_sum0.",  A(4,10,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "ps_sum1",   A(4,11,0), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+{ "ps_sum1.",  A(4,11,1), A_MASK, PPCGEKKO, { FRT,FRA,FRC,FRB }},
+
+{ "psq_l",     OP(56),    OP_MASK, PPCGEKKO, { FRT,PSQ_DD,RA,PSQ_WD,PSQ_GD }},
+{ "psq_lu",    OP(57),    OP_MASK, PPCGEKKO, { FRT,PSQ_DD,RA,PSQ_WD,PSQ_GD }},
+{ "psq_lux",   PSQX(4,76),PSQX_MASK, PPCGEKKO, { FRT,RA,RB,PSQ_WX,PSQ_GX }},
+{ "psq_lx",    PSQX(4,12),PSQX_MASK, PPCGEKKO, { FRT,RA,RB,PSQ_WX,PSQ_GX }},
+{ "psq_st",    OP(60),    OP_MASK, PPCGEKKO, { FRT,PSQ_DD,RA,PSQ_WD,PSQ_GD }},
+{ "psq_stu",   OP(61),    OP_MASK, PPCGEKKO, { FRT,PSQ_DD,RA,PSQ_WD,PSQ_GD }},
+{ "psq_stux",  PSQX(4,78), PSQX_MASK, PPCGEKKO, { FRT,RA,RB,PSQ_WX,PSQ_GX }},
+{ "psq_stx",   PSQX(4,14),  PSQX_MASK, PPCGEKKO, { FRT,RA,RB,PSQ_WX,PSQ_GX }},
 
 };
 
