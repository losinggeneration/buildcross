diff -ruN gcc-7.3.0/ChangeLog gcc-7.3.0-msp430/ChangeLog
--- gcc-7.3.0/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/ChangeLog	2019-06-25 02:27:21.053931761 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/config/acx.m4 gcc-7.3.0-msp430/config/acx.m4
--- gcc-7.3.0/config/acx.m4	2017-01-17 01:38:48.048122000 -0800
+++ gcc-7.3.0-msp430/config/acx.m4	2019-06-25 02:27:21.053931761 -0700
@@ -246,7 +246,7 @@
   [AS_HELP_STRING([--with-gcc-major-version-only], [use only GCC major number in filesystem paths])],
   [if test x$with_gcc_major_version_only = xyes ; then
     changequote(,)dnl
-    get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+    get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
     changequote([,])dnl
   fi
   ])
diff -ruN gcc-7.3.0/config/ChangeLog gcc-7.3.0-msp430/config/ChangeLog
--- gcc-7.3.0/config/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/config/ChangeLog	2019-06-25 02:27:21.053931761 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* acx.m4 (GCC_BASE_VER): Remove \$\$ from sed expression.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/config/mt-ospace gcc-7.3.0-msp430/config/mt-ospace
--- gcc-7.3.0/config/mt-ospace	2014-11-18 14:12:52.686034000 -0800
+++ gcc-7.3.0-msp430/config/mt-ospace	2019-06-25 02:27:21.053931761 -0700
@@ -1,3 +1,3 @@
 # Build libraries optimizing for space, not speed.
- CFLAGS_FOR_TARGET += -g -Os
- CXXFLAGS_FOR_TARGET += -g -Os
+ CFLAGS_FOR_TARGET += -g -Os -ffunction-sections -fdata-sections -mOs
+ CXXFLAGS_FOR_TARGET += -g -Os -ffunction-sections -fdata-sections -mOs
diff -ruN gcc-7.3.0/configure gcc-7.3.0-msp430/configure
--- gcc-7.3.0/configure	2017-03-22 10:51:18.122275000 -0700
+++ gcc-7.3.0-msp430/configure	2019-06-25 02:27:21.057931733 -0700
@@ -6620,7 +6620,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/dev/null gcc-7.3.0-msp430/dev/null
--- gcc-7.3.0/dev/null	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/dev/null	2019-06-25 02:27:32.305851262 -0700
@@ -0,0 +1,46 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// PR libstdc++/68397 -  std::tr1::expint fails in __expint_En_cont_frac
+// for some long double arguments due to low __max_iter value
+
+#include <tr1/cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  // Answers from Wolfram Alpha.
+  long double ans_ok = -0.10001943365331651406888645149537315243646135979573L;
+  long double ans_bomb = -0.10777727809650077516264612749163100483995270163783L;
+
+  long double Ei_ok = std::tr1::expint(-1.500001L);
+  long double diff_ok = std::abs(Ei_ok - ans_ok);
+  VERIFY(diff_ok < 1.0e-15L);
+
+  long double Ei_bomb = std::tr1::expint(-1.450001L);
+  long double diff_bomb = std::abs(Ei_bomb - ans_bomb);
+  VERIFY(diff_bomb < 1.0e-15L);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
+
diff -ruN gcc-7.3.0/fixincludes/ChangeLog gcc-7.3.0-msp430/fixincludes/ChangeLog
--- gcc-7.3.0/fixincludes/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/fixincludes/ChangeLog	2019-06-25 02:27:21.057931733 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/fixincludes/configure gcc-7.3.0-msp430/fixincludes/configure
--- gcc-7.3.0/fixincludes/configure	2017-01-17 01:38:48.048122000 -0800
+++ gcc-7.3.0-msp430/fixincludes/configure	2019-06-25 02:27:21.057931733 -0700
@@ -5401,7 +5401,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/gcc/ada/ChangeLog gcc-7.3.0-msp430/gcc/ada/ChangeLog
--- gcc-7.3.0/gcc/ada/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/gcc/ada/ChangeLog	2019-06-25 02:27:21.057931733 -0700
@@ -1,3 +1,101 @@
+2018-07-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (choices_to_gnu): Rename parameters.  Deal with
+	an operand of Character type.  Factor out range generation to the end.
+	Check that the bounds are literals and convert them to the type of the
+	operand before building the ranges.
+	* gcc-interface/utils.c (make_dummy_type): Minor tweak.
+	(make_packable_type): Propagate TYPE_DEBUG_TYPE.
+	(maybe_pad_type): Likewise.
+
+2018-07-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Deal with
+	more rvalues in the expression of a renaming.
+
+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/ada-tree.h (TYPE_RETURN_BY_DIRECT_REF_P): Change from
+	using TYPE_LANG_FLAG_4 to using TYPE_LANG_FLAG_0.
+	(TYPE_ALIGN_OK): Move around.
+	(TYPE_PADDING_FOR_COMPONENT): Remove superfluous parentheses.
+	* gcc-interface/decl.c (change_qualified_type): Move to...
+	(gnat_to_gnu_entity): Adjust comment.
+	* gcc-interface/gigi.h (change_qualified_type): ...here; make inline.
+	(ceil_pow2): Use ceil_log2.
+	* gcc-interface/utils.c (finish_subprog_decl): Add couple of comments
+	and do not set TREE_SIDE_EFFECTS.
+	(handle_noreturn_attribute): Use change_qualified_type.
+
+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Constant>: Do not get
+	the expression of a dispatch table that is not being defined.
+	<E_Record_Subtype>: Remove obsolete kludge.
+
+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backpor from mainline
+	2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Constant>: If this is
+	not a definition, retrieve the expression only if it's a compile-time
+	known value if we are just annotating types.
+
+	* gcc-interface/utils.c (convert): Do not try to upcast properly for a
+	conversion between tagged types in type_annotate_only mode.
+
+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-06-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Reuse the
+	existing fields of a dummy fat pointer type, if any.  Clear the
+	TYPE_DECL_SUPPRESS_DEBUG on the fat pointer type after completing it.
+
+2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/ada-tree.h (TYPE_PADDING_FOR_COMPONENT): New macro.
+	* gcc-interface/decl.c (gnat_to_gnu_component_type): Cache the padding
+	type built for an aliased component with variable size.
+
+2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-05-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Call_to_gnu): If this is a function call and
+	there is no target, also create a temporary for the return value for
+	an allocator if the type is an unconstrained record type with default
+	discriminant.
+
+2018-04-12  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2018-03-07  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* gcc-interface/Makefile.in (OSCONS_CPP): Remove redundant
+	$(GNATLIBCFLAGS).
+	(OSCONS_EXTRACT): Add $(GNATLIBCFLAGS_FOR_C).
+
+2018-03-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/82813
+	* gcc-interface/misc.c (gnat_post_options): Disable string overflow
+	warnings.
+
+2018-03-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (node_has_volatile_full_access) <N_Identifier>:
+	Consider only entities for objects.
+
+2018-03-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (convert_with_check): Fix typo in the condition
+	guarding the overflow check emitted for the upper bound of a floating-
+	point conversion.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/gcc/ada/gcc-interface/ada-tree.h gcc-7.3.0-msp430/gcc/ada/gcc-interface/ada-tree.h
--- gcc-7.3.0/gcc/ada/gcc-interface/ada-tree.h	2016-07-11 08:02:12.090258000 -0700
+++ gcc-7.3.0-msp430/gcc/ada/gcc-interface/ada-tree.h	2019-06-25 02:27:21.057931733 -0700
@@ -6,7 +6,7 @@
  *                                                                          *
  *                              C Header File                               *
  *                                                                          *
- *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *
+ *          Copyright (C) 1992-2018, Free Software Foundation, Inc.         *
  *                                                                          *
  * GNAT is free software;  you can  redistribute it  and/or modify it under *
  * terms of the  GNU General Public License as published  by the Free Soft- *
@@ -83,6 +83,12 @@
   ((TREE_CODE (NODE) == INTEGER_TYPE || TREE_CODE (NODE) == ARRAY_TYPE) \
    && TYPE_PACKED_ARRAY_TYPE_P (NODE))
 
+/* For FUNCTION_TYPEs, nonzero if the function returns by direct reference,
+   i.e. the callee returns a pointer to a memory location it has allocated
+   and the caller only needs to dereference the pointer.  */
+#define TYPE_RETURN_BY_DIRECT_REF_P(NODE) \
+  TYPE_LANG_FLAG_0 (FUNCTION_TYPE_CHECK (NODE))
+
 /* For INTEGER_TYPE, nonzero if this is a modular type with a modulus that
    is not equal to two to the power of its mode's size.  */
 #define TYPE_MODULAR_P(NODE) TYPE_LANG_FLAG_1 (INTEGER_TYPE_CHECK (NODE))
@@ -152,12 +158,6 @@
 #define TYPE_CONVENTION_FORTRAN_P(NODE) \
   TYPE_LANG_FLAG_4 (ARRAY_TYPE_CHECK (NODE))
 
-/* For FUNCTION_TYPEs, nonzero if the function returns by direct reference,
-   i.e. the callee returns a pointer to a memory location it has allocated
-   and the caller only needs to dereference the pointer.  */
-#define TYPE_RETURN_BY_DIRECT_REF_P(NODE) \
-  TYPE_LANG_FLAG_4 (FUNCTION_TYPE_CHECK (NODE))
-
 /* For RECORD_TYPE, UNION_TYPE and ENUMERAL_TYPE, nonzero if this is a dummy
    type, made to correspond to a private or incomplete type.  */
 #define TYPE_DUMMY_P(NODE) \
@@ -186,6 +186,9 @@
 /* True for a dummy type if TYPE appears in a profile.  */
 #define TYPE_DUMMY_IN_PROFILE_P(NODE) TYPE_LANG_FLAG_6 (NODE)
 
+/* True if objects of this type are guaranteed to be properly aligned.  */
+#define TYPE_ALIGN_OK(NODE) TYPE_LANG_FLAG_7 (NODE)
+
 /* True for types that implement a packed array and for original packed array
    types.  */
 #define TYPE_IMPL_PACKED_ARRAY_P(NODE) \
@@ -199,9 +202,6 @@
    alignment value the type ought to have.  */
 #define TYPE_MAX_ALIGN(NODE) (TYPE_PRECISION (RECORD_OR_UNION_CHECK (NODE)))
 
-/* True if objects of tagged types are guaranteed to be properly aligned.  */
-#define TYPE_ALIGN_OK(NODE) TYPE_LANG_FLAG_7 (NODE)
-
 /* For an UNCONSTRAINED_ARRAY_TYPE, this is the record containing both the
    template and the object.
 
@@ -232,6 +232,11 @@
    refer to the routine gnat_to_gnu_entity.  */
 #define TYPE_CI_CO_LIST(NODE) TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))
 
+/* For an ARRAY_TYPE with variable size, this is the padding type built for
+   the array type when it is itself the component type of another array.  */
+#define TYPE_PADDING_FOR_COMPONENT(NODE) \
+  TYPE_LANG_SLOT_1 (ARRAY_TYPE_CHECK (NODE))
+
 /* For a VECTOR_TYPE, this is the representative array type.  */
 #define TYPE_REPRESENTATIVE_ARRAY(NODE) \
   TYPE_LANG_SLOT_1 (VECTOR_TYPE_CHECK (NODE))
diff -ruN gcc-7.3.0/gcc/ada/gcc-interface/decl.c gcc-7.3.0-msp430/gcc/ada/gcc-interface/decl.c
--- gcc-7.3.0/gcc/ada/gcc-interface/decl.c	2017-12-14 09:05:43.652230000 -0800
+++ gcc-7.3.0-msp430/gcc/ada/gcc-interface/decl.c	2019-06-25 02:27:21.061931705 -0700
@@ -206,7 +206,6 @@
 static tree gnat_to_gnu_subprog_type (Entity_Id, bool, bool, tree *);
 static tree gnat_to_gnu_field (Entity_Id, tree, int, bool, bool);
 static tree gnu_ext_name_for_subprog (Entity_Id, tree);
-static tree change_qualified_type (tree, int);
 static void set_nonaliased_component_on_array_type (tree);
 static void set_reverse_storage_order_on_array_type (tree);
 static bool same_discriminant_p (Entity_Id, Entity_Id);
@@ -592,17 +591,22 @@
       /* If we have a constant that we are not defining, get the expression it
 	 was defined to represent.  This is necessary to avoid generating dumb
 	 elaboration code in simple cases, but we may throw it away later if it
-	 is not a constant.  But do not retrieve it if it is an allocator since
-	 the designated type might still be dummy at this point.  */
+	 is not a constant.  But do not do it for dispatch tables because they
+	 are only referenced indirectly and we need to have a consistent view
+	 of the exported and of the imported declarations of the tables from
+	 external units for them to be properly merged in LTO mode.  Moreover
+	 simply do not retrieve the expression it if it is an allocator since
+	 the designated type might still be dummy at this point.  Note that we
+	 invoke gnat_to_gnu_external and not gnat_to_gnu because the expression
+	 may contain N_Expression_With_Actions nodes and thus declarations of
+	 objects from other units that we need to discard.  */
       if (!definition
 	  && !No_Initialization (Declaration_Node (gnat_entity))
-	  && Present (Expression (Declaration_Node (gnat_entity)))
-	  && Nkind (Expression (Declaration_Node (gnat_entity)))
-	     != N_Allocator)
-	  /* The expression may contain N_Expression_With_Actions nodes and
-	     thus object declarations from other units.  Discard them.  */
-	gnu_expr
-	  = gnat_to_gnu_external (Expression (Declaration_Node (gnat_entity)));
+	  && !Is_Dispatch_Table_Entity (gnat_entity)
+	  && Present (gnat_temp = Expression (Declaration_Node (gnat_entity)))
+	  && Nkind (gnat_temp) != N_Allocator
+	  && (!type_annotate_only || Compile_Time_Known_Value (gnat_temp)))
+	gnu_expr = gnat_to_gnu_external (gnat_temp);
 
       /* ... fall through ... */
 
@@ -968,8 +972,7 @@
 	       function call is a constant object.  Therefore, it can be the
 	       inner object of a constant renaming and the renaming must be
 	       fully instantiated, i.e. it cannot be a reference to (part of)
-	       an existing object.  And treat other rvalues (addresses, null
-	       expressions, constructors and literals) the same way.  */
+	       an existing object.  And treat other rvalues the same way.  */
 	    tree inner = gnu_expr;
 	    while (handled_component_p (inner) || CONVERT_EXPR_P (inner))
 	      inner = TREE_OPERAND (inner, 0);
@@ -980,11 +983,11 @@
 	      inner = TREE_OPERAND (inner, 1);
 	    if ((TREE_CODE (inner) == CALL_EXPR
 		 && !call_is_atomic_load (inner))
-		|| TREE_CODE (inner) == ADDR_EXPR
-		|| TREE_CODE (inner) == NULL_EXPR
-		|| TREE_CODE (inner) == PLUS_EXPR
 		|| TREE_CODE (inner) == CONSTRUCTOR
 		|| CONSTANT_CLASS_P (inner)
+		|| COMPARISON_CLASS_P (inner)
+		|| BINARY_CLASS_P (inner)
+		|| EXPRESSION_CLASS_P (inner)
 		/* We need to detect the case where a temporary is created to
 		   hold the return value, since we cannot safely rename it at
 		   top level as it lives only in the elaboration routine.  */
@@ -1006,7 +1009,7 @@
 		   underlying object lives only in the elaboration routine.  */
 		|| (TREE_CODE (inner) == INDIRECT_REF
 		    && (inner
-			  = remove_conversions (TREE_OPERAND (inner, 0), true))
+			= remove_conversions (TREE_OPERAND (inner, 0), true))
 		    && TREE_CODE (inner) == VAR_DECL
 		    && DECL_RETURN_VALUE_P (inner)))
 	      ;
@@ -2063,11 +2066,16 @@
 	  {
 	    gnu_fat_type = TYPE_MAIN_VARIANT (TYPE_POINTER_TO (gnu_type));
 	    TYPE_NAME (gnu_fat_type) = NULL_TREE;
-	    /* Save the contents of the dummy type for update_pointer_to.  */
-	    TYPE_POINTER_TO (gnu_type) = copy_type (gnu_fat_type);
 	    gnu_ptr_template =
-	      TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_fat_type)));
+	      TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_fat_type)));
 	    gnu_template_type = TREE_TYPE (gnu_ptr_template);
+
+	    /* Save the contents of the dummy type for update_pointer_to.  */
+	    TYPE_POINTER_TO (gnu_type) = copy_type (gnu_fat_type);
+	    TYPE_FIELDS (TYPE_POINTER_TO (gnu_type))
+	      = copy_node (TYPE_FIELDS (gnu_fat_type));
+	    DECL_CHAIN (TYPE_FIELDS (TYPE_POINTER_TO (gnu_type)))
+	      = copy_node (DECL_CHAIN (TYPE_FIELDS (gnu_fat_type)));
 	  }
 	else
 	  {
@@ -2088,29 +2096,39 @@
 
 	/* Build the fat pointer type.  Use a "void *" object instead of
 	   a pointer to the array type since we don't have the array type
-	   yet (it will reference the fat pointer via the bounds).  */
-	tem
-	  = create_field_decl (get_identifier ("P_ARRAY"), ptr_type_node,
-			       gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);
-	DECL_CHAIN (tem)
-	  = create_field_decl (get_identifier ("P_BOUNDS"), gnu_ptr_template,
-			       gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);
+	   yet (it will reference the fat pointer via the bounds).  Note
+	   that we reuse the existing fields of a dummy type because for:
 
+	     type Arr is array (Positive range <>) of Element_Type;
+	     type Array_Ref is access Arr;
+	     Var : Array_Ref := Null;
+
+	   in a declarative part, Arr will be frozen only after Var, which
+	   means that the fields used in the CONSTRUCTOR built for Null are
+	   those of the dummy type, which in turn means that COMPONENT_REFs
+	   of Var may be built with these fields.  Now if COMPONENT_REFs of
+	   Var are also built later with the fields of the final type, the
+	   aliasing machinery may consider that the accesses are distinct
+	   if the FIELD_DECLs are distinct as objects.  */
 	if (COMPLETE_TYPE_P (gnu_fat_type))
 	  {
-	    /* We are going to lay it out again so reset the alias set.  */
-	    alias_set_type alias_set = TYPE_ALIAS_SET (gnu_fat_type);
-	    TYPE_ALIAS_SET (gnu_fat_type) = -1;
-	    finish_fat_pointer_type (gnu_fat_type, tem);
-	    TYPE_ALIAS_SET (gnu_fat_type) = alias_set;
+	    tem = TYPE_FIELDS (gnu_fat_type);
+	    TREE_TYPE (tem) = ptr_type_node;
+	    TREE_TYPE (DECL_CHAIN (tem)) = gnu_ptr_template;
+	    TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (gnu_fat_type)) = 0;
 	    for (t = gnu_fat_type; t; t = TYPE_NEXT_VARIANT (t))
-	      {
-		TYPE_FIELDS (t) = tem;
-		SET_TYPE_UNCONSTRAINED_ARRAY (t, gnu_type);
-	      }
+	      SET_TYPE_UNCONSTRAINED_ARRAY (t, gnu_type);
 	  }
 	else
 	  {
+	    tem
+	      = create_field_decl (get_identifier ("P_ARRAY"),
+				   ptr_type_node, gnu_fat_type,
+				   NULL_TREE, NULL_TREE, 0, 0);
+	    DECL_CHAIN (tem)
+	      = create_field_decl (get_identifier ("P_BOUNDS"),
+				   gnu_ptr_template, gnu_fat_type,
+				   NULL_TREE, NULL_TREE, 0, 0);
 	    finish_fat_pointer_type (gnu_fat_type, tem);
 	    SET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_type);
 	  }
@@ -3389,20 +3407,6 @@
 	      break;
 	    }
 
-	  /* If this is a record subtype associated with a dispatch table,
-	     strip the suffix.  This is necessary to make sure 2 different
-	     subtypes associated with the imported and exported views of a
-	     dispatch table are properly merged in LTO mode.  */
-	  if (Is_Dispatch_Table_Entity (gnat_entity))
-	    {
-	      char *p;
-	      Get_Encoded_Name (gnat_entity);
-	      p = strchr (Name_Buffer, '_');
-	      gcc_assert (p);
-	      strcpy (p+2, "dtS");
-	      gnu_entity_name = get_identifier (Name_Buffer);
-	    }
-
 	  /* When the subtype has discriminants and these discriminants affect
 	     the initial shape it has inherited, factor them in.  But for an
 	     Unchecked_Union (it must be an Itype), just return the type.
@@ -4681,7 +4685,7 @@
       /* If this is not an unconstrained array type, set some flags.  */
       if (TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE)
 	{
-	  /* Tell the middle-end that objects of tagged types are guaranteed to
+	  /* Record the property that objects of tagged types are guaranteed to
 	     be properly aligned.  This is necessary because conversions to the
 	     class-wide type are translated into conversions to the root type,
 	     which can be less aligned than some of its derived types.  */
@@ -5272,17 +5276,6 @@
 		     Is_Bit_Packed_Array (gnat_array) ? TYPE_DECL : VAR_DECL,
 		     true, Has_Component_Size_Clause (gnat_array));
 
-  /* If the array has aliased components and the component size can be zero,
-     force at least unit size to ensure that the components have distinct
-     addresses.  */
-  if (!gnu_comp_size
-      && Has_Aliased_Components (gnat_array)
-      && (integer_zerop (TYPE_SIZE (gnu_type))
-	  || (TREE_CODE (gnu_type) == ARRAY_TYPE
-	      && !TREE_CONSTANT (TYPE_SIZE (gnu_type)))))
-    gnu_comp_size
-      = size_binop (MAX_EXPR, TYPE_SIZE (gnu_type), bitsize_unit_node);
-
   /* If the component type is a RECORD_TYPE that has a self-referential size,
      then use the maximum size for the component size.  */
   if (!gnu_comp_size
@@ -5290,6 +5283,13 @@
       && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))
     gnu_comp_size = max_size (TYPE_SIZE (gnu_type), true);
 
+  /* If the array has aliased components and the component size is zero, force
+     the unit size to ensure that the components have distinct addresses.  */
+  if (!gnu_comp_size
+      && Has_Aliased_Components (gnat_array)
+      && integer_zerop (TYPE_SIZE (gnu_type)))
+    gnu_comp_size = bitsize_unit_node;
+
   /* Honor the component size.  This is not needed for bit-packed arrays.  */
   if (gnu_comp_size && !Is_Bit_Packed_Array (gnat_array))
     {
@@ -5312,6 +5312,30 @@
 			  gnat_array);
     }
 
+  /* This is a very special case where the array has aliased components and the
+     component size might be zero at run time.  As explained above, we force at
+     least the unit size but we don't want to build a distinct padding type for
+     each invocation (they are not canonicalized if they have variable size) so
+     we cache this special padding type as TYPE_PADDING_FOR_COMPONENT.  */
+  else if (Has_Aliased_Components (gnat_array)
+	   && TREE_CODE (gnu_type) == ARRAY_TYPE
+	   && !TREE_CONSTANT (TYPE_SIZE (gnu_type)))
+    {
+      if (TYPE_PADDING_FOR_COMPONENT (gnu_type))
+	gnu_type = TYPE_PADDING_FOR_COMPONENT (gnu_type);
+      else
+	{
+	  gnu_comp_size
+	    = size_binop (MAX_EXPR, TYPE_SIZE (gnu_type), bitsize_unit_node);
+	  TYPE_PADDING_FOR_COMPONENT (gnu_type)
+	    = maybe_pad_type (gnu_type, gnu_comp_size, 0, gnat_array,
+			      true, false, definition, true);
+	  gnu_type = TYPE_PADDING_FOR_COMPONENT (gnu_type);
+	  create_type_decl (TYPE_NAME (gnu_type), gnu_type, true, debug_info_p,
+			    gnat_array);
+	}
+    }
+
   /* If the component type is a padded type made for a non-bit-packed array
      of scalars with reverse storage order, we need to propagate the reverse
      storage order to the padding type since it is the innermost enclosing
@@ -6276,19 +6300,6 @@
   return gnu_ext_name;
 }
 
-/* Like build_qualified_type, but TYPE_QUALS is added to the existing
-   qualifiers on TYPE.  */
-
-static tree
-change_qualified_type (tree type, int type_quals)
-{
-  /* Qualifiers must be put on the associated array type.  */
-  if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)
-    return type;
-
-  return build_qualified_type (type, TYPE_QUALS (type) | type_quals);
-}
-
 /* Set TYPE_NONALIASED_COMPONENT on an array type built by means of
    build_nonshared_array_type.  */
 
@@ -6864,65 +6875,44 @@
    the value passed against the list of choices.  */
 
 static tree
-choices_to_gnu (tree operand, Node_Id choices)
+choices_to_gnu (tree gnu_operand, Node_Id gnat_choices)
 {
-  Node_Id choice;
-  Node_Id gnat_temp;
-  tree result = boolean_false_node;
-  tree this_test, low = 0, high = 0, single = 0;
+  tree gnu_result = boolean_false_node, gnu_type;
 
-  for (choice = First (choices); Present (choice); choice = Next (choice))
+  gnu_operand = maybe_character_value (gnu_operand);
+  gnu_type = TREE_TYPE (gnu_operand);
+
+  for (Node_Id gnat_choice = First (gnat_choices);
+       Present (gnat_choice);
+       gnat_choice = Next (gnat_choice))
     {
-      switch (Nkind (choice))
+      tree gnu_low = NULL_TREE, gnu_high = NULL_TREE;
+      tree gnu_test;
+
+      switch (Nkind (gnat_choice))
 	{
 	case N_Range:
-	  low = gnat_to_gnu (Low_Bound (choice));
-	  high = gnat_to_gnu (High_Bound (choice));
-
-	  this_test
-	    = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,
-			       build_binary_op (GE_EXPR, boolean_type_node,
-						operand, low, true),
-			       build_binary_op (LE_EXPR, boolean_type_node,
-						operand, high, true),
-			       true);
-
+	  gnu_low = gnat_to_gnu (Low_Bound (gnat_choice));
+	  gnu_high = gnat_to_gnu (High_Bound (gnat_choice));
 	  break;
 
 	case N_Subtype_Indication:
-	  gnat_temp = Range_Expression (Constraint (choice));
-	  low = gnat_to_gnu (Low_Bound (gnat_temp));
-	  high = gnat_to_gnu (High_Bound (gnat_temp));
-
-	  this_test
-	    = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,
-			       build_binary_op (GE_EXPR, boolean_type_node,
-						operand, low, true),
-			       build_binary_op (LE_EXPR, boolean_type_node,
-						operand, high, true),
-			       true);
+	  gnu_low = gnat_to_gnu (Low_Bound (Range_Expression
+					    (Constraint (gnat_choice))));
+	  gnu_high = gnat_to_gnu (High_Bound (Range_Expression
+					      (Constraint (gnat_choice))));
 	  break;
 
 	case N_Identifier:
 	case N_Expanded_Name:
-	  /* This represents either a subtype range, an enumeration
-	     literal, or a constant  Ekind says which.  If an enumeration
-	     literal or constant, fall through to the next case.  */
-	  if (Ekind (Entity (choice)) != E_Enumeration_Literal
-	      && Ekind (Entity (choice)) != E_Constant)
+	  /* This represents either a subtype range or a static value of
+	     some kind; Ekind says which.  */
+	  if (Is_Type (Entity (gnat_choice)))
 	    {
-	      tree type = gnat_to_gnu_type (Entity (choice));
-
-	      low = TYPE_MIN_VALUE (type);
-	      high = TYPE_MAX_VALUE (type);
+	      tree gnu_type = get_unpadded_type (Entity (gnat_choice));
 
-	      this_test
-		= build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,
-				   build_binary_op (GE_EXPR, boolean_type_node,
-						    operand, low, true),
-				   build_binary_op (LE_EXPR, boolean_type_node,
-						    operand, high, true),
-				   true);
+	      gnu_low = TYPE_MIN_VALUE (gnu_type);
+	      gnu_high = TYPE_MAX_VALUE (gnu_type);
 	      break;
 	    }
 
@@ -6930,27 +6920,49 @@
 
 	case N_Character_Literal:
 	case N_Integer_Literal:
-	  single = gnat_to_gnu (choice);
-	  this_test = build_binary_op (EQ_EXPR, boolean_type_node, operand,
-				       single, true);
+	  gnu_low = gnat_to_gnu (gnat_choice);
 	  break;
 
 	case N_Others_Choice:
-	  this_test = boolean_true_node;
 	  break;
 
 	default:
 	  gcc_unreachable ();
 	}
 
-      if (result == boolean_false_node)
-	result = this_test;
+      /* Everything should be folded into constants at this point.  */
+      gcc_assert (!gnu_low  || TREE_CODE (gnu_low)  == INTEGER_CST);
+      gcc_assert (!gnu_high || TREE_CODE (gnu_high) == INTEGER_CST);
+
+      if (gnu_low && TREE_TYPE (gnu_low) != gnu_type)
+	gnu_low = convert (gnu_type, gnu_low);
+      if (gnu_high && TREE_TYPE (gnu_high) != gnu_type)
+	gnu_high = convert (gnu_type, gnu_high);
+
+      if (gnu_low && gnu_high)
+	gnu_test
+	  = build_binary_op (TRUTH_ANDIF_EXPR, boolean_type_node,
+			     build_binary_op (GE_EXPR, boolean_type_node,
+					      gnu_operand, gnu_low, true),
+			     build_binary_op (LE_EXPR, boolean_type_node,
+					      gnu_operand, gnu_high, true),
+			     true);
+      else if (gnu_low)
+	gnu_test
+	  = build_binary_op (EQ_EXPR, boolean_type_node, gnu_operand, gnu_low,
+			     true);
+      else
+	gnu_test = boolean_true_node;
+
+      if (gnu_result == boolean_false_node)
+	gnu_result = gnu_test;
       else
-	result = build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node, result,
-				  this_test, true);
+	gnu_result
+	  = build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node, gnu_result,
+			     gnu_test, true);
     }
 
-  return result;
+  return gnu_result;
 }
 
 /* Adjust PACKED setting as passed to gnat_to_gnu_field for a field of
diff -ruN gcc-7.3.0/gcc/ada/gcc-interface/gigi.h gcc-7.3.0-msp430/gcc/ada/gcc-interface/gigi.h
--- gcc-7.3.0/gcc/ada/gcc-interface/gigi.h	2016-10-11 03:35:43.407602000 -0700
+++ gcc-7.3.0-msp430/gcc/ada/gcc-interface/gigi.h	2019-06-25 02:27:21.061931705 -0700
@@ -1074,7 +1074,7 @@
 static inline unsigned HOST_WIDE_INT
 ceil_pow2 (unsigned HOST_WIDE_INT x)
 {
-  return (unsigned HOST_WIDE_INT) 1 << (floor_log2 (x - 1) + 1);
+  return (unsigned HOST_WIDE_INT) 1 << ceil_log2 (x);
 }
 
 /* Return true if EXP, a CALL_EXPR, is an atomic load.  */
@@ -1171,3 +1171,16 @@
 
   return type;
 }
+
+/* Like build_qualified_type, but TYPE_QUALS is added to the existing
+   qualifiers on TYPE.  */
+
+static inline tree
+change_qualified_type (tree type, int type_quals)
+{
+  /* Qualifiers must be put on the associated array type.  */
+  if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)
+    return type;
+
+  return build_qualified_type (type, TYPE_QUALS (type) | type_quals);
+}
diff -ruN gcc-7.3.0/gcc/ada/gcc-interface/Makefile.in gcc-7.3.0-msp430/gcc/ada/gcc-interface/Makefile.in
--- gcc-7.3.0/gcc/ada/gcc-interface/Makefile.in	2017-12-04 05:41:46.640816000 -0800
+++ gcc-7.3.0-msp430/gcc/ada/gcc-interface/Makefile.in	2019-06-25 02:27:21.057931733 -0700
@@ -2756,9 +2756,9 @@
 # ada/types.h does not conflict with a same-named system header (VxWorks
 # has a <types.h> header).
 
-OSCONS_CPP=$(OSCONS_CC) $(GNATLIBCFLAGS) $(GNATLIBCFLAGS_FOR_C) -E -C \
+OSCONS_CPP=$(OSCONS_CC) $(GNATLIBCFLAGS_FOR_C) -E -C \
   -DTARGET=\"$(target)\" -iquote $(fsrcpfx)ada $(fsrcpfx)ada/s-oscons-tmplt.c > s-oscons-tmplt.i
-OSCONS_EXTRACT=$(OSCONS_CC) -S s-oscons-tmplt.i
+OSCONS_EXTRACT=$(OSCONS_CC) $(GNATLIBCFLAGS_FOR_C) -S s-oscons-tmplt.i
 
 # Note: if you need to build with a non-GNU compiler, you could adapt the
 # following definitions (written for VMS DEC-C)
diff -ruN gcc-7.3.0/gcc/ada/gcc-interface/misc.c gcc-7.3.0-msp430/gcc/ada/gcc-interface/misc.c
--- gcc-7.3.0/gcc/ada/gcc-interface/misc.c	2017-02-24 15:15:56.130329000 -0800
+++ gcc-7.3.0-msp430/gcc/ada/gcc-interface/misc.c	2019-06-25 02:27:21.061931705 -0700
@@ -262,6 +262,9 @@
   /* No psABI change warnings for Ada.  */
   warn_psabi = 0;
 
+  /* No string overflow warnings for Ada.  */
+  warn_stringop_overflow = 0;
+
   /* No caret by default for Ada.  */
   if (!global_options_set.x_flag_diagnostics_show_caret)
     global_dc->show_caret = false;
diff -ruN gcc-7.3.0/gcc/ada/gcc-interface/trans.c gcc-7.3.0-msp430/gcc/ada/gcc-interface/trans.c
--- gcc-7.3.0/gcc/ada/gcc-interface/trans.c	2017-12-13 01:30:42.156206000 -0800
+++ gcc-7.3.0-msp430/gcc/ada/gcc-interface/trans.c	2019-06-25 02:27:21.061931705 -0700
@@ -4059,6 +4059,8 @@
     case N_Identifier:
     case N_Expanded_Name:
       gnat_entity = Entity (gnat_node);
+      if (!Is_Object (gnat_entity))
+	break;
       return Is_Volatile_Full_Access (gnat_entity)
 	     || Is_Volatile_Full_Access (Etype (gnat_entity));
 
@@ -4324,12 +4326,15 @@
 	  because we need to preserve the return value before copying back the
 	  parameters.
 
-       2. There is no target and the call is made for neither an object nor a
+       2. There is no target and the call is made for neither an object, nor a
 	  renaming declaration, nor a return statement, nor an allocator, and
 	  the return type has variable size because in this case the gimplifier
-	  cannot create the temporary, or more generally is simply an aggregate
-	  type, because the gimplifier would then create the temporary in the
-	  outermost scope instead of locally.
+	  cannot create the temporary, or more generally is an aggregate type,
+	  because the gimplifier would create the temporary in the outermost
+	  scope instead of locally.  But there is an exception for an allocator
+	  of an unconstrained record type with default discriminant because we
+	  allocate the actual size in this case, unlike the other 3 cases, so
+	  we need a temporary to fetch the discriminant and we create it here.
 
        3. There is a target and it is a slice or an array with fixed size,
 	  and the return type has variable size, because the gimplifier
@@ -4348,8 +4353,9 @@
 	      && Nkind (Parent (gnat_node)) != N_Object_Declaration
 	      && Nkind (Parent (gnat_node)) != N_Object_Renaming_Declaration
 	      && Nkind (Parent (gnat_node)) != N_Simple_Return_Statement
-	      && !(Nkind (Parent (gnat_node)) == N_Qualified_Expression
-		   && Nkind (Parent (Parent (gnat_node))) == N_Allocator)
+	      && (!(Nkind (Parent (gnat_node)) == N_Qualified_Expression
+		    && Nkind (Parent (Parent (gnat_node))) == N_Allocator)
+		  || type_is_padding_self_referential (gnu_result_type))
 	      && AGGREGATE_TYPE_P (gnu_result_type)
 	      && !TYPE_IS_FAT_POINTER_P (gnu_result_type))
 	  || (gnu_target
@@ -9272,7 +9278,7 @@
 	  ? tree_int_cst_lt (gnu_out_ub, gnu_in_ub)
 	  : (FLOAT_TYPE_P (gnu_base_type)
 	     ? real_less (&TREE_REAL_CST (gnu_out_ub),
-			  &TREE_REAL_CST (gnu_in_lb))
+			  &TREE_REAL_CST (gnu_in_ub))
 	     : 1))
 	gnu_cond
 	  = build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node, gnu_cond,
diff -ruN gcc-7.3.0/gcc/ada/gcc-interface/utils.c gcc-7.3.0-msp430/gcc/ada/gcc-interface/utils.c
--- gcc-7.3.0/gcc/ada/gcc-interface/utils.c	2017-11-10 00:23:20.891496000 -0800
+++ gcc-7.3.0-msp430/gcc/ada/gcc-interface/utils.c	2019-06-25 02:27:21.061931705 -0700
@@ -1036,7 +1036,9 @@
 
   finish_record_type (new_type, nreverse (new_field_list), 2, false);
   relate_alias_sets (new_type, type, ALIAS_SET_COPY);
-  if (TYPE_STUB_DECL (type))
+  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)
+    SET_TYPE_DEBUG_TYPE (new_type, TYPE_DEBUG_TYPE (type));
+  else if (TYPE_STUB_DECL (type))
     SET_DECL_PARALLEL_TYPE (TYPE_STUB_DECL (new_type),
 			    DECL_PARALLEL_TYPE (TYPE_STUB_DECL (type)));
 
@@ -1367,7 +1369,7 @@
   finish_record_type (record, field, 1, false);
 
   if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)
-    SET_TYPE_DEBUG_TYPE (record, type);
+    SET_TYPE_DEBUG_TYPE (record, maybe_debug_type (type));
 
   /* Set the RM size if requested.  */
   if (set_rm_size)
@@ -3255,8 +3257,11 @@
   DECL_BY_REFERENCE (result_decl) = TREE_ADDRESSABLE (type);
   DECL_RESULT (decl) = result_decl;
 
+  /* Propagate the "const" property.  */
   TREE_READONLY (decl) = TYPE_READONLY (type);
-  TREE_SIDE_EFFECTS (decl) = TREE_THIS_VOLATILE (decl) = TYPE_VOLATILE (type);
+
+  /* Propagate the "noreturn" property.  */
+  TREE_THIS_VOLATILE (decl) = TYPE_VOLATILE (type);
 
   if (asm_name)
     {
@@ -4543,9 +4548,12 @@
 					   etype)))
     return build1 (VIEW_CONVERT_EXPR, type, expr);
 
-  /* If we are converting between tagged types, try to upcast properly.  */
+  /* If we are converting between tagged types, try to upcast properly.
+     But don't do it if we are just annotating types since tagged types
+     aren't fully laid out in this mode.  */
   else if (ecode == RECORD_TYPE && code == RECORD_TYPE
-	   && TYPE_ALIGN_OK (etype) && TYPE_ALIGN_OK (type))
+	   && TYPE_ALIGN_OK (etype) && TYPE_ALIGN_OK (type)
+	   && !type_annotate_only)
     {
       tree child_etype = etype;
       do {
@@ -6113,8 +6121,7 @@
 	   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)
     TREE_TYPE (*node)
       = build_pointer_type
-	(build_type_variant (TREE_TYPE (type),
-			     TYPE_READONLY (TREE_TYPE (type)), 1));
+	(change_qualified_type (TREE_TYPE (type), TYPE_QUAL_VOLATILE));
   else
     {
       warning (OPT_Wattributes, "%qs attribute ignored",
diff -ruN gcc-7.3.0/gcc/alias.c gcc-7.3.0-msp430/gcc/alias.c
--- gcc-7.3.0/gcc/alias.c	2017-05-03 04:22:34.926101000 -0700
+++ gcc-7.3.0-msp430/gcc/alias.c	2019-06-25 02:27:21.061931705 -0700
@@ -2997,7 +2997,8 @@
   int ret;
 
   gcc_checking_assert (x_canonicalized
-		       ? (x_addr != NULL_RTX && x_mode != VOIDmode)
+		       ? (x_addr != NULL_RTX
+			  && (x_mode != VOIDmode || GET_MODE (x) == VOIDmode))
 		       : (x_addr == NULL_RTX && x_mode == VOIDmode));
 
   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))
diff -ruN gcc-7.3.0/gcc/attribs.h gcc-7.3.0-msp430/gcc/attribs.h
--- gcc-7.3.0/gcc/attribs.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/attribs.h	2019-06-25 02:27:21.061931705 -0700
@@ -41,4 +41,53 @@
 extern struct scoped_attributes* register_scoped_attributes (const struct attribute_spec *,
 							     const char *);
 
+extern char *sorted_attr_string (tree);
+extern bool common_function_versions (tree, tree);
+extern char *make_unique_name (tree, const char *, bool);
+extern tree make_dispatcher_decl (const tree);
+extern bool is_function_default_version (const tree);
+
+/* For a given IDENTIFIER_NODE, strip leading and trailing '_' characters
+   so that we have a canonical form of attribute names.  */
+
+static inline tree
+canonicalize_attr_name (tree attr_name)
+{
+  const size_t l = IDENTIFIER_LENGTH (attr_name);
+  const char *s = IDENTIFIER_POINTER (attr_name);
+
+  if (l > 4 && s[0] == '_' && s[1] == '_' && s[l - 1] == '_' && s[l - 2] == '_')
+    return get_identifier_with_length (s + 2, l - 4);
+
+  return attr_name;
+}
+
+/* Compare attribute identifiers ATTR1 and ATTR2 with length ATTR1_LEN and
+   ATTR2_LEN.  */
+
+static inline bool
+cmp_attribs (const char *attr1, size_t attr1_len,
+	     const char *attr2, size_t attr2_len)
+{
+  return attr1_len == attr2_len && strncmp (attr1, attr2, attr1_len) == 0;
+}
+
+/* Compare attribute identifiers ATTR1 and ATTR2.  */
+
+static inline bool
+cmp_attribs (const char *attr1, const char *attr2)
+{
+  return cmp_attribs (attr1, strlen (attr1), attr2, strlen (attr2));
+}
+
+/* Given an identifier node IDENT and a string ATTR_NAME, return true
+   if the identifier node is a valid attribute name for the string.  */
+
+static inline bool
+is_attribute_p (const char *attr_name, const_tree ident)
+{
+  return cmp_attribs (attr_name, strlen (attr_name),
+		      IDENTIFIER_POINTER (ident), IDENTIFIER_LENGTH (ident));
+}
+
 #endif // GCC_ATTRIBS_H
diff -ruN gcc-7.3.0/gcc/BASE-VER gcc-7.3.0-msp430/gcc/BASE-VER
--- gcc-7.3.0/gcc/BASE-VER	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/gcc/BASE-VER	2019-06-25 02:27:21.057931733 -0700
@@ -1 +1 @@
-7.3.0
+7.3.2
diff -ruN gcc-7.3.0/gcc/brig/ChangeLog gcc-7.3.0-msp430/gcc/brig/ChangeLog
--- gcc-7.3.0/gcc/brig/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/gcc/brig/ChangeLog	2019-06-25 02:27:21.061931705 -0700
@@ -1,3 +1,8 @@
+2018-07-04  Martin Jambor  <mjambor@suse.cz>
+
+	PR hsa/86371
+	* Make-lang.in (BRIGINCLUDES): Remove erroneous include path in $HOME.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/gcc/brig/Make-lang.in gcc-7.3.0-msp430/gcc/brig/Make-lang.in
--- gcc-7.3.0/gcc/brig/Make-lang.in	2017-01-26 00:24:22.713350000 -0800
+++ gcc-7.3.0-msp430/gcc/brig/Make-lang.in	2019-06-25 02:27:21.061931705 -0700
@@ -235,8 +235,7 @@
 CFLAGS-brig/brig-lang.o += -DDEFAULT_TARGET_VERSION=\"$(version)\" \
 	-DDEFAULT_TARGET_MACHINE=\"$(target_noncanonical)\"
 
-BRIGINCLUDES = -I $(srcdir)/brig -I ${HOME}/local/include \
-	-I $(srcdir)/brig/brigfrontend
+BRIGINCLUDES = -I $(srcdir)/brig -I $(srcdir)/brig/brigfrontend
 
 brig/brig-machine.o: brig/brigfrontend/brig-machine.c
 	$(COMPILE) $(BRIGINCLUDES) $<
diff -ruN gcc-7.3.0/gcc/builtins.c gcc-7.3.0-msp430/gcc/builtins.c
--- gcc-7.3.0/gcc/builtins.c	2017-10-24 15:46:19.969481000 -0700
+++ gcc-7.3.0-msp430/gcc/builtins.c	2019-06-25 02:27:21.061931705 -0700
@@ -7538,8 +7538,7 @@
   const_tree argtype, parmtype;
   const_call_expr_arg_iterator iter;
 
-  if (TREE_CODE (t) != CALL_EXPR
-      || TREE_CODE (CALL_EXPR_FN (t)) != ADDR_EXPR)
+  if (TREE_CODE (t) != CALL_EXPR)
     return END_BUILTINS;
 
   fndecl = get_callee_fndecl (t);
@@ -9271,7 +9270,7 @@
       if (p2[0] == '\0')
 	/* strpbrk(x, "") == NULL.
 	   Evaluate and ignore s1 in case it had side-effects.  */
-	return omit_one_operand_loc (loc, TREE_TYPE (s1), integer_zero_node, s1);
+	return omit_one_operand_loc (loc, type, integer_zero_node, s1);
 
       if (p2[1] != '\0')
 	return NULL_TREE;  /* Really call strpbrk.  */
diff -ruN gcc-7.3.0/gcc/c/c-fold.c gcc-7.3.0-msp430/gcc/c/c-fold.c
--- gcc-7.3.0/gcc/c/c-fold.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/c/c-fold.c	2019-06-25 02:27:21.065931675 -0700
@@ -403,7 +403,7 @@
 	  && (op1 = get_base_address (op0)) != NULL_TREE
 	  && INDIRECT_REF_P (op1)
 	  && TREE_CONSTANT (TREE_OPERAND (op1, 0)))
-	ret = fold_convert_loc (loc, TREE_TYPE (expr), fold_offsetof_1 (op0));
+	ret = fold_offsetof (op0, TREE_TYPE (expr));
       else if (op0 != orig_op0 || in_init)
 	ret = in_init
 	  ? fold_build1_initializer_loc (loc, code, TREE_TYPE (expr), op0)
diff -ruN gcc-7.3.0/gcc/c/ChangeLog gcc-7.3.0-msp430/gcc/c/ChangeLog
--- gcc-7.3.0/gcc/c/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/gcc/c/ChangeLog	2019-06-25 02:27:21.065931675 -0700
@@ -1,3 +1,35 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/85696
+	* c-typeck.c (c_finish_omp_clauses): Don't use
+	c_omp_predetermined_sharing, instead just check TREE_READONLY.
+
+	2018-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* c-fold.c (c_fully_fold_internal): Use fold_offsetof rather than
+	fold_offsetof_1, pass TREE_TYPE (expr) as TYPE to it and drop the
+	fold_convert_loc.
+	* c-typeck.c (build_unary_op): Use fold_offsetof rather than
+	fold_offsetof_1, pass argtype as TYPE to it and drop the
+	fold_convert_loc.
+
+	2018-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/84999
+	* c-typeck.c (build_binary_op): If c_common_type_for_size fails when
+	building vector comparison, diagnose it and return error_mark_node.
+
+	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/84853
+	* c-typeck.c (build_binary_op) <case RSHIFT_EXPR, case LSHIFT_EXPR>:
+	If code1 is INTEGER_TYPE, only allow code0 VECTOR_TYPE if it has
+	INTEGER_TYPE element type.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/gcc/c/c-parser.c gcc-7.3.0-msp430/gcc/c/c-parser.c
--- gcc-7.3.0/gcc/c/c-parser.c	2017-12-10 12:52:54.772162000 -0800
+++ gcc-7.3.0-msp430/gcc/c/c-parser.c	2019-06-25 02:27:21.065931675 -0700
@@ -4163,9 +4163,11 @@
 	  attr_name = c_parser_attribute_any_word (parser);
 	  if (attr_name == NULL)
 	    break;
+	  attr_name = canonicalize_attr_name (attr_name);
 	  if (is_cilkplus_vector_p (attr_name))
 	    {
 	      c_token *v_token = c_parser_peek_token (parser);
+	      v_token->value = canonicalize_attr_name (v_token->value);
 	      c_parser_cilk_simd_fn_vector_attrs (parser, *v_token);
 	      /* If the next token isn't a comma, we're done.  */
 	      if (!c_parser_next_token_is (parser, CPP_COMMA))
@@ -4229,6 +4231,7 @@
 		  release_tree_vector (expr_list);
 		}
 	    }
+
 	  attr = build_tree_list (attr_name, attr_args);
 	  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))
 	    c_parser_consume_token (parser);
diff -ruN gcc-7.3.0/gcc/c/c-typeck.c gcc-7.3.0-msp430/gcc/c/c-typeck.c
--- gcc-7.3.0/gcc/c/c-typeck.c	2017-06-08 12:12:38.381833000 -0700
+++ gcc-7.3.0-msp430/gcc/c/c-typeck.c	2019-06-25 02:27:21.069931647 -0700
@@ -4638,7 +4638,7 @@
       if (val && INDIRECT_REF_P (val)
           && TREE_CONSTANT (TREE_OPERAND (val, 0)))
 	{
-	  ret = fold_convert_loc (location, argtype, fold_offsetof_1 (arg));
+	  ret = fold_offsetof (arg, argtype);
 	  goto return_build_unary_op;
 	}
 
@@ -11150,7 +11150,8 @@
 	  converted = 1;
 	}
       else if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE
-		|| code0 == VECTOR_TYPE)
+		|| (code0 == VECTOR_TYPE
+		    && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE))
 	       && code1 == INTEGER_TYPE)
 	{
 	  doing_shift = true;
@@ -11207,7 +11208,8 @@
 	  converted = 1;
 	}
       else if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE
-		|| code0 == VECTOR_TYPE)
+		|| (code0 == VECTOR_TYPE
+		    && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE))
 	       && code1 == INTEGER_TYPE)
 	{
 	  doing_shift = true;
@@ -11299,6 +11301,13 @@
           /* Always construct signed integer vector type.  */
           intt = c_common_type_for_size (GET_MODE_BITSIZE
 					   (TYPE_MODE (TREE_TYPE (type0))), 0);
+	  if (!intt)
+	    {
+	      error_at (location, "could not find an integer type "
+				  "of the same size as %qT",
+			TREE_TYPE (type0));
+	      return error_mark_node;
+	    }
           result_type = build_opaque_vector_type (intt,
 						  TYPE_VECTOR_SUBPARTS (type0));
           converted = 1;
@@ -11458,6 +11467,13 @@
           /* Always construct signed integer vector type.  */
           intt = c_common_type_for_size (GET_MODE_BITSIZE
 					   (TYPE_MODE (TREE_TYPE (type0))), 0);
+	  if (!intt)
+	    {
+	      error_at (location, "could not find an integer type "
+				  "of the same size as %qT",
+			TREE_TYPE (type0));
+	      return error_mark_node;
+	    }
           result_type = build_opaque_vector_type (intt,
 						  TYPE_VECTOR_SUBPARTS (type0));
           converted = 1;
@@ -13744,22 +13760,11 @@
 
 	      if (VAR_P (t) && DECL_THREAD_LOCAL_P (t))
 		share_name = "threadprivate";
-	      else switch (c_omp_predetermined_sharing (t))
+	      else if (TREE_READONLY (t))
 		{
-		case OMP_CLAUSE_DEFAULT_UNSPECIFIED:
-		  break;
-		case OMP_CLAUSE_DEFAULT_SHARED:
 		  /* const vars may be specified in firstprivate clause.  */
-		  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE
-		      && TREE_READONLY (t))
-		    break;
-		  share_name = "shared";
-		  break;
-		case OMP_CLAUSE_DEFAULT_PRIVATE:
-		  share_name = "private";
-		  break;
-		default:
-		  gcc_unreachable ();
+		  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FIRSTPRIVATE)
+		    share_name = "shared";
 		}
 	      if (share_name)
 		{
diff -ruN gcc-7.3.0/gcc/calls.c gcc-7.3.0-msp430/gcc/calls.c
--- gcc-7.3.0/gcc/calls.c	2017-09-07 13:20:43.146003000 -0700
+++ gcc-7.3.0-msp430/gcc/calls.c	2019-06-25 02:27:21.069931647 -0700
@@ -1196,65 +1196,79 @@
 static tree
 alloc_max_size (void)
 {
-  if (!alloc_object_size_limit)
-    {
-      alloc_object_size_limit = TYPE_MAX_VALUE (ssizetype);
+  if (alloc_object_size_limit)
+    return alloc_object_size_limit;
 
-      if (warn_alloc_size_limit)
-	{
-	  char *end = NULL;
-	  errno = 0;
-	  unsigned HOST_WIDE_INT unit = 1;
-	  unsigned HOST_WIDE_INT limit
-	    = strtoull (warn_alloc_size_limit, &end, 10);
+  alloc_object_size_limit = TYPE_MAX_VALUE (ssizetype);
 
-	  if (!errno)
-	    {
-	      if (end && *end)
-		{
-		  /* Numeric option arguments are at most INT_MAX.  Make it
-		     possible to specify a larger value by accepting common
-		     suffixes.  */
-		  if (!strcmp (end, "kB"))
-		    unit = 1000;
-		  else if (!strcasecmp (end, "KiB") || strcmp (end, "KB"))
-		    unit = 1024;
-		  else if (!strcmp (end, "MB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000;
-		  else if (!strcasecmp (end, "MiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024;
-		  else if (!strcasecmp (end, "GB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000;
-		  else if (!strcasecmp (end, "GiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024;
-		  else if (!strcasecmp (end, "TB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000;
-		  else if (!strcasecmp (end, "TiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024;
-		  else if (!strcasecmp (end, "PB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000;
-		  else if (!strcasecmp (end, "PiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024;
-		  else if (!strcasecmp (end, "EB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000
-			   * 1000;
-		  else if (!strcasecmp (end, "EiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024
-			   * 1024;
-		  else
-		    unit = 0;
-		}
+  if (!warn_alloc_size_limit)
+    return alloc_object_size_limit;
 
-	      if (unit)
-		{
-		  wide_int w = wi::uhwi (limit, HOST_BITS_PER_WIDE_INT + 64);
-		  w *= unit;
-		  if (wi::ltu_p (w, alloc_object_size_limit))
-		    alloc_object_size_limit = wide_int_to_tree (ssizetype, w);
-		}
-	    }
+  const char *optname = "-Walloc-size-larger-than=";
+
+  char *end = NULL;
+  errno = 0;
+  unsigned HOST_WIDE_INT unit = 1;
+  unsigned HOST_WIDE_INT limit
+    = strtoull (warn_alloc_size_limit, &end, 10);
+
+  /* If the value is too large to be represented use the maximum
+     representable value that strtoull sets limit to (setting
+     errno to ERANGE).  */
+
+  if (end && *end)
+    {
+      /* Numeric option arguments are at most INT_MAX.  Make it
+	 possible to specify a larger value by accepting common
+	 suffixes.  */
+      if (!strcmp (end, "kB"))
+	unit = 1000;
+      else if (!strcasecmp (end, "KiB") || !strcmp (end, "KB"))
+	unit = 1024;
+      else if (!strcmp (end, "MB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000;
+      else if (!strcasecmp (end, "MiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024;
+      else if (!strcasecmp (end, "GB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000;
+      else if (!strcasecmp (end, "GiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024;
+      else if (!strcasecmp (end, "TB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000;
+      else if (!strcasecmp (end, "TiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024;
+      else if (!strcasecmp (end, "PB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000;
+      else if (!strcasecmp (end, "PiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024;
+      else if (!strcasecmp (end, "EB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000
+	  * 1000;
+      else if (!strcasecmp (end, "EiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024
+	  * 1024;
+      else
+	{
+	  /* This could mean an unknown suffix or a bad prefix, like
+	     "+-1".  */
+	  warning_at (UNKNOWN_LOCATION, 0,
+		      "invalid argument %qs to %qs",
+		      warn_alloc_size_limit, optname);
+	  /* Ignore the limit extracted by strtoull.  */
+	  unit = 0;
 	}
     }
+
+  if (unit)
+    {
+      widest_int w = wi::mul (limit, unit);
+      if (w < wi::to_widest (alloc_object_size_limit))
+	alloc_object_size_limit
+	  = wide_int_to_tree (ptrdiff_type_node, w);
+      else
+	alloc_object_size_limit = build_all_ones_cst (size_type_node);
+    }
+
   return alloc_object_size_limit;
 }
 
@@ -3133,9 +3147,14 @@
 	if (CALL_EXPR_RETURN_SLOT_OPT (exp)
 	    && target
 	    && MEM_P (target)
-	    && !(MEM_ALIGN (target) < TYPE_ALIGN (rettype)
-		 && SLOW_UNALIGNED_ACCESS (TYPE_MODE (rettype),
-					   MEM_ALIGN (target))))
+	    /* If rettype is addressable, we may not create a temporary.
+	       If target is properly aligned at runtime and the compiler
+	       just doesn't know about it, it will work fine, otherwise it
+	       will be UB.  */
+	    && (TREE_ADDRESSABLE (rettype)
+		|| !(MEM_ALIGN (target) < TYPE_ALIGN (rettype)
+		     && SLOW_UNALIGNED_ACCESS (TYPE_MODE (rettype),
+					       MEM_ALIGN (target)))))
 	  structure_value_addr = XEXP (target, 0);
 	else
 	  {
diff -ruN gcc-7.3.0/gcc/c-family/array-notation-common.c gcc-7.3.0-msp430/gcc/c-family/array-notation-common.c
--- gcc-7.3.0/gcc/c-family/array-notation-common.c	2017-01-17 07:27:18.386272000 -0800
+++ gcc-7.3.0-msp430/gcc/c-family/array-notation-common.c	2019-06-25 02:27:21.061931705 -0700
@@ -27,6 +27,8 @@
 #include "options.h"
 #include "c-family/c-common.h"
 #include "tree-iterator.h"
+#include "stringpool.h"
+#include "attribs.h"
 
 /* Returns true if the function call in FNDECL is  __sec_implicit_index.  */
 
diff -ruN gcc-7.3.0/gcc/c-family/c-attribs.c gcc-7.3.0-msp430/gcc/c-family/c-attribs.c
--- gcc-7.3.0/gcc/c-family/c-attribs.c	2017-09-19 02:02:33.118878000 -0700
+++ gcc-7.3.0-msp430/gcc/c-family/c-attribs.c	2019-06-25 02:27:21.065931675 -0700
@@ -2745,7 +2745,8 @@
        && !SCALAR_FLOAT_TYPE_P (type)
        && !FIXED_POINT_TYPE_P (type))
       || (!SCALAR_FLOAT_MODE_P (orig_mode)
-	  && GET_MODE_CLASS (orig_mode) != MODE_INT
+	  && (GET_MODE_CLASS (orig_mode) != MODE_INT
+	      && GET_MODE_CLASS (orig_mode) != MODE_PARTIAL_INT)
 	  && !ALL_SCALAR_FIXED_POINT_MODE_P (orig_mode))
       || !tree_fits_uhwi_p (TYPE_SIZE_UNIT (type))
       || TREE_CODE (type) == BOOLEAN_TYPE)
diff -ruN gcc-7.3.0/gcc/c-family/c-common.c gcc-7.3.0-msp430/gcc/c-family/c-common.c
--- gcc-7.3.0/gcc/c-family/c-common.c	2017-12-15 13:50:52.870936000 -0800
+++ gcc-7.3.0-msp430/gcc/c-family/c-common.c	2019-06-25 02:27:21.065931675 -0700
@@ -5434,10 +5434,8 @@
   if (TREE_CODE (TREE_TYPE (param)) != POINTER_TYPE)
     return;
 
-  /* When not optimizing diagnose the simple cases of null arguments.
-     When optimization is enabled defer the checking until expansion
-     when more cases can be detected.  */
-  if (integer_zerop (param))
+  /* Diagnose the simple cases of null arguments.  */
+  if (integer_zerop (fold_for_warn (param)))
     {
       warning_at (pctx->loc, OPT_Wnonnull, "null argument where non-null "
 		  "required (argument %lu)", (unsigned long) param_num);
@@ -6253,10 +6251,11 @@
 
 /* Fold an offsetof-like expression.  EXPR is a nested sequence of component
    references with an INDIRECT_REF of a constant at the bottom; much like the
-   traditional rendering of offsetof as a macro.  Return the folded result.  */
+   traditional rendering of offsetof as a macro.  TYPE is the desired type of
+   the whole expression.  Return the folded result.  */
 
 tree
-fold_offsetof_1 (tree expr, enum tree_code ctx)
+fold_offsetof (tree expr, tree type, enum tree_code ctx)
 {
   tree base, off, t;
   tree_code code = TREE_CODE (expr);
@@ -6281,10 +6280,10 @@
 	  error ("cannot apply %<offsetof%> to a non constant address");
 	  return error_mark_node;
 	}
-      return TREE_OPERAND (expr, 0);
+      return convert (type, TREE_OPERAND (expr, 0));
 
     case COMPONENT_REF:
-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), code);
+      base = fold_offsetof (TREE_OPERAND (expr, 0), type, code);
       if (base == error_mark_node)
 	return base;
 
@@ -6301,7 +6300,7 @@
       break;
 
     case ARRAY_REF:
-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), code);
+      base = fold_offsetof (TREE_OPERAND (expr, 0), type, code);
       if (base == error_mark_node)
 	return base;
 
@@ -6358,23 +6357,16 @@
       /* Handle static members of volatile structs.  */
       t = TREE_OPERAND (expr, 1);
       gcc_assert (VAR_P (t));
-      return fold_offsetof_1 (t);
+      return fold_offsetof (t, type);
 
     default:
       gcc_unreachable ();
     }
 
+  if (!POINTER_TYPE_P (type))
+    return size_binop (PLUS_EXPR, base, convert (type, off));
   return fold_build_pointer_plus (base, off);
 }
-
-/* Likewise, but convert it to the return type of offsetof.  */
-
-tree
-fold_offsetof (tree expr)
-{
-  return convert (size_type_node, fold_offsetof_1 (expr));
-}
-
 
 /* *PTYPE is an incomplete array.  Complete it with a domain based on
    INITIAL_VALUE.  If INITIAL_VALUE is not present, use 1 if DO_DEFAULT
diff -ruN gcc-7.3.0/gcc/c-family/c-common.h gcc-7.3.0-msp430/gcc/c-family/c-common.h
--- gcc-7.3.0/gcc/c-family/c-common.h	2017-03-30 23:40:39.410565000 -0700
+++ gcc-7.3.0-msp430/gcc/c-family/c-common.h	2019-06-25 02:27:21.065931675 -0700
@@ -1053,8 +1053,8 @@
 
 extern void verify_sequence_points (tree);
 
-extern tree fold_offsetof_1 (tree, tree_code ctx = ERROR_MARK);
-extern tree fold_offsetof (tree);
+extern tree fold_offsetof (tree, tree = size_type_node,
+			   tree_code ctx = ERROR_MARK);
 
 extern int complete_array_type (tree *, tree, bool);
 
diff -ruN gcc-7.3.0/gcc/c-family/c-cppbuiltin.c gcc-7.3.0-msp430/gcc/c-family/c-cppbuiltin.c
--- gcc-7.3.0/gcc/c-family/c-cppbuiltin.c	2017-09-10 01:44:04.892925000 -0700
+++ gcc-7.3.0-msp430/gcc/c-family/c-cppbuiltin.c	2019-06-25 02:27:21.065931675 -0700
@@ -1119,7 +1119,7 @@
 	       floatn_nx_types[i].extended ? "X" : "");
       sprintf (csuffix, "F%d%s", floatn_nx_types[i].n,
 	       floatn_nx_types[i].extended ? "x" : "");
-      builtin_define_float_constants (prefix, csuffix, "%s", NULL,
+      builtin_define_float_constants (prefix, ggc_strdup (csuffix), "%s", NULL,
 				      FLOATN_NX_TYPE_NODE (i));
     }
 
@@ -1566,7 +1566,14 @@
   int digits;
   const char *fp_suffix;
 };
-static GTY(()) struct lazy_hex_fp_value_struct lazy_hex_fp_values[12];
+/* Number of the expensive to compute macros we should evaluate lazily.
+   Each builtin_define_float_constants invocation calls
+   builtin_define_with_hex_fp_value 4 times and builtin_define_float_constants
+   is called for FLT, DBL, LDBL and up to NUM_FLOATN_NX_TYPES times for
+   FLTNN*.  */ 
+#define LAZY_HEX_FP_VALUES_CNT (4 * (3 + NUM_FLOATN_NX_TYPES))
+static GTY(()) struct lazy_hex_fp_value_struct
+  lazy_hex_fp_values[LAZY_HEX_FP_VALUES_CNT];
 static GTY(()) int lazy_hex_fp_value_count;
 
 static bool
@@ -1611,7 +1618,7 @@
   char dec_str[64], buf1[256], buf2[256];
 
   /* This is very expensive, so if possible expand them lazily.  */
-  if (lazy_hex_fp_value_count < 12
+  if (lazy_hex_fp_value_count < LAZY_HEX_FP_VALUES_CNT
       && flag_dump_macros == 0
       && !cpp_get_options (parse_in)->traditional)
     {
diff -ruN gcc-7.3.0/gcc/c-family/c-format.c gcc-7.3.0-msp430/gcc/c-family/c-format.c
--- gcc-7.3.0/gcc/c-family/c-format.c	2017-06-07 04:29:34.217350000 -0700
+++ gcc-7.3.0-msp430/gcc/c-family/c-format.c	2019-06-25 02:27:21.065931675 -0700
@@ -33,6 +33,7 @@
 #include "substring-locations.h"
 #include "selftest.h"
 #include "builtins.h"
+#include "attribs.h"
 
 /* Handle attributes associated with format checking.  */
 
@@ -63,7 +64,6 @@
 static bool get_constant (tree expr, unsigned HOST_WIDE_INT *value,
 			  int validated_p);
 static const char *convert_format_name_to_system_name (const char *attr_name);
-static bool cmp_attribs (const char *tattr_name, const char *attr_name);
 
 static int first_target_format_type;
 static const char *format_name (int format_num);
@@ -3904,24 +3904,6 @@
   return attr_name;
 }
 
-/* Return true if TATTR_NAME and ATTR_NAME are the same format attribute,
-   counting "name" and "__name__" as the same, false otherwise.  */
-static bool
-cmp_attribs (const char *tattr_name, const char *attr_name)
-{
-  int alen = strlen (attr_name);
-  int slen = (tattr_name ? strlen (tattr_name) : 0);
-  if (alen > 4 && attr_name[0] == '_' && attr_name[1] == '_'
-      && attr_name[alen - 1] == '_' && attr_name[alen - 2] == '_')
-    {
-      attr_name += 2;
-      alen -= 4;
-    }
-  if (alen != slen || strncmp (tattr_name, attr_name, alen) != 0)
-    return false;
-  return true;
-}
-
 /* Handle a "format" attribute; arguments as in
    struct attribute_spec.handler.  */
 tree
@@ -3950,6 +3932,10 @@
     }
 #endif
 
+  /* Canonicalize name of format function.  */
+  if (TREE_CODE (TREE_VALUE (args)) == IDENTIFIER_NODE)
+    TREE_VALUE (args) = canonicalize_attr_name (TREE_VALUE (args));
+
   if (!decode_format_attr (args, &info, 0))
     {
       *no_add_attrs = true;
diff -ruN gcc-7.3.0/gcc/c-family/c-gimplify.c gcc-7.3.0-msp430/gcc/c-family/c-gimplify.c
--- gcc-7.3.0/gcc/c-family/c-gimplify.c	2017-01-20 04:02:50.662517000 -0800
+++ gcc-7.3.0-msp430/gcc/c-family/c-gimplify.c	2019-06-25 02:27:21.065931675 -0700
@@ -244,7 +244,9 @@
 				    unsigned_type_node)
 	    && !types_compatible_p (TYPE_MAIN_VARIANT (TREE_TYPE (*op1_p)),
 				    integer_type_node))
-	  *op1_p = convert (unsigned_type_node, *op1_p);
+	  /* Make sure to unshare the result, tree sharing is invalid
+	     during gimplification.  */
+	  *op1_p = unshare_expr (convert (unsigned_type_node, *op1_p));
 	break;
       }
 
diff -ruN gcc-7.3.0/gcc/c-family/ChangeLog gcc-7.3.0-msp430/gcc/c-family/ChangeLog
--- gcc-7.3.0/gcc/c-family/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/gcc/c-family/ChangeLog	2019-06-25 02:27:21.061931705 -0700
@@ -1,3 +1,56 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86210
+	* c-common.c (check_nonnull_arg): Use fold_for_warn.  Adjust obsolete
+	comment.
+
+	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/85696
+	* c-omp.c (c_omp_predetermined_sharing): Return
+	OMP_CLAUSE_DEFAULT_SHARED for artificial vars with integral type.
+
+	2018-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* c-common.h (fold_offsetof_1): Removed.
+	(fold_offsetof): Add TYPE argument defaulted to size_type_node and
+	CTX argument defaulted to ERROR_MARK.
+	* c-common.c (fold_offsetof_1): Renamed to ...
+	(fold_offsetof): ... this.  Remove wrapper function.  Add TYPE
+	argument, convert the pointer constant to TYPE and use size_binop
+	with PLUS_EXPR instead of fold_build_pointer_plus if type is not
+	a pointer type.  Adjust recursive calls.
+
+2018-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-03-16  Richard Biener  <rguenther@suse.de>
+
+	PR c/84873
+	* c-gimplify.c (c_gimplify_expr): Revert previous change.  Instead
+	unshare the possibly folded expression.
+
+	2018-03-15  Richard Biener  <rguenther@suse.de>
+
+	PR c/84873
+	* c-gimplify.c (c_gimplify_expr): Do not fold expressions.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* c-cppbuiltin.c (c_cpp_builtins): Use ggc_strdup for the fp_suffix
+	argument.
+	(LAZY_HEX_FP_VALUES_CNT): Define.
+	(lazy_hex_fp_values): Allow up to LAZY_HEX_FP_VALUES_CNT lazy hex fp
+	values rather than just 12.
+	(builtin_define_with_hex_fp_value): Likewise.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/gcc/c-family/c-lex.c gcc-7.3.0-msp430/gcc/c-family/c-lex.c
--- gcc-7.3.0/gcc/c-family/c-lex.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/c-family/c-lex.c	2019-06-25 02:27:21.065931675 -0700
@@ -316,6 +316,7 @@
     {
       attr_name = get_identifier ((const char *)
 				  cpp_token_as_text (pfile, token));
+      attr_name = canonicalize_attr_name (attr_name);
       if (c_dialect_cxx ())
 	{
 	  int idx = 0;
diff -ruN gcc-7.3.0/gcc/c-family/c-omp.c gcc-7.3.0-msp430/gcc/c-family/c-omp.c
--- gcc-7.3.0/gcc/c-family/c-omp.c	2017-09-07 13:18:45.055400000 -0700
+++ gcc-7.3.0-msp430/gcc/c-family/c-omp.c	2019-06-25 02:27:21.065931675 -0700
@@ -1540,5 +1540,13 @@
   if (TREE_READONLY (decl))
     return OMP_CLAUSE_DEFAULT_SHARED;
 
+  /* Predetermine artificial variables holding integral values, those
+     are usually result of gimplify_one_sizepos or SAVE_EXPR
+     gimplification.  */
+  if (VAR_P (decl)
+      && DECL_ARTIFICIAL (decl)
+      && INTEGRAL_TYPE_P (TREE_TYPE (decl)))
+    return OMP_CLAUSE_DEFAULT_SHARED;
+
   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
 }
diff -ruN gcc-7.3.0/gcc/c-family/c-pretty-print.c gcc-7.3.0-msp430/gcc/c-family/c-pretty-print.c
--- gcc-7.3.0/gcc/c-family/c-pretty-print.c	2017-01-05 19:34:25.740273000 -0800
+++ gcc-7.3.0-msp430/gcc/c-family/c-pretty-print.c	2019-06-25 02:27:21.065931675 -0700
@@ -24,6 +24,7 @@
 #include "c-pretty-print.h"
 #include "diagnostic.h"
 #include "stor-layout.h"
+#include "stringpool.h"
 #include "attribs.h"
 #include "intl.h"
 #include "tree-pretty-print.h"
diff -ruN gcc-7.3.0/gcc/cfgexpand.c gcc-7.3.0-msp430/gcc/cfgexpand.c
--- gcc-7.3.0/gcc/cfgexpand.c	2017-01-04 17:46:32.188651000 -0800
+++ gcc-7.3.0-msp430/gcc/cfgexpand.c	2019-06-25 02:27:21.069931647 -0700
@@ -1252,10 +1252,10 @@
 	 allocate it, which means that in-frame portion is just a
 	 pointer.  ??? We've got a pseudo for sure here, do we
 	 actually dynamically allocate its spilling area if needed?
-	 ??? Isn't it a problem when POINTER_SIZE also exceeds
-	 MAX_SUPPORTED_STACK_ALIGNMENT, as on cris and lm32?  */
+	 ??? Isn't it a problem when Pmode alignment also exceeds
+	 MAX_SUPPORTED_STACK_ALIGNMENT, as can happen on cris and lm32?  */
       if (align > MAX_SUPPORTED_STACK_ALIGNMENT)
-	align = POINTER_SIZE;
+	align = GET_MODE_ALIGNMENT (Pmode);
 
       record_alignment_for_reg_var (align);
     }
@@ -1375,7 +1375,7 @@
   /* If the variable alignment is very large we'll dynamicaly allocate
      it, which means that in-frame portion is just a pointer.  */
   if (align > MAX_SUPPORTED_STACK_ALIGNMENT)
-    align = POINTER_SIZE;
+    align = GET_MODE_ALIGNMENT (Pmode);
 
   record_alignment_for_reg_var (align);
 
@@ -1592,7 +1592,7 @@
       /* If the variable alignment is very large we'll dynamicaly allocate
 	 it, which means that in-frame portion is just a pointer.  */
       if (align > MAX_SUPPORTED_STACK_ALIGNMENT)
-	align = POINTER_SIZE;
+	align = GET_MODE_ALIGNMENT (Pmode);
     }
 
   record_alignment_for_reg_var (align);
@@ -2997,14 +2997,14 @@
 
       generating_concat_p = 0;
 
-      if ((TREE_CODE (val) == INDIRECT_REF
-	   && allows_mem)
+      if ((TREE_CODE (val) == INDIRECT_REF && allows_mem)
 	  || (DECL_P (val)
 	      && (allows_mem || REG_P (DECL_RTL (val)))
 	      && ! (REG_P (DECL_RTL (val))
 		    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type)))
 	  || ! allows_reg
-	  || is_inout)
+	  || is_inout
+	  || TREE_ADDRESSABLE (type))
 	{
 	  op = expand_expr (val, NULL_RTX, VOIDmode,
 			    !allows_reg ? EXPAND_MEMORY : EXPAND_WRITE);
@@ -3013,7 +3013,7 @@
 
 	  if (! allows_reg && !MEM_P (op))
 	    error ("output number %d not directly addressable", i);
-	  if ((! allows_mem && MEM_P (op))
+	  if ((! allows_mem && MEM_P (op) && GET_MODE (op) != BLKmode)
 	      || GET_CODE (op) == CONCAT)
 	    {
 	      rtx old_op = op;
diff -ruN gcc-7.3.0/gcc/cgraph.h gcc-7.3.0-msp430/gcc/cgraph.h
--- gcc-7.3.0/gcc/cgraph.h	2017-04-28 04:42:14.556427000 -0700
+++ gcc-7.3.0-msp430/gcc/cgraph.h	2019-06-25 02:27:21.069931647 -0700
@@ -321,6 +321,9 @@
      or abstract function kept for debug info purposes only.  */
   bool real_symbol_p (void);
 
+  /* Return true when the symbol needs to be output to the LTO symbol table.  */
+  bool output_to_lto_symbol_table_p (void);
+
   /* Determine if symbol declaration is needed.  That is, visible to something
      either outside this translation unit, something magic in the system
      configury. This function is used just during symbol creation.  */
diff -ruN gcc-7.3.0/gcc/ChangeLog gcc-7.3.0-msp430/gcc/ChangeLog
--- gcc-7.3.0/gcc/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/gcc/ChangeLog	2019-06-25 02:27:21.057931733 -0700
@@ -1,3 +1,1821 @@
+2018-08-25  Jozef Lawrynowicz  <jozef.l@mittosystems.com>
+
+	Backport from mainline
+	PR target/86662
+	* gcc/tree.c (build_common_tree_nodes): Initialize integer_types array
+	with all enabled __intN types.
+
+	* gcc/testsuite/gcc.target/msp430/pr86662.c: New test.
+
+2018-08-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-08-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/87014
+	* config/i386/i386.md (eh_return): Always update EH return
+	address in word_mode.
+
+2018-08-17  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-08-11  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (UNSPEC_MEMORY_BARRIER): New unspec enum.
+	Update comment for atomic instructions.
+	(atomic_storeqi, atomic_storehi, atomic_storesi, atomic_storesf,
+	atomic_loaddf, atomic_loaddf_1, atomic_storedf, atomic_storedf_1):
+	Remove.
+	(atomic_loaddi): Revise fence expansion to only emit fence prior to
+	load for __ATOMIC_SEQ_CST model.
+	(atomic_loaddi_1): Remove float register target.
+	(atomic_storedi): Handle CONST_INT values.
+	(atomic_storedi_1): Remove float register source.  Add special case
+	for zero value.
+	(memory_barrier): New expander and insn.
+
+2018-08-13  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2018-05-09  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/85645
+	* regrename.c (build_def_use): Also kill the chains that include the
+	destination of a REG_CFA_REGISTER note.
+
+	PR rtl-optimization/85645
+	*  regcprop.c (copyprop_hardreg_forward_1): Don't propagate into an
+	insn that has a REG_CFA_REGISTER note.
+
+2018-08-10  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2018-06-19  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/86197
+	* config/rs6000/rs6000.md (rs6000_discover_homogeneous_aggregate): An
+	ieee128 argument takes up only one (vector) register, not two (floating
+	point) registers.
+
+2018-08-02  Jozef Lawrynowicz  <jozef.l@mittosystems.com>
+
+	Backport from mainline
+	2018-07-31  Jozef Lawrynowicz  <jozef.l@mittosystems.com>
+
+	PR middle-end/86705
+	* gcc/cfgexpand.c (set_parm_rtl): Use the alignment of Pmode when
+	MAX_SUPPORTED_STACK_ALIGNMENT would otherwise be exceeded by the
+	requested variable alignment.
+	(expand_one_ssa_partition): Likewise.
+	(expand_one_var): Likewise.
+
+2018-08-01  Richard Biener  <rguenther@suse.de>
+
+	PR bootstrap/86724
+	* graphite.h: Include isl/id.h and isl/space.h to allow build
+	with ISL 0.20.
+
+2018-07-29  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_output_addr_vec): Align address table.
+	* config/pa/pa.h (JUMP_TABLES_IN_TEXT_SECTION): Revise comment.
+	* config/pa/pa32-linux.h (JUMP_TABLES_IN_TEXT_SECTION): Define.
+
+2018-07-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	PR target/84168
+	2017-09-28  Joseph Myers  <joseph@codesourcery.com>
+
+	* config/aarch64/aarch64.c (aarch64_elf_asm_constructor)
+	(aarch64_elf_asm_destructor): Pass SECTION_NOTYPE to get_section
+	when creating .init_array and .fini_array sections with priority
+	specified.
+
+2018-07-12  Richard Biener  <rguenther@suse.de>
+
+	PR target/84829
+	* config/gnu-user.h (GNU_USER_TARGET_NO_PTHREADS_LIB_SPEC):
+	Remove -mieee-fp handling.
+
+2018-07-10  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline
+	2017-09-07  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/vsx.md (define_insn "*stxvl"): Add missing argument to
+	the sldi instruction.
+
+2018-06-29  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* lex.c (search_line_fast): Remove illegal coercion of an
+	unaligned pointer value to vector pointer type and replace with
+	use of __builtin_vec_vsx_ld () built-in function, which operates
+	on unaligned pointer values.
+
+2018-06-27  David Edelsohn  <dje.gcc@gmail.com>
+
+	2018-06-19  Tony Reix  <tony.reix@atos.com>
+	    Damien Bergamini  <damien.bergamini@atos.com>
+	    David Edelsohn  <dje.gcc@gmail.com>
+
+	* collect2.c (static_obj): New variable.
+	(static_libs): New variable.
+	(is_in_list): Uncomment declaration.
+	(main): Track AIX libraries linked statically.
+	(is_in_list): Uncomment definition.
+	(scan_prog_file): Don't add AIX shared libraries initializer
+	to constructor list if linking statically.
+
+2018-06-26  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backported from mainline
+	2018-06-20  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Change
+	behavior of vec_packsu (vector unsigned long long, vector unsigned
+	long long) to match behavior of vec_packs with same signature.
+
+2018-06-26  Robin Dapp  <rdapp@linux.vnet.ibm.com>
+
+	* config/s390/s390.h (enum processor_flags): Do not use
+	default tune parameter when -march was specified.
+
+2018-06-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/86314
+	* config/i386/i386.md (setcc + movzbl to xor + setcc peephole2s):
+	Check reg_overlap_mentioned_p in addition to reg_set_p with the same
+	operands.
+
+2018-06-25  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-04-17  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/85424
+	* config/rs6000/rs6000.md (pack<mode>): Do not try handle a pack
+	where the inputs overlap with the output.
+
+2018-06-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84786
+	* config/i386/sse.md (vshift_count): New mode attr.
+	(<shift_insn><mode>3<mask_name>): Use <vshift_count>N instead of vN
+	as last operand's constraint for VI2_AVX2_AVX512BW shifts.  Use YvN
+	instead of vN as last operand's constraint for VI48_AVX2 shifts.
+
+2018-06-23  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR tree-optimization/85989
+	* gimple-ssa-backprop.c (backprop::m_visited_phis): New member
+	variable.
+	(backprop::intersect_uses): Check it when deciding whether this
+	is a backedge reference.
+	(backprop::process_block): Add each phi to m_visited_phis
+	after visiting it, then clear it at the end.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/86231
+	* tree-vrp.c (union_ranges): For (  [  )  ] or (   )[   ] range and
+	anti-range don't overwrite *vr0min before using it to compute *vr0max.
+
+	2018-06-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/85878
+	* expr.c (expand_assignment): Only call store_expr for halves if the
+	mode is the same.
+
+	2018-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85945
+	* lower-subreg.c (find_decomposable_subregs): Don't decompose float
+	subregs of multi-word pseudos unless the float mode has word size.
+
+	2018-06-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86025
+	* tree.c (inchash::add_expr): Handle IDENTIFIER_NODE.
+
+	2018-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85659
+	* cfgexpand.c (expand_asm_stmt): Don't create a temporary if
+	the type is addressable.  Don't force op into register if it has
+	BLKmode.
+
+	2018-05-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR web/85578
+	* doc/install.texi2html: Replace _002d with - and _002a with * in
+	generated html files using sed.
+
+	2018-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85529
+	* tree-ssa-reassoc.c (optimize_range_tests_var_bound): Add FIRST_BB
+	argument.  Don't call get_nonzero_bits if opcode is ERROR_MARK_NODE,
+	rhs2 def stmt's bb is dominated by first_bb and it isn't an obvious
+	zero extension or masking of the MSB bit.
+	(optimize_range_tests): Add FIRST_BB argument, pass it through
+	to optimize_range_tests_var_bound.
+	(maybe_optimize_range_tests, reassociate_bb): Adjust
+	optimize_range_tests callers.
+
+	2018-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85446
+	* match.pd ((intptr_t) x eq/ne CST to x eq/ne (typeof x) cst): Require
+	the integral and pointer types to have the same precision.
+
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure.ac (gcc-driver-name.h): Honor --with-gcc-major-version
+	by using gcc_base_ver to generate a gcc_driver_version, and use
+	it when generating GCC_DRIVER_NAME.
+	* configure: Regenerate.
+
+	2018-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85431
+	* dse.c (record_store): Ignore zero width stores.
+
+	PR target/85430
+	* config/i386/i386.md (*ashlqi3_1_slp): Use alu1 type instead of alu.
+
+	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85300
+	* combine.c (subst): Handle subst of CONST_SCALAR_INT_P new_rtx also
+	into FLOAT and UNSIGNED_FLOAT like ZERO_EXTEND, return a CLOBBER if
+	simplify_unary_operation fails.
+
+	2018-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85257
+	* fold-const.c (native_encode_vector): If not all elts could fit
+	and off is -1, return 0 rather than offset.
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Pass
+	(offset - offset2) / BITS_PER_UNIT as 4th argument to
+	native_encode_expr.  Verify len * BITS_PER_UNIT >= maxsizei.  Don't
+	adjust buffer in native_interpret_expr call.
+
+	2018-04-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/85252
+	* dwarf2out.c (rtl_for_decl_init): For STRING_CST initializer only
+	build CONST_STRING if TYPE_MAX_VALUE is non-NULL and is INTEGER_CST.
+
+	2018-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85167
+	* shrink-wrap.c (move_insn_for_shrink_wrap): Don't set bb_uses and
+	bb_defs if *split_p, instead preinitialize it to NULL.
+
+	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85095
+	* config/i386/i386.md (*add<mode>3_carry_0, *addsi3_carry_zext_0,
+	*sub<mode>3_carry_0, *subsi3_carry_zext_0): New patterns.
+
+	2018-03-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/85022
+	* emit-rtl.c (init_emit_regs): Indicate that VOIDmode MEMs don't have
+	known size by default.
+
+	PR inline-asm/85034
+	* function.c (match_asm_constraints_1): Don't optimize if input
+	doesn't satisfy general_operand predicate for output's mode.
+
+	PR inline-asm/85022
+	* alias.c (write_dependence_p): Don't require for x_canonicalized
+	non-VOIDmode if x has VOIDmode.
+
+	2018-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/84941
+	* function.c (match_asm_constraints_1): Don't do the optimization
+	if input isn't a REG, SUBREG, MEM or constant.
+
+	PR sanitizer/85018
+	* dwarf2asm.c (dw2_output_indirect_constant_1): Set
+	DECL_INITIAL (decl) to decl at the end.
+	* varasm.c (use_blocks_for_decl_p): Revert the 2018-03-20 change,
+	adjust the comment.
+
+	2018-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/84875
+	* dce.c (delete_unmarked_insns): Don't remove frame related noop moves
+	holding REG_CFA_RESTORE notes, instead turn them into a USE.
+
+	PR c/84953
+	* builtins.c (fold_builtin_strpbrk): For strpbrk(x, "") use type
+	instead of TREE_TYPE (s1) for the return value.
+
+	PR target/84990
+	* dwarf2asm.c (dw2_output_indirect_constant_1): Temporarily turn off
+	flag_section_anchors.
+	* varasm.c (use_blocks_for_decl_p): Remove hack for
+	dw2_force_const_mem.
+
+	2018-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/78651
+	* dwarf2asm.c: Include fold-const.c.
+	(dw2_output_indirect_constant_1): Set DECL_INITIAL (decl) to ADDR_EXPR
+	of decl rather than decl itself.
+
+	2018-03-19  Maxim Ostapenko  <m.ostapenko@samsung.com>
+
+	PR sanitizer/78651
+	* dwarf2asm.c (dw2_output_indirect_constant_1): Disable ASan before
+	calling assemble_variable.
+
+	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84899
+	* postreload.c (reload_combine_recognize_pattern): Perform
+	INTVAL addition in unsigned HOST_WIDE_INT type to avoid UB and
+	truncate_int_for_mode the result for the destination's mode.
+
+	PR tree-optimization/84841
+	* tree-ssa-reassoc.c (INTEGER_CONST_TYPE): Change to 1 << 4 from
+	1 << 3.
+	(FLOAT_ONE_CONST_TYPE): Define.
+	(constant_type): Return FLOAT_ONE_CONST_TYPE for -1.0 and 1.0.
+	(sort_by_operand_rank): Put entries with higher constant_type last
+	rather than first to match comments.
+
+	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/79085
+	* calls.c (expand_call): For TREE_ADDRESSABLE rettype ignore alignment
+	check and use address of target always.
+
+	PR target/84860
+	* optabs.c (emit_conditional_move): Pass address of cmode's copy
+	rather than address of cmode as last argument to prepare_cmp_insn.
+
+	2018-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/84834
+	* match.pd ((A & C) != 0 ? D : 0): Use INTEGER_CST@2 instead of
+	integer_pow2p@2 and test integer_pow2p in condition.
+	(A < 0 ? C : 0): Similarly for @1.
+
+	PR target/84827
+	* config/i386/i386.md (round<mode>2): For 387 fancy math, disable
+	pattern if -ftrapping-math -fno-fp-int-builtin-inexact.
+
+	PR target/84786
+	* config/i386/sse.md (sse2_loadhpd): Use Yv constraint rather than v
+	on the last operand.
+
+	2018-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84772
+	* config/rs6000/rs6000.c (rs6000_gimplify_va_arg): Mark va_arg_tmp
+	temporary TREE_ADDRESSABLE before gimplification of BUILT_IN_MEMCPY.
+
+	PR c++/84767
+	* tree-inline.c (copy_tree_body_r): For INDIRECT_REF of a remapped
+	decl, use remap_type if we want to use the type.
+
+	2018-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/84739
+	* tree-tailcall.c (find_tail_calls): Check call arguments against
+	DECL_ARGUMENTS (current_function_decl) rather than
+	DECL_ARGUMENTS (func) when checking for tail recursion.
+
+	2018-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84700
+	* combine.c (combine_simplify_rtx): Don't try to simplify if
+	if_then_else_cond returned non-NULL, but either true_rtx or false_rtx
+	are equal to x.
+
+2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2018-06-05  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/arm/arm_cmse.h (cmse_nsfptr_create): Change typeof to
+	__typeof__.
+	(cmse_check_pointed_object): Likewise.
+
+2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2018-05-17  Jerome Lambourg  <lambourg@adacore.com>
+
+	* config/arm/arm_cmse.h (cmse_nsfptr_create, cmse_is_nsfptr): Remove
+	#include <stdint.h>.  Replace intptr_t with __INTPTR_TYPE__.
+
+2018-06-21  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2018-06-15  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config.gcc (riscv*-*-elf* | riscv*-*-rtems*): Use custom
+	multilibs for *-*-rtems*.
+	* config/riscv/t-rtems: New file.
+
+2018-06-19  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	2018-06-19  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/xtensa.md (UNSPEC_FRAME_BLOCKAGE): New unspec
+	constant.
+	(allocate_stack, frame_blockage, *frame_blockage): New patterns.
+
+2018-06-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gimplify.c (gimplify_init_constructor): Really never clear for an
+	incomplete constructor if CONSTRUCTOR_NO_CLEARING is set.
+
+2018-06-18  Martin Sebor  <msebor@redhat.com>
+
+        PR middle-end/82063
+        * calls.c (alloc_max_size): Correct a logic error/typo.
+        Treat excessive arguments as infinite.  Warn for invalid arguments.
+        * doc/invoke.texi (-Walloc-size-larger-than): Update.
+
+2018-06-14  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2018-06-14  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rtems.h (STDINT_LONG32): Define.
+
+2018-06-11  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-06-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/85755
+	* config/rs6000/rs6000.c (mem_operand_gpr): Enable PRE_INC and PRE_DEC
+	addresses.
+
+2018-06-07  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-06-06  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/63177
+	* /config/rs6000/rs6000.h (ASM_CPU_SPEC): Add support for -mpower9.
+	Don't handle -mcpu=power8 if -mpower9-vector is also used.
+
+2018-06-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-05-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85588
+	* fold-const.c (negate_expr_p): Restrict negation of operand
+	zero of a division to when we know that can happen without
+	overflow.
+	(fold_negate_expr_1): Likewise.
+
+	2018-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85567
+	* gimplify.c (gimplify_save_expr): When in SSA form allow
+	SAVE_EXPRs to compute to SSA vars.
+
+	2018-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85597
+	* tree-vect-stmts.c (vectorizable_operation): For ternary SLP
+	do not use split vect_get_vec_defs call but call vect_get_slp_defs
+	directly.
+
+2018-06-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-06-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390-builtin-types.def: Add void function type.
+	* config/s390/s390-builtins.def: Use the function type for the
+	tbeginc builtin.
+
+2018-06-01  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/85712
+	Backport from mainline:
+	2018-05-23  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/85712
+	* gimple-ssa-strength-reduction.c (struct slsr_cand_d): Add
+	first_interp field.
+	(alloc_cand_and_find_basis): Initialize first_interp field.
+	(slsr_process_mul): Modify first_interp field.
+	(slsr_process_add): Likewise.
+	(slsr_process_cast): Modify first_interp field for each new
+	interpretation.
+	(slsr_process_copy): Likewise.
+	(dump_candidate): Dump first_interp field.
+	(replace_mult_candidate): Process all interpretations, not just
+	subsequent ones.
+	(replace_rhs_if_not_dup): Likewise.
+	(replace_one_candidate): Likewise.
+
+	Backport from mainline:
+	2018-05-25  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/85712
+	* gimple-ssa-strength-reduction.c (replace_one_candidate): Skip if
+	this candidate has already been replaced in-situ by a copy.
+
+2018-05-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (cvtusi2<ssescalarmodesuffix>64<round_name>):
+	Add {q} suffix to insn mnemonic.
+
+2018-05-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/85903
+	* config/i386/sse.md (movdi_to_sse): Do not generate pseudo
+	when memory input operand is handled.
+
+2018-05-21  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline
+	2018-05-17  Pat Haugen  <pthaugen@us.ibm.com>
+		    Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/85698
+	* config/rs6000/rs6000.c (rs6000_output_move_128bit): Check
+	dest operand.
+
+2018-05-17  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2018-05-11  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/85655
+	* ipa-cp.c (intersect_with_plats): Check that the lattice contains
+	single const.
+
+2018-05-01  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2018-04-16  Cesar Philippidis  <cesar@codesourcery.com>
+		    Tom de Vries  <tom@codesourcery.com>
+
+	PR middle-end/84955
+	* omp-expand.c (expand_oacc_for): Add dummy false branch for
+	tiled basic blocks without omp continue statements.
+
+2018-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-04-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85284
+	* tree-ssa-loop-niter.c (number_of_iterations_exit_assumptions):
+	Only use the niter constraining form of simple_iv when the exit
+	is always executed.
+
+	2018-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85244
+	* tree-dfa.c (get_ref_base_and_extent): Reset seen_variable_array_ref
+	after seeing a component reference with an adjacent field.  Treat
+	refs to arrays at struct end of external decls similar to
+	refs to unconstrained commons.
+
+	2018-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85168
+	* tree-ssa-sccvn.c (vn_reference_maybe_forwprop_address): Avoid
+	propagating abnormals.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-17  Martin Liska  <mliska@suse.cz>
+
+	PR lto/85405
+	* ipa-devirt.c (odr_types_equivalent_p): Remove trailing
+	in message, remote space in between '_G' and '('.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-17  Jan Hubicka  <jh@suse.cz>
+
+	PR lto/85405
+	* ipa-devirt.c (odr_types_equivalent_p): Handle bit fields.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
+		    Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/85081
+	* gimplify.c (asan_poison_variable): Don't do the check for
+	gimplify_omp_ctxp here.
+	(gimplify_decl_expr): Do it here.
+	(gimplify_target_expr): Likewise.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-21  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/84963
+	* ipa-icf.c (sem_item_optimizer::fixup_points_to_sets): Remove
+	not intended return statement.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-13  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/84658.
+	* (sem_item_optimizer::sem_item_optimizer): Initialize new
+	vector.
+	(sem_item_optimizer::~sem_item_optimizer): Release it.
+	(sem_item_optimizer::merge_classes): Register variable aliases.
+	(sem_item_optimizer::fixup_pt_set): New function.
+	(sem_item_optimizer::fixup_points_to_sets): Likewise.
+	* ipa-icf.h: Declare new variables and functions.
+
+2018-04-23  Aaron Sawdey  <acsawdey@linux.ibm.com>
+
+	Backport from mainline
+	2018-04-16  Aaron Sawdey  <acsawdey@linux.ibm.com>
+
+	PR target/83660
+	* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin): Mark
+	vec_extract expression as having side effects to make sure it gets
+	a cleanup point.
+
+2018-04-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/85496
+	* expr.c (store_field): In the bitfield case, if the value comes from
+	a function call and is returned in registers by means of a PARALLEL,
+	do not change the mode of the temporary unless BLKmode and VOIDmode.
+
+2018-04-20  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-09  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83969
+	* config/rs6000/rs6000.c (rs6000_offsettable_memref_p): New prototype.
+	Add strict argument and use it.
+	(rs6000_split_multireg_move): Update for new strict argument.
+	(mem_operand_gpr): Disallow all non-offsettable addresses.
+	* config/rs6000/rs6000.md (*movdi_internal64): Use YZ constraint.
+
+2018-04-18  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2018-04-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/85261
+	* config/arm/arm-builtins.c (arm_expand_builtin): Force input operand
+	into register.
+
+2018-04-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-04-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390.c (s390_output_indirect_thunk_function): Check
+	also for flag_dwarf2_cfi_asm.
+
+2018-04-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.md (stack_probe_internal): Rename
+	from "probe_stack".  Update all callers.
+
+2018-04-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2018-04-04  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/85203
+	* config/arm/arm-builtins.c (arm_expand_builtin): Change
+	expansion to perform a bitwise AND of the argument followed by a
+	boolean negation of the result.
+
+2018-04-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/84748
+	* config/aarch64/aarch64.md (*compare_cstore<mode>_insn): Mark pattern
+	as clobbering CC_REGNUM.
+
+2018-04-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/85196
+	* config/sparc/sparc.c (sparc_expand_move): Deal with symbolic operands
+	based on LABEL_REF.  Remove useless assertion.
+	(pic_address_needs_scratch): Fix formatting.
+	(sparc_legitimize_pic_address): Minor tweaks.
+	(sparc_delegitimize_address): Adjust assertion accordingly.
+	* config/sparc/sparc.md (movsi_pic_label_ref): Change label_ref_operand
+	into symbolic_operand.
+	(movsi_high_pic_label_ref): Likewise.
+	(movsi_lo_sum_pic_label_ref): Likewise.
+	(movdi_pic_label_ref): Likewise.
+	(movdi_high_pic_label_ref): Likewise.
+	(movdi_lo_sum_pic_label_ref): Likewise.
+
+2018-04-06  Amaan Cheval  <amaan.cheval@gmail.com>
+
+	* config.gcc (x86_64-*-rtems*): Add rtems.h to tm_file for
+	custom LIB_SPEC setup.
+
+2018-04-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/85193
+	* config/i386/i386.md (define_attr "memory"): Handle rotate1 type.
+
+2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR rtl-optimization/84878
+	* ddg.c (add_cross_iteration_register_deps): Use DF_REF_BB to determine
+	the basic block.  Assert the use reference is not artificial and that
+	it has an associated insn.
+
+2018-04-03  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.c (emit_i387_cw_initialization): Always use logic
+	instructions when changing rounding bits to preserve precision bits
+	in the x87 control word.
+
+2018-04-03  Cesar Philippidis  <cesar@codesourcery.com>
+
+	Backport from mainline
+	2018-03-27  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR target/85056
+	* config/nvptx/nvptx.c (nvptx_assemble_decl_begin): Add '[]' to
+	extern array declarations.
+
+2018-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84912
+	* config/rs6000/rs6000.h: Update copyright date.
+	(RS6000_BTM_POWERPC64): New define.
+	(RS6000_BTM_COMMON): Add RS6000_BTM_POWERPC64.
+	* config/rs6000/rs6000.c: Update copyright date.
+	(rs6000_builtin_mask_calculate): Add support for RS6000_BTM_POWERPC64.
+	(rs6000_invalid_builtin): Add handling for RS6000_BTM_POWERPC64
+	(rs6000_builtin_mask_names): Add RS6000_BTM_POWERPC64.
+	* config/rs6000/rs6000-builtin.def: Update copyright date.
+	(BU_P7_POWERPC64_MISC_2): New macro definition.
+	(DIVDE): Use it.
+	(DIVDEU): Likewise.
+
+	Backport from mainline
+	2018-03-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84912
+	* config/rs6000/rs6000-builtin.def (DIVWEO): Delete macro expansion.
+	(DIVWEUO): Likewise.
+	(DIVDEO): Likewise.
+	(DIVDEUO): Likewise.
+	* config/rs6000/rs6000.c (builtin_function_type): Remove support for
+	DIVWEUO and DIVDEUO.
+	* config/rs6000/rs6000.md: Update copyright date.
+	(UNSPEC_DIVEO, UNSPEC_DIVEUO): Delete unspecs.
+	(UNSPEC_DIV_EXTEND): Remove deleted unspecs.
+	(div_extend): Likewise.
+	* doc/extend.texi: Update copyright date.
+	(__builtin_divweo): Remove documentation for deleted builtin function.
+	(__builtin_divweuo): Likewise.
+	(__builtin_divdeo): Likewise.
+	(__builtin_divdeuo): Likewise.
+
+2018-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-30  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/80546
+	* config/rs6000/vsx.md (??r): New mode attribute.
+	(*vsx_mov<mode>_64bit): Use it.
+	(*vsx_mov<mode>_32bit): Likewise.
+
+2018-03-29  Sebastian Peryt  <sebastian.peryt@intel.com>
+
+	PR c++/84783
+	* config/i386/avx512vlintrin.h (_mm256_permutexvar_epi64)
+	(_mm256_permutexvar_epi32, _mm256_permutex_epi64): New intrinsics.
+
+2018-03-29  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from mainline
+	2018-03-22  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/84826
+	* config/arm/arm.h (machine_function): Add static_chain_stack_bytes.
+	* config/arm/arm.c (arm_compute_static_chain_stack_bytes): Avoid
+	re-computing once computed.
+	(arm_expand_prologue): Compute machine->static_chain_stack_bytes.
+	(arm_init_machine_status): Initialize
+	machine->static_chain_stack_bytes.
+
+2018-03-28  Sudakshina Das  <sudi.das@arm.com>
+
+	2018-03-19  Sudakshina Das  <sudi.das@arm.com>
+	PR target/81647
+
+	* config/aarch64/aarch64-simd.md (vec_cmp<mode><v_cmp_result>): Modify
+	instructions for UNLT, UNLE, UNGT, UNGE, UNEQ, UNORDERED and ORDERED.
+
+2018-03-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/85026
+	* config/arm/arm.md (unaligned_loadhis): Remove first alternative.
+	Clean up attributes.
+
+2018-03-28  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2018-03-08  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/82411
+	* config/rs6000/rs6000.c (rs6000_elf_in_small_data_p): Don't put
+	readonly data in sdata, if that is disabled.
+	* config/rs6000/sysv4.opt (mreadonly-in-sdata): New option.
+	* doc/invoke.texi (RS/6000 and PowerPC Options): Document
+	-mreadonly-in-sdata option.
+
+2018-03-27  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from mainline:
+	2018-03-20  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82989
+	* config/arm/neon.md (ashldi3_neon): Update ?s for constraints
+	to favor GPR over NEON registers.
+	(<shift>di3_neon): Likewise.
+
+2018-03-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/82518
+	* config/arm/arm.c (arm_array_mode_supported_p): Return false for
+	BYTES_BIG_ENDIAN.
+
+2018-03-23  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-20  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83789
+	* config/rs6000/altivec.md (altivec_lvx_<mode>_2op): Delete define_insn.
+	(altivec_lvx_<mode>_1op): Likewise.
+	(altivec_stvx_<mode>_2op): Likewise.
+	(altivec_stvx_<mode>_1op): Likewise.
+	(altivec_lvx_<VM2:mode>): New define_expand.
+	(altivec_stvx_<VM2:mode>): Likewise.
+	(altivec_lvx_<VM2:mode>_2op_<P:mptrsize>): New define_insn.
+	(altivec_lvx_<VM2:mode>_1op_<P:mptrsize>): Likewise.
+	(altivec_stvx_<VM2:mode>_2op_<P:mptrsize>): Likewise.
+	(altivec_stvx_<VM2:mode>_1op_<P:mptrsize>): Likewise.
+	* config/rs6000/rs6000.c (altivec_expand_lv_builtin): Likewise.
+	(altivec_expand_stv_builtin): Likewise.
+	(altivec_expand_builtin): Likewise.
+	* config/rs6000/vector.md: Likewise.
+
+2018-03-23  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline:
+	2018-03-14  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/r6000.c (rtx_is_swappable_p): Add case UNSPEC_VPERMXOR.
+
+2018-03-22  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2018-03-22  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/84956
+	* tree-ssa-tail-merge.c (find_clusters_1): Skip bbs with
+	bb_has_abnormal_pred.
+
+2018-03-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-03-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84574
+	* config/i386/i386.c (indirect_thunk_needed): Update comments.
+	(indirect_thunk_bnd_needed): Likewise.
+	(indirect_thunks_used): Likewise.
+	(indirect_thunks_bnd_used): Likewise.
+	(indirect_return_needed): New.
+	(indirect_return_bnd_needed): Likewise.
+	(output_indirect_thunk_function): Add a bool argument for
+	function return.
+	(output_indirect_thunk_function): Don't generate alias for
+	function return thunk.
+	(ix86_code_end): Call output_indirect_thunk_function to generate
+	function return thunks.
+	(ix86_output_function_return): Set indirect_return_bnd_needed
+	and indirect_return_needed instead of indirect_thunk_bnd_needed
+	and indirect_thunk_needed.
+
+2018-03-14  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/83451
+	* config/pa/pa.c (pa_emit_move_sequence):  Always emit secondary reload
+	insn for floating-point loads and stores.
+
+2018-03-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/invoke.texi (-mclflushopt): Fix spelling of option.
+
+2018-03-12  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR tree-optimization/84485
+	* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Return
+	true for zero dependence distances if the step might be zero,
+	and if there is no metadata that guarantees correctness.
+	(vect_analyze_data_ref_access): Check safelen as well as
+	force_vectorize.
+
+2018-03-11  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-02-14  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/83984
+	* config/pa/pa.md: Load address of PIC label using the linkage table
+	if the label is nonlocal.
+
+	Backport from mainline
+	2018-03-06  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.h (ASM_GENERATE_INTERNAL_LABEL): Revise to use
+	sprint_ul.
+	(ASM_OUTPUT_ADDR_VEC_ELT): Revise for above change.
+	(ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.
+	* config/pa/pa64-hpux.h (ASM_GENERATE_INTERNAL_LABEL): Revise as above.
+
+2018-03-09  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	Backport from mainline
+	2017-09-13  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	* config/aarch64/aarch64.c (aarch64_override_options_after_change_1):
+	Disable pc relative literal load irrespective of TARGET_FIX_ERR_A53_84341
+	for default.
+
+2018-03-06  Denis Chertykov  <chertykov@gmail.com>
+
+	Backport from mainline
+	2018-02-07  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/84209
+	* config/avr/avr.h (GENERAL_REGNO_P, GENERAL_REG_P): New macros.
+	* config/avr/avr.md: Only post-reload split REG-REG moves if
+	either register is GENERAL_REG_P.
+
+2018-03-06  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline
+	2/16/18  commit 257748  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/altivec.h: Remove vec_vextract4b and vec_vinsert4b.
+	* config/rs6000/rs6000-builtin.def: Remove macro expansion for
+	VINSERT4B_DI and VINSERT4B.
+	* config/rs6000/rs6000.c: Remove case statements for
+	P9V_BUILTIN_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
+	and P9V_BUILTIN_VEC_VINSERT4B.
+	* config/rs6000/rs6000-c.c (altivec_expand_builtin): Remove entries for
+	P9V_BUILTIN_VEC_VEXTRACT4B and P9V_BUILTIN_VEC_VINSERT4B.
+	* config/rs6000/vsx.md:  Remove define_expand vinsert4b,
+	define_insn *vinsert4b_internal, define_insn "*vinsert4b_di_internal.
+	* doc/extend.texi: Remove vec_vextract4b, non ABI definitions for
+	vec_insert4b.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-20  Martin Liska  <mliska@suse.cz>
+
+	PR c/84310
+	PR target/79747
+	* final.c (shorten_branches): Build align_tab array with one
+	more element.
+	* opts.c (finish_options): Add alignment option limit check.
+	(MAX_CODE_ALIGN): Likewise.
+	(MAX_CODE_ALIGN_VALUE): Likewise.
+	* doc/invoke.texi: Document maximum allowed option value for
+	all -falign-* options.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-19  Martin Liska  <mliska@suse.cz>
+
+	PR other/80589
+	* doc/invoke.texi: Fix typo.
+	* params.def (PARAM_MAX_LOOP_HEADER_INSNS): Likewise.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-05  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/84137
+	* doc/gcov.texi: Fix typo in documentation.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-05  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/83879
+	* doc/gcov.texi: Document necessity of --dynamic-list-data when
+	using dlopen functionality.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-12-19  Martin Liska  <mliska@suse.cz>
+
+	PR rtl-optimization/82675
+	* loop-unroll.c (unroll_loop_constant_iterations): Allocate one
+	more element in sbitmap.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-05  Martin Liska  <mliska@suse.cz>
+
+	* ipa-utils.c (ipa_merge_profiles): Do not merge alias or
+	a function without profile.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-21  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR c/84229
+	* ipa-cp.c (determine_versionability): Do not version functions caling
+	va_arg_pack.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/81360
+	* cgraph.h (symtab_node::output_to_lto_symbol_table_p): Declare
+	* symtab.c: Include builtins.h
+	(symtab_node::output_to_lto_symbol_table_p): Move here
+	from lto-streamer-out.c:output_symbol_p.
+	* lto-streamer-out.c (write_symbol): Turn early exit to assert.
+	(output_symbol_p): Move all logic to symtab.c
+	(produce_symtab): Update.
+
+2018-03-06  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-22  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR target/81572
+	* lra-int.h (LRA_UNKNOWN_ALT, LRA_NON_CLOBBERED_ALT): New macros.
+	* lra.c (lra_set_insn_recog_data, lra_update_insn_recog_data): Use
+	LRA_UNKNOWN_ALT.
+	* lra-constraints.c (curr_insn_transform): Set up
+	LRA_NON_CLOBBERED_ALT for moves processed on the fast path.  Use
+	LRA_UNKNOWN_ALT.
+	(remove_inheritance_pseudos): Use LRA_UNKNOWN_ALT.
+	* lra-eliminations.c (spill_pseudos): Ditto.
+	(process_insn_for_elimination): Ditto.
+	* lra-lives.c (reg_early_clobber_p): Use the new macros.
+	* lra-spills.c (spill_pseudos): Use LRA_UNKNOWN_ALT and
+	LRA_NON_CLOBBERED_ALT.
+
+2018-03-06  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-03-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84486
+	* tree-ssa-pre.c (create_expression_by_pieces): Remove dead code.
+	When inserting a __builtin_assume_aligned call set the LHS
+	SSA name alignment info accordingly.
+
+	2018-02-28  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/84607
+	* genmatch.c (capture_info::walk_match): Do not mark
+	captured expressions without operands as expr_p given
+	they act more like predicates and should be subject to
+	"lost tail" side-effect preserving.
+
+2018-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84524
+	* config/i386/sse.md (*<code><mode>3): Replace <mask_prefix3> with
+	orig,vex.
+	(*<plusminus_insn><mode>3): Likewise.  Remove <mask_operand3> uses.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+		    Richard Biener  <rguenther@suse.de>
+
+	PR ipa/84628
+	* expr.c (expand_expr_real_1) <case CALL_EXPR>: Don't emit diagnostics
+	for error or warning attributes if CALL_FROM_THUNK_P is set.
+	Formatting fixes.
+
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/84625
+	* config/i386/i386.c (ix86_print_operand): Use conditional
+	output_operand_lossage instead of gcc_assert if CONST_VECTOR is not
+	zero vector.
+
+	2018-02-23  Jakub Jelinek  <jakub@redhat.com>
+
+	* ipa-prop.c (ipa_vr_ggc_hash_traits::hash): Hash p->min and
+	p->max as pointers rather than using iterative_hash_expr.
+
+	2017-11-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/82916
+	* gimple-ssa-store-merging.c
+	(pass_store_merging::terminate_all_aliasing_chains): For
+	gimple_store_p stmts also call refs_output_dependent_p.
+
+	2018-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84444
+	* builtins.c (builtin_mathfn_code): Don't check if CALL_EXPR_FN (t)
+	is ADDR_EXPR.
+
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/84425
+	* ipa-inline.c (inline_small_functions): Fix a typo.
+
+	2018-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/82210
+	* stor-layout.c (place_field): For variable length fields, adjust
+	offset_align afterwards not just based on the field's alignment,
+	but also on the size.
+
+	2018-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* omp-low.c (maybe_remove_omp_member_access_dummy_vars,
+	remove_member_access_dummy_vars): New functions.
+	(lower_omp_for, lower_omp_taskreg, lower_omp_target,
+	lower_omp_1, execute_lower_omp): Use them.
+
+	PR rtl-optimization/84308
+	* shrink-wrap.c (spread_components): Release todo vector.
+
+	2018-02-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/84285
+	* gcc.c (STATIC_LIBASAN_LIBS, STATIC_LIBTSAN_LIBS,
+	STATIC_LIBLSAN_LIBS, STATIC_LIBUBSAN_LIBS): Handle -static like
+	-static-lib*san.
+
+	2018-02-09  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83659
+	* fold-const.c (fold_indirect_ref_1): Use VECTOR_TYPE_P macro.
+	Formatting fixes.  Verify first that tree_fits_shwi_p (op01).
+	Sync some changes from cxx_fold_indirect_ref.
+
+	2018-02-07  Jakub Jelinek  <jakub@redhat.com>
+
+	* tree-eh.c (operation_could_trap_helper_p): Ignore honor_trapv for
+	*DIV_EXPR and *MOD_EXPR.
+
+	2018-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/81661
+	PR tree-optimization/84117
+	* tree-eh.h (rewrite_to_non_trapping_overflow): Declare.
+	* tree-eh.c: Include gimplify.h.
+	(find_trapping_overflow, replace_trapping_overflow,
+	rewrite_to_non_trapping_overflow): New functions.
+	* tree-vect-loop.c: Include tree-eh.h.
+	(vect_get_loop_niters): Use rewrite_to_non_trapping_overflow.
+
+	2018-01-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/83986
+	* sched-deps.c (sched_analyze_insn): For frame related insns, add anti
+	dependence against last_pending_memory_flush in addition to
+	pending_jump_insns.
+
+	2018-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/84040
+	* sched-deps.c (sched_macro_fuse_insns): Return immediately if
+	!insn_set.
+
+	2018-01-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/83977
+	* tree-inline.c (tree_function_versioning): Remove "omp declare simd"
+	attributes from DECL_ATTRIBUTES (new_decl) without affecting
+	DECL_ATTRIBUTES (old_decl).
+
+	2018-01-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/83945
+	* tree-emutls.c: Include gimplify.h.
+	(lower_emutls_2): New function.
+	(lower_emutls_1): If ADDR_EXPR is a gimple invariant and walk_tree
+	with lower_emutls_2 callback finds some TLS decl in it, unshare_expr
+	it before further processing.
+
+	PR target/83930
+	* simplify-rtx.c (simplify_binary_operation_1) <case UMOD>: Use
+	UINTVAL (trueop1) instead of INTVAL (op1).
+
+	2018-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/83722
+	* gcc.c (try_generate_repro): Pass
+	&temp_stderr_files[RETRY_ICE_ATTEMPTS - 1] rather than
+	&temp_stdout_files[RETRY_ICE_ATTEMPTS - 1] as last argument to
+	do_report_bug.
+
+	2018-01-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/83605
+	* gimple-ssa-strength-reduction.c: Include tree-eh.h.
+	(find_candidates_dom_walker::before_dom_children): Ignore stmts that
+	can throw.
+
+2018-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84039
+	* config/i386/constraints.md (Bs): Replace
+	ix86_indirect_branch_register with
+	TARGET_INDIRECT_BRANCH_REGISTER.
+	(Bw): Likewise.
+	* config/i386/i386.md (indirect_jump): Likewise.
+	(tablejump): Likewise.
+	(*sibcall_memory): Likewise.
+	(*sibcall_value_memory): Likewise.
+	Peepholes of indirect call and jump via memory: Likewise.
+	(*sibcall_GOT_32): Disallowed for TARGET_INDIRECT_BRANCH_REGISTER.
+	(*sibcall_value_GOT_32): Likewise.
+	* config/i386/predicates.md (indirect_branch_operand): Likewise.
+	(GOT_memory_operand): Likewise.
+	(call_insn_operand): Likewise.
+	(sibcall_insn_operand): Likewise.
+	(GOT32_symbol_operand): Likewise.
+	* config/i386/i386.h (TARGET_INDIRECT_BRANCH_REGISTER): New.
+
+2018-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/i386.c (ix86_output_indirect_jmp): Update comments.
+
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84530
+	* config/i386/i386-protos.h (ix86_output_indirect_jmp): Remove
+	the bool argument.
+	(ix86_output_indirect_function_return): New prototype.
+	(ix86_split_simple_return_pop_internal): Likewise.
+	* config/i386/i386.c (indirect_return_via_cx): New.
+	(indirect_return_via_cx_bnd): Likewise.
+	(indirect_thunk_name): Handle return va CX_REG.
+	(output_indirect_thunk_function): Create alias for
+	__x86_return_thunk_[re]cx and __x86_return_thunk_[re]cx_bnd.
+	(ix86_output_indirect_jmp): Remove the bool argument.
+	(ix86_output_indirect_function_return): New function.
+	(ix86_split_simple_return_pop_internal): Likewise.
+	* config/i386/i386.md (*indirect_jump): Don't pass false
+	to ix86_output_indirect_jmp.
+	(*tablejump_1): Likewise.
+	(simple_return_pop_internal): Change it to define_insn_and_split.
+	Call ix86_split_simple_return_pop_internal to split it for
+	-mfunction-return=.
+	(simple_return_indirect_internal): Call
+	ix86_output_indirect_function_return instead of
+	ix86_output_indirect_jmp.
+
+2017-03-02  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport from trunk r256891:
+	2018-01-19  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR target/83790
+	* config/nvptx/nvptx.c (output_init_frag): Don't use generic address
+	spaces for function labels.
+
+2018-02-26  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline: commit 257747 on 2018-02-16.
+
+	* config/rs6000/altivec.h: Add builtin names vec_extract4b
+	vec_insert4b.
+	* config/rs6000/rs6000-builtin.def: Add INSERT4B and EXTRACT4B
+	definitions.
+	* config/rs6000/rs6000-c.c: Add the definitions for
+	P9V_BUILTIN_VEC_EXTRACT4B and P9V_BUILTIN_VEC_INSERT4B.
+	* config/rs6000/rs6000.c (altivec_expand_builtin): Add
+	P9V_BUILTIN_EXTRACT4B and P9V_BUILTIN_INSERT4B case statements.
+	* config/rs6000/vsx.md: Add define_insn extract4b.  Add define_expand
+	definition for insert4b and define insn *insert3b_internal.
+	* doc/extend.texi: Add documentation for vec_extract4b.
+
+2018-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/83496
+	* reorg.c (steal_delay_list_from_target): Change REDUNDANT array from
+	booleans to RTXes.  Call fix_reg_dead_note on every non-null element.
+	(steal_delay_list_from_fallthrough): Call fix_reg_dead_note on a
+	redundant insn, if any.
+	(relax_delay_slots): Likewise.
+	(update_reg_unused_notes): Rename REDUNDANT_INSN to OTHER_INSN.
+
+2018-02-22  Sudakshina Das  <sudi.das@arm.com>
+	    Bin Cheng  <bin.cheng@arm.com>
+
+	Backport from mainline:
+	2017-12-14  Sudakshina Das  <sudi.das@arm.com>
+		    Bin Cheng  <bin.cheng@arm.com>
+
+	PR target/81228
+	* config/aarch64/aarch64.c (aarch64_select_cc_mode): Move LTGT to
+	CCFPEmode.
+	* config/aarch64/aarch64-simd.md (vec_cmp<mode><v_cmp_result>): Add
+	LTGT.
+
+2018-02-16  Jozef Lawrynowicz <jozefl.gcc@gmail.com>
+
+	PR target/79242
+	* machmode.def: Define a complex mode for PARTIAL_INT.
+	* genmodes.c (complex_class): Return MODE_COMPLEX_INT for
+	MODE_PARTIAL_INT.
+	* doc/rtl.texi: Document CSPImode.
+	* config/msp430/msp430.c (msp430_hard_regno_nregs): Add CPSImode
+	handling.
+	(msp430_hard_regno_nregs_with_padding): Likewise.
+
+2018-02-16  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from trunk
+	2018-01-10  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82096
+	* expmed.c (emit_store_flag_force): Swap if const op0
+	and change VOIDmode to mode of op0.
+
+2018-02-16  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84190
+	* tree-ssa.c (non_rewritable_mem_ref_base): Do not touch
+	volatile accesses if the decl isn't volatile.
+
+2018-02-15  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-02-07  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/84154
+	* config/rs6000/rs6000.md (fix_trunc<SFDF:mode><QHI:mode>2):
+	Convert from define_expand to be define_insn_and_split.  Rework
+	float/double/_Float128 conversions to QI/HI/SImode to work with
+	both ISA 2.07 (power8) or ISA 3.0 (power9).  Fix regression where
+	conversions to QI/HImode types did a store and then a load to
+	truncate the value.  For conversions to VSX registers, don't split
+	the insn, instead emit the code directly.  Use the code iterator
+	any_fix to combine signed and unsigned conversions.
+	(fix<uns>_trunc<SFDF:mode>si2_p8): Likewise.
+	(fixuns_trunc<SFDF:mode><QHI:mode>2): Likewise.
+	(fix_trunc<IEEE128:mode><QHI:mode>2): Likewise.
+	(fix<uns>_trunc<SFDF:mode><QHI:mode>2): Likewise.
+	(fix_<mode>di2_hw): Likewise.
+	(fixuns_<mode>di2_hw): Likewise.
+	(fix_<mode>si2_hw): Likewise.
+	(fixuns_<mode>si2_hw): Likewise.
+	(fix<uns>_<IEEE128:mode><SDI:mode>2_hw): Likewise.
+	(fix<uns>_trunc<IEEE128:mode><QHI:mode>2): Likewise.
+	(fctiw<u>z_<mode>_smallint): Rename fctiw<u>z_<mode>_smallint to
+	fix<uns>_trunc<SFDF:mode>si2_p8.
+	(fix_trunc<SFDF:mode><QHI:mode>2_internal): Delete, no longer
+	used.
+	(fixuns_trunc<SFDF:mode><QHI:mode>2_internal): Likewise.
+	(fix<uns>_<mode>_mem): Likewise.
+	(fctiw<u>z_<mode>_mem): Likewise.
+	(fix<uns>_<mode>_mem): Likewise.
+	(fix<uns>_trunc<SFDF:mode><QHSI:mode>2_mem): On ISA 3.0, prevent
+	the register allocator from doing a direct move to the GPRs to do
+	a store, and instead use the ISA 3.0 store byte/half-word from
+	vector register instruction.  For IEEE 128-bit floating point,
+	also optimize stores of 32-bit ints.
+	(fix<uns>_trunc<IEEE128:mode><QHSI:mode>2_mem): Likewise.
+
+2018-02-15  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>
+
+	Back port from mainline
+	2018-01-30  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>
+
+	PR target/83758
+	* config/rs6000/rs6000.c (rs6000_internal_arg_pointer): Only return
+	a reg rtx.
+
+2018-02-14  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-02-13  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84279
+	* config/rs6000/rs6000.c (mem_operand_gpr): Disallow altivec addresses.
+
+2018-02-14  Martin Jambor  <mjambor@suse.cz>
+
+	PR c++/83990
+	* ipa-prop.c (ipa_modify_call_arguments): Use location of call
+	statements, also set location of a load to a temporary.
+
+2018-02-10  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (hppa_profile_hook): Mark SYMBOL_REF for _mcount as
+	function label.
+
+	Backport from mainline
+	2018-02-01  Aldy Hernandez  <aldyh@redhat.com>
+
+	PR target/84089
+	* config/pa/predicates.md (base14_operand): Handle VOIDmode.
+
+2018-02-09  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Martin Jambor  <mjambor@suse.cz>
+
+	* hsa-gen.c (get_symbol_for_decl): Set program allocation for
+	static local variables.
+
+2018-02-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	PR target/PR84295
+	* config/s390/s390.c (s390_set_current_function): Invoke
+	s390_indirect_branch_settings also if fndecl didn't change.
+
+2018-02-08  Iain Sandoe  <iain@codesourcery.com>
+
+	PR target/84113
+	* config/rs6000/altivec.md (*restore_world): Remove LR use.
+	* config/rs6000/predicates.md (restore_world_operation): Adjust op
+	count, remove one USE.
+
+2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390-opts.h (enum indirect_branch): Define.
+	* config/s390/s390-protos.h (s390_return_addr_from_memory)
+	(s390_indirect_branch_via_thunk)
+	(s390_indirect_branch_via_inline_thunk): Add function prototypes.
+	(enum s390_indirect_branch_type): Define.
+	* config/s390/s390.c (struct s390_frame_layout, struct
+	machine_function): Remove.
+	(indirect_branch_prez10thunk_mask, indirect_branch_z10thunk_mask)
+	(indirect_branch_table_label_no, indirect_branch_table_name):
+	Define variables.
+	(INDIRECT_BRANCH_NUM_OPTIONS): Define macro.
+	(enum s390_indirect_branch_option): Define.
+	(s390_return_addr_from_memory): New function.
+	(s390_handle_string_attribute): New function.
+	(s390_attribute_table): Add new attribute handler.
+	(s390_execute_label): Handle UNSPEC_EXECUTE_JUMP patterns.
+	(s390_indirect_branch_via_thunk): New function.
+	(s390_indirect_branch_via_inline_thunk): New function.
+	(s390_function_ok_for_sibcall): When jumping via thunk disallow
+	sibling call optimization for non z10 compiles.
+	(s390_emit_call): Force indirect branch target to be a single
+	register.  Add r1 clobber for non-z10 compiles.
+	(s390_emit_epilogue): Emit return jump via return_use expander.
+	(s390_reorg): Handle JUMP_INSNs as execute targets.
+	(s390_option_override_internal): Perform validity checks for the
+	new command line options.
+	(s390_indirect_branch_attrvalue): New function.
+	(s390_indirect_branch_settings): New function.
+	(s390_set_current_function): Invoke s390_indirect_branch_settings.
+	(s390_output_indirect_thunk_function):  New function.
+	(s390_code_end): Implement target hook.
+	(s390_case_values_threshold): Implement target hook.
+	(TARGET_ASM_CODE_END, TARGET_CASE_VALUES_THRESHOLD): Define target
+	macros.
+	* config/s390/s390.h (struct s390_frame_layout)
+	(struct	machine_function): Move here from s390.c.
+	(TARGET_INDIRECT_BRANCH_NOBP_RET)
+	(TARGET_INDIRECT_BRANCH_NOBP_JUMP)
+	(TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)
+	(TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)
+	(TARGET_INDIRECT_BRANCH_NOBP_CALL)
+	(TARGET_DEFAULT_INDIRECT_BRANCH_TABLE)
+	(TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL)
+	(TARGET_INDIRECT_BRANCH_THUNK_NAME_EX)
+	(TARGET_INDIRECT_BRANCH_TABLE): Define macros.
+	* config/s390/s390.md (UNSPEC_EXECUTE_JUMP)
+	(INDIRECT_BRANCH_THUNK_REGNUM): Define constants.
+	(mnemonic attribute): Add values which aren't recognized
+	automatically.
+	("*cjump_long", "*icjump_long", "*basr", "*basr_r"): Disable
+	pattern for branch conversion.  Fix mnemonic attribute.
+	("*c<code>", "*sibcall_br", "*sibcall_value_br", "*return"): Emit
+	indirect branch via thunk if requested.
+	("indirect_jump", "<code>"): Expand patterns for branch conversion.
+	("*indirect_jump"): Disable for branch conversion using out of
+	line thunks.
+	("indirect_jump_via_thunk<mode>_z10")
+	("indirect_jump_via_thunk<mode>")
+	("indirect_jump_via_inlinethunk<mode>_z10")
+	("indirect_jump_via_inlinethunk<mode>", "*casesi_jump")
+	("casesi_jump_via_thunk<mode>_z10", "casesi_jump_via_thunk<mode>")
+	("casesi_jump_via_inlinethunk<mode>_z10")
+	("casesi_jump_via_inlinethunk<mode>", "*basr_via_thunk<mode>_z10")
+	("*basr_via_thunk<mode>", "*basr_r_via_thunk_z10")
+	("*basr_r_via_thunk", "return<mode>_prez10"): New pattern.
+	("*indirect2_jump"): Disable for branch conversion.
+	("casesi_jump"): Turn into expander and expand patterns for branch
+	conversion.
+	("return_use"): New expander.
+	("*return"): Emit return via thunk and rename it to ...
+	("*return<mode>"): ... this one.
+	* config/s390/s390.opt: Add new options and and enum for the
+	option values.
+
+2018-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84233
+	* tree-ssa-phiprop.c (propagate_with_phi): Use separate
+	changed flag instead of boguously re-using phi_inserted.
+
+2018-02-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-06  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_option_override_internal):
+	Display warning message for -mno-speculate-indirect-jumps.
+
+2018-02-05  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline
+	2018-01-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR bootstrap/84017
+	* configure.ac (gcc_cv_as_shf_merge): Disable on Solaris 10/x86.
+	* configure: Regenerate.
+
+2018-02-05  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-02-01  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/56010
+	PR target/83743
+	* config/rs6000/driver-rs6000.c: #include "diagnostic.h".
+	#include "opts.h".
+	(rs6000_supported_cpu_names): New static variable.
+	(linux_cpu_translation_table): Likewise.
+	(elf_platform) <cpu>: Define new static variable and use it.
+	Translate kernel AT_PLATFORM name to canonical name if needed.
+	Error if platform name is unknown.
+
+2018-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/i386.c (ix86_output_function_return): Pass
+	INVALID_REGNUM, instead of -1, as invalid register number to
+	indirect_thunk_name and output_indirect_thunk.
+
+2018-02-01  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-01-31  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/84123
+	* combine.c (change_zero_ext): Check if hard register satisfies
+	can_change_dest_mode before calling gen_lowpart_SUBREG.
+
+2018-02-01  Renlin Li  <renlin.li@arm.com>
+
+	Backport from mainline
+	2018-02-01  Renlin Li  <renlin.li@arm.com>
+
+	PR target/83370
+	* config/aarch64/aarch64.c (aarch64_class_max_nregs): Handle
+	TAILCALL_ADDR_REGS.
+	(aarch64_register_move_cost): Likewise.
+	* config/aarch64/aarch64.h (reg_class): Rename CALLER_SAVE_REGS to
+	TAILCALL_ADDR_REGS.
+	(REG_CLASS_NAMES): Likewise.
+	(REG_CLASS_CONTENTS): Rename CALLER_SAVE_REGS to
+	TAILCALL_ADDR_REGS. Remove IP registers.
+	* config/aarch64/aarch64.md (Ucs): Update register constraint.
+
+2018-02-01  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2017-11-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/82795
+	* tree-if-conv.c (predicate_mem_writes): Remove bogus assert.
+
+2018-01-31  Richard Biener <rguenther@suse.de>
+	    Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-01-29  Richard Biener <rguenther@suse.de>
+		    Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR bootstrap/80867
+	* tree-vect-stmts.c (vectorizable_call): Don't call
+	targetm.vectorize_builtin_md_vectorized_function if callee is
+	NULL.
+
+2018-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/84071
+	* doc/tm.texi.in (WORD_REGISTER_OPERATIONS): Add explicit case.
+	* doc/tm.texi: Regenerate.
+
+2018-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/84071
+	* combine.c (record_dead_and_set_regs_1): Record the source unmodified
+	for a paradoxical SUBREG on a WORD_REGISTER_OPERATIONS target.
+
+2018-01-29  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline
+	2018-01-24  Joseph Myers  <joseph@codesourcery.com>
+
+	PR target/68467
+	* config/m68k/m68k.c (m68k_promote_function_mode): New function.
+	(TARGET_PROMOTE_FUNCTION_MODE): New macro.
+
+2018-01-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-01-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/81763
+	* config/i386/i386.md (*andndi3_doubleword): Add earlyclobber
+	to (=&r,r,rm) alternative. Add (=r,0,rm) and (=r,r,0) alternatives.
+
+2018-01-29  Alan Modra  <amodra@gmail.com>
+
+	Backport from mainline
+	2018-01-26  Alan Modra  <amodra@gmail.com>
+	PR target/84033
+	* config/rs6000/rs6000.c (rtx_is_swappable_p): Exclude
+	UNSPEC_VBPERMQ.
+
+2018-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* doc/invoke.texi: Replace -mfunction-return==@var{choice} with
+	-mfunction-return=@var{choice}.
+
+2018-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-01-23  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/83905
+	* config/i386/i386.c (ix86_expand_prologue): Use cost reference
+	of struct ix86_frame.
+	(ix86_expand_epilogue): Likewise.  Add a local variable for
+	the reg_save_offset field in struct ix86_frame.
+
+2018-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/83985
+	* dce.c (deletable_insn_p): Return false for separate shrink wrapping
+	REG_CFA_RESTORE insns.
+	(delete_unmarked_insns): Don't ignore separate shrink wrapping
+	REG_CFA_RESTORE insns here.
+
+2018-01-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-01-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.c (indirect_thunk_name): Declare regno
+	as unsigned int.  Compare regno with INVALID_REGNUM.
+	(output_indirect_thunk): Ditto.
+	(output_indirect_thunk_function): Ditto.
+	(ix86_code_end): Declare regno as unsigned int.  Use INVALID_REGNUM
+	in the call to output_indirect_thunk_function.
+
+2018-01-25  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-01-22  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/83862
+	* config/rs6000/rs6000-protos.h (rs6000_split_signbit): Delete,
+	no longer used.
+	* config/rs6000/rs6000.c (rs6000_split_signbit): Likewise.
+	* config/rs6000/rs6000.md (signbit<mode>2): Change code for IEEE
+	128-bit to produce an UNSPEC move to get the double word with the
+	signbit and then a shift directly to do signbit.
+	(signbit<mode>2_dm): Replace old IEEE 128-bit signbit
+	implementation with a new version that just does either a direct
+	move or a regular move.  Move memory interface to separate insns.
+	Move insns so they are next to the expander.
+	(signbit<mode>2_dm_mem_be): New combiner insns to combine load
+	with signbit move.  Split big and little endian case.
+	(signbit<mode>2_dm_mem_le): Likewise.
+	(signbit<mode>2_dm_<su>ext): Delete, no longer used.
+	(signbit<mode>2_dm2): Likewise.
+
+2018-01-25  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-01-10  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83399
+	* config/rs6000/rs6000.c (print_operand) <'y'>: Use
+	VECTOR_MEM_ALTIVEC_OR_VSX_P.
+	* config/rs6000/vsx.md (*vsx_le_perm_load_<mode> for VSX_D): Use
+	indexed_or_indirect_operand predicate.
+	(*vsx_le_perm_load_<mode> for VSX_W): Likewise.
+	(*vsx_le_perm_load_v8hi): Likewise.
+	(*vsx_le_perm_load_v16qi): Likewise.
+	(*vsx_le_perm_store_<mode> for VSX_D): Likewise.
+	(*vsx_le_perm_store_<mode> for VSX_W): Likewise.
+	(*vsx_le_perm_store_v8hi): Likewise.
+	(*vsx_le_perm_store_v16qi): Likewise.
+	(eight unnamed splitters): Likewise.
+
+2018-01-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-01-02  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000-p8swap.c (swap_feeds_both_load_and_store):
+	New function.
+	(rs6000_analyze_swaps): Mark a web unoptimizable if it contains a
+	swap associated with both a load and a store.
+
+2018-01-25  Richard Biener  <rguenther@suse.de>
+
+	* BASE-VER: Increment to 7.3.1.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/gcc/collect2.c gcc-7.3.0-msp430/gcc/collect2.c
--- gcc-7.3.0/gcc/collect2.c	2017-04-03 15:30:56.274463000 -0700
+++ gcc-7.3.0-msp430/gcc/collect2.c	2019-06-25 02:27:21.069931647 -0700
@@ -1,6 +1,6 @@
 /* Collect static initialization info into data structures that can be
    traversed by C++ initialization and finalization routines.
-   Copyright (C) 1992-2017 Free Software Foundation, Inc.
+   Copyright (C) 1992-2018 Free Software Foundation, Inc.
    Contributed by Chris Smith (csmith@convex.com).
    Heavily modified by Michael Meissner (meissner@cygnus.com),
    Per Bothner (bothner@cygnus.com), and John Gilmore (gnu@cygnus.com).
@@ -201,6 +201,7 @@
 bool helpflag;			/* true if --help */
 
 static int shared_obj;			/* true if -shared */
+static int static_obj;			/* true if -static */
 
 static const char *c_file;		/* <xxx>.c for constructor/destructor list.  */
 static const char *o_file;		/* <xxx>.o for constructor/destructor list.  */
@@ -255,6 +256,7 @@
 #ifdef COLLECT_EXPORT_LIST
 /* Lists to keep libraries to be scanned for global constructors/destructors.  */
 static struct head libs;                    /* list of libraries */
+static struct head static_libs;             /* list of statically linked libraries */
 static struct path_prefix cmdline_lib_dirs; /* directories specified with -L */
 static struct path_prefix libpath_lib_dirs; /* directories in LIBPATH */
 static struct path_prefix *libpaths[3] = {&cmdline_lib_dirs,
@@ -320,9 +322,7 @@
 static void scan_libraries (const char *);
 #endif
 #ifdef COLLECT_EXPORT_LIST
-#if 0
 static int is_in_list (const char *, struct id *);
-#endif
 static void write_aix_file (FILE *, struct id *);
 static char *resolve_lib_name (const char *);
 #endif
@@ -911,6 +911,9 @@
   int first_file;
   int num_c_args;
   char **old_argv;
+#ifdef COLLECT_EXPORT_LIST
+  bool is_static = false;
+#endif
   int i;
 
   for (i = 0; i < USE_LD_MAX; i++)
@@ -1241,6 +1244,8 @@
 	*c_ptr++ = xstrdup (q);
       if (strcmp (q, "-shared") == 0)
 	shared_obj = 1;
+      if (strcmp (q, "-static") == 0)
+	static_obj = 1;
       if (*q == '-' && q[1] == 'B')
 	{
 	  *c_ptr++ = xstrdup (q);
@@ -1269,6 +1274,9 @@
   /* Parse arguments.  Remember output file spec, pass the rest to ld.  */
   /* After the first file, put in the c++ rt0.  */
 
+#ifdef COLLECT_EXPORT_LIST
+  is_static = static_obj;
+#endif
   first_file = 1;
   while ((arg = *++argv) != (char *) 0)
     {
@@ -1374,6 +1382,18 @@
 #endif
               break;
 
+#ifdef COLLECT_EXPORT_LIST
+	    case 'b':
+	      if (!strcmp (arg, "-bstatic"))
+		{
+		  is_static = true;
+		}
+	      else if (!strcmp (arg, "-bdynamic") || !strcmp (arg, "-bshared"))
+		{
+		  is_static = false;
+		}
+	      break;
+#endif
 	    case 'l':
 	      if (first_file)
 		{
@@ -1390,6 +1410,8 @@
 
 		/* Saving a full library name.  */
 		add_to_list (&libs, s);
+		if (is_static)
+		    add_to_list (&static_libs, s);
 	      }
 #endif
 	      break;
@@ -1490,6 +1512,8 @@
 	    {
 	      /* Saving a full library name.  */
 	      add_to_list (&libs, arg);
+	      if (is_static)
+		add_to_list (&static_libs, arg);
 	    }
 #endif
 	}
@@ -1501,6 +1525,8 @@
     {
       fprintf (stderr, "List of libraries:\n");
       dump_list (stderr, "\t", libs.first);
+      fprintf (stderr, "List of statically linked libraries:\n");
+      dump_list (stderr, "\t", static_libs.first);
     }
 
   /* The AIX linker will discard static constructors in object files if
@@ -1525,9 +1551,11 @@
       this_filter &= ~SCAN_DWEH;
 #endif
 
+    /* Scan object files.  */
     while (export_object_lst < object)
       scan_prog_file (*export_object_lst++, PASS_OBJ, this_filter);
 
+    /* Scan libraries.  */
     for (; list; list = list->next)
       scan_prog_file (list->name, PASS_FIRST, this_filter);
 
@@ -1975,7 +2003,6 @@
 
 #ifdef COLLECT_EXPORT_LIST
 /* This function is really used only on AIX, but may be useful.  */
-#if 0
 static int
 is_in_list (const char *prefix, struct id *list)
 {
@@ -1986,7 +2013,6 @@
     }
     return 0;
 }
-#endif
 #endif /* COLLECT_EXPORT_LIST */
 
 /* Added for debugging purpose.  */
@@ -2815,7 +2841,12 @@
 			case SYM_AIXI:
 			  if (! (filter & SCAN_CTOR))
 			    break;
-			  if (is_shared && !aixlazy_flag)
+			  if (is_shared && !aixlazy_flag
+#ifdef COLLECT_EXPORT_LIST
+			      && ! static_obj
+			      && ! is_in_list (prog_name, static_libs.first)
+#endif
+			      )
 			    add_to_list (&constructors, name);
 			  break;
 
diff -ruN gcc-7.3.0/gcc/combine.c gcc-7.3.0-msp430/gcc/combine.c
--- gcc-7.3.0/gcc/combine.c	2018-01-14 07:45:38.584347000 -0800
+++ gcc-7.3.0-msp430/gcc/combine.c	2019-06-25 02:27:21.069931647 -0700
@@ -5482,11 +5482,15 @@
 		    x = gen_rtx_CLOBBER (mode, const0_rtx);
 		}
 	      else if (CONST_SCALAR_INT_P (new_rtx)
-		       && GET_CODE (x) == ZERO_EXTEND)
+		       && (GET_CODE (x) == ZERO_EXTEND
+			   || GET_CODE (x) == FLOAT
+			   || GET_CODE (x) == UNSIGNED_FLOAT))
 		{
-		  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),
-						new_rtx, GET_MODE (XEXP (x, 0)));
-		  gcc_assert (x);
+		  x = simplify_unary_operation (GET_CODE (x), GET_MODE (x),
+						new_rtx,
+						GET_MODE (XEXP (x, 0)));
+		  if (!x)
+		    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);
 		}
 	      else
 		SUBST (XEXP (x, i), new_rtx);
@@ -5637,7 +5641,11 @@
 	  /* If everything is a comparison, what we have is highly unlikely
 	     to be simpler, so don't use it.  */
 	  && ! (COMPARISON_P (x)
-		&& (COMPARISON_P (true_rtx) || COMPARISON_P (false_rtx))))
+		&& (COMPARISON_P (true_rtx) || COMPARISON_P (false_rtx)))
+	  /* Similarly, if we end up with one of the expressions the same
+	     as the original, it is certainly not simpler.  */
+	  && ! rtx_equal_p (x, true_rtx)
+	  && ! rtx_equal_p (x, false_rtx))
 	{
 	  rtx cop1 = const0_rtx;
 	  enum rtx_code cond_code = simplify_comparison (NE, &cond, &cop1);
@@ -11322,8 +11330,15 @@
 	    x = gen_rtx_LSHIFTRT (inner_mode, XEXP (x, 0), GEN_INT (start));
 	  else
 	    x = XEXP (x, 0);
+
 	  if (mode != inner_mode)
-	    x = gen_lowpart_SUBREG (mode, x);
+	    {
+	      if (REG_P (x) && HARD_REGISTER_P (x)
+		  && !can_change_dest_mode (x, 0, mode))
+		continue;
+
+	      x = gen_lowpart_SUBREG (mode, x);
+	    }
 	}
       else if (GET_CODE (x) == ZERO_EXTEND
 	       && SCALAR_INT_MODE_P (mode)
@@ -11335,7 +11350,13 @@
 	  size = GET_MODE_PRECISION (GET_MODE (XEXP (x, 0)));
 	  x = SUBREG_REG (XEXP (x, 0));
 	  if (GET_MODE (x) != mode)
-	    x = gen_lowpart_SUBREG (mode, x);
+	    {
+	      if (REG_P (x) && HARD_REGISTER_P (x)
+		  && !can_change_dest_mode (x, 0, mode))
+		continue;
+
+	      x = gen_lowpart_SUBREG (mode, x);
+	    }
 	}
       else if (GET_CODE (x) == ZERO_EXTEND
 	       && SCALAR_INT_MODE_P (mode)
@@ -13081,8 +13102,11 @@
   if (REG_P (dest))
     {
       /* If we are setting the whole register, we know its value.  Otherwise
-	 show that we don't know the value.  We can handle SUBREG in
-	 some cases.  */
+	 show that we don't know the value.  We can handle a SUBREG if it's
+	 the low part, but we must be careful with paradoxical SUBREGs on
+	 RISC architectures because we cannot strip e.g. an extension around
+	 a load and record the naked load since the RTL middle-end considers
+	 that the upper bits are defined according to LOAD_EXTEND_OP.  */
       if (GET_CODE (setter) == SET && dest == SET_DEST (setter))
 	record_value_for_reg (dest, record_dead_insn, SET_SRC (setter));
       else if (GET_CODE (setter) == SET
@@ -13091,8 +13115,11 @@
 	       && GET_MODE_PRECISION (GET_MODE (dest)) <= BITS_PER_WORD
 	       && subreg_lowpart_p (SET_DEST (setter)))
 	record_value_for_reg (dest, record_dead_insn,
-			      gen_lowpart (GET_MODE (dest),
-						       SET_SRC (setter)));
+			      WORD_REGISTER_OPERATIONS
+			      && paradoxical_subreg_p (SET_DEST (setter))
+			      ? SET_SRC (setter)
+			      : gen_lowpart (GET_MODE (dest),
+					     SET_SRC (setter)));
       else
 	record_value_for_reg (dest, record_dead_insn, NULL_RTX);
     }
diff -ruN gcc-7.3.0/gcc/config/aarch64/aarch64.c gcc-7.3.0-msp430/gcc/config/aarch64/aarch64.c
--- gcc-7.3.0/gcc/config/aarch64/aarch64.c	2017-11-03 08:01:10.970890000 -0700
+++ gcc-7.3.0-msp430/gcc/config/aarch64/aarch64.c	2019-06-25 02:27:21.073931619 -0700
@@ -4664,13 +4664,13 @@
 	case UNGT:
 	case UNGE:
 	case UNEQ:
-	case LTGT:
 	  return CCFPmode;
 
 	case LT:
 	case LE:
 	case GT:
 	case GE:
+	case LTGT:
 	  return CCFPEmode;
 
 	default:
@@ -5721,7 +5721,7 @@
 {
   switch (regclass)
     {
-    case CALLER_SAVE_REGS:
+    case TAILCALL_ADDR_REGS:
     case POINTER_REGS:
     case GENERAL_REGS:
     case ALL_REGS:
@@ -5804,7 +5804,7 @@
          -Wformat-truncation false positive, use a larger size.  */
       char buf[23];
       snprintf (buf, sizeof (buf), ".init_array.%.5u", priority);
-      s = get_section (buf, SECTION_WRITE, NULL);
+      s = get_section (buf, SECTION_WRITE | SECTION_NOTYPE, NULL);
       switch_to_section (s);
       assemble_align (POINTER_SIZE);
       assemble_aligned_integer (POINTER_BYTES, symbol);
@@ -5824,7 +5824,7 @@
          -Wformat-truncation false positive, use a larger size.  */
       char buf[23];
       snprintf (buf, sizeof (buf), ".fini_array.%.5u", priority);
-      s = get_section (buf, SECTION_WRITE, NULL);
+      s = get_section (buf, SECTION_WRITE | SECTION_NOTYPE, NULL);
       switch_to_section (s);
       assemble_align (POINTER_SIZE);
       assemble_aligned_integer (POINTER_BYTES, symbol);
@@ -7799,10 +7799,10 @@
     = aarch64_tune_params.regmove_cost;
 
   /* Caller save and pointer regs are equivalent to GENERAL_REGS.  */
-  if (to == CALLER_SAVE_REGS || to == POINTER_REGS)
+  if (to == TAILCALL_ADDR_REGS || to == POINTER_REGS)
     to = GENERAL_REGS;
 
-  if (from == CALLER_SAVE_REGS || from == POINTER_REGS)
+  if (from == TAILCALL_ADDR_REGS || from == POINTER_REGS)
     from = GENERAL_REGS;
 
   /* Moving between GPR and stack cost is the same as GP2GP.  */
@@ -8608,17 +8608,6 @@
   if (opts->x_pcrelative_literal_loads == 1)
     aarch64_pcrelative_literal_loads = true;
 
-  /* This is PR70113. When building the Linux kernel with
-     CONFIG_ARM64_ERRATUM_843419, support for relocations
-     R_AARCH64_ADR_PREL_PG_HI21 and R_AARCH64_ADR_PREL_PG_HI21_NC is
-     removed from the kernel to avoid loading objects with possibly
-     offending sequences.  Without -mpc-relative-literal-loads we would
-     generate such relocations, preventing the kernel build from
-     succeeding.  */
-  if (opts->x_pcrelative_literal_loads == 2
-      && TARGET_FIX_ERR_A53_843419)
-    aarch64_pcrelative_literal_loads = true;
-
   /* In the tiny memory model it makes no sense to disallow PC relative
      literal pool loads.  */
   if (aarch64_cmodel == AARCH64_CMODEL_TINY
diff -ruN gcc-7.3.0/gcc/config/aarch64/aarch64.h gcc-7.3.0-msp430/gcc/config/aarch64/aarch64.h
--- gcc-7.3.0/gcc/config/aarch64/aarch64.h	2017-09-21 05:16:31.171118000 -0700
+++ gcc-7.3.0-msp430/gcc/config/aarch64/aarch64.h	2019-06-25 02:27:21.073931619 -0700
@@ -439,7 +439,7 @@
 enum reg_class
 {
   NO_REGS,
-  CALLER_SAVE_REGS,
+  TAILCALL_ADDR_REGS,
   GENERAL_REGS,
   STACK_REG,
   POINTER_REGS,
@@ -454,7 +454,7 @@
 #define REG_CLASS_NAMES				\
 {						\
   "NO_REGS",					\
-  "CALLER_SAVE_REGS",				\
+  "TAILCALL_ADDR_REGS",				\
   "GENERAL_REGS",				\
   "STACK_REG",					\
   "POINTER_REGS",				\
@@ -466,7 +466,7 @@
 #define REG_CLASS_CONTENTS						\
 {									\
   { 0x00000000, 0x00000000, 0x00000000 },	/* NO_REGS */		\
-  { 0x0007ffff, 0x00000000, 0x00000000 },	/* CALLER_SAVE_REGS */	\
+  { 0x0004ffff, 0x00000000, 0x00000000 },	/* TAILCALL_ADDR_REGS */\
   { 0x7fffffff, 0x00000000, 0x00000003 },	/* GENERAL_REGS */	\
   { 0x80000000, 0x00000000, 0x00000000 },	/* STACK_REG */		\
   { 0xffffffff, 0x00000000, 0x00000003 },	/* POINTER_REGS */	\
diff -ruN gcc-7.3.0/gcc/config/aarch64/aarch64.md gcc-7.3.0-msp430/gcc/config/aarch64/aarch64.md
--- gcc-7.3.0/gcc/config/aarch64/aarch64.md	2017-04-05 04:48:02.927619000 -0700
+++ gcc-7.3.0-msp430/gcc/config/aarch64/aarch64.md	2019-06-25 02:27:21.073931619 -0700
@@ -3093,7 +3093,8 @@
 (define_insn_and_split "*compare_cstore<mode>_insn"
   [(set (match_operand:GPI 0 "register_operand" "=r")
 	 (EQL:GPI (match_operand:GPI 1 "register_operand" "r")
-		  (match_operand:GPI 2 "aarch64_imm24" "n")))]
+		  (match_operand:GPI 2 "aarch64_imm24" "n")))
+   (clobber (reg:CC CC_REGNUM))]
   "!aarch64_move_imm (INTVAL (operands[2]), <MODE>mode)
    && !aarch64_plus_operand (operands[2], <MODE>mode)
    && !reload_completed"
diff -ruN gcc-7.3.0/gcc/config/aarch64/aarch64-simd.md gcc-7.3.0-msp430/gcc/config/aarch64/aarch64-simd.md
--- gcc-7.3.0/gcc/config/aarch64/aarch64-simd.md	2017-03-16 04:41:24.816592000 -0700
+++ gcc-7.3.0-msp430/gcc/config/aarch64/aarch64-simd.md	2019-06-25 02:27:21.069931647 -0700
@@ -2462,10 +2462,10 @@
 	  break;
 	}
       /* Fall through.  */
-    case UNGE:
+    case UNLT:
       std::swap (operands[2], operands[3]);
       /* Fall through.  */
-    case UNLE:
+    case UNGT:
     case GT:
       comparison = gen_aarch64_cmgt<mode>;
       break;
@@ -2476,10 +2476,10 @@
 	  break;
 	}
       /* Fall through.  */
-    case UNGT:
+    case UNLE:
       std::swap (operands[2], operands[3]);
       /* Fall through.  */
-    case UNLT:
+    case UNGE:
     case GE:
       comparison = gen_aarch64_cmge<mode>;
       break;
@@ -2490,6 +2490,7 @@
     case UNEQ:
     case ORDERED:
     case UNORDERED:
+    case LTGT:
       break;
     default:
       gcc_unreachable ();
@@ -2501,21 +2502,35 @@
     case UNGT:
     case UNLE:
     case UNLT:
-    case NE:
-      /* FCM returns false for lanes which are unordered, so if we use
-	 the inverse of the comparison we actually want to emit, then
-	 invert the result, we will end up with the correct result.
-	 Note that a NE NaN and NaN NE b are true for all a, b.
-
-	 Our transformations are:
-	 a UNGE b -> !(b GT a)
-	 a UNGT b -> !(b GE a)
-	 a UNLE b -> !(a GT b)
-	 a UNLT b -> !(a GE b)
-	 a   NE b -> !(a EQ b)  */
-      gcc_assert (comparison != NULL);
-      emit_insn (comparison (operands[0], operands[2], operands[3]));
-      emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
+      {
+	/* All of the above must not raise any FP exceptions.  Thus we first
+	   check each operand for NaNs and force any elements containing NaN to
+	   zero before using them in the compare.
+	   Example: UN<cc> (a, b) -> UNORDERED (a, b) |
+				     (cm<cc> (isnan (a) ? 0.0 : a,
+					      isnan (b) ? 0.0 : b))
+	   We use the following transformations for doing the comparisions:
+	   a UNGE b -> a GE b
+	   a UNGT b -> a GT b
+	   a UNLE b -> b GE a
+	   a UNLT b -> b GT a.  */
+
+	rtx tmp0 = gen_reg_rtx (<V_cmp_result>mode);
+	rtx tmp1 = gen_reg_rtx (<V_cmp_result>mode);
+	rtx tmp2 = gen_reg_rtx (<V_cmp_result>mode);
+	emit_insn (gen_aarch64_cmeq<mode> (tmp0, operands[2], operands[2]));
+	emit_insn (gen_aarch64_cmeq<mode> (tmp1, operands[3], operands[3]));
+	emit_insn (gen_and<v_cmp_result>3 (tmp2, tmp0, tmp1));
+	emit_insn (gen_and<v_cmp_result>3 (tmp0, tmp0,
+			lowpart_subreg (<V_cmp_result>mode, operands[2], <MODE>mode)));
+	emit_insn (gen_and<v_cmp_result>3 (tmp1, tmp1,
+			lowpart_subreg (<V_cmp_result>mode, operands[3], <MODE>mode)));
+	gcc_assert (comparison != NULL);
+	emit_insn (comparison (operands[0],
+			       lowpart_subreg (<MODE>mode, tmp0, <V_cmp_result>mode),
+			       lowpart_subreg (<MODE>mode, tmp1, <V_cmp_result>mode)));
+	emit_insn (gen_orn<v_cmp_result>3 (operands[0], tmp2, operands[0]));
+      }
       break;
 
     case LT:
@@ -2523,42 +2538,46 @@
     case GT:
     case GE:
     case EQ:
+    case NE:
       /* The easy case.  Here we emit one of FCMGE, FCMGT or FCMEQ.
 	 As a LT b <=> b GE a && a LE b <=> b GT a.  Our transformations are:
 	 a GE b -> a GE b
 	 a GT b -> a GT b
 	 a LE b -> b GE a
 	 a LT b -> b GT a
-	 a EQ b -> a EQ b  */
+	 a EQ b -> a EQ b
+	 a NE b -> ~(a EQ b)  */
       gcc_assert (comparison != NULL);
       emit_insn (comparison (operands[0], operands[2], operands[3]));
+      if (code == NE)
+	emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
       break;
 
-    case UNEQ:
-      /* We first check (a > b ||  b > a) which is !UNEQ, inverting
-	 this result will then give us (a == b || a UNORDERED b).  */
+    case LTGT:
+      /* LTGT is not guranteed to not generate a FP exception.  So let's
+	 go the faster way : ((a > b) || (b > a)).  */
       emit_insn (gen_aarch64_cmgt<mode> (operands[0],
 					 operands[2], operands[3]));
       emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[3], operands[2]));
       emit_insn (gen_ior<v_cmp_result>3 (operands[0], operands[0], tmp));
-      emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
-      break;
-
-    case UNORDERED:
-      /* Operands are ORDERED iff (a > b || b >= a), so we can compute
-	 UNORDERED as !ORDERED.  */
-      emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[2], operands[3]));
-      emit_insn (gen_aarch64_cmge<mode> (operands[0],
-					 operands[3], operands[2]));
-      emit_insn (gen_ior<v_cmp_result>3 (operands[0], operands[0], tmp));
-      emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
       break;
 
     case ORDERED:
-      emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[2], operands[3]));
-      emit_insn (gen_aarch64_cmge<mode> (operands[0],
-					 operands[3], operands[2]));
-      emit_insn (gen_ior<v_cmp_result>3 (operands[0], operands[0], tmp));
+    case UNORDERED:
+    case UNEQ:
+      /* cmeq (a, a) & cmeq (b, b).  */
+      emit_insn (gen_aarch64_cmeq<mode> (operands[0],
+					 operands[2], operands[2]));
+      emit_insn (gen_aarch64_cmeq<mode> (tmp, operands[3], operands[3]));
+      emit_insn (gen_and<v_cmp_result>3 (operands[0], operands[0], tmp));
+
+      if (code == UNORDERED)
+	emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
+      else if (code == UNEQ)
+	{
+	  emit_insn (gen_aarch64_cmeq<mode> (tmp, operands[2], operands[3]));
+	  emit_insn (gen_orn<v_cmp_result>3 (operands[0], operands[0], tmp));
+	}
       break;
 
     default:
diff -ruN gcc-7.3.0/gcc/config/aarch64/constraints.md gcc-7.3.0-msp430/gcc/config/aarch64/constraints.md
--- gcc-7.3.0/gcc/config/aarch64/constraints.md	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/aarch64/constraints.md	2019-06-25 02:27:21.073931619 -0700
@@ -21,8 +21,8 @@
 (define_register_constraint "k" "STACK_REG"
   "@internal The stack register.")
 
-(define_register_constraint "Ucs" "CALLER_SAVE_REGS"
-  "@internal The caller save registers.")
+(define_register_constraint "Ucs" "TAILCALL_ADDR_REGS"
+  "@internal Registers suitable for an indirect tail call")
 
 (define_register_constraint "w" "FP_REGS"
   "Floating point and SIMD vector registers.")
diff -ruN gcc-7.3.0/gcc/config/alpha/alpha.c gcc-7.3.0-msp430/gcc/config/alpha/alpha.c
--- gcc-7.3.0/gcc/config/alpha/alpha.c	2018-01-07 11:14:55.390095000 -0800
+++ gcc-7.3.0-msp430/gcc/config/alpha/alpha.c	2019-06-25 02:27:21.073931619 -0700
@@ -7750,13 +7750,13 @@
 	  int probed;
 
 	  for (probed = 4096; probed < probed_size; probed += 8192)
-	    emit_insn (gen_probe_stack (GEN_INT (-probed)));
+	    emit_insn (gen_stack_probe_internal (GEN_INT (-probed)));
 
 	  /* We only have to do this probe if we aren't saving registers or
 	     if we are probing beyond the frame because of -fstack-check.  */
 	  if ((sa_size == 0 && probed_size > probed - 4096)
 	      || flag_stack_check)
-	    emit_insn (gen_probe_stack (GEN_INT (-probed_size)));
+	    emit_insn (gen_stack_probe_internal (GEN_INT (-probed_size)));
 	}
 
       if (frame_size != 0)
diff -ruN gcc-7.3.0/gcc/config/alpha/alpha.md gcc-7.3.0-msp430/gcc/config/alpha/alpha.md
--- gcc-7.3.0/gcc/config/alpha/alpha.md	2018-01-14 07:45:38.584347000 -0800
+++ gcc-7.3.0-msp430/gcc/config/alpha/alpha.md	2019-06-25 02:27:21.073931619 -0700
@@ -4915,7 +4915,7 @@
 
 
 ;; Subroutine of stack space allocation.  Perform a stack probe.
-(define_expand "probe_stack"
+(define_expand "stack_probe_internal"
   [(set (match_dup 1) (match_operand:DI 0 "const_int_operand"))]
   ""
 {
@@ -4950,12 +4950,14 @@
 
 	  int probed = 4096;
 
-	  emit_insn (gen_probe_stack (GEN_INT (- probed)));
+	  emit_insn (gen_stack_probe_internal (GEN_INT (- probed)));
 	  while (probed + 8192 < INTVAL (operands[1]))
-	    emit_insn (gen_probe_stack (GEN_INT (- (probed += 8192))));
+	    emit_insn (gen_stack_probe_internal
+		       (GEN_INT (- (probed += 8192))));
 
 	  if (probed + 4096 < INTVAL (operands[1]))
-	    emit_insn (gen_probe_stack (GEN_INT (- INTVAL(operands[1]))));
+	    emit_insn (gen_stack_probe_internal
+		       (GEN_INT (- INTVAL(operands[1]))));
 	}
 
       operands[1] = GEN_INT (- INTVAL (operands[1]));
diff -ruN gcc-7.3.0/gcc/config/arm/arm-builtins.c gcc-7.3.0-msp430/gcc/config/arm/arm-builtins.c
--- gcc-7.3.0/gcc/config/arm/arm-builtins.c	2017-06-23 09:08:40.529482000 -0700
+++ gcc-7.3.0-msp430/gcc/config/arm/arm-builtins.c	2019-06-25 02:27:21.073931619 -0700
@@ -2576,7 +2576,7 @@
 	  icode = CODE_FOR_set_fpscr;
 	  arg0 = CALL_EXPR_ARG (exp, 0);
 	  op0 = expand_normal (arg0);
-	  pat = GEN_FCN (icode) (op0);
+	  pat = GEN_FCN (icode) (force_reg (SImode, op0));
 	}
       emit_insn (pat);
       return target;
@@ -2584,7 +2584,9 @@
     case ARM_BUILTIN_CMSE_NONSECURE_CALLER:
       target = gen_reg_rtx (SImode);
       op0 = arm_return_addr (0, NULL_RTX);
-      emit_insn (gen_addsi3 (target, op0, const1_rtx));
+      emit_insn (gen_andsi3 (target, op0, const1_rtx));
+      op1 = gen_rtx_EQ (SImode, target, const0_rtx);
+      emit_insn (gen_cstoresi4 (target, op1, target, const0_rtx));
       return target;
 
     case ARM_BUILTIN_TEXTRMSB:
diff -ruN gcc-7.3.0/gcc/config/arm/arm.c gcc-7.3.0-msp430/gcc/config/arm/arm.c
--- gcc-7.3.0/gcc/config/arm/arm.c	2017-11-21 10:14:34.017128000 -0800
+++ gcc-7.3.0-msp430/gcc/config/arm/arm.c	2019-06-25 02:27:21.077931589 -0700
@@ -19097,6 +19097,11 @@
 static int
 arm_compute_static_chain_stack_bytes (void)
 {
+  /* Once the value is updated from the init value of -1, do not
+     re-compute.  */
+  if (cfun->machine->static_chain_stack_bytes != -1)
+    return cfun->machine->static_chain_stack_bytes;
+
   /* See the defining assertion in arm_expand_prologue.  */
   if (IS_NESTED (arm_current_func_type ())
       && ((TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)
@@ -21395,6 +21400,11 @@
       emit_insn (gen_movsi (stack_pointer_rtx, r1));
     }
 
+  /* Let's compute the static_chain_stack_bytes required and store it.  Right
+     now the value must the -1 as stored by arm_init_machine_status ().  */
+  cfun->machine->static_chain_stack_bytes
+    = arm_compute_static_chain_stack_bytes ();
+
   /* The static chain register is the same as the IP register.  If it is
      clobbered when creating the frame, we need to save and restore it.  */
   clobber_ip = IS_NESTED (func_type)
@@ -24542,6 +24552,7 @@
 #if ARM_FT_UNKNOWN != 0
   machine->func_type = ARM_FT_UNKNOWN;
 #endif
+  machine->static_chain_stack_bytes = -1;
   return machine;
 }
 
@@ -26853,7 +26864,10 @@
 arm_array_mode_supported_p (machine_mode mode,
 			    unsigned HOST_WIDE_INT nelems)
 {
-  if (TARGET_NEON
+  /* We don't want to enable interleaved loads and stores for BYTES_BIG_ENDIAN
+     for now, as the lane-swapping logic needs to be extended in the expanders.
+     See PR target/82518.  */
+  if (TARGET_NEON && !BYTES_BIG_ENDIAN
       && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))
       && (nelems >= 2 && nelems <= 4))
     return true;
diff -ruN gcc-7.3.0/gcc/config/arm/arm_cmse.h gcc-7.3.0-msp430/gcc/config/arm/arm_cmse.h
--- gcc-7.3.0/gcc/config/arm/arm_cmse.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/arm/arm_cmse.h	2019-06-25 02:27:21.077931589 -0700
@@ -35,7 +35,6 @@
 #if __ARM_FEATURE_CMSE & 1
 
 #include <stddef.h>
-#include <stdint.h>
 
 #ifdef __ARM_BIG_ENDIAN
 
@@ -174,9 +173,9 @@
 #define CMSE_MPU_NONSECURE	16
 #define CMSE_NONSECURE		18
 
-#define cmse_nsfptr_create(p) ((typeof ((p))) ((intptr_t) (p) & ~1))
+#define cmse_nsfptr_create(p) ((__typeof__ ((p))) ((__INTPTR_TYPE__) (p) & ~1))
 
-#define cmse_is_nsfptr(p) (!((intptr_t) (p) & 1))
+#define cmse_is_nsfptr(p) (!((__INTPTR_TYPE__) (p) & 1))
 
 #endif /* __ARM_FEATURE_CMSE & 2 */
 
@@ -188,7 +187,7 @@
 cmse_check_address_range (void *, size_t, int);
 
 #define cmse_check_pointed_object(p, f) \
-  ((typeof ((p))) cmse_check_address_range ((p), sizeof (*(p)), (f)))
+  ((__typeof__ ((p))) cmse_check_address_range ((p), sizeof (*(p)), (f)))
 
 #endif /* __ARM_FEATURE_CMSE & 1 */
 
diff -ruN gcc-7.3.0/gcc/config/arm/arm.h gcc-7.3.0-msp430/gcc/config/arm/arm.h
--- gcc-7.3.0/gcc/config/arm/arm.h	2018-01-08 10:42:50.166542000 -0800
+++ gcc-7.3.0-msp430/gcc/config/arm/arm.h	2019-06-25 02:27:21.077931589 -0700
@@ -1420,6 +1420,9 @@
   machine_mode thumb1_cc_mode;
   /* Set to 1 after arm_reorg has started.  */
   int after_arm_reorg;
+  /* The number of bytes used to store the static chain register on the
+     stack, above the stack frame.  */
+  int static_chain_stack_bytes;
 }
 machine_function;
 #endif
diff -ruN gcc-7.3.0/gcc/config/arm/arm.md gcc-7.3.0-msp430/gcc/config/arm/arm.md
--- gcc-7.3.0/gcc/config/arm/arm.md	2017-06-02 04:19:16.254269000 -0700
+++ gcc-7.3.0-msp430/gcc/config/arm/arm.md	2019-06-25 02:27:21.077931589 -0700
@@ -4498,16 +4498,13 @@
    (set_attr "type" "load1")])
 
 (define_insn "unaligned_loadhis"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
+  [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(sign_extend:SI
-	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uw,Uh")]
+	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uh")]
 		     UNSPEC_UNALIGNED_LOAD)))]
   "unaligned_access"
   "ldrsh%?\t%0, %1\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  [(set_attr "predicable" "yes")
    (set_attr "type" "load_byte")])
 
 (define_insn "unaligned_loadhiu"
diff -ruN gcc-7.3.0/gcc/config/arm/neon.md gcc-7.3.0-msp430/gcc/config/arm/neon.md
--- gcc-7.3.0/gcc/config/arm/neon.md	2018-01-17 03:51:03.248284000 -0800
+++ gcc-7.3.0-msp430/gcc/config/arm/neon.md	2019-06-25 02:27:21.077931589 -0700
@@ -1143,12 +1143,12 @@
 )
 
 (define_insn_and_split "ashldi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand"	    "= w, w,?&r,?r,?&r, ?w,w")
-	(ashift:DI (match_operand:DI 1 "s_register_operand" " 0w, w, 0r, 0,  r, 0w,w")
-		   (match_operand:SI 2 "general_operand"    "rUm, i,  r, i,  i,rUm,i")))
-   (clobber (match_scratch:SI 3				    "= X, X,?&r, X,  X,  X,X"))
-   (clobber (match_scratch:SI 4				    "= X, X,?&r, X,  X,  X,X"))
-   (clobber (match_scratch:DI 5				    "=&w, X,  X, X,  X, &w,X"))
+  [(set (match_operand:DI 0 "s_register_operand"	    "= w, w, &r, r, &r, ?w,?w")
+	(ashift:DI (match_operand:DI 1 "s_register_operand" " 0w, w, 0r, 0,  r, 0w, w")
+		   (match_operand:SI 2 "general_operand"    "rUm, i,  r, i,  i,rUm, i")))
+   (clobber (match_scratch:SI 3				    "= X, X, &r, X,  X,  X, X"))
+   (clobber (match_scratch:SI 4				    "= X, X, &r, X,  X,  X, X"))
+   (clobber (match_scratch:DI 5				    "=&w, X,  X, X,  X, &w, X"))
    (clobber (reg:CC_C CC_REGNUM))]
   "TARGET_NEON"
   "#"
@@ -1243,7 +1243,7 @@
 ;; ashrdi3_neon
 ;; lshrdi3_neon
 (define_insn_and_split "<shift>di3_neon"
-  [(set (match_operand:DI 0 "s_register_operand"	     "= w, w,?&r,?r,?&r,?w,?w")
+  [(set (match_operand:DI 0 "s_register_operand"	     "= w, w, &r, r, &r,?w,?w")
 	(RSHIFTS:DI (match_operand:DI 1 "s_register_operand" " 0w, w, 0r, 0,  r,0w, w")
 		    (match_operand:SI 2 "reg_or_int_operand" "  r, i,  r, i,  i, r, i")))
    (clobber (match_scratch:SI 3				     "=2r, X, &r, X,  X,2r, X"))
diff -ruN gcc-7.3.0/gcc/config/avr/avr.h gcc-7.3.0-msp430/gcc/config/avr/avr.h
--- gcc-7.3.0/gcc/config/avr/avr.h	2017-01-16 01:48:45.991005000 -0800
+++ gcc-7.3.0-msp430/gcc/config/avr/avr.h	2019-06-25 02:27:21.077931589 -0700
@@ -153,6 +153,9 @@
 
 #define FIRST_PSEUDO_REGISTER 36
 
+#define GENERAL_REGNO_P(N)	IN_RANGE (N, 2, 31)
+#define GENERAL_REG_P(X)	(REG_P (X) && GENERAL_REGNO_P (REGNO (X)))
+
 #define FIXED_REGISTERS {\
   1,1,/* r0 r1 */\
   0,0,/* r2 r3 */\
diff -ruN gcc-7.3.0/gcc/config/avr/avr.md gcc-7.3.0-msp430/gcc/config/avr/avr.md
--- gcc-7.3.0/gcc/config/avr/avr.md	2017-03-08 00:52:05.354083000 -0800
+++ gcc-7.3.0-msp430/gcc/config/avr/avr.md	2019-06-25 02:27:21.077931589 -0700
@@ -3362,6 +3362,8 @@
         (match_operand:HI 1 "reg_or_0_operand"))]
   "optimize
    && reload_completed
+   && GENERAL_REG_P (operands[0])
+   && (operands[1] == const0_rtx || GENERAL_REG_P (operands[1]))
    && (!AVR_HAVE_MOVW
        || const0_rtx == operands[1])"
   [(set (match_dup 2) (match_dup 3))
diff -ruN gcc-7.3.0/gcc/config/gnu-user.h gcc-7.3.0-msp430/gcc/config/gnu-user.h
--- gcc-7.3.0/gcc/config/gnu-user.h	2017-08-29 01:22:44.285050000 -0700
+++ gcc-7.3.0-msp430/gcc/config/gnu-user.h	2019-06-25 02:27:21.077931589 -0700
@@ -122,7 +122,7 @@
 
 #define GNU_USER_TARGET_NO_PTHREADS_LIB_SPEC \
   "%{shared:-lc} \
-   %{!shared:%{mieee-fp:-lieee} %{profile:-lc_p}%{!profile:-lc}}"
+   %{!shared:%{profile:-lc_p}%{!profile:-lc}}"
 
 #define GNU_USER_TARGET_LIB_SPEC \
   "%{pthread:-lpthread} " \
diff -ruN gcc-7.3.0/gcc/config/i386/avx512vlintrin.h gcc-7.3.0-msp430/gcc/config/i386/avx512vlintrin.h
--- gcc-7.3.0/gcc/config/i386/avx512vlintrin.h	2017-03-09 01:11:06.511939000 -0800
+++ gcc-7.3.0-msp430/gcc/config/i386/avx512vlintrin.h	2019-06-25 02:27:21.077931589 -0700
@@ -9099,6 +9099,17 @@
 
 extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm256_permutexvar_epi64 (__m256i __X, __m256i __Y)
+{
+  return (__m256i) __builtin_ia32_permvardi256_mask ((__v4di) __Y,
+						     (__v4di) __X,
+						     (__v4di)
+						     _mm256_setzero_si256 (),
+						     (__mmask8) -1);
+}
+
+extern __inline __m256i
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_mask_permutexvar_epi64 (__m256i __W, __mmask8 __M, __m256i __X,
 			       __m256i __Y)
 {
@@ -9163,6 +9174,17 @@
 
 extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm256_permutexvar_epi32 (__m256i __X, __m256i __Y)
+{
+  return (__m256i) __builtin_ia32_permvarsi256_mask ((__v8si) __Y,
+						     (__v8si) __X,
+						     (__v8si)
+						     _mm256_setzero_si256 (),
+						     (__mmask8) -1);
+}
+
+extern __inline __m256i
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_mask_permutexvar_epi32 (__m256i __W, __mmask8 __M, __m256i __X,
 			       __m256i __Y)
 {
@@ -9751,6 +9773,17 @@
 #ifdef __OPTIMIZE__
 extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm256_permutex_epi64 (__m256i __X, const int __I)
+{
+  return (__m256i) __builtin_ia32_permdi256_mask ((__v4di) __X,
+					      __I,
+					      (__v4di)
+					      _mm256_setzero_si256 (),
+					      (__mmask8) -1);
+}
+
+extern __inline __m256i
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_mask_permutex_epi64 (__m256i __W, __mmask8 __M,
 			    __m256i __X, const int __I)
 {
@@ -12367,6 +12400,13 @@
 					    _mm256_undefined_pd (),		\
 					    (__mmask8)-1))
 
+#define _mm256_permutex_epi64(X, I)				\
+  ((__m256i) __builtin_ia32_permdi256_mask ((__v4di)(__m256i)(X), \
+					    (int)(I),		\
+					    (__v4di)(__m256i)	\
+					    (_mm256_setzero_si256 ()),\
+					    (__mmask8) -1))
+
 #define _mm256_maskz_permutex_epi64(M, X, I)                    \
   ((__m256i) __builtin_ia32_permdi256_mask ((__v4di)(__m256i)(X),    \
 					    (int)(I),                \
diff -ruN gcc-7.3.0/gcc/config/i386/constraints.md gcc-7.3.0-msp430/gcc/config/i386/constraints.md
--- gcc-7.3.0/gcc/config/i386/constraints.md	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/config/i386/constraints.md	2019-06-25 02:27:21.081931561 -0700
@@ -198,7 +198,7 @@
 
 (define_constraint "Bs"
   "@internal Sibcall memory operand."
-  (ior (and (not (match_test "ix86_indirect_branch_register"))
+  (ior (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (not (match_test "TARGET_X32"))
 	    (match_operand 0 "sibcall_memory_operand"))
        (and (match_test "TARGET_X32 && Pmode == DImode")
@@ -206,7 +206,7 @@
 
 (define_constraint "Bw"
   "@internal Call memory operand."
-  (ior (and (not (match_test "ix86_indirect_branch_register"))
+  (ior (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (not (match_test "TARGET_X32"))
 	    (match_operand 0 "memory_operand"))
        (and (match_test "TARGET_X32 && Pmode == DImode")
diff -ruN gcc-7.3.0/gcc/config/i386/i386.c gcc-7.3.0-msp430/gcc/config/i386/i386.c
--- gcc-7.3.0/gcc/config/i386/i386.c	2018-01-16 04:49:29.534125000 -0800
+++ gcc-7.3.0-msp430/gcc/config/i386/i386.c	2019-06-25 02:27:21.085931533 -0700
@@ -12031,19 +12031,29 @@
    labels in call and return thunks.  */
 static int indirectlabelno;
 
-/* True if call and return thunk functions are needed.  */
+/* True if call thunk function is needed.  */
 static bool indirect_thunk_needed = false;
-/* True if call and return thunk functions with the BND prefix are
-   needed.  */
+/* True if call thunk function with the BND prefix is needed.  */
 static bool indirect_thunk_bnd_needed = false;
 
 /* Bit masks of integer registers, which contain branch target, used
-   by call and return thunks functions.  */
+   by call thunk functions.  */
 static int indirect_thunks_used;
 /* Bit masks of integer registers, which contain branch target, used
-   by call and return thunks functions with the BND prefix.  */
+   by call thunk functions with the BND prefix.  */
 static int indirect_thunks_bnd_used;
 
+/* True if return thunk function is needed.  */
+static bool indirect_return_needed = false;
+/* True if return thunk function with the BND prefix is needed.  */
+static bool indirect_return_bnd_needed = false;
+
+/* True if return thunk function via CX is needed.  */
+static bool indirect_return_via_cx;
+/* True if return thunk function via CX with the BND prefix is
+   needed.  */
+static bool indirect_return_via_cx_bnd;
+
 #ifndef INDIRECT_LABEL
 # define INDIRECT_LABEL "LIND"
 #endif
@@ -12051,34 +12061,32 @@
 /* Fills in the label name that should be used for the indirect thunk.  */
 
 static void
-indirect_thunk_name (char name[32], int regno, bool need_bnd_p,
-		     bool ret_p)
+indirect_thunk_name (char name[32], unsigned int regno,
+		     bool need_bnd_p, bool ret_p)
 {
-  if (regno >= 0 && ret_p)
+  if (regno != INVALID_REGNUM && regno != CX_REG && ret_p)
     gcc_unreachable ();
 
   if (USE_HIDDEN_LINKONCE)
     {
       const char *bnd = need_bnd_p ? "_bnd" : "";
-      if (regno >= 0)
+      const char *ret = ret_p ? "return" : "indirect";
+      if (regno != INVALID_REGNUM)
 	{
 	  const char *reg_prefix;
 	  if (LEGACY_INT_REGNO_P (regno))
 	    reg_prefix = TARGET_64BIT ? "r" : "e";
 	  else
 	    reg_prefix = "";
-	  sprintf (name, "__x86_indirect_thunk%s_%s%s",
-		   bnd, reg_prefix, reg_names[regno]);
+	  sprintf (name, "__x86_%s_thunk%s_%s%s",
+		   ret, bnd, reg_prefix, reg_names[regno]);
 	}
       else
-	{
-	  const char *ret = ret_p ? "return" : "indirect";
-	  sprintf (name, "__x86_%s_thunk%s", ret, bnd);
-	}
+	sprintf (name, "__x86_%s_thunk%s", ret, bnd);
     }
   else
     {
-      if (regno >= 0)
+      if (regno != INVALID_REGNUM)
 	{
 	  if (need_bnd_p)
 	    ASM_GENERATE_INTERNAL_LABEL (name, "LITBR", regno);
@@ -12130,7 +12138,7 @@
  */
 
 static void
-output_indirect_thunk (bool need_bnd_p, int regno)
+output_indirect_thunk (bool need_bnd_p, unsigned int regno)
 {
   char indirectlabel1[32];
   char indirectlabel2[32];
@@ -12160,7 +12168,7 @@
 
   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);
 
-  if (regno >= 0)
+  if (regno != INVALID_REGNUM)
     {
       /* MOV.  */
       rtx xops[2];
@@ -12184,18 +12192,20 @@
 }
 
 /* Output a funtion with a call and return thunk for indirect branch.
-   If BND_P is true, the BND prefix is needed.   If REGNO != -1,  the
-   function address is in REGNO.  Otherwise, the function address is
-   on the top of stack.  */
+   If BND_P is true, the BND prefix is needed.  If REGNO != INVALID_REGNUM,
+   the function address is in REGNO.  Otherwise, the function address is
+   on the top of stack.  Thunk is used for function return if RET_P is
+   true.  */
 
 static void
-output_indirect_thunk_function (bool need_bnd_p, int regno)
+output_indirect_thunk_function (bool need_bnd_p, unsigned int regno,
+				bool ret_p)
 {
   char name[32];
   tree decl;
 
   /* Create __x86_indirect_thunk/__x86_indirect_thunk_bnd.  */
-  indirect_thunk_name (name, regno, need_bnd_p, false);
+  indirect_thunk_name (name, regno, need_bnd_p, ret_p);
   decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
 		     get_identifier (name),
 		     build_function_type_list (void_type_node, NULL_TREE));
@@ -12238,36 +12248,6 @@
 	ASM_OUTPUT_LABEL (asm_out_file, name);
       }
 
-  if (regno < 0)
-    {
-      /* Create alias for __x86.return_thunk/__x86.return_thunk_bnd.  */
-      char alias[32];
-
-      indirect_thunk_name (alias, regno, need_bnd_p, true);
-#if TARGET_MACHO
-      if (TARGET_MACHO)
-	{
-	  fputs ("\t.weak_definition\t", asm_out_file);
-	  assemble_name (asm_out_file, alias);
-	  fputs ("\n\t.private_extern\t", asm_out_file);
-	  assemble_name (asm_out_file, alias);
-	  putc ('\n', asm_out_file);
-	  ASM_OUTPUT_LABEL (asm_out_file, alias);
-	}
-#else
-      ASM_OUTPUT_DEF (asm_out_file, alias, name);
-      if (USE_HIDDEN_LINKONCE)
-	{
-	  fputs ("\t.globl\t", asm_out_file);
-	  assemble_name (asm_out_file, alias);
-	  putc ('\n', asm_out_file);
-	  fputs ("\t.hidden\t", asm_out_file);
-	  assemble_name (asm_out_file, alias);
-	  putc ('\n', asm_out_file);
-	}
-#endif
-    }
-
   DECL_INITIAL (decl) = make_node (BLOCK);
   current_function_decl = decl;
   allocate_struct_function (decl, false);
@@ -12312,21 +12292,31 @@
 ix86_code_end (void)
 {
   rtx xops[2];
-  int regno;
+  unsigned int regno;
+
+  if (indirect_return_needed)
+    output_indirect_thunk_function (false, INVALID_REGNUM, true);
+  if (indirect_return_bnd_needed)
+    output_indirect_thunk_function (true, INVALID_REGNUM, true);
+
+  if (indirect_return_via_cx)
+    output_indirect_thunk_function (false, CX_REG, true);
+  if (indirect_return_via_cx_bnd)
+    output_indirect_thunk_function (true, CX_REG, true);
 
   if (indirect_thunk_needed)
-    output_indirect_thunk_function (false, -1);
+    output_indirect_thunk_function (false, INVALID_REGNUM, false);
   if (indirect_thunk_bnd_needed)
-    output_indirect_thunk_function (true, -1);
+    output_indirect_thunk_function (true, INVALID_REGNUM, false);
 
   for (regno = FIRST_REX_INT_REG; regno <= LAST_REX_INT_REG; regno++)
     {
-      int i = regno - FIRST_REX_INT_REG + LAST_INT_REG + 1;
+      unsigned int i = regno - FIRST_REX_INT_REG + LAST_INT_REG + 1;
       if ((indirect_thunks_used & (1 << i)))
-	output_indirect_thunk_function (false, regno);
+	output_indirect_thunk_function (false, regno, false);
 
       if ((indirect_thunks_bnd_used & (1 << i)))
-	output_indirect_thunk_function (true, regno);
+	output_indirect_thunk_function (true, regno, false);
     }
 
   for (regno = AX_REG; regno <= SP_REG; regno++)
@@ -12335,10 +12325,10 @@
       tree decl;
 
       if ((indirect_thunks_used & (1 << regno)))
-	output_indirect_thunk_function (false, regno);
+	output_indirect_thunk_function (false, regno, false);
 
       if ((indirect_thunks_bnd_used & (1 << regno)))
-	output_indirect_thunk_function (true, regno);
+	output_indirect_thunk_function (true, regno, false);
 
       if (!(pic_labels_used & (1 << regno)))
 	continue;
@@ -14061,7 +14051,6 @@
 {
   struct machine_function *m = cfun->machine;
   rtx insn, t;
-  struct ix86_frame frame;
   HOST_WIDE_INT allocate;
   bool int_registers_saved;
   bool sse_registers_saved;
@@ -14085,7 +14074,7 @@
   m->fs.sp_valid = true;
 
   ix86_compute_frame_layout ();
-  frame = m->frame;
+  const struct ix86_frame &frame = cfun->machine->frame;
 
   if (!TARGET_64BIT && ix86_function_ms_hook_prologue (current_function_decl))
     {
@@ -14748,13 +14737,12 @@
 {
   struct machine_function *m = cfun->machine;
   struct machine_frame_state frame_state_save = m->fs;
-  struct ix86_frame frame;
   bool restore_regs_via_mov;
   bool using_drap;
 
   ix86_finalize_stack_realign_flags ();
   ix86_compute_frame_layout ();
-  frame = m->frame;
+  const struct ix86_frame &frame = cfun->machine->frame;
 
   m->fs.sp_valid = (!frame_pointer_needed
 		    || (crtl->sp_is_unchanging
@@ -14796,11 +14784,13 @@
 				  + UNITS_PER_WORD);
     }
 
+  HOST_WIDE_INT reg_save_offset = frame.reg_save_offset;
+
   /* Special care must be taken for the normal return case of a function
      using eh_return: the eax and edx registers are marked as saved, but
      not restored along this path.  Adjust the save location to match.  */
   if (crtl->calls_eh_return && style != 2)
-    frame.reg_save_offset -= 2 * UNITS_PER_WORD;
+    reg_save_offset -= 2 * UNITS_PER_WORD;
 
   /* EH_RETURN requires the use of moves to function properly.  */
   if (crtl->calls_eh_return)
@@ -14816,11 +14806,11 @@
   else if (TARGET_EPILOGUE_USING_MOVE
 	   && cfun->machine->use_fast_prologue_epilogue
 	   && (frame.nregs > 1
-	       || m->fs.sp_offset != frame.reg_save_offset))
+	       || m->fs.sp_offset != reg_save_offset))
     restore_regs_via_mov = true;
   else if (frame_pointer_needed
 	   && !frame.nregs
-	   && m->fs.sp_offset != frame.reg_save_offset)
+	   && m->fs.sp_offset != reg_save_offset)
     restore_regs_via_mov = true;
   else if (frame_pointer_needed
 	   && TARGET_USE_LEAVE
@@ -14858,7 +14848,7 @@
       rtx t;
 
       if (frame.nregs)
-	ix86_emit_restore_regs_using_mov (frame.reg_save_offset, style == 2);
+	ix86_emit_restore_regs_using_mov (reg_save_offset, style == 2);
 
       /* eh_return epilogues need %ecx added to the stack pointer.  */
       if (style == 2)
@@ -14948,19 +14938,19 @@
 	 epilogues.  */
       if (!m->fs.sp_valid
  	  || (TARGET_SEH
-	      && (m->fs.sp_offset - frame.reg_save_offset
+	      && (m->fs.sp_offset - reg_save_offset
 		  >= SEH_MAX_FRAME_SIZE)))
 	{
 	  pro_epilogue_adjust_stack (stack_pointer_rtx, hard_frame_pointer_rtx,
 				     GEN_INT (m->fs.fp_offset
-					      - frame.reg_save_offset),
+					      - reg_save_offset),
 				     style, false);
 	}
-      else if (m->fs.sp_offset != frame.reg_save_offset)
+      else if (m->fs.sp_offset != reg_save_offset)
 	{
 	  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,
 				     GEN_INT (m->fs.sp_offset
-					      - frame.reg_save_offset),
+					      - reg_save_offset),
 				     style,
 				     m->fs.cfa_reg == stack_pointer_rtx);
 	}
@@ -18842,7 +18832,8 @@
 	 since we can in fact encode that into an immediate.  */
       if (GET_CODE (x) == CONST_VECTOR)
 	{
-	  gcc_assert (x == CONST0_RTX (GET_MODE (x)));
+	  if (x != CONST0_RTX (GET_MODE (x)))
+	    output_operand_lossage ("invalid vector immediate");
 	  x = const0_rtx;
 	}
 
@@ -19807,72 +19798,36 @@
   emit_insn (gen_x86_fnstcw_1 (stored_mode));
   emit_move_insn (reg, copy_rtx (stored_mode));
 
-  if (TARGET_64BIT || TARGET_PARTIAL_REG_STALL
-      || optimize_insn_for_size_p ())
-    {
-      switch (mode)
-	{
-	case I387_CW_TRUNC:
-	  /* round toward zero (truncate) */
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0c00)));
-	  slot = SLOT_CW_TRUNC;
-	  break;
-
-	case I387_CW_FLOOR:
-	  /* round down toward -oo */
-	  emit_insn (gen_andhi3 (reg, reg, GEN_INT (~0x0c00)));
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0400)));
-	  slot = SLOT_CW_FLOOR;
-	  break;
-
-	case I387_CW_CEIL:
-	  /* round up toward +oo */
-	  emit_insn (gen_andhi3 (reg, reg, GEN_INT (~0x0c00)));
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0800)));
-	  slot = SLOT_CW_CEIL;
-	  break;
-
-	case I387_CW_MASK_PM:
-	  /* mask precision exception for nearbyint() */
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0020)));
-	  slot = SLOT_CW_MASK_PM;
-	  break;
-
-	default:
-	  gcc_unreachable ();
-	}
-    }
-  else
+  switch (mode)
     {
-      switch (mode)
-	{
-	case I387_CW_TRUNC:
-	  /* round toward zero (truncate) */
-	  emit_insn (gen_insvsi_1 (reg, GEN_INT (0xc)));
-	  slot = SLOT_CW_TRUNC;
-	  break;
-
-	case I387_CW_FLOOR:
-	  /* round down toward -oo */
-	  emit_insn (gen_insvsi_1 (reg, GEN_INT (0x4)));
-	  slot = SLOT_CW_FLOOR;
-	  break;
-
-	case I387_CW_CEIL:
-	  /* round up toward +oo */
-	  emit_insn (gen_insvsi_1 (reg, GEN_INT (0x8)));
-	  slot = SLOT_CW_CEIL;
-	  break;
-
-	case I387_CW_MASK_PM:
-	  /* mask precision exception for nearbyint() */
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0020)));
-	  slot = SLOT_CW_MASK_PM;
-	  break;
+    case I387_CW_TRUNC:
+      /* round toward zero (truncate) */
+      emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0c00)));
+      slot = SLOT_CW_TRUNC;
+      break;
+
+    case I387_CW_FLOOR:
+      /* round down toward -oo */
+      emit_insn (gen_andhi3 (reg, reg, GEN_INT (~0x0c00)));
+      emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0400)));
+      slot = SLOT_CW_FLOOR;
+      break;
+
+    case I387_CW_CEIL:
+      /* round up toward +oo */
+      emit_insn (gen_andhi3 (reg, reg, GEN_INT (~0x0c00)));
+      emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0800)));
+      slot = SLOT_CW_CEIL;
+      break;
+
+    case I387_CW_MASK_PM:
+      /* mask precision exception for nearbyint() */
+      emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0020)));
+      slot = SLOT_CW_MASK_PM;
+      break;
 
-	default:
-	  gcc_unreachable ();
-	}
+    default:
+      gcc_unreachable ();
     }
 
   gcc_assert (slot < MAX_386_STACK_LOCALS);
@@ -29109,18 +29064,17 @@
   else
     ix86_output_indirect_branch_via_push (call_op, xasm, sibcall_p);
 }
-/* Output indirect jump.  CALL_OP is the jump target.  Jump is a
-   function return if RET_P is true.  */
+
+/* Output indirect jump.  CALL_OP is the jump target.  */
 
 const char *
-ix86_output_indirect_jmp (rtx call_op, bool ret_p)
+ix86_output_indirect_jmp (rtx call_op)
 {
   if (cfun->machine->indirect_branch_type != indirect_branch_keep)
     {
-      /* We can't have red-zone if this isn't a function return since
-	 "call" in the indirect thunk pushes the return address onto
-	 stack, destroying red-zone.  */
-      if (!ret_p && ix86_red_zone_size != 0)
+      /* We can't have red-zone since "call" in the indirect thunk
+         pushes the return address onto stack, destroying red-zone.  */
+      if (ix86_red_zone_size != 0)
 	gcc_unreachable ();
 
       ix86_output_indirect_branch (call_op, "%0", true);
@@ -29146,20 +29100,21 @@
 	{
 	  bool need_thunk = (cfun->machine->function_return_type
 			     == indirect_branch_thunk);
-	  indirect_thunk_name (thunk_name, -1, need_bnd_p, true);
+	  indirect_thunk_name (thunk_name, INVALID_REGNUM, need_bnd_p,
+			       true);
 	  if (need_bnd_p)
 	    {
-	      indirect_thunk_bnd_needed |= need_thunk;
+	      indirect_return_bnd_needed |= need_thunk;
 	      fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
 	    }
 	  else
 	    {
-	      indirect_thunk_needed |= need_thunk;
+	      indirect_return_needed |= need_thunk;
 	      fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
 	    }
 	}
       else
-	output_indirect_thunk (need_bnd_p, -1);
+	output_indirect_thunk (need_bnd_p, INVALID_REGNUM);
 
       return "";
     }
@@ -29170,6 +29125,86 @@
   return "rep%; ret";
 }
 
+/* Output indirect function return.  RET_OP is the function return
+   target.  */
+
+const char *
+ix86_output_indirect_function_return (rtx ret_op)
+{
+  if (cfun->machine->function_return_type != indirect_branch_keep)
+    {
+      char thunk_name[32];
+      bool need_bnd_p = ix86_bnd_prefixed_insn_p (current_output_insn);
+      unsigned int regno = REGNO (ret_op);
+      gcc_assert (regno == CX_REG);
+
+      if (cfun->machine->function_return_type
+	  != indirect_branch_thunk_inline)
+	{
+	  bool need_thunk = (cfun->machine->function_return_type
+			     == indirect_branch_thunk);
+	  indirect_thunk_name (thunk_name, regno, need_bnd_p, true);
+	  if (need_bnd_p)
+	    {
+	      if (need_thunk)
+		{
+		  indirect_return_via_cx_bnd = true;
+		  indirect_thunks_bnd_used |= 1 << CX_REG;
+		}
+	      fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
+	    }
+	  else
+	    {
+	      if (need_thunk)
+		{
+		  indirect_return_via_cx = true;
+		  indirect_thunks_used |= 1 << CX_REG;
+		}
+	      fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
+	    }
+	}
+      else
+	output_indirect_thunk (need_bnd_p, regno);
+
+      return "";
+    }
+  else
+    return "%!jmp\t%A0";
+}
+
+/* Split simple return with popping POPC bytes from stack to indirect
+   branch with stack adjustment .  */
+
+void
+ix86_split_simple_return_pop_internal (rtx popc)
+{
+  struct machine_function *m = cfun->machine;
+  rtx ecx = gen_rtx_REG (SImode, CX_REG);
+  rtx_insn *insn;
+
+  /* There is no "pascal" calling convention in any 64bit ABI.  */
+  gcc_assert (!TARGET_64BIT);
+
+  insn = emit_insn (gen_pop (ecx));
+  m->fs.cfa_offset -= UNITS_PER_WORD;
+  m->fs.sp_offset -= UNITS_PER_WORD;
+
+  rtx x = plus_constant (Pmode, stack_pointer_rtx, UNITS_PER_WORD);
+  x = gen_rtx_SET (stack_pointer_rtx, x);
+  add_reg_note (insn, REG_CFA_ADJUST_CFA, x);
+  add_reg_note (insn, REG_CFA_REGISTER, gen_rtx_SET (ecx, pc_rtx));
+  RTX_FRAME_RELATED_P (insn) = 1;
+
+  x = gen_rtx_PLUS (Pmode, stack_pointer_rtx, popc);
+  x = gen_rtx_SET (stack_pointer_rtx, x);
+  insn = emit_insn (x);
+  add_reg_note (insn, REG_CFA_ADJUST_CFA, x);
+  RTX_FRAME_RELATED_P (insn) = 1;
+
+  /* Now return address is in ECX.  */
+  emit_jump_insn (gen_simple_return_indirect_internal (ecx));
+}
+
 /* Output the assembly for a call instruction.  */
 
 const char *
diff -ruN gcc-7.3.0/gcc/config/i386/i386.h gcc-7.3.0-msp430/gcc/config/i386/i386.h
--- gcc-7.3.0/gcc/config/i386/i386.h	2018-01-16 03:10:44.253204000 -0800
+++ gcc-7.3.0-msp430/gcc/config/i386/i386.h	2019-06-25 02:27:21.085931533 -0700
@@ -2719,6 +2719,11 @@
 #define TARGET_RECIP_VEC_DIV	((recip_mask & RECIP_MASK_VEC_DIV) != 0)
 #define TARGET_RECIP_VEC_SQRT	((recip_mask & RECIP_MASK_VEC_SQRT) != 0)
 
+
+#define TARGET_INDIRECT_BRANCH_REGISTER \
+  (ix86_indirect_branch_register \
+   || cfun->machine->indirect_branch_type != indirect_branch_keep)
+
 #define IX86_HLE_ACQUIRE (1 << 16)
 #define IX86_HLE_RELEASE (1 << 17)
 
diff -ruN gcc-7.3.0/gcc/config/i386/i386.md gcc-7.3.0-msp430/gcc/config/i386/i386.md
--- gcc-7.3.0/gcc/config/i386/i386.md	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/config/i386/i386.md	2019-06-25 02:27:21.085931533 -0700
@@ -739,7 +739,7 @@
 	   (if_then_else (match_operand 1 "constant_call_address_operand")
 	     (const_string "none")
 	     (const_string "load"))
-	 (and (eq_attr "type" "alu1,negnot,ishift1,sselog1,sseshuf1")
+	 (and (eq_attr "type" "alu1,negnot,ishift1,rotate1,sselog1,sseshuf1")
 	      (match_operand 1 "memory_operand"))
 	   (const_string "both")
 	 (and (match_operand 0 "memory_operand")
@@ -750,7 +750,7 @@
 	 (match_operand 1 "memory_operand")
 	   (const_string "load")
 	 (and (eq_attr "type"
-		 "!alu1,negnot,ishift1,
+		 "!alu1,negnot,ishift1,rotate1,
 		   imov,imovx,icmp,test,bitmanip,
 		   fmov,fcmp,fsgn,
 		   sse,ssemov,ssecmp,ssecomi,ssecvt,ssecvt1,sseicvt,
@@ -6685,6 +6685,20 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "<MODE>")])
 
+(define_insn "*add<mode>3_carry_0"
+  [(set (match_operand:SWI 0 "nonimmediate_operand" "=<r>m")
+	(plus:SWI
+	  (match_operator:SWI 3 "ix86_carry_flag_operator"
+	    [(match_operand 2 "flags_reg_operand") (const_int 0)])
+	  (match_operand:SWI 1 "nonimmediate_operand" "0")))
+   (clobber (reg:CC FLAGS_REG))]
+  "ix86_unary_operator_ok (PLUS, <MODE>mode, operands)"
+  "adc{<imodesuffix>}\t{$0, %0|%0, 0}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "<MODE>")])
+
 (define_insn "*addsi3_carry_zext"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
@@ -6701,6 +6715,20 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
+(define_insn "*addsi3_carry_zext_0"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (plus:SI (match_operator:SI 2 "ix86_carry_flag_operator"
+		    [(reg FLAGS_REG) (const_int 0)])
+		   (match_operand:SI 1 "register_operand" "0"))))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_64BIT"
+  "adc{l}\t{$0, %k0|%k0, 0}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "SI")])
+
 ;; There is no point to generate ADCX instruction. ADC is shorter and faster.
 
 (define_insn "addcarry<mode>"
@@ -6741,6 +6769,20 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "<MODE>")])
 
+(define_insn "*sub<mode>3_carry_0"
+  [(set (match_operand:SWI 0 "nonimmediate_operand" "=<r>m")
+	(minus:SWI
+	  (match_operand:SWI 1 "nonimmediate_operand" "0")
+	  (match_operator:SWI 3 "ix86_carry_flag_operator"
+	    [(match_operand 2 "flags_reg_operand") (const_int 0)])))
+   (clobber (reg:CC FLAGS_REG))]
+  "ix86_unary_operator_ok (MINUS, <MODE>mode, operands)"
+  "sbb{<imodesuffix>}\t{$0, %0|%0, 0}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "<MODE>")])
+
 (define_insn "*subsi3_carry_zext"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
@@ -6758,6 +6800,21 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
+(define_insn "*subsi3_carry_zext_0"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (minus:SI
+	    (match_operand:SI 1 "register_operand" "0")
+	    (match_operator:SI 2 "ix86_carry_flag_operator"
+	      [(reg FLAGS_REG) (const_int 0)]))))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_64BIT"
+  "sbb{l}\t{$0, %k0|%k0, 0}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "SI")])
+
 (define_insn "subborrow<mode>"
   [(set (reg:CCC FLAGS_REG)
 	(compare:CCC
@@ -8584,14 +8641,14 @@
 })
 
 (define_insn "*andndi3_doubleword"
-  [(set (match_operand:DI 0 "register_operand" "=r,&r")
+  [(set (match_operand:DI 0 "register_operand" "=&r,r,r,&r")
 	(and:DI
-	  (not:DI (match_operand:DI 1 "register_operand" "r,0"))
-	  (match_operand:DI 2 "nonimmediate_operand" "rm,rm")))
+	  (not:DI (match_operand:DI 1 "register_operand" "r,0,r,0"))
+	  (match_operand:DI 2 "nonimmediate_operand" "rm,rm,0,rm")))
    (clobber (reg:CC FLAGS_REG))]
   "!TARGET_64BIT && TARGET_STV && TARGET_SSE2"
   "#"
-  [(set_attr "isa" "bmi,*")])
+  [(set_attr "isa" "bmi,bmi,bmi,*")])
 
 (define_split
   [(set (match_operand:DI 0 "register_operand")
@@ -9916,7 +9973,7 @@
 {
   switch (get_attr_type (insn))
     {
-    case TYPE_ALU:
+    case TYPE_ALU1:
       gcc_assert (operands[1] == const1_rtx);
       return "add{b}\t%0, %0";
 
@@ -9932,12 +9989,12 @@
      (cond [(and (and (match_test "TARGET_DOUBLE_WITH_ADD")
 		      (match_operand 0 "register_operand"))
 		 (match_operand 1 "const1_operand"))
-	      (const_string "alu")
+	      (const_string "alu1")
 	   ]
 	   (const_string "ishift1")))
    (set (attr "length_immediate")
      (if_then_else
-       (ior (eq_attr "type" "alu")
+       (ior (eq_attr "type" "alu1")
 	    (and (eq_attr "type" "ishift1")
 		 (and (match_operand 1 "const1_operand")
 		      (ior (match_test "TARGET_SHIFT1")
@@ -11625,7 +11682,7 @@
   [(set (pc) (match_operand 0 "indirect_branch_operand"))]
   ""
 {
-  if (TARGET_X32 || ix86_indirect_branch_register)
+  if (TARGET_X32 || TARGET_INDIRECT_BRANCH_REGISTER)
     operands[0] = convert_memory_address (word_mode, operands[0]);
   cfun->machine->has_local_indirect_jump = true;
 })
@@ -11633,7 +11690,7 @@
 (define_insn "*indirect_jump"
   [(set (pc) (match_operand:W 0 "indirect_branch_operand" "rBw"))]
   ""
-  "* return ix86_output_indirect_jmp (operands[0], false);"
+  "* return ix86_output_indirect_jmp (operands[0]);"
   [(set (attr "type")
      (if_then_else (match_test "(cfun->machine->indirect_branch_type
 				 != indirect_branch_keep)")
@@ -11679,7 +11736,7 @@
 					 OPTAB_DIRECT);
     }
 
-  if (TARGET_X32 || ix86_indirect_branch_register)
+  if (TARGET_X32 || TARGET_INDIRECT_BRANCH_REGISTER)
     operands[0] = convert_memory_address (word_mode, operands[0]);
   cfun->machine->has_local_indirect_jump = true;
 })
@@ -11688,7 +11745,7 @@
   [(set (pc) (match_operand:W 0 "indirect_branch_operand" "rBw"))
    (use (label_ref (match_operand 1)))]
   ""
-  "* return ix86_output_indirect_jmp (operands[0], false);"
+  "* return ix86_output_indirect_jmp (operands[0]);"
   [(set (attr "type")
      (if_then_else (match_test "(cfun->machine->indirect_branch_type
 				 != indirect_branch_keep)")
@@ -11730,6 +11787,7 @@
   "(peep2_reg_dead_p (3, operands[1])
     || operands_match_p (operands[1], operands[3]))
    && ! reg_overlap_mentioned_p (operands[3], operands[0])
+   && ! reg_overlap_mentioned_p (operands[3], operands[4])
    && ! reg_set_p (operands[3], operands[4])
    && peep2_regno_dead_p (0, FLAGS_REG)"
   [(parallel [(set (match_dup 5) (match_dup 0))
@@ -11776,6 +11834,7 @@
   "(peep2_reg_dead_p (3, operands[1])
     || operands_match_p (operands[1], operands[3]))
    && ! reg_overlap_mentioned_p (operands[3], operands[0])
+   && ! reg_overlap_mentioned_p (operands[3], operands[4])
    && ! reg_set_p (operands[3], operands[4])
    && peep2_regno_dead_p (0, FLAGS_REG)"
   [(parallel [(set (match_dup 5) (match_dup 0))
@@ -11852,7 +11911,10 @@
 		     (match_operand:SI 0 "register_no_elim_operand" "U")
 		     (match_operand:SI 1 "GOT32_symbol_operand"))))
 	 (match_operand 2))]
-  "!TARGET_MACHO && !TARGET_64BIT && SIBLING_CALL_P (insn)"
+  "!TARGET_MACHO
+  && !TARGET_64BIT
+  && !TARGET_INDIRECT_BRANCH_REGISTER
+  && SIBLING_CALL_P (insn)"
 {
   rtx fnaddr = gen_rtx_PLUS (SImode, operands[0], operands[1]);
   fnaddr = gen_const_mem (SImode, fnaddr);
@@ -11871,7 +11933,7 @@
   [(call (mem:QI (match_operand:W 0 "memory_operand" "m"))
 	 (match_operand 1))
    (unspec [(const_int 0)] UNSPEC_PEEPSIB)]
-  "!TARGET_X32 && !ix86_indirect_branch_register"
+  "!TARGET_X32 && !TARGET_INDIRECT_BRANCH_REGISTER"
   "* return ix86_output_call_insn (insn, operands[0]);"
   [(set_attr "type" "call")])
 
@@ -11881,7 +11943,7 @@
    (call (mem:QI (match_dup 0))
 	 (match_operand 3))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && SIBLING_CALL_P (peep2_next_insn (1))
    && !reg_mentioned_p (operands[0],
 			CALL_INSN_FUNCTION_USAGE (peep2_next_insn (1)))"
@@ -11896,7 +11958,7 @@
    (call (mem:QI (match_dup 0))
 	 (match_operand 3))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && SIBLING_CALL_P (peep2_next_insn (2))
    && !reg_mentioned_p (operands[0],
 			CALL_INSN_FUNCTION_USAGE (peep2_next_insn (2)))"
@@ -11994,7 +12056,7 @@
         (match_operand:W 1 "memory_operand"))
    (set (pc) (match_dup 0))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && peep2_reg_dead_p (2, operands[0])"
   [(set (pc) (match_dup 1))])
 
@@ -12055,7 +12117,10 @@
 			  (match_operand:SI 1 "register_no_elim_operand" "U")
 			  (match_operand:SI 2 "GOT32_symbol_operand"))))
 	 (match_operand 3)))]
-  "!TARGET_MACHO && !TARGET_64BIT && SIBLING_CALL_P (insn)"
+  "!TARGET_MACHO
+   && !TARGET_64BIT
+   && !TARGET_INDIRECT_BRANCH_REGISTER
+   && SIBLING_CALL_P (insn)"
 {
   rtx fnaddr = gen_rtx_PLUS (SImode, operands[1], operands[2]);
   fnaddr = gen_const_mem (SImode, fnaddr);
@@ -12076,7 +12141,7 @@
  	(call (mem:QI (match_operand:W 1 "memory_operand" "m"))
 	      (match_operand 2)))
    (unspec [(const_int 0)] UNSPEC_PEEPSIB)]
-  "!TARGET_X32 && !ix86_indirect_branch_register"
+  "!TARGET_X32 && !TARGET_INDIRECT_BRANCH_REGISTER"
   "* return ix86_output_call_insn (insn, operands[1]);"
   [(set_attr "type" "callv")])
 
@@ -12087,7 +12152,7 @@
    (call (mem:QI (match_dup 0))
 		 (match_operand 3)))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && SIBLING_CALL_P (peep2_next_insn (1))
    && !reg_mentioned_p (operands[0],
 			CALL_INSN_FUNCTION_USAGE (peep2_next_insn (1)))"
@@ -12104,7 +12169,7 @@
 	(call (mem:QI (match_dup 0))
 	      (match_operand 3)))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && SIBLING_CALL_P (peep2_next_insn (2))
    && !reg_mentioned_p (operands[0],
 			CALL_INSN_FUNCTION_USAGE (peep2_next_insn (2)))"
@@ -12354,11 +12419,14 @@
    (set_attr "prefix_rep" "1")
    (set_attr "modrm" "0")])
 
-(define_insn "simple_return_pop_internal"
+(define_insn_and_split "simple_return_pop_internal"
   [(simple_return)
    (use (match_operand:SI 0 "const_int_operand"))]
   "reload_completed"
   "%!ret\t%0"
+  "&& cfun->machine->function_return_type != indirect_branch_keep"
+  [(const_int 0)]
+  "ix86_split_simple_return_pop_internal (operands[0]); DONE;"
   [(set_attr "length" "3")
    (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "2")
@@ -12369,7 +12437,7 @@
   [(simple_return)
    (use (match_operand:SI 0 "register_operand" "r"))]
   "reload_completed"
-  "* return ix86_output_indirect_jmp (operands[0], true);"
+  "* return ix86_output_indirect_function_return (operands[0]);"
   [(set (attr "type")
      (if_then_else (match_test "(cfun->machine->indirect_branch_type
 				 != indirect_branch_keep)")
@@ -12524,7 +12592,10 @@
      stack address we wish to restore.  */
   tmp = gen_rtx_PLUS (Pmode, arg_pointer_rtx, sa);
   tmp = plus_constant (Pmode, tmp, -UNITS_PER_WORD);
-  tmp = gen_rtx_MEM (Pmode, tmp);
+  /* Return address is always in word_mode.  */
+  tmp = gen_rtx_MEM (word_mode, tmp);
+  if (GET_MODE (ra) != word_mode)
+    ra = convert_to_mode (word_mode, ra, 1);
   emit_move_insn (tmp, ra);
 
   emit_jump_insn (gen_eh_return_internal ());
@@ -15527,7 +15598,8 @@
   "(TARGET_USE_FANCY_MATH_387
     && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)
 	|| TARGET_MIX_SSE_I387)
-    && flag_unsafe_math_optimizations)
+    && flag_unsafe_math_optimizations
+    && (flag_fp_int_builtin_inexact || !flag_trapping_math))
    || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH
        && !flag_trapping_math && !flag_rounding_math)"
 {
diff -ruN gcc-7.3.0/gcc/config/i386/i386-protos.h gcc-7.3.0-msp430/gcc/config/i386/i386-protos.h
--- gcc-7.3.0/gcc/config/i386/i386-protos.h	2018-01-16 03:10:44.253204000 -0800
+++ gcc-7.3.0-msp430/gcc/config/i386/i386-protos.h	2019-06-25 02:27:21.081931561 -0700
@@ -313,8 +313,10 @@
 #endif
 
 extern const char * ix86_output_call_insn (rtx_insn *insn, rtx call_op);
-extern const char * ix86_output_indirect_jmp (rtx call_op, bool ret_p);
+extern const char * ix86_output_indirect_jmp (rtx call_op);
 extern const char * ix86_output_function_return (bool long_p);
+extern const char * ix86_output_indirect_function_return (rtx ret_op);
+extern void ix86_split_simple_return_pop_internal (rtx);
 extern bool ix86_operands_ok_for_move_multiple (rtx *operands, bool load,
 						enum machine_mode mode);
 
diff -ruN gcc-7.3.0/gcc/config/i386/predicates.md gcc-7.3.0-msp430/gcc/config/i386/predicates.md
--- gcc-7.3.0/gcc/config/i386/predicates.md	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/config/i386/predicates.md	2019-06-25 02:27:21.085931533 -0700
@@ -635,7 +635,7 @@
 ;; Test for a valid operand for indirect branch.
 (define_predicate "indirect_branch_operand"
   (ior (match_operand 0 "register_operand")
-       (and (not (match_test "ix86_indirect_branch_register"))
+       (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (not (match_test "TARGET_X32"))
 	    (match_operand 0 "memory_operand"))))
 
@@ -679,7 +679,7 @@
   (ior (match_test "constant_call_address_operand
 		     (op, mode == VOIDmode ? mode : Pmode)")
        (match_operand 0 "call_register_no_elim_operand")
-       (and (not (match_test "ix86_indirect_branch_register"))
+       (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (ior (and (not (match_test "TARGET_X32"))
 		      (match_operand 0 "memory_operand"))
 		 (and (match_test "TARGET_X32 && Pmode == DImode")
@@ -690,7 +690,7 @@
   (ior (match_test "constant_call_address_operand
 		     (op, mode == VOIDmode ? mode : Pmode)")
        (match_operand 0 "register_no_elim_operand")
-       (and (not (match_test "ix86_indirect_branch_register"))
+       (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (ior (and (not (match_test "TARGET_X32"))
 		      (match_operand 0 "sibcall_memory_operand"))
 		 (and (match_test "TARGET_X32 && Pmode == DImode")
diff -ruN gcc-7.3.0/gcc/config/i386/sse.md gcc-7.3.0-msp430/gcc/config/i386/sse.md
--- gcc-7.3.0/gcc/config/i386/sse.md	2017-12-15 14:08:20.346277000 -0800
+++ gcc-7.3.0-msp430/gcc/config/i386/sse.md	2019-06-25 02:27:21.085931533 -0700
@@ -1134,11 +1134,8 @@
 					     operands[2]));
    }
  else if (memory_operand (operands[1], DImode))
-   {
-     rtx tmp = gen_reg_rtx (V2DImode);
-     emit_insn (gen_vec_concatv2di (tmp, operands[1], const0_rtx));
-     emit_move_insn (operands[0], gen_lowpart (V4SImode, tmp));
-   }
+   emit_insn (gen_vec_concatv2di (gen_lowpart (V2DImode, operands[0]),
+				  operands[1], const0_rtx));
  else
    gcc_unreachable ();
  DONE;
@@ -4398,7 +4395,7 @@
 	  (match_operand:VF_128 1 "register_operand" "v")
 	  (const_int 1)))]
   "TARGET_AVX512F && TARGET_64BIT"
-  "vcvtusi2<ssescalarmodesuffix>\t{%2, <round_op3>%1, %0|%0, %1<round_op3>, %2}"
+  "vcvtusi2<ssescalarmodesuffix>{q}\t{%2, <round_op3>%1, %0|%0, %1<round_op3>, %2}"
   [(set_attr "type" "sseicvt")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<ssescalarmode>")])
@@ -8883,14 +8880,14 @@
 ;; see comment above inline_secondary_memory_needed function in i386.c
 (define_insn "sse2_loadhpd"
   [(set (match_operand:V2DF 0 "nonimmediate_operand"
-	  "=x,v,x,v,o,o ,o")
+	  "=x,v,x,v ,o,o ,o")
 	(vec_concat:V2DF
 	  (vec_select:DF
 	    (match_operand:V2DF 1 "nonimmediate_operand"
-	  " 0,v,0,v,0,0 ,0")
+	  " 0,v,0,v ,0,0 ,0")
 	    (parallel [(const_int 0)]))
 	  (match_operand:DF 2 "nonimmediate_operand"
-	  " m,m,x,v,x,*f,r")))]
+	  " m,m,x,Yv,x,*f,r")))]
   "TARGET_SSE2 && !(MEM_P (operands[1]) && MEM_P (operands[2]))"
   "@
    movhpd\t{%2, %0|%0, %2}
@@ -9938,11 +9935,11 @@
    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)"
   "@
    p<plusminus_mnemonic><ssemodesuffix>\t{%2, %0|%0, %2}
-   vp<plusminus_mnemonic><ssemodesuffix>\t{%2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2}"
+   vp<plusminus_mnemonic><ssemodesuffix>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "isa" "noavx,avx")
    (set_attr "type" "sseiadd")
    (set_attr "prefix_data16" "1,*")
-   (set_attr "prefix" "<mask_prefix3>")
+   (set_attr "prefix" "orig,vex")
    (set_attr "mode" "<sseinsnmode>")])
 
 (define_insn "*<plusminus_insn><mode>3_mask"
@@ -10683,11 +10680,14 @@
        (const_string "0")))
    (set_attr "mode" "<sseinsnmode>")])
 
+(define_mode_attr vshift_count
+  [(V32HI "v") (V16HI "Yv") (V8HI "Yv")])
+
 (define_insn "<shift_insn><mode>3<mask_name>"
   [(set (match_operand:VI2_AVX2_AVX512BW 0 "register_operand" "=x,v")
 	(any_lshift:VI2_AVX2_AVX512BW
 	  (match_operand:VI2_AVX2_AVX512BW 1 "register_operand" "0,v")
-	  (match_operand:DI 2 "nonmemory_operand" "xN,vN")))]
+	  (match_operand:DI 2 "nonmemory_operand" "xN,<vshift_count>N")))]
   "TARGET_SSE2 && <mask_mode512bit_condition> && <mask_avx512bw_condition>"
   "@
    p<vshift><ssemodesuffix>\t{%2, %0|%0, %2}
@@ -10706,7 +10706,7 @@
   [(set (match_operand:VI48_AVX2 0 "register_operand" "=x,x,v")
 	(any_lshift:VI48_AVX2
 	  (match_operand:VI48_AVX2 1 "register_operand" "0,x,v")
-	  (match_operand:DI 2 "nonmemory_operand" "xN,xN,vN")))]
+	  (match_operand:DI 2 "nonmemory_operand" "xN,xN,YvN")))]
   "TARGET_SSE2 && <mask_mode512bit_condition>"
   "@
    p<vshift><ssemodesuffix>\t{%2, %0|%0, %2}
@@ -11822,7 +11822,7 @@
 	    (eq_attr "mode" "TI"))
        (const_string "1")
        (const_string "*")))
-   (set_attr "prefix" "<mask_prefix3>")
+   (set_attr "prefix" "orig,vex")
    (set (attr "mode")
 	(cond [(and (match_test "<MODE_SIZE> == 16")
 		    (match_test "TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL"))
diff -ruN gcc-7.3.0/gcc/config/m68k/m68k.c gcc-7.3.0-msp430/gcc/config/m68k/m68k.c
--- gcc-7.3.0/gcc/config/m68k/m68k.c	2017-04-03 15:30:56.274463000 -0700
+++ gcc-7.3.0-msp430/gcc/config/m68k/m68k.c	2019-06-25 02:27:21.089931503 -0700
@@ -185,6 +185,8 @@
 static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;
 static enum flt_eval_method
 m68k_excess_precision (enum excess_precision_type);
+static machine_mode m68k_promote_function_mode (const_tree, machine_mode,
+						int *, const_tree, int);
 
 /* Initialize the GCC target structure.  */
 
@@ -332,6 +334,9 @@
 #undef TARGET_ATOMIC_TEST_AND_SET_TRUEVAL
 #define TARGET_ATOMIC_TEST_AND_SET_TRUEVAL 128
 
+#undef TARGET_PROMOTE_FUNCTION_MODE
+#define TARGET_PROMOTE_FUNCTION_MODE m68k_promote_function_mode
+
 static const struct attribute_spec m68k_attribute_table[] =
 {
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,
@@ -6571,4 +6576,20 @@
   return FLT_EVAL_METHOD_UNPREDICTABLE;
 }
 
+/* Implement TARGET_PROMOTE_FUNCTION_MODE.  */
+
+static machine_mode
+m68k_promote_function_mode (const_tree type, machine_mode mode,
+                            int *punsignedp ATTRIBUTE_UNUSED,
+                            const_tree fntype ATTRIBUTE_UNUSED,
+                            int for_return)
+{
+  /* Promote libcall arguments narrower than int to match the normal C
+     ABI (for which promotions are handled via
+     TARGET_PROMOTE_PROTOTYPES).  */
+  if (type == NULL_TREE && !for_return && (mode == QImode || mode == HImode))
+    return SImode;
+  return mode;
+}
+
 #include "gt-m68k.h"
diff -ruN gcc-7.3.0/gcc/config/msp430/driver-msp430.c gcc-7.3.0-msp430/gcc/config/msp430/driver-msp430.c
--- gcc-7.3.0/gcc/config/msp430/driver-msp430.c	2017-01-10 12:59:20.679684000 -0800
+++ gcc-7.3.0-msp430/gcc/config/msp430/driver-msp430.c	2019-06-25 02:27:21.089931503 -0700
@@ -23,20 +23,14 @@
 #include "coretypes.h"
 #include "diagnostic.h"
 #include "tm.h"
+#include "msp430-devices.h"
 
-/* This is a copy of the same data structure found in gas/config/tc-msp430.c
-   Also another (sort-of) copy can be found in gcc/config/msp430/msp430.c
-   Keep these three structures in sync.
+/* This structure is no longer being maintained.  Up-to-date data is read from
+   a devices.csv file on the user's system.
    The data in this structure has been extracted from version 1.194 of the
    devices.csv file released by TI in September 2016.  */
 
-struct msp430_mcu_data
-{
-  const char * name;
-  unsigned int revision; /* 0=> MSP430, 1=>MSP430X, 2=> MSP430Xv2.  */
-  unsigned int hwmpy;    /* 0=>none, 1=>16-bit, 2=>16-bit w/sign extend, 4=>32-bit, 8=> 32-bit (5xx).  */
-}
-msp430_mcu_data [] =
+struct t_msp430_mcu_data hard_msp430_mcu_data[] =
 {
   { "cc430f5123",2,8 },
   { "cc430f5125",2,8 },
@@ -643,7 +637,70 @@
   { "rf430frl153h_rom",0,0 },
   { "rf430frl154h",0,0 },
   { "rf430frl154h_rom",0,0 }
-};  
+};
+
+char * driver_devices_csv_loc = NULL;
+
+static int
+parse_devices_csv_wrapper (const char * mcu_name)
+{
+  if (driver_devices_csv_loc)
+    parse_devices_csv (driver_devices_csv_loc, mcu_name);
+  else if (devices_csv_loc)
+    parse_devices_csv (devices_csv_loc, mcu_name);
+  else
+    return 1;
+  return 0;
+}
+
+const char *
+msp430_check_path_for_devices (int argc, const char **argv)
+{
+  /* devices_csv_loc is set by the option.  */
+  if (devices_csv_loc)
+    return NULL;
+  else if (driver_devices_csv_loc)
+    return concat ("-mdevices-csv-loc=", driver_devices_csv_loc, NULL);
+  const char dirsep[2] = { DIR_SEPARATOR, 0 };
+  FILE * devices_csv = NULL;
+  char * local_devices_csv_loc = NULL;
+  int i;
+  for (i = 0; i < argc; i++)
+    {
+      char *inc_path = ASTRDUP (argv[i]);
+      msp430_canonicalize_path (&inc_path);
+      if (!IS_DIR_SEPARATOR (inc_path[strlen (inc_path) - 1]))
+	inc_path = concat (inc_path, dirsep, NULL);
+      local_devices_csv_loc = concat (inc_path, "devices.csv", NULL);
+      devices_csv = fopen (local_devices_csv_loc, "r");
+      if (devices_csv != NULL)
+	{
+	  fclose (devices_csv);
+	  driver_devices_csv_loc = local_devices_csv_loc;
+	  return concat ("-mdevices-csv-loc=", local_devices_csv_loc, NULL);
+	}
+    }
+  return NULL;
+}
+
+const char *
+msp430_select_cpu (int argc, const char ** argv)
+{
+  if (argc == 0 || parse_devices_csv_wrapper (argv[0]))
+    return NULL;
+  switch (extracted_mcu_data.revision)
+    {
+    case 0:
+      return "-mcpu=msp430";
+    case 1:
+      return "-mcpu=msp430x";
+    case 2:
+      return "-mcpu=msp430xv2";
+    default:
+      error ("Unexpected error get msp430 cpu type\n");
+      return NULL;
+    }
+}
 
 /* Implement spec function `msp430_hwmult_lib.  */
 
@@ -651,7 +708,6 @@
 msp430_select_hwmult_lib (int argc ATTRIBUTE_UNUSED, const char ** argv ATTRIBUTE_UNUSED)
 {
   int i;
-
   switch (argc)
   {
   case 1:
@@ -686,22 +742,26 @@
       }
     else if (strcasecmp (argv[0], "mcu") == 0)
       {
-	for (i = ARRAY_SIZE (msp430_mcu_data); i--;)
-	  if (strcasecmp (argv[argc - 1], msp430_mcu_data[i].name) == 0)
-	    {
-	      switch (msp430_mcu_data[i].hwmpy)
-		{
-		case 0: return "-lmul_none";
-		case 2:
-		case 1: return "-lmul_16";
-		case 4: return "-lmul_32";
-		case 8: return "-lmul_f5";
-		default:
-		  error ("unrecognized hwpy field in msp430_mcu_data[%d]: %d",
-			 i, msp430_mcu_data[i].hwmpy);
+	parse_devices_csv_wrapper (argv[argc - 1]);
+	if (extracted_mcu_data.name == NULL)
+	  {
+	    for (i = ARRAY_SIZE (hard_msp430_mcu_data); i--;)
+	      if (strcasecmp (argv[argc - 1],
+			      hard_msp430_mcu_data[i].name) == 0)
+		extracted_mcu_data = hard_msp430_mcu_data[i];
+	  }
+	switch (extracted_mcu_data.hwmpy)
+	  {
+	  case 0: return "-lmul_none";
+	  case 2:
+	  case 1: return "-lmul_16";
+	  case 4: return "-lmul_32";
+	  case 8: return "-lmul_f5";
+	  default:
+		  error ("unrecognized hwpy field in hard_msp430_mcu_data[%d]: %d",
+			 i, hard_msp430_mcu_data[i].hwmpy);
 		  break;
-		}
-	    }
+	  }
       }
     else
       error ("unexpected first argument to msp430_select_hwmult_lib: %s", argv[0]);
@@ -714,3 +774,12 @@
   
   return "-lmul_none";
 }
+
+const char *
+msp430_get_linker_devices_include_path (int argc ATTRIBUTE_UNUSED, const char **argv ATTRIBUTE_UNUSED)
+{
+  char *devices_csv_path;
+  if (check_env_var_for_devices (&devices_csv_path))
+    return NULL;
+  return concat ("-L", msp430_dirname (devices_csv_path), NULL);
+}
diff -ruN gcc-7.3.0/gcc/config/msp430/msp430.c gcc-7.3.0-msp430/gcc/config/msp430/msp430.c
--- gcc-7.3.0/gcc/config/msp430/msp430.c	2017-03-10 17:43:48.186872000 -0800
+++ gcc-7.3.0-msp430/gcc/config/msp430/msp430.c	2019-06-25 02:27:21.089931503 -0700
@@ -27,9 +27,9 @@
 #include "tree.h"
 #include "gimple-expr.h"
 #include "df.h"
-#include "memmodel.h"
 #include "tm_p.h"
 #include "regs.h"
+#include "memmodel.h"
 #include "emit-rtl.h"
 #include "diagnostic-core.h"
 #include "fold-const.h"
@@ -40,6 +40,10 @@
 #include "expr.h"
 #include "langhooks.h"
 #include "builtins.h"
+#include "intl.h"
+#include "msp430-devices.h"
+#include "incpath.h"
+#include "prefix.h"
 
 /* This file should be included last.  */
 #include "target-def.h"
@@ -90,19 +94,12 @@
 #undef  TARGET_OPTION_OVERRIDE
 #define TARGET_OPTION_OVERRIDE		msp430_option_override
 
-/* This is a copy of the same data structure found in gas/config/tc-msp430.c
-   Also another (sort-of) copy can be found in gcc/config/msp430/t-msp430
-   Keep these three structures in sync.
+/* This structure is no longer being maintained.  Up-to-date data is read from
+   a devices.csv file on the user's system.
    The data in this structure has been extracted from version 1.194 of the
    devices.csv file released by TI in September 2016.  */
 
-struct msp430_mcu_data
-{
-  const char * name;
-  unsigned int revision; /* 0=> MSP430, 1=>MSP430X, 2=> MSP430Xv2.  */
-  unsigned int hwmpy;    /* 0=>none, 1=>16-bit, 2=>16-bit w/sign extend, 4=>32-bit, 8=> 32-bit (5xx).  */
-}
-msp430_mcu_data [] =
+struct t_msp430_mcu_data hard_msp430_mcu_data[] =
 {
   { "cc430f5123",2,8 },
   { "cc430f5125",2,8 },
@@ -719,12 +716,21 @@
 {
   if (target_mcu)
     {
+      find_devices_csv (target_mcu);
       unsigned int i;
       static char mcu_name [64];
 
-      snprintf (mcu_name, sizeof (mcu_name) - 1, "__%s__", target_mcu);
-      for (i = strlen (mcu_name); i--;)
-	mcu_name[i] = TOUPPER (mcu_name[i]);
+      /* The 'i' in msp430i* devices must be lower case so the correct
+	 definition in msp430.h is used.  */
+      if (strncmp (target_mcu, "msp430i", 7) == 0)
+	snprintf (mcu_name, sizeof (mcu_name) - 1, "__MSP430i%s__",
+		  target_mcu + 7);
+      else
+	{
+	  snprintf (mcu_name, sizeof (mcu_name) - 1, "__%s__", target_mcu);
+	  for (i = strlen (mcu_name); i--;)
+	    mcu_name[i] = TOUPPER (mcu_name[i]);
+	}
       return mcu_name;
     }
 
@@ -762,45 +768,60 @@
 
   if (target_mcu)
     {
+      find_devices_csv (target_mcu);
       int i;
 
       /* FIXME: If the array were alpha sorted, we could use a binary search.  */
-      for (i = ARRAY_SIZE (msp430_mcu_data); i--;)
-	if (strcasecmp (msp430_mcu_data[i].name, target_mcu) == 0)
+      if (extracted_mcu_data.name == NULL)
+	for (i = ARRAY_SIZE (hard_msp430_mcu_data); i--;)
 	  {
-	    bool xisa = msp430_mcu_data[i].revision >= 1; 
-
-	    if (msp430_warn_mcu)
+	    if (strcasecmp (hard_msp430_mcu_data[i].name, target_mcu) == 0)
 	      {
-		if (target_cpu&& msp430x != xisa)
-		  warning (0, "MCU '%s' supports %s ISA but -mcpu option is set to %s",
-			   target_mcu, xisa ? "430X" : "430", msp430x ? "430X" : "430");
-
-		if (msp430_mcu_data[i].hwmpy == 0
-		    && msp430_hwmult_type != MSP430_HWMULT_AUTO
-		    && msp430_hwmult_type != MSP430_HWMULT_NONE)
-		  warning (0, "MCU '%s' does not have hardware multiply support, but -mhwmult is set to %s",
-			   target_mcu,
-			   msp430_hwmult_type == MSP430_HWMULT_SMALL ? "16-bit"
-			   : msp430_hwmult_type == MSP430_HWMULT_LARGE ? "32-bit" : "f5series");
-		else if (msp430_hwmult_type == MSP430_HWMULT_SMALL
-		    && msp430_mcu_data[i].hwmpy != 1
-		    && msp430_mcu_data[i].hwmpy != 2 )
-		  warning (0, "MCU '%s' supports %s hardware multiply, but -mhwmult is set to 16-bit",
-			   target_mcu, hwmult_name (msp430_mcu_data[i].hwmpy));
-		else if (msp430_hwmult_type == MSP430_HWMULT_LARGE && msp430_mcu_data[i].hwmpy != 4)
-		  warning (0, "MCU '%s' supports %s hardware multiply, but -mhwmult is set to 32-bit",
-			   target_mcu, hwmult_name (msp430_mcu_data[i].hwmpy));
-		else if (msp430_hwmult_type == MSP430_HWMULT_F5SERIES && msp430_mcu_data[i].hwmpy != 8)
-		  warning (0, "MCU '%s' supports %s hardware multiply, but -mhwmult is set to f5series",
-			   target_mcu, hwmult_name (msp430_mcu_data[i].hwmpy));
+		extracted_mcu_data = hard_msp430_mcu_data[i];
+		break;
 	      }
-
-	    msp430x = xisa;
-	    break;
 	  }
+      if (extracted_mcu_data.name != NULL)
+	{
+	  bool xisa = extracted_mcu_data.revision >= 1;
+
+	  if (msp430_warn_mcu)
+	    {
+	      if (target_cpu && msp430x != xisa)
+		warning (0, "MCU '%s' supports %s ISA but -mcpu option is set "
+			 "to %s", target_mcu, xisa ? "430X" : "430",
+			 msp430x ? "430X" : "430");
+
+	      if (extracted_mcu_data.hwmpy == 0
+		  && msp430_hwmult_type != MSP430_HWMULT_AUTO
+		  && msp430_hwmult_type != MSP430_HWMULT_NONE)
+		warning (0, "MCU '%s' does not have hardware multiply support, "
+			 "but -mhwmult is set to %s",
+			 target_mcu,
+			 msp430_hwmult_type == MSP430_HWMULT_SMALL ? "16-bit"
+			 : msp430_hwmult_type == MSP430_HWMULT_LARGE ? "32-bit"
+			 : "f5series");
+	      else if (msp430_hwmult_type == MSP430_HWMULT_SMALL
+		       && extracted_mcu_data.hwmpy != 1
+		       && extracted_mcu_data.hwmpy != 2)
+		warning (0, "MCU '%s' supports %s hardware multiply, "
+			 "but -mhwmult is set to 16-bit",
+			 target_mcu, hwmult_name (extracted_mcu_data.hwmpy));
+	      else if (msp430_hwmult_type == MSP430_HWMULT_LARGE
+		       && extracted_mcu_data.hwmpy != 4)
+		warning (0, "MCU '%s' supports %s hardware multiply, "
+			 "but -mhwmult is set to 32-bit",
+			 target_mcu, hwmult_name (extracted_mcu_data.hwmpy));
+	      else if (msp430_hwmult_type == MSP430_HWMULT_F5SERIES
+		       && extracted_mcu_data.hwmpy != 8)
+		warning (0, "MCU '%s' supports %s hardware multiply, "
+			 "but -mhwmult is set to f5series",
+			 target_mcu, hwmult_name (extracted_mcu_data.hwmpy));
+	    }
 
-      if (i < 0)
+	  msp430x = xisa;
+	}
+      else
 	{
 	  if (msp430_hwmult_type == MSP430_HWMULT_AUTO)
 	    {
@@ -840,7 +861,8 @@
     }
 
   /* The F5 series are all able to support the 430X ISA.  */
-  if (target_cpu == NULL && target_mcu == NULL && msp430_hwmult_type == MSP430_HWMULT_F5SERIES)
+  if (target_cpu == NULL && target_mcu == NULL
+      && msp430_hwmult_type == MSP430_HWMULT_F5SERIES)
     msp430x = true;
 
   if (TARGET_LARGE && !msp430x)
@@ -857,6 +879,11 @@
   else
     flag_omit_frame_pointer = true;
 
+  /* The MSP ABI C Helper functions do not have versions which can perform
+     overflow checking.  */
+  if (flag_trapv)
+    error ("-ftrapv is not supported for msp430-elf");
+
   /* This is a hack to work around a problem with the newlib build
      mechanism.  Newlib always appends CFLAGS to the end of the GCC
      command line and always sets -O2 in CFLAGS.  Thus it is not
@@ -905,6 +932,8 @@
 {
   if (mode == PSImode && msp430x)
     return 1;
+  if (mode == CPSImode && msp430x)
+    return 2;
   return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)
 	  / UNITS_PER_WORD);
 }
@@ -927,6 +956,8 @@
 {
   if (mode == PSImode)
     return 2;
+  if (mode == CPSImode)
+    return 4;
   return msp430_hard_regno_nregs (regno, mode);
 }
 
@@ -1311,15 +1342,21 @@
 #undef  TARGET_PASS_BY_REFERENCE
 #define TARGET_PASS_BY_REFERENCE msp430_pass_by_reference
 
+/* Structs/unions/classes up to and including 32-bits can be passed by value.
+   If larger than 32-bits, they must be passed by reference.  */
 static bool
 msp430_pass_by_reference (cumulative_args_t cap ATTRIBUTE_UNUSED,
 			  machine_mode mode,
 			  const_tree type,
 			  bool named ATTRIBUTE_UNUSED)
 {
-  return (mode == BLKmode
-	  || (type && TREE_CODE (type) == RECORD_TYPE)
-	  || (type && TREE_CODE (type) == UNION_TYPE));
+  return ((mode == BLKmode
+	   || (type && TREE_CODE (type) == RECORD_TYPE)
+	   || (type && TREE_CODE (type) == UNION_TYPE)));
+/* Save for MSP430-GCC 8.  */
+#if 0
+	  && tree_to_uhwi (TYPE_SIZE (type)) > 32);
+#endif
 }
 
 #undef  TARGET_CALLEE_COPIES
@@ -1771,6 +1808,8 @@
 const char * const  ATTR_EITHER = "either";
 const char * const  ATTR_NOINIT = "noinit";
 const char * const  ATTR_PERSIST = "persistent";
+const char * const  SEC_NOINIT = ".noinit";
+const char * const  SEC_PERSIST = ".persistent";
 
 static inline bool
 has_attr (const char * attr, tree decl)
@@ -1818,6 +1857,15 @@
   return has_attr (ATTR_CRIT, decl);
 }
 
+static bool
+has_section_name (const char * name, tree decl = current_function_decl)
+{
+  if (decl == NULL_TREE)
+    return false;
+  return (DECL_SECTION_NAME (decl)
+    && (strcmp (name, DECL_SECTION_NAME (decl)) == 0));
+}
+
 #undef  TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS
 #define TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS	msp430_allocate_stack_slots_for_args
 
@@ -1828,6 +1876,17 @@
   return ! is_naked_func ();
 }
 
+#undef TARGET_WARN_FUNC_RETURN
+#define TARGET_WARN_FUNC_RETURN msp430_warn_func_return
+
+static bool
+msp430_warn_func_return (tree decl)
+{
+  /* Naked functions are implemented entirely in assembly, including the
+     return sequence, so suppress warnings about this.  */
+  return !is_naked_func (decl);
+}
+
 /* Verify MSP430 specific attributes.  */
 #define TREE_NAME_EQ(NAME, STR) (strcmp (IDENTIFIER_POINTER (NAME), (STR)) == 0)
 
@@ -1840,11 +1899,9 @@
 {
   gcc_assert (DECL_P (* node));
 
+  /* Only the interrupt attribute takes an argument.  */
   if (args != NULL)
     {
-      /* Only the interrupt attribute takes an argument.  */
-      gcc_assert (TREE_NAME_EQ (name, ATTR_INTR));
-
       tree value = TREE_VALUE (args);
 
       switch (TREE_CODE (value))
@@ -1889,9 +1946,12 @@
       if (TREE_CODE (TREE_TYPE (* node)) == FUNCTION_TYPE
 	  && ! VOID_TYPE_P (TREE_TYPE (TREE_TYPE (* node))))
 	message = "interrupt handlers must be void";
-
-      if (! TREE_PUBLIC (* node))
-	message = "interrupt handlers cannot be static";
+      else
+	{
+	  /* Ensure interrupt handlers never get optimised out.  */
+	  TREE_USED (* node) = 1;
+	  DECL_PRESERVE_P (* node) = 1;
+	}
     }
   else if (TREE_NAME_EQ (name, ATTR_REENT))
     {
@@ -1983,23 +2043,70 @@
   gcc_assert (DECL_P (* node));
   gcc_assert (args == NULL);
 
-  if (TREE_CODE (* node) != VAR_DECL)
-    message = "%qE attribute only applies to variables";
+  /* Variable name to use in warning string, defaults to attribute name.  */
+  tree var = name;
+  tree decl = *node;
+
+  if (TREE_CODE (decl) != VAR_DECL)
+    {
+      message = G_("%qE attribute only applies to variables");
+      goto fail;
+    }
 
-  if (DECL_SECTION_NAME (* node))
-    message = "%qE attribute cannot be applied to variables with specific sections";
+  if ((TREE_NAME_EQ (name, ATTR_PERSIST)
+       && has_attr (ATTR_NOINIT, decl))
+      || (TREE_NAME_EQ (name, ATTR_NOINIT)
+	  && has_attr (ATTR_PERSIST, decl)))
+    {
+      message
+	= "variable %qE cannot have both noinit and persistent attributes";
+      var = decl;
+      goto fail;
+    }
 
-  /* If this var is thought to be common, then change this.  Common variables
-     are assigned to sections before the backend has a chance to process them.  */
-  if (DECL_COMMON (* node))
-    DECL_COMMON (* node) = 0;
 
-  if (message)
+  /* The decl may have already been given a section attribute
+     from a previous declaration.  Ensure they match.  */
+  if (DECL_SECTION_NAME (decl) != NULL
+      && ((TREE_NAME_EQ (name, ATTR_PERSIST)
+	   && strcmp (SEC_PERSIST, DECL_SECTION_NAME (decl)) != 0)
+	  || (TREE_NAME_EQ (name, ATTR_NOINIT)
+	      && strcmp (SEC_NOINIT, DECL_SECTION_NAME (decl)) != 0)))
     {
-      warning (OPT_Wattributes, message, name);
-      * no_add_attrs = true;
+      message = G_("section of %qE conflicts with previous declaration");
+      var = decl;
+      goto fail;
     }
-    
+
+  if (!TREE_STATIC (decl) && !TREE_PUBLIC (decl) && !DECL_EXTERNAL (decl))
+    {
+      message = G_("%qE attribute has no effect on automatic variables");
+      goto fail;
+    }
+
+  if (TREE_NAME_EQ (name, ATTR_PERSIST))
+    {
+      if (DECL_INITIAL (decl) == NULL
+	  || initializer_zerop (DECL_INITIAL (decl)))
+	warning (OPT_Wattributes,
+		 "variable %qE was declared persistent and should be explicitly initialized", decl);
+    }
+
+  /* In some cases the front-end will place data before msp430_select_section
+     gets a chance, so just put noinit and persistent variables in the correct
+     section now.  */
+  if (TREE_NAME_EQ (name, ATTR_PERSIST))
+    set_decl_section_name (decl, SEC_PERSIST);
+  else if (TREE_NAME_EQ (name, ATTR_NOINIT))
+    set_decl_section_name (decl, SEC_NOINIT);
+
+  goto done;
+
+fail:
+  warning (OPT_Wattributes, message, var);
+  * no_add_attrs = true;
+
+done:
   return NULL_TREE;
 }
 
@@ -2167,6 +2274,12 @@
   if (has_attr ("section", decl))
     return NULL;
 
+  /* If the function has been put in the .lowtext section (because it is an
+     interrupt handler, and the large memory model is used), then do not add
+     any prefixes.  */
+  if (has_section_name (".lowtext", decl))
+    return NULL;
+
   /* If the object has __attribute__((lower)) then use the ".lower." prefix.  */
   if (has_attr (ATTR_LOWER, decl))
     return lower_prefix;
@@ -2175,6 +2288,11 @@
   if (! msp430x)
     return NULL;
 
+  /* Do not add prefixes to data to be placed in the .noinit or .persistent
+     section.  */
+  if (has_attr (ATTR_NOINIT, decl) || has_attr (ATTR_PERSIST, decl))
+    return NULL;
+
   if (has_attr (ATTR_UPPER, decl))
     return upper_prefix;
 
@@ -2317,9 +2435,9 @@
     name += strlen (upper_prefix);
   else if (strncmp (name, either_prefix, strlen (either_prefix)) == 0)
     name += strlen (either_prefix);
-  else if (strcmp (name, ".noinit") == 0)
+  else if (strcmp (name, SEC_NOINIT) == 0)
     return SECTION_WRITE | SECTION_BSS | SECTION_NOTYPE;
-  else if (strcmp (name, ".persistent") == 0)
+  else if (strcmp (name, SEC_PERSIST) == 0)
     return SECTION_WRITE | SECTION_NOTYPE;
   
   return default_section_type_flags (decl, name, reloc);
@@ -3239,12 +3357,21 @@
   if (strncasecmp (target_mcu, "msp430f6", 8) == 0)
     return cached_result = true;
 
+  find_devices_csv (target_mcu);
   int i;
 
-  /* FIXME: This array is alpha sorted - we could use a binary search.  */
-  for (i = ARRAY_SIZE (msp430_mcu_data); i--;)
-    if (strcasecmp (target_mcu, msp430_mcu_data[i].name) == 0)
-      return cached_result = msp430_mcu_data[i].hwmpy == 8;
+  if (extracted_mcu_data.name == NULL)
+    {
+      /* FIXME: This array is alpha sorted - we could use a binary search.  */
+      for (i = ARRAY_SIZE (hard_msp430_mcu_data); i--;)
+	if (strcasecmp (target_mcu, hard_msp430_mcu_data[i].name) == 0)
+	  {
+	    extracted_mcu_data = hard_msp430_mcu_data[i];
+	    return cached_result = extracted_mcu_data.hwmpy == 8;
+	  }
+    }
+  else
+    return cached_result = extracted_mcu_data.hwmpy == 8;
 
   return cached_result = false;
 }
@@ -3270,10 +3397,19 @@
 
   cached_match = target_mcu;
 
-  /* FIXME: This array is alpha sorted - we could use a binary search.  */
-  for (i = ARRAY_SIZE (msp430_mcu_data); i--;)
-    if (strcasecmp (target_mcu, msp430_mcu_data[i].name) == 0)
-      return cached_result = msp430_mcu_data[i].hwmpy == 4;
+  find_devices_csv (target_mcu);
+  if (extracted_mcu_data.name == NULL)
+    {
+      /* FIXME: This array is alpha sorted - we could use a binary search.  */
+      for (i = ARRAY_SIZE (hard_msp430_mcu_data); i--;)
+	if (strcasecmp (target_mcu, hard_msp430_mcu_data[i].name) == 0)
+	  {
+	    extracted_mcu_data = hard_msp430_mcu_data[i];
+	    return cached_result = extracted_mcu_data.hwmpy == 4;
+	  }
+    }
+  else
+    return cached_result = extracted_mcu_data.hwmpy == 4;
 
   return cached_result = false;
 }
@@ -3302,10 +3438,19 @@
 
   cached_match = target_mcu;
 
-  /* FIXME: This array is alpha sorted - we could use a binary search.  */
-  for (i = ARRAY_SIZE (msp430_mcu_data); i--;)
-    if (strcasecmp (target_mcu, msp430_mcu_data[i].name) == 0)
-      return cached_result = msp430_mcu_data[i].hwmpy == 0;
+  find_devices_csv (target_mcu);
+  if (extracted_mcu_data.name == NULL)
+    {
+      /* FIXME: This array is alpha sorted - we could use a binary search.  */
+      for (i = ARRAY_SIZE (hard_msp430_mcu_data); i--;)
+	if (strcasecmp (target_mcu, hard_msp430_mcu_data[i].name) == 0)
+	  {
+	    extracted_mcu_data = hard_msp430_mcu_data[i];
+	    return cached_result = extracted_mcu_data.hwmpy == 0;
+	  }
+    }
+  else
+    return cached_result = extracted_mcu_data.hwmpy == 0;
 
   /* If we do not recognise the MCU name, we assume that it does not support
      any kind of hardware multiply - this is the safest assumption to make.  */
@@ -3349,6 +3494,9 @@
 	}
     }
 
+  if (user_label_prefix[0] != 0)
+    fputs (user_label_prefix, file);
+
   fputs (name, file);
 }
 
@@ -3405,6 +3553,7 @@
       fprintf (file, "(%s)", reg_names [REGNO (XEXP (addr, 0))]);
       return;
 
+      /* TODO: If REG is the dst operand, syntax should be 0(REG).  */
     case REG:
       fprintf (file, "@");
       break;
@@ -3595,6 +3744,10 @@
     case 'X':
       /* This is used to turn, for example, an ADD opcode into an ADDX
 	 opcode when we're using 20-bit addresses.  */
+#if 0
+      if ((GET_MODE (op) != QImode || GET_CODE (op) != MEM)
+	  && (TARGET_LARGE || GET_MODE (op) == PSImode))
+#endif
       if (TARGET_LARGE || GET_MODE (op) == PSImode)
 	fprintf (file, "X");
       /* We don't care which operand we use, but we want 'X' in the MD
@@ -3772,6 +3925,18 @@
      right shift instruction to perform the rest of the shift.  */
   return "rrum.w\t#1, %0 { rpt\t%Z2 { rrax.w\t%0"; /* Six bytes.  */
 }
+
+void
+msp430_register_pre_includes (const char *sysroot ATTRIBUTE_UNUSED, const char *iprefix ATTRIBUTE_UNUSED, int stdinc ATTRIBUTE_UNUSED)
+{
+  char *include_dir;
+  if (check_env_var_for_devices (&include_dir))
+    return;
+  include_dir = msp430_dirname (include_dir);
+
+  include_dir = update_path (include_dir, "");
+  add_path (include_dir, SYSTEM, false, false);
+}
 
 struct gcc_target targetm = TARGET_INITIALIZER;
 
diff -ruN gcc-7.3.0/gcc/config/msp430/msp430-devices.c gcc-7.3.0-msp430/gcc/config/msp430/msp430-devices.c
--- gcc-7.3.0/gcc/config/msp430/msp430-devices.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/config/msp430/msp430-devices.c	2019-06-25 02:27:21.089931503 -0700
@@ -0,0 +1,266 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "target.h"
+#include "rtl.h"
+#include "tree.h"
+#include "gimple-expr.h"
+#include "df.h"
+#include "tm_p.h"
+#include "regs.h"
+#include "memmodel.h"
+#include "emit-rtl.h"
+#include "diagnostic-core.h"
+#include "fold-const.h"
+#include "stor-layout.h"
+#include "calls.h"
+#include "output.h"
+#include "explow.h"
+#include "expr.h"
+#include "langhooks.h"
+#include "builtins.h"
+#include "intl.h"
+#include "msp430-devices.h"
+
+struct t_msp430_mcu_data extracted_mcu_data;
+
+/* If modifying this string check uses of it in this file where characters at
+   the start are skipped.  */
+static const char * advice_string
+  = "Please obtain the latest version of the msp430-gcc-support-files archive "
+  "from: \n\"http://software-dl.ti.com/msp430/msp430_public_sw/mcu/msp430/MSPGCC/latest/index_FDS.html\"\n"
+  "and place the full path to the \"include\" directory containing devices.csv "
+  "on an include path specified with -I\n"
+  "Defaulting to the hard-coded device data...";
+
+/* Give function unique name in case some system headers e.g. libgen.h are included. */
+char *
+msp430_dirname (char *path)
+{
+  int i;
+  int len = strlen (path);
+  /* Start from the second last char in case the string ends with a dirsep.  */
+  for (i = len - 2; i >= 0; i--)
+    {
+      if (IS_DIR_SEPARATOR (path[i]))
+	{
+	  path[i] = '\0';
+	  return path;
+	}
+    }
+  return path;
+}
+
+/* This is to canonicalize the path. On windows we can have a mix of forward
+   and backslashes which means the path passed to -L is bogus.  */
+void
+msp430_canonicalize_path (char **path)
+{
+  char *t_path = *path;
+  unsigned int i;
+  for (i = 0; i < strlen (t_path); i++)
+    if (IS_DIR_SEPARATOR (t_path[i]))
+      t_path[i] = DIR_SEPARATOR;
+}
+
+void
+process_collect_gcc_into_devices_dir (char **devices_loc)
+{
+  char *t_devices_include_loc = *devices_loc;
+  /* Go up a directory to sysroot.  */
+  t_devices_include_loc = msp430_dirname (msp430_dirname (t_devices_include_loc));
+  char rest_of_devices_path[] = "/msp430-elf/include/devices/";
+  t_devices_include_loc = concat (t_devices_include_loc, rest_of_devices_path, NULL);
+  *devices_loc = t_devices_include_loc;
+}
+
+int
+check_env_var_for_devices (char **local_devices_csv_loc)
+{
+  const char dirsep[2] = { DIR_SEPARATOR, 0 };
+  FILE * devices_csv_file;
+  char *collect_gcc = getenv("COLLECT_GCC");
+  char *msp430_gcc_include_dir = getenv ("MSP430_GCC_INCLUDE_DIR");
+  char *vars_to_try[] = { msp430_gcc_include_dir, collect_gcc };
+
+  int i;
+  for (i = 0; i < 2; i++)
+    {
+      if (vars_to_try[i] == NULL)
+	continue;
+      char *t_devices_loc = ASTRDUP (vars_to_try[i]);
+      devices_csv_file = NULL;
+      /* msp430_gcc_include_dir */
+      if (i == 0)
+	{
+	  if (!IS_DIR_SEPARATOR (t_devices_loc[strlen (t_devices_loc) - 1]))
+	    t_devices_loc = concat (t_devices_loc, dirsep, NULL);
+	  t_devices_loc = concat (t_devices_loc, "devices.csv", NULL);
+	}
+      /* collect_gcc */
+      else if (i == 1)
+	{
+	  process_collect_gcc_into_devices_dir (&t_devices_loc);
+	  t_devices_loc = concat (t_devices_loc, "devices.csv", NULL);
+	}
+      devices_csv_file = fopen (t_devices_loc,  "r");
+      if (devices_csv_file != NULL)
+	{
+	  fclose (devices_csv_file);
+	  *local_devices_csv_loc = t_devices_loc;
+	  msp430_canonicalize_path (local_devices_csv_loc);
+	  return 0;
+	}
+    }
+  return 1;
+}
+
+void
+find_devices_csv (const char * mcu_name)
+{
+  /* This function only needs to be executed once, but it can be first called
+     from a number of different locations.  */
+  char *local_devices_csv_loc = NULL;
+  static int executed = 0;
+  if (executed == 1)
+    return;
+  executed = 1;
+  if (devices_csv_loc)
+    parse_devices_csv (devices_csv_loc, mcu_name);
+  else if (!check_env_var_for_devices (&local_devices_csv_loc))
+    parse_devices_csv (local_devices_csv_loc, mcu_name);
+  else if (!TARGET_DISABLE_DEVICE_WARN)
+    warning (0, "devices.csv not found on any include paths.\n%s",
+	     advice_string);
+}
+
+void
+parse_devices_csv (const char * real_devices_csv_loc, const char * mcu_name)
+{
+  FILE * devices_csv = fopen (real_devices_csv_loc, "r");
+  /* devices_csv should never be NULL at this stage.  */
+  if (devices_csv == NULL)
+    {
+      if (!TARGET_DISABLE_DEVICE_WARN)
+	warning (0, "Unexpected error opening devices.csv\n");
+      return;
+    }
+  /* Some devices have a large number of errata, which means that MPY_TYPE
+     isn't found until the ~100th character in the line.  line_buf_siz set to
+     200 to be safe and hopefully future proof.  */
+  const int line_buf_siz = 200;
+  char line[line_buf_siz];
+  const char comma[2] = ",";
+  char * res;
+  int found_headings = 0;
+  int cpu_type = -1;
+  int mpy_type = -1;
+  int cpu_type_column = -1;
+  int mpy_type_column = -1;
+  const char * device_name_heading = "# Device Name";
+  const char * cpu_type_heading = "CPU_TYPE";
+  const char * mpy_type_heading = "MPY_TYPE";
+  while (1)
+    {
+      res = fgets (line, line_buf_siz, devices_csv);
+      if (res == NULL)
+	{
+	  if (!TARGET_DISABLE_DEVICE_WARN)
+	    warning (0, "Device %s not found in devices.csv.  Check the device "
+		     "name is correct or\n%s", mcu_name, advice_string+6);
+	  goto end;
+	}
+      else if (strncmp (line, device_name_heading,
+			strlen (device_name_heading)) == 0)
+	{
+	  found_headings = 1;
+	  int curr_column = 0;
+	  char * heading = strtok (line, comma);
+	  while (heading != NULL)
+	    {
+	      if (strncmp (heading, cpu_type_heading,
+			   strlen (cpu_type_heading)) == 0)
+		  cpu_type_column = curr_column;
+	      else if (strncmp (heading, mpy_type_heading,
+			   strlen (mpy_type_heading)) == 0)
+		  mpy_type_column = curr_column;
+	      heading = strtok (NULL, comma);
+	      curr_column++;
+	    }
+	  if (curr_column < cpu_type_column || curr_column < mpy_type_column)
+	    {
+	      if (!TARGET_DISABLE_DEVICE_WARN)
+		warning (0, "Couldn't read the required data from devices.csv "
+			 "into a buffer.  There may be too many CPU_Bugs in "
+			 "the row for %s.  Try removing these so CPU_TYPE and "
+			 "MPY_TYPE fit in the buffer.", target_mcu);
+	      goto end;
+	    }
+	  else if (cpu_type_column == -1 || mpy_type_column == -1)
+	    {
+	      if (!TARGET_DISABLE_DEVICE_WARN)
+		warning (0, "CPU_TYPE and/or MPY_TYPE headings not present "
+			 "in devices.csv, or format not as expected.\n%s",
+			 advice_string);
+	      goto end;
+	    }
+	}
+      else if (strncasecmp (line, mcu_name, strlen (mcu_name)) == 0)
+	{
+	  if (found_headings == 0)
+	    {
+	      if (!TARGET_DISABLE_DEVICE_WARN)
+		warning (0, "Column headings format of devices.csv not as "
+			 "expected.\n%s", advice_string);
+	      goto end;
+	    }
+	  extracted_mcu_data.name = mcu_name;
+	  char * val = strtok (line, comma);
+	  int final_col_num = (cpu_type_column < mpy_type_column)
+	    ? mpy_type_column : cpu_type_column;
+	  int curr_col;
+	  for (curr_col = 0; curr_col < final_col_num + 1; curr_col++)
+	    {
+	      if (curr_col == cpu_type_column)
+		{
+		  cpu_type = atoi (val);
+		  if (strlen (val) != 1 || (cpu_type == 0 && val[0] != '0')
+		      || cpu_type > 2 || cpu_type < 0)
+		    {
+		      if (!TARGET_DISABLE_DEVICE_WARN)
+			warning (0, "Invalid CPU_TYPE read from devices.csv.\n"
+				 "%s", advice_string);
+		      goto end;
+		    }
+		  extracted_mcu_data.revision = cpu_type;
+		}
+	      else if (curr_col == mpy_type_column)
+		{
+		  mpy_type = atoi (val);
+		  if ((mpy_type == 0 && val[0] != '0')
+		      || !(mpy_type == 0
+			   || mpy_type == 1
+			   || mpy_type == 2
+			   || mpy_type == 4
+			   || mpy_type == 8))
+		    {
+		      if (!TARGET_DISABLE_DEVICE_WARN)
+			warning (0, "Invalid MPY_TYPE read from devices.csv.\n"
+				 "%s", advice_string);
+		      goto end;
+		    }
+		  extracted_mcu_data.hwmpy = mpy_type;
+		}
+	      val = strtok (NULL, comma);
+	    }
+	  if (cpu_type == -1 || mpy_type == -1)
+	    if (!TARGET_DISABLE_DEVICE_WARN)
+	      warning (0, "Unknown error reading CPU_TYPE and/or MPY_TYPE from "
+		       "devices.csv.\n%s\n", advice_string);
+	  goto end;
+	}
+    }
+ end:
+  fclose (devices_csv);
+}
diff -ruN gcc-7.3.0/gcc/config/msp430/msp430-devices.h gcc-7.3.0-msp430/gcc/config/msp430/msp430-devices.h
--- gcc-7.3.0/gcc/config/msp430/msp430-devices.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/config/msp430/msp430-devices.h	2019-06-25 02:27:21.089931503 -0700
@@ -0,0 +1,17 @@
+struct t_msp430_mcu_data
+{
+  const char * name;
+  unsigned int revision; /* 0=> MSP430, 1=>MSP430X, 2=> MSP430Xv2.  */
+  unsigned int hwmpy;    /* 0=>none, 1=>16-bit, 2=>16-bit w/sign extend, 4=>32-bit, 8=> 32-bit (5xx).  */
+};
+
+extern struct t_msp430_mcu_data extracted_mcu_data;
+
+void find_devices_csv (const char * mcu_name);
+void parse_devices_csv (const char * real_devices_csv_loc,
+			const char * mcu_name);
+
+void msp430_canonicalize_path (char **path);
+void process_collect_gcc_into_devices_dir (char **devices_loc);
+int check_env_var_for_devices (char **local_devices_csv_loc);
+char *msp430_dirname (char *path);
diff -ruN gcc-7.3.0/gcc/config/msp430/msp430.h gcc-7.3.0-msp430/gcc/config/msp430/msp430.h
--- gcc-7.3.0/gcc/config/msp430/msp430.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/msp430/msp430.h	2019-06-25 02:27:21.089931503 -0700
@@ -44,6 +44,17 @@
     }                                           \
   while (0)
 
+extern const char * msp430_select_hwmult_lib (int, const char **);
+extern const char * msp430_select_cpu (int, const char **);
+extern const char * msp430_check_path_for_devices (int, const char **);
+extern const char * msp430_get_linker_devices_include_path (int, const char **);
+
+# define EXTRA_SPEC_FUNCTIONS				\
+  { "msp430_hwmult_lib", msp430_select_hwmult_lib }, \
+  { "msp430_select_cpu", msp430_select_cpu }, \
+  { "msp430_check_path_for_devices", msp430_check_path_for_devices }, \
+  { "msp430_get_linker_devices_include_path", msp430_get_linker_devices_include_path },
+
 #undef  STARTFILE_SPEC
 #define STARTFILE_SPEC "%{pg:gcrt0.o%s}%{!pg:%{minrt:crt0-minrt.o%s}%{!minrt:crt0.o%s}} %{!minrt:crtbegin.o%s}"
 
@@ -52,22 +63,27 @@
 #define ENDFILE_SPEC "%{!minrt:crtend.o%s} %{minrt:crtn-minrt.o%s}%{!minrt:crtn.o%s} -lgcc"
 
 #define ASM_SPEC "-mP " /* Enable polymorphic instructions.  */ \
-  "%{mcpu=*:-mcpu=%*}%{!mcpu=*:%{mmcu=*:-mmcu=%*}} " /* Pass the CPU type on to the assembler.  */ \
+  "%{mcpu=*:-mcpu=%*} " /* Pass the CPU type on to the assembler.  */ \
   "%{mrelax=-mQ} " /* Pass the relax option on to the assembler.  */ \
   "%{mlarge:-ml} " /* Tell the assembler if we are building for the LARGE pointer model.  */ \
   "%{!msim:-md} %{msim:%{mlarge:-md}} " /* Copy data from ROM to RAM if necessary.  */ \
   "%{msilicon-errata=*:-msilicon-errata=%*} " /* Pass on -msilicon-errata.  */ \
   "%{msilicon-errata-warn=*:-msilicon-errata-warn=%*} " /* Pass on -msilicon-errata-warn.  */ \
-  "%{ffunction-sections:-gdwarf-sections} " /* If function sections are being created then create DWARF line number sections as well.  */
+  "%{ffunction-sections:-gdwarf-sections} " /* If function sections are being created then create DWARF line number sections as well.  */ \
+  "%{mdata-region=*:-mdata-region=%*} " /* Pass on -mdata-region.  */
 
 /* Enable linker section garbage collection by default, unless we
    are creating a relocatable binary (gc does not work) or debugging
    is enabled  (the GDB testsuite relies upon unused entities not being deleted).  */
-#define LINK_SPEC "%{mrelax:--relax} %{mlarge:%{!r:%{!g:--gc-sections}}}"
-
-extern const char * msp430_select_hwmult_lib (int, const char **);
-# define EXTRA_SPEC_FUNCTIONS				\
-  { "msp430_hwmult_lib", msp430_select_hwmult_lib },
+#define LINK_SPEC "%{mrelax:--relax} %{mlarge:%{!r:%{!g:--gc-sections}}} " \
+  "%{mcode-region=*:--code-region=%*} %{mdata-region=*:--data-region=%*}" \
+  "%:msp430_get_linker_devices_include_path(%{L*:%*})"
+
+/* Look for devices.csv in the folders specified by include paths.  */
+#define DRIVER_SELF_SPECS	      \
+  " %{I*:%:msp430_check_path_for_devices(%{I*:%*})}"       \
+  " %{L*:%:msp430_check_path_for_devices(%{L*:%*})}"       \
+  " %{mmcu=*:%:msp430_select_cpu(%{mmcu=*:%*})}"
 
 /* Specify the libraries to include on the linker command line.
 
@@ -424,6 +440,14 @@
 
 #define ACCUMULATE_OUTGOING_ARGS 1
 
+/* FIXME define BRANCH_COST and maybe get rid of this to allow the definition
+   in fold-const.c to takeover.  */
+/* Don't know what this does so disable since it doesnt have any positive
+   (or apparently negative) effect.  */
+#if 0
+#define LOGICAL_OP_NON_SHORT_CIRCUIT 0
+#endif
+
 #undef  ASM_DECLARE_FUNCTION_NAME
 #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \
   msp430_start_function ((FILE), (NAME), (DECL))
@@ -433,5 +457,8 @@
 #undef  USE_SELECT_SECTION_FOR_FUNCTIONS
 #define USE_SELECT_SECTION_FOR_FUNCTIONS 1
 
+void msp430_register_pre_includes (const char *sysroot, const char *iprefix, int stdinc);
+#define TARGET_EXTRA_PRE_INCLUDES msp430_register_pre_includes 
+
 #define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN)	\
   msp430_output_aligned_decl_common ((FILE), (DECL), (NAME), (SIZE), (ALIGN))
diff -ruN gcc-7.3.0/gcc/config/msp430/msp430.md gcc-7.3.0-msp430/gcc/config/msp430/msp430.md
--- gcc-7.3.0/gcc/config/msp430/msp430.md	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/msp430/msp430.md	2019-06-25 02:27:21.089931503 -0700
@@ -619,15 +619,15 @@
 
 (define_insn "zero_extendqisi2"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=r")
-	(zero_extend:SI (subreg:HI (match_operand:QI 1 "nonimmediate_operand" "rm") 0)))]
-  "msp430x"
-  "MOV.B\t%1,%L0 { CLR\t%H0"
+	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "rm")))]
+  ""
+  "MOV.B\t%1,%L0 { AND\t#0xff,%L0 { CLR\t%H0"
 )
 
 (define_insn "zero_extendhisi2"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=rm,r")
 	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "0,r")))]
-  "msp430x"
+  ""
   "@
   MOV.W\t#0,%H0
   MOV.W\t%1,%L0 { MOV.W\t#0,%H0"
diff -ruN gcc-7.3.0/gcc/config/msp430/msp430.opt gcc-7.3.0-msp430/gcc/config/msp430/msp430.opt
--- gcc-7.3.0/gcc/config/msp430/msp430.opt	2017-01-09 13:48:33.107036000 -0800
+++ gcc-7.3.0-msp430/gcc/config/msp430/msp430.opt	2019-06-25 02:27:21.089931503 -0700
@@ -92,3 +92,12 @@
 msilicon-errata-warn=
 Target Joined RejectNegative Report ToLower
 Passes on a request to the assembler to warn about various silicon errata.
+
+mdevices-csv-loc=
+Target Joined Var(devices_csv_loc) RejectNegative Report
+The path to devices.csv.  The GCC driver can normally locate devices.csv itself
+and pass this option to the compiler, so the user shouldn't need to pass this.
+
+mdisable-device-warnings
+Target RejectNegative Mask(DISABLE_DEVICE_WARN) Report
+Suppress warnings regarding devices.csv not being found on an include path.
diff -ruN gcc-7.3.0/gcc/config/msp430/t-msp430 gcc-7.3.0-msp430/gcc/config/msp430/t-msp430
--- gcc-7.3.0/gcc/config/msp430/t-msp430	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/msp430/t-msp430	2019-06-25 02:27:21.089931503 -0700
@@ -22,6 +22,10 @@
   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)
 	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
 
+msp430-devices.o: $(srcdir)/config/msp430/msp430-devices.c \
+  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)
+	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<
+
 # Enable multilibs:
 
 MULTILIB_OPTIONS    = mcpu=msp430 mlarge 
@@ -30,235 +34,8 @@
 # Match -mcpu=430
 MULTILIB_MATCHES    = mcpu?msp430=mcpu?430
 
-# Match the known 430 ISA mcu names.
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c091
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c092
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c111
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c1111
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c112
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c1121
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c1331
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c1351
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c311s
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c312
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c313
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c314
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c315
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c323
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c325
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c412
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c413
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430e112
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430e313
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430e315
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430e325
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f110
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1101
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1101a
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1111
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1111a
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f112
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1121
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1121a
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1122
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1132
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f122
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1222
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f123
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1232
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f133
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f135
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f155
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f156
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f157
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2001
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2002
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2003
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2011
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2012
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2013
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2101
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2111
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2112
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2121
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2122
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2131
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2132
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2232
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2234
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2252
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2254
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2272
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2274
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f412
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f413
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4132
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f415
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4152
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f417
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4250
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4260
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4270
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f435
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4351
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f436
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4361
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f437
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4371
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f438
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f439
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f477
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f478
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f479
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fe423
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fe4232
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fe423a
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fe4242
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fe425
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fe4252
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fe425a
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fe427
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fe4272
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fe427a
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fg4250
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fg4260
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fg4270
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fg437
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fg438
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fg439
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fg477
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fg478
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fg479
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fw423
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fw425
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fw427
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fw428
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430fw429
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2001
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2101
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2102
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2111
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2112
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2113
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2121
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2131
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2132
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2152
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2153
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2201
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2202
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2203
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2210
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2211
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2212
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2213
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2221
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2230
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2231
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2232
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2233
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2252
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2253
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2302
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2303
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2312
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2313
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2332
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2333
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2352
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2353
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2402
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2403
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2412
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2413
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2432
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2433
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2444
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2452
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2453
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2513
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2533
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2544
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2553
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2744
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2755
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2855
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430g2955
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430l092
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430p112
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430p313
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430p315
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430p315s
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430p325
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430tch5e
-MULTILIB_MATCHES += mcpu?msp430=mmcu?rf430frl152h
-MULTILIB_MATCHES += mcpu?msp430=mmcu?rf430frl152h_rom
-MULTILIB_MATCHES += mcpu?msp430=mmcu?rf430frl153h
-MULTILIB_MATCHES += mcpu?msp430=mmcu?rf430frl153h_rom
-MULTILIB_MATCHES += mcpu?msp430=mmcu?rf430frl154h
-MULTILIB_MATCHES += mcpu?msp430=mmcu?rf430frl154h_rom
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c336
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430c337
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430e337
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f147
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1471
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f148
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1481
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f149
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1491
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1610
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1611
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f1612
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f167
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f168
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f169
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f423
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f423a
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f425
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f425a
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f427
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f427a
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f447
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f448
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4481
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f449
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4491
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430p337
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430afe221
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430afe222
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430afe223
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430afe231
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430afe232
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430afe233
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430afe251
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430afe252
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430afe253
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f233
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2330
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f235
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2350
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2370
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2410
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f247
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2471
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f248
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2481
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f249
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f2491
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430i2020
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430i2021
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430i2030
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430i2031
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430i2040
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430i2041
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430i2xxgeneric
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4783
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4784
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4793
-MULTILIB_MATCHES += mcpu?msp430=mmcu?msp430f4794
-
-# Add additional MCU matches like this:
-# MULTILIB_MATCHES += mcpu?msp430x=mmcu?xxxxxxxxxx
+# Multilibs for specific cpu options are chosen by making the GCC driver parse
+# the -mmcu option and add the correct -mcpu option for the chosen device
 
 MULTILIB_EXCEPTIONS = mcpu=msp430/mlarge
 
diff -ruN gcc-7.3.0/gcc/config/nvptx/nvptx.c gcc-7.3.0-msp430/gcc/config/nvptx/nvptx.c
--- gcc-7.3.0/gcc/config/nvptx/nvptx.c	2017-07-18 06:06:07.105447000 -0700
+++ gcc-7.3.0-msp430/gcc/config/nvptx/nvptx.c	2019-06-25 02:27:21.089931503 -0700
@@ -1875,9 +1875,15 @@
   
   if (sym)
     {
-      fprintf (asm_out_file, "generic(");
+      bool function = (SYMBOL_REF_DECL (sym)
+		       && (TREE_CODE (SYMBOL_REF_DECL (sym)) == FUNCTION_DECL));
+      if (!function)
+	fprintf (asm_out_file, "generic(");
       output_address (VOIDmode, sym);
-      fprintf (asm_out_file, val ? ") + " : ")");
+      if (!function)
+	fprintf (asm_out_file, ")");
+      if (val)
+	fprintf (asm_out_file, " + ");
     }
 
   if (!sym || val)
@@ -2002,6 +2008,9 @@
 nvptx_assemble_decl_begin (FILE *file, const char *name, const char *section,
 			   const_tree type, HOST_WIDE_INT size, unsigned align)
 {
+  bool atype = (TREE_CODE (type) == ARRAY_TYPE)
+    && (TYPE_DOMAIN (type) == NULL_TREE);
+
   while (TREE_CODE (type) == ARRAY_TYPE)
     type = TREE_TYPE (type);
 
@@ -2041,6 +2050,8 @@
     /* We make everything an array, to simplify any initialization
        emission.  */
     fprintf (file, "[" HOST_WIDE_INT_PRINT_DEC "]", init_frag.remaining);
+  else if (atype)
+    fprintf (file, "[]");
 }
 
 /* Called when the initializer for a decl has been completely output through
diff -ruN gcc-7.3.0/gcc/config/pa/pa32-linux.h gcc-7.3.0-msp430/gcc/config/pa/pa32-linux.h
--- gcc-7.3.0/gcc/config/pa/pa32-linux.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/pa/pa32-linux.h	2019-06-25 02:27:21.089931503 -0700
@@ -62,3 +62,12 @@
 
 #undef  WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+/* Place jump tables in the text section except when generating non-PIC
+   code.  When generating non-PIC code, the relocations needed to load the
+   address of the jump table result in a text label in the final executable
+   if the jump table is placed in the text section.  This breaks the unwind
+   data for the function.  Thus, the jump table needs to be placed in
+   rodata when generating non-PIC code.  */
+#undef JUMP_TABLES_IN_TEXT_SECTION
+#define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)
diff -ruN gcc-7.3.0/gcc/config/pa/pa64-hpux.h gcc-7.3.0-msp430/gcc/config/pa/pa64-hpux.h
--- gcc-7.3.0/gcc/config/pa/pa64-hpux.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/pa/pa64-hpux.h	2019-06-25 02:27:21.089931503 -0700
@@ -245,8 +245,18 @@
 
 /* We need to use the HP style for internal labels.  */
 #undef ASM_GENERATE_INTERNAL_LABEL
-#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)	\
-  sprintf (LABEL, "*%c$%s%04ld", (PREFIX)[0], (PREFIX) + 1, (long)(NUM))
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)		\
+  do								\
+    {								\
+      char *__p;						\
+      (LABEL)[0] = '*';						\
+      (LABEL)[1] = (PREFIX)[0];					\
+      (LABEL)[2] = '$';						\
+      __p = stpcpy (&(LABEL)[3], &(PREFIX)[1]);			\
+      sprint_ul (__p, (unsigned long) (NUM));			\
+    }								\
+  while (0)
+
 
 #else /* USING_ELFOS_H */
 
diff -ruN gcc-7.3.0/gcc/config/pa/pa.c gcc-7.3.0-msp430/gcc/config/pa/pa.c
--- gcc-7.3.0/gcc/config/pa/pa.c	2017-12-17 09:02:10.304809000 -0800
+++ gcc-7.3.0-msp430/gcc/config/pa/pa.c	2019-06-25 02:27:21.089931503 -0700
@@ -1725,9 +1725,7 @@
 		}
 	      else
 		emit_move_insn (scratch_reg, XEXP (op1, 0));
-	      emit_insn (gen_rtx_SET (operand0,
-				  replace_equiv_address (op1, scratch_reg)));
-	      return 1;
+	      op1 = replace_equiv_address (op1, scratch_reg);
 	    }
 	}
       else if ((!INT14_OK_STRICT && symbolic_memory_operand (op1, VOIDmode))
@@ -1737,10 +1735,10 @@
 	  /* Load memory address into SCRATCH_REG.  */
 	  scratch_reg = force_mode (word_mode, scratch_reg);
 	  emit_move_insn (scratch_reg, XEXP (op1, 0));
-	  emit_insn (gen_rtx_SET (operand0,
-				  replace_equiv_address (op1, scratch_reg)));
-	  return 1;
+	  op1 = replace_equiv_address (op1, scratch_reg);
 	}
+      emit_insn (gen_rtx_SET (operand0, op1));
+      return 1;
     }
   else if (scratch_reg
 	   && FP_REG_P (operand1)
@@ -1778,9 +1776,7 @@
 		}
 	      else
 		emit_move_insn (scratch_reg, XEXP (op0, 0));
-	      emit_insn (gen_rtx_SET (replace_equiv_address (op0, scratch_reg),
-				      operand1));
-	      return 1;
+	      op0 = replace_equiv_address (op0, scratch_reg);
 	    }
 	}
       else if ((!INT14_OK_STRICT && symbolic_memory_operand (op0, VOIDmode))
@@ -1790,10 +1786,10 @@
 	  /* Load memory address into SCRATCH_REG.  */
 	  scratch_reg = force_mode (word_mode, scratch_reg);
 	  emit_move_insn (scratch_reg, XEXP (op0, 0));
-	  emit_insn (gen_rtx_SET (replace_equiv_address (op0, scratch_reg),
-				  operand1));
-	  return 1;
+	  op0 = replace_equiv_address (op0, scratch_reg);
 	}
+      emit_insn (gen_rtx_SET (op0, operand1));
+      return 1;
     }
   /* Handle secondary reloads for loads of FP registers from constant
      expressions by forcing the constant into memory.  For the most part,
@@ -4562,13 +4558,17 @@
      lcla2 and load_offset_label_address insn patterns.  */
   rtx reg = gen_reg_rtx (SImode);
   rtx_code_label *label_rtx = gen_label_rtx ();
-  rtx mcount = gen_rtx_MEM (Pmode, gen_rtx_SYMBOL_REF (Pmode, "_mcount"));
   int reg_parm_stack_space = REG_PARM_STACK_SPACE (NULL_TREE);
-  rtx arg_bytes, begin_label_rtx;
+  rtx arg_bytes, begin_label_rtx, mcount, sym;
   rtx_insn *call_insn;
   char begin_label_name[16];
   bool use_mcount_pcrel_call;
 
+  /* Set up call destination.  */
+  sym = gen_rtx_SYMBOL_REF (Pmode, "_mcount");
+  pa_encode_label (sym);
+  mcount = gen_rtx_MEM (Pmode, sym);
+
   /* If we can reach _mcount with a pc-relative call, we can optimize
      loading the address of the current function.  This requires linker
      long branch stub support.  */
@@ -10645,6 +10645,8 @@
 {
   int idx, vlen = XVECLEN (body, 0);
 
+  if (!TARGET_SOM)
+    fputs ("\t.align 4\n", asm_out_file);
   targetm.asm_out.internal_label (asm_out_file, "L", CODE_LABEL_NUMBER (lab));
   if (TARGET_GAS)
     fputs ("\t.begin_brtab\n", asm_out_file);
diff -ruN gcc-7.3.0/gcc/config/pa/pa.h gcc-7.3.0-msp430/gcc/config/pa/pa.h
--- gcc-7.3.0/gcc/config/pa/pa.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/pa/pa.h	2019-06-25 02:27:21.089931503 -0700
@@ -1153,8 +1153,18 @@
    PREFIX is the class of label and NUM is the number within the class.
    This is suitable for output with `assemble_name'.  */
 
-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)	\
-  sprintf (LABEL, "*%c$%s%04ld", (PREFIX)[0], (PREFIX) + 1, (long)(NUM))
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)		\
+  do								\
+    {								\
+      char *__p;						\
+      (LABEL)[0] = '*';						\
+      (LABEL)[1] = (PREFIX)[0];					\
+      (LABEL)[2] = '$';						\
+      __p = stpcpy (&(LABEL)[3], &(PREFIX)[1]);			\
+      sprint_ul (__p, (unsigned long) (NUM));			\
+    }								\
+  while (0)
+
 
 /* Output the definition of a compiler-generated label named NAME.  */
 
@@ -1172,35 +1182,37 @@
 #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \
   pa_output_ascii ((FILE), (P), (SIZE))
 
-/* Jump tables are always placed in the text section.  Technically, it
-   is possible to put them in the readonly data section.  This has the
-   benefit of getting the table out of .text and reducing branch lengths
-   as a result.
+/* Jump tables are always placed in the text section.  We have to do
+   this for the HP-UX SOM target as we can't switch sections in the
+   middle of a function.
+
+   On ELF targets, it is possible to put them in the readonly-data section.
+   This would get the table out of .text and reduce branch lengths.
 
-   The downside is that an additional insn (addil) is needed to access
+   A downside is that an additional insn (addil) is needed to access
    the table when generating PIC code.  The address difference table
-   also has to use 32-bit pc-relative relocations.  Currently, GAS does
-   not support these relocations, although it is easily modified to do
-   this operation.
+   also has to use 32-bit pc-relative relocations.
 
    The table entries need to look like "$L1+(.+8-$L0)-$PIC_pcrel$0"
    when using ELF GAS.  A simple difference can be used when using
-   SOM GAS or the HP assembler.  The final downside is GDB complains
-   about the nesting of the label for the table when debugging.  */
+   the HP assembler.
+
+   The final downside is GDB complains about the nesting of the label
+   for the table.  */
 
 #define JUMP_TABLES_IN_TEXT_SECTION 1
 
 /* This is how to output an element of a case-vector that is absolute.  */
 
 #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \
-  fprintf (FILE, "\t.word L$%04d\n", VALUE)
+  fprintf (FILE, "\t.word L$%d\n", VALUE)
 
 /* This is how to output an element of a case-vector that is relative. 
    Since we always place jump tables in the text section, the difference
    is absolute and requires no relocation.  */
 
 #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \
-  fprintf (FILE, "\t.word L$%04d-L$%04d\n", VALUE, REL)
+  fprintf (FILE, "\t.word L$%d-L$%d\n", VALUE, REL)
 
 /* This is how to output an absolute case-vector.  */
 
diff -ruN gcc-7.3.0/gcc/config/pa/pa.md gcc-7.3.0-msp430/gcc/config/pa/pa.md
--- gcc-7.3.0/gcc/config/pa/pa.md	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/pa/pa.md	2019-06-25 02:27:21.089931503 -0700
@@ -84,6 +84,7 @@
    UNSPEC_TLSGD_PIC
    UNSPEC_TLSLDM_PIC
    UNSPEC_TLSIE_PIC
+   UNSPEC_MEMORY_BARRIER
   ])
 
 ;; UNSPEC_VOLATILE:
@@ -2536,24 +2537,40 @@
 
   xoperands[0] = operands[0];
   xoperands[1] = operands[1];
-  xoperands[2] = gen_label_rtx ();
 
-  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",
-				     CODE_LABEL_NUMBER (xoperands[2]));
-  output_asm_insn (\"mfia %0\", xoperands);
-
-  /* If we're trying to load the address of a label that happens to be
-     close, then we can use a shorter sequence.  */
   if (GET_CODE (operands[1]) == LABEL_REF
-      && !LABEL_REF_NONLOCAL_P (operands[1])
-      && INSN_ADDRESSES_SET_P ()
-      && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))
-	        - INSN_ADDRESSES (INSN_UID (insn))) < 8100)
-    output_asm_insn (\"ldo %1-%2(%0),%0\", xoperands);
+      && !LABEL_REF_NONLOCAL_P (operands[1]))
+    {
+      xoperands[2] = gen_label_rtx ();
+      (*targetm.asm_out.internal_label) (asm_out_file, \"L\",
+					 CODE_LABEL_NUMBER (xoperands[2]));
+      output_asm_insn (\"mfia %0\", xoperands);
+
+      /* If we're trying to load the address of a label that happens to be
+	 close, then we can use a shorter sequence.  */
+      if (INSN_ADDRESSES_SET_P ()
+	  && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))
+		  - INSN_ADDRESSES (INSN_UID (insn))) < 8100)
+	output_asm_insn (\"ldo %1-%2(%0),%0\", xoperands);
+      else
+	{
+	  output_asm_insn (\"addil L%%%1-%2,%0\", xoperands);
+	  output_asm_insn (\"ldo R%%%1-%2(%0),%0\", xoperands);
+	}
+    }
   else
     {
-      output_asm_insn (\"addil L%%%1-%2,%0\", xoperands);
-      output_asm_insn (\"ldo R%%%1-%2(%0),%0\", xoperands);
+      /* Load using linkage table.  */
+      if (TARGET_64BIT)
+	{
+	  output_asm_insn (\"addil LT%%%1,%%r27\", xoperands);
+	  output_asm_insn (\"ldd RT%%%1(%0),%0\", xoperands);
+	}
+      else
+	{
+	  output_asm_insn (\"addil LT%%%1,%%r19\", xoperands);
+	  output_asm_insn (\"ldw RT%%%1(%0),%0\", xoperands);
+	}
     }
   return \"\";
 }"
@@ -2570,25 +2587,33 @@
 
   xoperands[0] = operands[0];
   xoperands[1] = operands[1];
-  xoperands[2] = gen_label_rtx ();
-
-  output_asm_insn (\"bl .+8,%0\", xoperands);
-  output_asm_insn (\"depi 0,31,2,%0\", xoperands);
-  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",
-				     CODE_LABEL_NUMBER (xoperands[2]));
 
-  /* If we're trying to load the address of a label that happens to be
-     close, then we can use a shorter sequence.  */
   if (GET_CODE (operands[1]) == LABEL_REF
-      && !LABEL_REF_NONLOCAL_P (operands[1])
-      && INSN_ADDRESSES_SET_P ()
-      && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))
-	        - INSN_ADDRESSES (INSN_UID (insn))) < 8100)
-    output_asm_insn (\"ldo %1-%2(%0),%0\", xoperands);
+      && !LABEL_REF_NONLOCAL_P (operands[1]))
+    {
+      xoperands[2] = gen_label_rtx ();
+      output_asm_insn (\"bl .+8,%0\", xoperands);
+      output_asm_insn (\"depi 0,31,2,%0\", xoperands);
+      (*targetm.asm_out.internal_label) (asm_out_file, \"L\",
+					 CODE_LABEL_NUMBER (xoperands[2]));
+
+      /* If we're trying to load the address of a label that happens to be
+	 close, then we can use a shorter sequence.  */
+      if (INSN_ADDRESSES_SET_P ()
+	  && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))
+		  - INSN_ADDRESSES (INSN_UID (insn))) < 8100)
+	output_asm_insn (\"ldo %1-%2(%0),%0\", xoperands);
+      else
+	{
+	  output_asm_insn (\"addil L%%%1-%2,%0\", xoperands);
+	  output_asm_insn (\"ldo R%%%1-%2(%0),%0\", xoperands);
+	}
+    }
   else
     {
-      output_asm_insn (\"addil L%%%1-%2,%0\", xoperands);
-      output_asm_insn (\"ldo R%%%1-%2(%0),%0\", xoperands);
+      /* Load using linkage table.  */
+      output_asm_insn (\"addil LT%%%1,%%r19\", xoperands);
+      output_asm_insn (\"ldw RT%%%1(%0),%0\", xoperands);
     }
   return \"\";
 }"
@@ -9931,84 +9956,8 @@
 ;; doubleword loads and stores are not guaranteed to be atomic
 ;; when referencing the I/O address space.
 
-;; The kernel cmpxchg operation on linux is not atomic with respect to
-;; memory stores on SMP machines, so we must do stores using a cmpxchg
-;; operation.
-
 ;; These patterns are at the bottom so the non atomic versions are preferred.
 
-;; Implement atomic QImode store using exchange.
-
-(define_expand "atomic_storeqi"
-  [(match_operand:QI 0 "memory_operand")                ;; memory
-   (match_operand:QI 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-  FAIL;
-})
-
-;; Implement atomic HImode stores using exchange.
-
-(define_expand "atomic_storehi"
-  [(match_operand:HI 0 "memory_operand")                ;; memory
-   (match_operand:HI 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-  FAIL;
-})
-
-;; Implement atomic SImode store using exchange.
-
-(define_expand "atomic_storesi"
-  [(match_operand:SI 0 "memory_operand")                ;; memory
-   (match_operand:SI 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-  FAIL;
-})
-
-;; Implement atomic SFmode store using exchange.
-
-(define_expand "atomic_storesf"
-  [(match_operand:SF 0 "memory_operand")                ;; memory
-   (match_operand:SF 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-  FAIL;
-})
-
 ;; Implement atomic DImode load using 64-bit floating point load.
 
 (define_expand "atomic_loaddi"
@@ -10024,47 +9973,39 @@
 
   model = memmodel_from_int (INTVAL (operands[2]));
   operands[1] = force_reg (SImode, XEXP (operands[1], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));
   if (is_mm_seq_cst (model))
     expand_mem_thread_fence (model);
+  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));
+  expand_mem_thread_fence (model);
   DONE;
 })
 
 (define_insn "atomic_loaddi_1"
-  [(set (match_operand:DI 0 "register_operand" "=f,r")
-        (mem:DI (match_operand:SI 1 "register_operand" "r,r")))
-   (clobber (match_scratch:DI 2 "=X,f"))]
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (mem:DI (match_operand:SI 1 "register_operand" "r")))
+   (clobber (match_scratch:DI 2 "=f"))]
   "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
-  "@
-   {fldds|fldd} 0(%1),%0
-   {fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
+  "{fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
+  [(set_attr "type" "move")
+   (set_attr "length" "16")])
 
 ;; Implement atomic DImode store.
 
 (define_expand "atomic_storedi"
   [(match_operand:DI 0 "memory_operand")                ;; memory
-   (match_operand:DI 1 "register_operand")              ;; val out
+   (match_operand:DI 1 "reg_or_cint_move_operand")      ;; val out
    (match_operand:SI 2 "const_int_operand")]            ;; model
   ""
 {
   enum memmodel model;
 
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-
   if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
     FAIL;
 
   model = memmodel_from_int (INTVAL (operands[2]));
   operands[0] = force_reg (SImode, XEXP (operands[0], 0));
+  if (operands[1] != CONST0_RTX (DImode))
+    operands[1] = force_reg (DImode, operands[1]);
   expand_mem_thread_fence (model);
   emit_insn (gen_atomic_storedi_1 (operands[0], operands[1]));
   if (is_mm_seq_cst (model))
@@ -10074,87 +10015,33 @@
 
 (define_insn "atomic_storedi_1"
   [(set (mem:DI (match_operand:SI 0 "register_operand" "r,r"))
-        (match_operand:DI 1 "register_operand" "f,r"))
+        (match_operand:DI 1 "reg_or_0_operand" "M,r"))
    (clobber (match_scratch:DI 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS
-   && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL"
+  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
   "@
-   {fstds|fstd} %1,0(%0)
+   {fstds|fstd} %%fr0,0(%0)
    {stws|stw} %1,-16(%%sp)\n\t{stws|stw} %R1,-12(%%sp)\n\t{fldds|fldd} -16(%%sp),%2\n\t{fstds|fstd} %2,0(%0)"
   [(set_attr "type" "move,move")
    (set_attr "length" "4,16")])
 
-;; Implement atomic DFmode load using 64-bit floating point load.
-
-(define_expand "atomic_loaddf"
-  [(match_operand:DF 0 "register_operand")              ;; val out
-   (match_operand:DF 1 "memory_operand")                ;; memory
-   (match_operand:SI 2 "const_int_operand")]            ;; model
+;; PA 2.0 hardware supports out-of-order execution of loads and stores, so
+;; we need a memory barrier to enforce program order for memory references.
+;; Since we want PA 1.x code to be PA 2.0 compatible, we also need the
+;; barrier when generating PA 1.x code.
+
+(define_expand "memory_barrier"
+  [(set (match_dup 0)
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]
   ""
 {
-  enum memmodel model;
-
-  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
-    FAIL;
-
-  model = memmodel_from_int (INTVAL (operands[2]));
-  operands[1] = force_reg (SImode, XEXP (operands[1], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_loaddf_1 (operands[0], operands[1]));
-  if (is_mm_seq_cst (model))
-    expand_mem_thread_fence (model);
-  DONE;
+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[0]) = 1;
 })
 
-(define_insn "atomic_loaddf_1"
-  [(set (match_operand:DF 0 "register_operand" "=f,r")
-        (mem:DF (match_operand:SI 1 "register_operand" "r,r")))
-   (clobber (match_scratch:DF 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
-  "@
-   {fldds|fldd} 0(%1),%0
-   {fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
-
-;; Implement atomic DFmode store using 64-bit floating point store.
-
-(define_expand "atomic_storedf"
-  [(match_operand:DF 0 "memory_operand")                ;; memory
-   (match_operand:DF 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
+(define_insn "*memory_barrier"
+  [(set (match_operand:BLK 0 "" "")
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]
   ""
-{
-  enum memmodel model;
-
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-
-  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
-    FAIL;
-
-  model = memmodel_from_int (INTVAL (operands[2]));
-  operands[0] = force_reg (SImode, XEXP (operands[0], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_storedf_1 (operands[0], operands[1]));
-  if (is_mm_seq_cst (model))
-    expand_mem_thread_fence (model);
-  DONE;
-})
-
-(define_insn "atomic_storedf_1"
-  [(set (mem:DF (match_operand:SI 0 "register_operand" "r,r"))
-        (match_operand:DF 1 "register_operand" "f,r"))
-   (clobber (match_scratch:DF 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS
-   && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL"
-  "@
-   {fstds|fstd} %1,0(%0)
-   {stws|stw} %1,-16(%%sp)\n\t{stws|stw} %R1,-12(%%sp)\n\t{fldds|fldd} -16(%%sp),%2\n\t{fstds|fstd} %2,0(%0)"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
+  "sync"
+  [(set_attr "type" "binary")
+   (set_attr "length" "4")])
diff -ruN gcc-7.3.0/gcc/config/pa/predicates.md gcc-7.3.0-msp430/gcc/config/pa/predicates.md
--- gcc-7.3.0/gcc/config/pa/predicates.md	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/pa/predicates.md	2019-06-25 02:27:21.089931503 -0700
@@ -277,6 +277,9 @@
     case HImode:
       return true;
 
+    case VOIDmode:
+      return false;
+
     default:
       return (INTVAL (op) % GET_MODE_SIZE (mode)) == 0;
     }
diff -ruN gcc-7.3.0/gcc/config/riscv/t-rtems gcc-7.3.0-msp430/gcc/config/riscv/t-rtems
--- gcc-7.3.0/gcc/config/riscv/t-rtems	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/config/riscv/t-rtems	2019-06-25 02:27:21.089931503 -0700
@@ -0,0 +1,25 @@
+MULTILIB_OPTIONS	=
+MULTILIB_DIRNAMES	=
+
+MULTILIB_OPTIONS	+= march=rv32i/march=rv32im/march=rv32imafd/march=rv32iac/march=rv32imac/march=rv32imafc/march=rv64imafd/march=rv64imac/march=rv64imafdc
+MULTILIB_DIRNAMES	+= rv32i       rv32im       rv32imafd       rv32iac       rv32imac       rv32imafc       rv64imafd       rv64imac       rv64imafdc
+
+MULTILIB_OPTIONS	+= mabi=ilp32/mabi=ilp32f/mabi=ilp32d/mabi=lp64/mabi=lp64d
+MULTILIB_DIRNAMES	+= ilp32      ilp32f      ilp32d      lp64      lp64d
+
+MULTILIB_OPTIONS	+= mcmodel=medany
+MULTILIB_DIRNAMES	+= medany
+
+MULTILIB_REQUIRED	=
+MULTILIB_REQUIRED	+= march=rv32i/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32im/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32imafd/mabi=ilp32d
+MULTILIB_REQUIRED	+= march=rv32iac/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32imac/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32imafc/mabi=ilp32f
+MULTILIB_REQUIRED	+= march=rv64imafd/mabi=lp64d
+MULTILIB_REQUIRED	+= march=rv64imafd/mabi=lp64d/mcmodel=medany
+MULTILIB_REQUIRED	+= march=rv64imac/mabi=lp64
+MULTILIB_REQUIRED	+= march=rv64imac/mabi=lp64/mcmodel=medany
+MULTILIB_REQUIRED	+= march=rv64imafdc/mabi=lp64d
+MULTILIB_REQUIRED	+= march=rv64imafdc/mabi=lp64d/mcmodel=medany
diff -ruN gcc-7.3.0/gcc/config/rs6000/altivec.h gcc-7.3.0-msp430/gcc/config/rs6000/altivec.h
--- gcc-7.3.0/gcc/config/rs6000/altivec.h	2017-03-20 11:05:00.873711000 -0700
+++ gcc-7.3.0-msp430/gcc/config/rs6000/altivec.h	2019-06-25 02:27:21.089931503 -0700
@@ -398,8 +398,8 @@
 #define vec_vctzd __builtin_vec_vctzd
 #define vec_vctzh __builtin_vec_vctzh
 #define vec_vctzw __builtin_vec_vctzw
-#define vec_vextract4b __builtin_vec_vextract4b
-#define vec_vinsert4b __builtin_vec_vinsert4b
+#define vec_extract4b __builtin_vec_extract4b
+#define vec_insert4b __builtin_vec_insert4b
 #define vec_vprtyb __builtin_vec_vprtyb
 #define vec_vprtybd __builtin_vec_vprtybd
 #define vec_vprtybw __builtin_vec_vprtybw
diff -ruN gcc-7.3.0/gcc/config/rs6000/altivec.md gcc-7.3.0-msp430/gcc/config/rs6000/altivec.md
--- gcc-7.3.0/gcc/config/rs6000/altivec.md	2018-01-14 09:47:30.483964000 -0800
+++ gcc-7.3.0-msp430/gcc/config/rs6000/altivec.md	2019-06-25 02:27:21.089931503 -0700
@@ -414,7 +414,6 @@
 (define_insn "*restore_world"
  [(match_parallel 0 "restore_world_operation"
                   [(return)
-		   (use (reg:SI LR_REGNO))
                    (use (match_operand:SI 1 "call_operand" "s"))
                    (clobber (match_operand:SI 2 "gpc_reg_operand" "=r"))])]
  "TARGET_MACHO && (DEFAULT_ABI == ABI_DARWIN) && TARGET_32BIT"
@@ -2616,39 +2615,49 @@
   "lvx %0,%y1"
   [(set_attr "type" "vecload")])
 
-; The next two patterns embody what lvx should usually look like.
-(define_insn "altivec_lvx_<mode>_2op"
-  [(set (match_operand:VM2 0 "register_operand" "=v")
-        (mem:VM2 (and:DI (plus:DI (match_operand:DI 1 "register_operand" "b")
-                                  (match_operand:DI 2 "register_operand" "r"))
-		         (const_int -16))))]
-  "TARGET_ALTIVEC && TARGET_64BIT"
-  "lvx %0,%1,%2"
-  [(set_attr "type" "vecload")])
-
-(define_insn "altivec_lvx_<mode>_1op"
-  [(set (match_operand:VM2 0 "register_operand" "=v")
-        (mem:VM2 (and:DI (match_operand:DI 1 "register_operand" "r")
-			 (const_int -16))))]
-  "TARGET_ALTIVEC && TARGET_64BIT"
-  "lvx %0,0,%1"
-  [(set_attr "type" "vecload")])
+; The following patterns embody what lvx should usually look like.
+(define_expand "altivec_lvx_<VM2:mode>"
+  [(set (match_operand:VM2 0 "register_operand")
+	(match_operand:VM2 1 "altivec_indexed_or_indirect_operand"))]
+  "TARGET_ALTIVEC"
+{
+  rtx addr = XEXP (operand1, 0);
+  if (GET_CODE (addr) == PLUS
+      && REG_P (XEXP (addr, 0))
+      && REG_P (XEXP (addr, 1)))
+    {
+      rtx op1 = XEXP (addr, 0);
+      rtx op2 = XEXP (addr, 1);
+      if (TARGET_64BIT)
+	emit_insn (gen_altivec_lvx_<VM2:mode>_2op_di (operand0, op1, op2));
+      else
+	emit_insn (gen_altivec_lvx_<VM2:mode>_2op_si (operand0, op1, op2));
+    }
+  else
+    {
+      if (TARGET_64BIT)
+	emit_insn (gen_altivec_lvx_<VM2:mode>_1op_di (operand0, addr));
+      else
+	emit_insn (gen_altivec_lvx_<VM2:mode>_1op_si (operand0, addr));
+    }
+  DONE;
+})
 
-; 32-bit versions of the above.
-(define_insn "altivec_lvx_<mode>_2op_si"
+; The next two patterns embody what lvx should usually look like.
+(define_insn "altivec_lvx_<VM2:mode>_2op_<P:mptrsize>"
   [(set (match_operand:VM2 0 "register_operand" "=v")
-        (mem:VM2 (and:SI (plus:SI (match_operand:SI 1 "register_operand" "b")
-                                  (match_operand:SI 2 "register_operand" "r"))
-		         (const_int -16))))]
-  "TARGET_ALTIVEC && TARGET_32BIT"
+	(mem:VM2 (and:P (plus:P (match_operand:P 1 "register_operand" "b")
+				(match_operand:P 2 "register_operand" "r"))
+			(const_int -16))))]
+  "TARGET_ALTIVEC"
   "lvx %0,%1,%2"
   [(set_attr "type" "vecload")])
 
-(define_insn "altivec_lvx_<mode>_1op_si"
+(define_insn "altivec_lvx_<VM2:mode>_1op_<P:mptrsize>"
   [(set (match_operand:VM2 0 "register_operand" "=v")
-        (mem:VM2 (and:SI (match_operand:SI 1 "register_operand" "r")
-			 (const_int -16))))]
-  "TARGET_ALTIVEC && TARGET_32BIT"
+	(mem:VM2 (and:P (match_operand:P 1 "register_operand" "r")
+			(const_int -16))))]
+  "TARGET_ALTIVEC"
   "lvx %0,0,%1"
   [(set_attr "type" "vecload")])
 
@@ -2664,39 +2673,49 @@
   "stvx %1,%y0"
   [(set_attr "type" "vecstore")])
 
-; The next two patterns embody what stvx should usually look like.
-(define_insn "altivec_stvx_<mode>_2op"
-  [(set (mem:VM2 (and:DI (plus:DI (match_operand:DI 1 "register_operand" "b")
-  	                          (match_operand:DI 2 "register_operand" "r"))
-	                 (const_int -16)))
-        (match_operand:VM2 0 "register_operand" "v"))]
-  "TARGET_ALTIVEC && TARGET_64BIT"
-  "stvx %0,%1,%2"
-  [(set_attr "type" "vecstore")])
-
-(define_insn "altivec_stvx_<mode>_1op"
-  [(set (mem:VM2 (and:DI (match_operand:DI 1 "register_operand" "r")
-	                 (const_int -16)))
-        (match_operand:VM2 0 "register_operand" "v"))]
-  "TARGET_ALTIVEC && TARGET_64BIT"
-  "stvx %0,0,%1"
-  [(set_attr "type" "vecstore")])
+; The following patterns embody what stvx should usually look like.
+(define_expand "altivec_stvx_<VM2:mode>"
+  [(set (match_operand:VM2 1 "altivec_indexed_or_indirect_operand")
+	(match_operand:VM2 0 "register_operand"))]
+  "TARGET_ALTIVEC"
+{
+  rtx addr = XEXP (operand1, 0);
+  if (GET_CODE (addr) == PLUS
+      && REG_P (XEXP (addr, 0))
+      && REG_P (XEXP (addr, 1)))
+    {
+      rtx op1 = XEXP (addr, 0);
+      rtx op2 = XEXP (addr, 1);
+      if (TARGET_64BIT)
+	emit_insn (gen_altivec_stvx_<VM2:mode>_2op_di (operand0, op1, op2));
+      else
+	emit_insn (gen_altivec_stvx_<VM2:mode>_2op_si (operand0, op1, op2));
+    }
+  else
+    {
+      if (TARGET_64BIT)
+	emit_insn (gen_altivec_stvx_<VM2:mode>_1op_di (operand0, addr));
+      else
+	emit_insn (gen_altivec_stvx_<VM2:mode>_1op_si (operand0, addr));
+    }
+  DONE;
+})
 
-; 32-bit versions of the above.
-(define_insn "altivec_stvx_<mode>_2op_si"
-  [(set (mem:VM2 (and:SI (plus:SI (match_operand:SI 1 "register_operand" "b")
-  	                          (match_operand:SI 2 "register_operand" "r"))
-	                 (const_int -16)))
-        (match_operand:VM2 0 "register_operand" "v"))]
-  "TARGET_ALTIVEC && TARGET_32BIT"
+; The next two patterns embody what stvx should usually look like.
+(define_insn "altivec_stvx_<VM2:mode>_2op_<P:mptrsize>"
+  [(set (mem:VM2 (and:P (plus:P (match_operand:P 1 "register_operand" "b")
+				(match_operand:P 2 "register_operand" "r"))
+			(const_int -16)))
+	(match_operand:VM2 0 "register_operand" "v"))]
+  "TARGET_ALTIVEC"
   "stvx %0,%1,%2"
   [(set_attr "type" "vecstore")])
 
-(define_insn "altivec_stvx_<mode>_1op_si"
-  [(set (mem:VM2 (and:SI (match_operand:SI 1 "register_operand" "r")
-	                 (const_int -16)))
-        (match_operand:VM2 0 "register_operand" "v"))]
-  "TARGET_ALTIVEC && TARGET_32BIT"
+(define_insn "altivec_stvx_<VM2:mode>_1op_<P:mptrsize>"
+  [(set (mem:VM2 (and:P (match_operand:P 1 "register_operand" "r")
+			(const_int -16)))
+	(match_operand:VM2 0 "register_operand" "v"))]
+  "TARGET_ALTIVEC"
   "stvx %0,0,%1"
   [(set_attr "type" "vecstore")])
 
diff -ruN gcc-7.3.0/gcc/config/rs6000/driver-rs6000.c gcc-7.3.0-msp430/gcc/config/rs6000/driver-rs6000.c
--- gcc-7.3.0/gcc/config/rs6000/driver-rs6000.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/rs6000/driver-rs6000.c	2019-06-25 02:27:21.089931503 -0700
@@ -21,6 +21,8 @@
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
+#include "diagnostic.h"
+#include "opts.h"
 #include <stdlib.h>
 
 #ifdef _AIX
@@ -36,6 +38,44 @@
 # include <sys/sysctl.h>
 #endif
 
+#ifdef __linux__
+/* Canonical GCC cpu name table.  */
+static const char *rs6000_supported_cpu_names[] =
+{
+#define RS6000_CPU(NAME, CPU, FLAGS) NAME,
+#include "rs6000-cpus.def"
+#undef RS6000_CPU
+};
+
+/* This table holds a list of cpus where their Linux AT_PLATFORM name differs
+   from their GCC canonical name.  The first column in a row contains the GCC
+   canonical cpu name and the other columns in that row contain AT_PLATFORM
+   names that should be mapped to the canonical name.  */
+
+static const char *linux_cpu_translation_table[][4] = {
+  { "403", "ppc403", NULL },
+  { "405", "ppc405", NULL },
+  { "440", "ppc440", "ppc440gp", NULL },
+  { "476", "ppc470", NULL },
+  { "601", "ppc601", NULL },
+  { "603", "ppc603", NULL },
+  { "604", "ppc604", NULL },
+  { "7400", "ppc7400", NULL },
+  { "7450", "ppc7450", NULL },
+  { "750", "ppc750", NULL },
+  { "823", "ppc823", NULL },
+  { "8540", "ppc8540", NULL },
+  { "8548", "ppc8548", NULL },
+  { "970", "ppc970", NULL },
+  { "cell", "ppc-cell-be", NULL },
+  { "e500mc", "ppce500mc", NULL },
+  { "e5500", "ppce5500", NULL },
+  { "e6500", "ppce6500", NULL },
+  { "power7", "power7+", NULL },
+  { NULL } /* End of table sentinel.  */
+};
+#endif
+
 const char *host_detect_local_cpu (int argc, const char **argv);
 
 #if GCC_VERSION >= 0
@@ -156,14 +196,19 @@
 
 #ifdef __linux__
 
-/* Returns AT_PLATFORM if present, otherwise generic PowerPC.  */
+/* Returns the canonical AT_PLATFORM if present, otherwise NULL.  */
 
 static const char *
 elf_platform (void)
 {
-  int fd;
+  /* Used to cache the result we determine below.  */
+  static const char *cpu = NULL;
+
+  /* Use the cached AT_PLATFORM cpu name if we've already determined it.  */
+  if (cpu != NULL)
+    return cpu;
 
-  fd = open ("/proc/self/auxv", O_RDONLY);
+  int fd = open ("/proc/self/auxv", O_RDONLY);
 
   if (fd != -1)
     {
@@ -177,15 +222,51 @@
       if (n > 0)
 	{
 	  for (av = (ElfW(auxv_t) *) buf; av->a_type != AT_NULL; ++av)
-	    switch (av->a_type)
+	    if (av->a_type == AT_PLATFORM)
 	      {
-	      case AT_PLATFORM:
-		return (const char *) av->a_un.a_val;
-
-	      default:
+		/* Cache the result.  */
+		cpu = (const char *) av->a_un.a_val;
 		break;
 	      }
 	}
+
+      /* Verify that CPU is either a valid -mcpu=<cpu> option name, or is a
+	 valid alternative name.  If it is a valid alternative name, then use
+	 the canonical name.  */
+      if (cpu != NULL)
+	{
+	  size_t i, j;
+	  char *s;
+
+	  /* Check if AT_PLATFORM is a GCC canonical cpu name.  */
+	  for (i = 0; i < ARRAY_SIZE (rs6000_supported_cpu_names); i++)
+	    if (!strcmp (cpu, rs6000_supported_cpu_names[i]))
+	      return cpu;
+
+	  /* Check if AT_PLATFORM can be translated to a canonical cpu name.  */
+	  for (i = 0; linux_cpu_translation_table[i][0] != NULL; i++)
+	    {
+	      const char *canonical = linux_cpu_translation_table[i][0];
+	      for (j = 1; linux_cpu_translation_table[i][j] != NULL; j++)
+		if (!strcmp (cpu, linux_cpu_translation_table[i][j]))
+		  {
+		    /* Cache the result.  */
+		    cpu = canonical;
+		    return cpu;
+		  }
+	    }
+
+	  /* The kernel returned an AT_PLATFORM name we do not support.  */
+	  auto_vec <const char *> candidates;
+	  for (i = 0; i < ARRAY_SIZE (rs6000_supported_cpu_names); i++)
+	    candidates.safe_push (rs6000_supported_cpu_names[i]);
+	  candidates_list_and_hint (cpu, s, candidates);
+	  fatal_error (
+	    input_location,
+	    "Unsupported cpu name returned from kernel for -mcpu=native: %s\n"
+	    "Please use an explicit cpu name.  Valid cpu names are: %s",
+	    cpu, s);
+	}
     }
   return NULL;
 }
diff -ruN gcc-7.3.0/gcc/config/rs6000/predicates.md gcc-7.3.0-msp430/gcc/config/rs6000/predicates.md
--- gcc-7.3.0/gcc/config/rs6000/predicates.md	2017-05-25 18:52:24.663969000 -0700
+++ gcc-7.3.0-msp430/gcc/config/rs6000/predicates.md	2019-06-25 02:27:21.093931475 -0700
@@ -1468,13 +1468,12 @@
   rtx elt;
   int count = XVECLEN (op, 0);
 
-  if (count != 59)
+  if (count != 58)
     return 0;
 
   index = 0;
   if (GET_CODE (XVECEXP (op, 0, index++)) != RETURN
       || GET_CODE (XVECEXP (op, 0, index++)) != USE
-      || GET_CODE (XVECEXP (op, 0, index++)) != USE
       || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER)
     return 0;
 
diff -ruN gcc-7.3.0/gcc/config/rs6000/rs6000-builtin.def gcc-7.3.0-msp430/gcc/config/rs6000/rs6000-builtin.def
--- gcc-7.3.0/gcc/config/rs6000/rs6000-builtin.def	2017-03-10 11:16:04.268840000 -0800
+++ gcc-7.3.0-msp430/gcc/config/rs6000/rs6000-builtin.def	2019-06-25 02:27:21.093931475 -0700
@@ -1,5 +1,5 @@
 /* Builtin functions for rs6000/powerpc.
-   Copyright (C) 2009-2017 Free Software Foundation, Inc.
+   Copyright (C) 2009-2018 Free Software Foundation, Inc.
    Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)
 
    This file is part of GCC.
@@ -659,6 +659,14 @@
 		     | RS6000_BTC_BINARY),				\
 		    CODE_FOR_ ## ICODE)			/* ICODE */
 
+#define BU_P7_POWERPC64_MISC_2(ENUM, NAME, ATTR, ICODE)			\
+  RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,		/* ENUM */      \
+		    "__builtin_" NAME,			/* NAME */      \
+		    RS6000_BTM_POPCNTD			/* MASK */	\
+		    | RS6000_BTM_POWERPC64,				\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */      \
+		    | RS6000_BTC_BINARY),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
 
 /* Miscellaneous builtins for instructions added in ISA 2.07.  These
    instructions do require the ISA 2.07 vector support, but they aren't vector
@@ -2034,8 +2042,8 @@
 
 /* Insert/extract 4 byte word into a vector.  */
 BU_P9V_VSX_2 (VEXTRACT4B,   "vextract4b",	CONST,	vextract4b)
-BU_P9V_VSX_3 (VINSERT4B,    "vinsert4b",	CONST,	vinsert4b)
-BU_P9V_VSX_3 (VINSERT4B_DI, "vinsert4b_di",	CONST,	vinsert4b_di)
+BU_P9V_VSX_3 (INSERT4B,    "insert4b",		CONST,  insert4b)
+BU_P9V_VSX_2 (EXTRACT4B,   "extract4b", 	CONST,  extract4b)
 
 /* 3 argument vector functions returning void, treated as SPECIAL,
    added in ISA 3.0 (power9).  */
@@ -2084,10 +2092,11 @@
 BU_P9V_OVERLOAD_2 (VEXTULX,	"vextulx")
 BU_P9V_OVERLOAD_2 (VEXTURX,	"vexturx")
 BU_P9V_OVERLOAD_2 (VEXTRACT4B,	"vextract4b")
+BU_P9V_OVERLOAD_2 (EXTRACT4B,  "extract4b")
 
 /* ISA 3.0 Vector scalar overloaded 3 argument functions */
 BU_P9V_OVERLOAD_3 (STXVL,	"stxvl")
-BU_P9V_OVERLOAD_3 (VINSERT4B,	"vinsert4b")
+BU_P9V_OVERLOAD_3 (INSERT4B,    "insert4b")
 
 /* Overloaded CMPNE support was implemented prior to Power 9,
    so is not mentioned here.  */
@@ -2103,13 +2112,9 @@
 
 /* 2 argument extended divide functions added in ISA 2.06.  */
 BU_P7_MISC_2 (DIVWE,		"divwe",	CONST,	dive_si)
-BU_P7_MISC_2 (DIVWEO,		"divweo",	CONST,	diveo_si)
 BU_P7_MISC_2 (DIVWEU,		"divweu",	CONST,	diveu_si)
-BU_P7_MISC_2 (DIVWEUO,		"divweuo",	CONST,	diveuo_si)
-BU_P7_MISC_2 (DIVDE,		"divde",	CONST,	dive_di)
-BU_P7_MISC_2 (DIVDEO,		"divdeo",	CONST,	diveo_di)
-BU_P7_MISC_2 (DIVDEU,		"divdeu",	CONST,	diveu_di)
-BU_P7_MISC_2 (DIVDEUO,		"divdeuo",	CONST,	diveuo_di)
+BU_P7_POWERPC64_MISC_2 (DIVDE,	"divde",	CONST,	dive_di)
+BU_P7_POWERPC64_MISC_2 (DIVDEU,	"divdeu",	CONST,	diveu_di)
 
 /* 1 argument DFP (decimal floating point) functions added in ISA 2.05.  */
 BU_DFP_MISC_1 (DXEX,		"dxex",		CONST,	dfp_dxex_dd)
diff -ruN gcc-7.3.0/gcc/config/rs6000/rs6000.c gcc-7.3.0-msp430/gcc/config/rs6000/rs6000.c
--- gcc-7.3.0/gcc/config/rs6000/rs6000.c	2018-01-17 17:34:10.497108000 -0800
+++ gcc-7.3.0-msp430/gcc/config/rs6000/rs6000.c	2019-06-25 02:27:21.097931448 -0700
@@ -1,5 +1,5 @@
 /* Subroutines used for code generation on IBM RS/6000.
-   Copyright (C) 1991-2017 Free Software Foundation, Inc.
+   Copyright (C) 1991-2018 Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
    This file is part of GCC.
@@ -1372,6 +1372,7 @@
 						   int, int, int *);
 static bool rs6000_mode_dependent_address (const_rtx);
 static bool rs6000_debug_mode_dependent_address (const_rtx);
+static bool rs6000_offsettable_memref_p (rtx, machine_mode, bool);
 static enum reg_class rs6000_secondary_reload_class (enum reg_class,
 						     machine_mode, rtx);
 static enum reg_class rs6000_debug_secondary_reload_class (enum reg_class,
@@ -3890,6 +3891,7 @@
 	  | ((TARGET_P9_MISC)		    ? RS6000_BTM_P9_MISC   : 0)
 	  | ((TARGET_MODULO)		    ? RS6000_BTM_MODULO    : 0)
 	  | ((TARGET_64BIT)		    ? RS6000_BTM_64BIT     : 0)
+	  | ((TARGET_POWERPC64)		    ? RS6000_BTM_POWERPC64 : 0)
 	  | ((TARGET_CRYPTO)		    ? RS6000_BTM_CRYPTO	   : 0)
 	  | ((TARGET_HTM)		    ? RS6000_BTM_HTM	   : 0)
 	  | ((TARGET_DFP)		    ? RS6000_BTM_DFP	   : 0)
@@ -5563,6 +5565,11 @@
   if (TARGET_LINK_STACK == -1)
     SET_TARGET_LINK_STACK (rs6000_cpu == PROCESSOR_PPC476 && flag_pic);
 
+  /* Deprecate use of -mno-speculate-indirect-jumps.  */
+  if (!rs6000_speculate_indirect_jumps)
+    warning (0, "%qs is deprecated and not recommended in any circumstances",
+	     "-mno-speculate-indirect-jumps");
+
   return ret;
 }
 
@@ -8558,6 +8565,17 @@
   int extra;
   rtx addr = XEXP (op, 0);
 
+  /* PR85755: Allow PRE_INC and PRE_DEC addresses.  */
+  if (TARGET_UPDATE
+      && (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)
+      && mode_supports_pre_incdec_p (mode)
+      && legitimate_indirect_address_p (XEXP (addr, 0), false))
+    return true;
+
+  /* Don't allow non-offsettable addresses.  See PRs 83969 and 84279.  */
+  if (!rs6000_offsettable_memref_p (op, mode, false))
+    return false;
+
   op = address_offset (addr);
   if (op == NULL_RTX)
     return true;
@@ -10328,7 +10346,7 @@
    in 32-bit mode, that the recog predicate rejects.  */
 
 static bool
-rs6000_offsettable_memref_p (rtx op, machine_mode reg_mode)
+rs6000_offsettable_memref_p (rtx op, machine_mode reg_mode, bool strict)
 {
   bool worst_case;
 
@@ -10336,7 +10354,7 @@
     return false;
 
   /* First mimic offsettable_memref_p.  */
-  if (offsettable_address_p (true, GET_MODE (op), XEXP (op, 0)))
+  if (offsettable_address_p (strict, GET_MODE (op), XEXP (op, 0)))
     return true;
 
   /* offsettable_address_p invokes rs6000_mode_dependent_address, but
@@ -10350,7 +10368,7 @@
   worst_case = ((TARGET_POWERPC64 && GET_MODE_CLASS (reg_mode) == MODE_INT)
 		|| GET_MODE_SIZE (reg_mode) == 4);
   return rs6000_legitimate_offset_address_p (GET_MODE (op), XEXP (op, 0),
-					     true, worst_case);
+					     strict, worst_case);
 }
 
 /* Determine the reassociation width to be used in reassociate_bb.
@@ -11574,12 +11592,12 @@
 
       if (field_count > 0)
 	{
-	  int n_regs = (SCALAR_FLOAT_MODE_P (field_mode) ?
-			(GET_MODE_SIZE (field_mode) + 7) >> 3 : 1);
+	  int reg_size = ALTIVEC_OR_VSX_VECTOR_MODE (field_mode) ? 16 : 8;
+	  int field_size = ROUND_UP (GET_MODE_SIZE (field_mode), reg_size);
 
 	  /* The ELFv2 ABI allows homogeneous aggregates to occupy
 	     up to AGGR_ARG_NUM_REG registers.  */
-	  if (field_count * n_regs <= AGGR_ARG_NUM_REG)
+	  if (field_count * field_size <= AGGR_ARG_NUM_REG * reg_size)
 	    {
 	      if (elt_mode)
 		*elt_mode = field_mode;
@@ -14106,6 +14124,7 @@
 
       tree copy = build_call_expr (builtin_decl_implicit (BUILT_IN_MEMCPY),
 				   3, dest_addr, addr, size_int (rsize * 4));
+      TREE_ADDRESSABLE (tmp) = 1;
 
       gimplify_and_add (copy, pre_p);
       addr = dest_addr;
@@ -15087,12 +15106,12 @@
   /* For LVX, express the RTL accurately by ANDing the address with -16.
      LVXL and LVE*X expand to use UNSPECs to hide their special behavior,
      so the raw address is fine.  */
-  if (icode == CODE_FOR_altivec_lvx_v2df_2op
-      || icode == CODE_FOR_altivec_lvx_v2di_2op
-      || icode == CODE_FOR_altivec_lvx_v4sf_2op
-      || icode == CODE_FOR_altivec_lvx_v4si_2op
-      || icode == CODE_FOR_altivec_lvx_v8hi_2op
-      || icode == CODE_FOR_altivec_lvx_v16qi_2op)
+  if (icode == CODE_FOR_altivec_lvx_v2df
+      || icode == CODE_FOR_altivec_lvx_v2di
+      || icode == CODE_FOR_altivec_lvx_v4sf
+      || icode == CODE_FOR_altivec_lvx_v4si
+      || icode == CODE_FOR_altivec_lvx_v8hi
+      || icode == CODE_FOR_altivec_lvx_v16qi)
     {
       rtx rawaddr;
       if (op0 == const0_rtx)
@@ -15278,12 +15297,12 @@
   /* For STVX, express the RTL accurately by ANDing the address with -16.
      STVXL and STVE*X expand to use UNSPECs to hide their special behavior,
      so the raw address is fine.  */
-  if (icode == CODE_FOR_altivec_stvx_v2df_2op
-      || icode == CODE_FOR_altivec_stvx_v2di_2op
-      || icode == CODE_FOR_altivec_stvx_v4sf_2op
-      || icode == CODE_FOR_altivec_stvx_v4si_2op
-      || icode == CODE_FOR_altivec_stvx_v8hi_2op
-      || icode == CODE_FOR_altivec_stvx_v16qi_2op)
+  if (icode == CODE_FOR_altivec_stvx_v2df
+      || icode == CODE_FOR_altivec_stvx_v2di
+      || icode == CODE_FOR_altivec_stvx_v4sf
+      || icode == CODE_FOR_altivec_stvx_v4si
+      || icode == CODE_FOR_altivec_stvx_v8hi
+      || icode == CODE_FOR_altivec_stvx_v16qi)
     {
       if (op1 == const0_rtx)
 	rawaddr = op2;
@@ -16184,18 +16203,18 @@
   switch (fcode)
     {
     case ALTIVEC_BUILTIN_STVX_V2DF:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v2df_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v2df, exp);
     case ALTIVEC_BUILTIN_STVX_V2DI:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v2di_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v2di, exp);
     case ALTIVEC_BUILTIN_STVX_V4SF:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4sf_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4sf, exp);
     case ALTIVEC_BUILTIN_STVX:
     case ALTIVEC_BUILTIN_STVX_V4SI:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4si_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4si, exp);
     case ALTIVEC_BUILTIN_STVX_V8HI:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v8hi_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v8hi, exp);
     case ALTIVEC_BUILTIN_STVX_V16QI:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v16qi_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v16qi, exp);
     case ALTIVEC_BUILTIN_STVEBX:
       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvebx, exp);
     case ALTIVEC_BUILTIN_STVEHX:
@@ -16374,6 +16393,7 @@
 
     case P9V_BUILTIN_VEXTRACT4B:
     case P9V_BUILTIN_VEC_VEXTRACT4B:
+    case P9V_BUILTIN_VEC_EXTRACT4B:
       arg1 = CALL_EXPR_ARG (exp, 1);
       STRIP_NOPS (arg1);
 
@@ -16388,9 +16408,7 @@
 	}
       break;
 
-    case P9V_BUILTIN_VINSERT4B:
-    case P9V_BUILTIN_VINSERT4B_DI:
-    case P9V_BUILTIN_VEC_VINSERT4B:
+    case P9V_BUILTIN_VEC_INSERT4B:
       arg2 = CALL_EXPR_ARG (exp, 2);
       STRIP_NOPS (arg2);
 
@@ -16400,7 +16418,7 @@
 
       if (TREE_CODE (arg2) != INTEGER_CST || TREE_INT_CST_LOW (arg2) > 12)
 	{
-	  error ("third argument to vec_vinsert4b must be 0..12");
+	  error ("third argument to vec_insert4b must be 0..12");
 	  return expand_call (exp, target, false);
 	}
       break;
@@ -16460,23 +16478,23 @@
       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvxl_v16qi,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V2DF:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v2df_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v2df,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V2DI:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v2di_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v2di,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V4SF:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4sf_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4sf,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX:
     case ALTIVEC_BUILTIN_LVX_V4SI:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4si_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4si,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V8HI:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v8hi_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v8hi,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V16QI:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v16qi_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v16qi,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVLX:
       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvlx,
@@ -17040,6 +17058,11 @@
     error ("Builtin function %s requires the -mhard-float option", name);
   else if ((fnmask & RS6000_BTM_FLOAT128) != 0)
     error ("Builtin function %s requires the -mfloat128 option", name);
+  else if ((fnmask & (RS6000_BTM_POPCNTD | RS6000_BTM_POWERPC64))
+	   == (RS6000_BTM_POPCNTD | RS6000_BTM_POWERPC64))
+    error ("builtin function %qs requires the %qs (or newer), and "
+	   "%qs or %qs options",
+	   name, "-mcpu=power7", "-m64", "-mpowerpc64");
   else
     error ("Builtin function %s is not supported with the current options",
 	   name);
@@ -18804,9 +18827,7 @@
     case CRYPTO_BUILTIN_VPMSUM:
     case MISC_BUILTIN_ADDG6S:
     case MISC_BUILTIN_DIVWEU:
-    case MISC_BUILTIN_DIVWEUO:
     case MISC_BUILTIN_DIVDEU:
-    case MISC_BUILTIN_DIVDEUO:
       h.uns_p[0] = 1;
       h.uns_p[1] = 1;
       h.uns_p[2] = 1;
@@ -23267,7 +23288,7 @@
 	}
 
       else if (TARGET_ALTIVEC && src_vmx_p
-	       && altivec_indexed_or_indirect_operand (src, mode))
+	       && altivec_indexed_or_indirect_operand (dest, mode))
 	return "stvx %1,%y0";
 
       else if (TARGET_VSX && src_vsx_p)
@@ -23980,7 +24001,7 @@
 
 	    /* Fall through.  Must be [reg+reg].  */
 	  }
-	if (VECTOR_MEM_ALTIVEC_P (GET_MODE (x))
+	if (VECTOR_MEM_ALTIVEC_OR_VSX_P (GET_MODE (x))
 	    && GET_CODE (tmp) == AND
 	    && GET_CODE (XEXP (tmp, 1)) == CONST_INT
 	    && INTVAL (XEXP (tmp, 1)) == -16)
@@ -25907,49 +25928,6 @@
     emit_move_insn (dest, target);
 }
 
-/* Split a signbit operation on 64-bit machines with direct move.  Also allow
-   for the value to come from memory or if it is already loaded into a GPR.  */
-
-void
-rs6000_split_signbit (rtx dest, rtx src)
-{
-  machine_mode d_mode = GET_MODE (dest);
-  machine_mode s_mode = GET_MODE (src);
-  rtx dest_di = (d_mode == DImode) ? dest : gen_lowpart (DImode, dest);
-  rtx shift_reg = dest_di;
-
-  gcc_assert (FLOAT128_IEEE_P (s_mode) && TARGET_POWERPC64);
-
-  if (MEM_P (src))
-    {
-      rtx mem = (WORDS_BIG_ENDIAN
-		 ? adjust_address (src, DImode, 0)
-		 : adjust_address (src, DImode, 8));
-      emit_insn (gen_rtx_SET (dest_di, mem));
-    }
-
-  else
-    {
-      unsigned int r = reg_or_subregno (src);
-
-      if (INT_REGNO_P (r))
-	shift_reg = gen_rtx_REG (DImode, r + (BYTES_BIG_ENDIAN == 0));
-
-      else
-	{
-	  /* Generate the special mfvsrd instruction to get it in a GPR.  */
-	  gcc_assert (VSX_REGNO_P (r));
-	  if (s_mode == KFmode)
-	    emit_insn (gen_signbitkf2_dm2 (dest_di, src));
-	  else
-	    emit_insn (gen_signbittf2_dm2 (dest_di, src));
-	}
-    }
-
-  emit_insn (gen_lshrdi3 (dest_di, shift_reg, GEN_INT (63)));
-  return;
-}
-
 /* A subroutine of the atomic operation splitters.  Jump to LABEL if
    COND is true.  Mark the jump as unlikely to be taken.  */
 
@@ -26588,7 +26566,7 @@
 	      emit_insn (gen_add3_insn (breg, breg, delta_rtx));
 	      src = replace_equiv_address (src, breg);
 	    }
-	  else if (! rs6000_offsettable_memref_p (src, reg_mode))
+	  else if (! rs6000_offsettable_memref_p (src, reg_mode, true))
 	    {
 	      if (GET_CODE (XEXP (src, 0)) == PRE_MODIFY)
 		{
@@ -26655,7 +26633,7 @@
 		emit_insn (gen_add3_insn (breg, breg, delta_rtx));
 	      dst = replace_equiv_address (dst, breg);
 	    }
-	  else if (!rs6000_offsettable_memref_p (dst, reg_mode)
+	  else if (!rs6000_offsettable_memref_p (dst, reg_mode, true)
 		   && GET_CODE (XEXP (dst, 0)) != LO_SUM)
 	    {
 	      if (GET_CODE (XEXP (dst, 0)) == PRE_MODIFY)
@@ -26694,7 +26672,7 @@
 		}
 	    }
 	  else if (GET_CODE (XEXP (dst, 0)) != LO_SUM)
-	    gcc_assert (rs6000_offsettable_memref_p (dst, reg_mode));
+	    gcc_assert (rs6000_offsettable_memref_p (dst, reg_mode, true));
 	}
 
       for (i = 0; i < nregs; i++)
@@ -31988,8 +31966,9 @@
 	  emit_insn_after (pat, get_insns ());
 	  pop_topmost_sequence ();
 	}
-      return plus_constant (Pmode, cfun->machine->split_stack_arg_pointer,
-			    FIRST_PARM_OFFSET (current_function_decl));
+      rtx ret = plus_constant (Pmode, cfun->machine->split_stack_arg_pointer,
+			       FIRST_PARM_OFFSET (current_function_decl));
+      return copy_to_reg (ret);
     }
   return virtual_incoming_args_rtx;
 }
@@ -35647,6 +35626,11 @@
     }
   else
     {
+      /* If we are told not to put readonly data in sdata, then don't.  */
+      if (TREE_READONLY (decl) && rs6000_sdata != SDATA_EABI
+	  && !rs6000_readonly_in_sdata)
+	return false;
+
       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (decl));
 
       if (size > 0
@@ -39167,6 +39151,7 @@
   { "hard-dfp",		 RS6000_BTM_DFP,	false, false },
   { "hard-float",	 RS6000_BTM_HARD_FLOAT,	false, false },
   { "long-double-128",	 RS6000_BTM_LDBL128,	false, false },
+  { "powerpc64",	 RS6000_BTM_POWERPC64,  false, false },
   { "float128",		 RS6000_BTM_FLOAT128,   false, false },
 };
 
@@ -41657,6 +41642,38 @@
   return 1;
 }
 
+/* Return 1 iff UID, known to reference a swap, is both fed by a load
+   and a feeder of a store.  */
+static unsigned int
+swap_feeds_both_load_and_store (swap_web_entry *insn_entry)
+{
+  rtx insn = insn_entry->insn;
+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);
+  df_ref def, use;
+  struct df_link *link = 0;
+  rtx_insn *load = 0, *store = 0;
+  bool fed_by_load = 0;
+  bool feeds_store = 0;
+
+  FOR_EACH_INSN_INFO_USE (use, insn_info)
+    {
+      link = DF_REF_CHAIN (use);
+      load = DF_REF_INSN (link->ref);
+      if (insn_is_load_p (load) && insn_is_swap_p (load))
+	fed_by_load = 1;
+    }
+
+  FOR_EACH_INSN_INFO_DEF (def, insn_info)
+    {
+      link = DF_REF_CHAIN (def);
+      store = DF_REF_INSN (link->ref);
+      if (insn_is_store_p (store) && insn_is_swap_p (store))
+	feeds_store = 1;
+    }
+
+  return fed_by_load && feeds_store;
+}
+
 /* Return TRUE if insn is a swap fed by a load from the constant pool.  */
 static bool
 const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)
@@ -41860,6 +41877,7 @@
 	  {
 	  default:
 	    break;
+	  case UNSPEC_VBPERMQ:
 	  case UNSPEC_VMRGH_DIRECT:
 	  case UNSPEC_VMRGL_DIRECT:
 	  case UNSPEC_VPACK_SIGN_SIGN_SAT:
@@ -41871,6 +41889,7 @@
 	  case UNSPEC_VPERM_UNS:
 	  case UNSPEC_VPERMHI:
 	  case UNSPEC_VPERMSI:
+	  case UNSPEC_VPERMXOR:
 	  case UNSPEC_VPKPX:
 	  case UNSPEC_VSLDOI:
 	  case UNSPEC_VSLO:
@@ -43129,6 +43148,14 @@
 	  && !insn_entry[i].is_swap && !insn_entry[i].is_swappable)
 	root->web_not_optimizable = 1;
 
+      /* If we have a swap that is both fed by a permuting load
+	 and a feeder of a permuting store, then the optimization
+	 isn't appropriate.  (Consider vec_xl followed by vec_xst_be.)  */
+      else if (insn_entry[i].is_swap && !insn_entry[i].is_load
+	       && !insn_entry[i].is_store
+	       && swap_feeds_both_load_and_store (&insn_entry[i]))
+	root->web_not_optimizable = 1;
+
       /* If we have permuting loads or stores that are not accompanied
 	 by a register swap, the optimization isn't appropriate.  */
       else if (insn_entry[i].is_load && insn_entry[i].is_swap)
diff -ruN gcc-7.3.0/gcc/config/rs6000/rs6000-c.c gcc-7.3.0-msp430/gcc/config/rs6000/rs6000-c.c
--- gcc-7.3.0/gcc/config/rs6000/rs6000-c.c	2017-09-15 04:24:49.297777000 -0700
+++ gcc-7.3.0-msp430/gcc/config/rs6000/rs6000-c.c	2019-06-25 02:27:21.093931475 -0700
@@ -2393,7 +2393,7 @@
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKSDUS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKSDUS,
+  { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKUDUS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_VPKSWUS, ALTIVEC_BUILTIN_VPKSWUS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
@@ -5047,6 +5047,8 @@
     RS6000_BTI_INTDI, RS6000_BTI_V16QI, RS6000_BTI_UINTSI, 0 },
   { P9V_BUILTIN_VEC_VEXTRACT4B, P9V_BUILTIN_VEXTRACT4B,
     RS6000_BTI_INTDI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTSI, 0 },
+  { P9V_BUILTIN_VEC_EXTRACT4B, P9V_BUILTIN_EXTRACT4B,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, 0 },
 
   { P9V_BUILTIN_VEC_VEXTULX, P9V_BUILTIN_VEXTUBLX,
     RS6000_BTI_INTQI, RS6000_BTI_UINTSI,
@@ -5101,27 +5103,12 @@
   { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },
 
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B,
-    RS6000_BTI_V16QI, RS6000_BTI_V4SI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTSI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B,
-    RS6000_BTI_V16QI, RS6000_BTI_unsigned_V4SI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTSI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B,
+  { P9V_BUILTIN_VEC_INSERT4B, P9V_BUILTIN_INSERT4B,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_V4SI,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI },
+  { P9V_BUILTIN_VEC_INSERT4B, P9V_BUILTIN_INSERT4B,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V4SI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTSI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
-    RS6000_BTI_V16QI, RS6000_BTI_INTDI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTDI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTDI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTDI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTDI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI },
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI },
 
   { P8V_BUILTIN_VEC_VADDECUQ, P8V_BUILTIN_VADDECUQ,
     RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI },
@@ -6088,6 +6075,15 @@
       stmt = build_binary_op (loc, PLUS_EXPR, stmt, arg2, 1);
       stmt = build_indirect_ref (loc, stmt, RO_NULL);
 
+      /* PR83660: We mark this as having side effects so that
+	 downstream in fold_build_cleanup_point_expr () it will get a
+	 CLEANUP_POINT_EXPR.  If it does not we can run into an ICE
+	 later in gimplify_cleanup_point_expr ().  Potentially this
+	 causes missed optimization because the actually is no side
+	 effect.  */
+      if (c_dialect_cxx ())
+	TREE_SIDE_EFFECTS (stmt) = 1;
+
       return stmt;
     }
 
diff -ruN gcc-7.3.0/gcc/config/rs6000/rs6000.h gcc-7.3.0-msp430/gcc/config/rs6000/rs6000.h
--- gcc-7.3.0/gcc/config/rs6000/rs6000.h	2017-03-22 10:47:55.458489000 -0700
+++ gcc-7.3.0-msp430/gcc/config/rs6000/rs6000.h	2019-06-25 02:27:21.097931448 -0700
@@ -1,5 +1,5 @@
 /* Definitions of target machine for GNU compiler, for IBM RS/6000.
-   Copyright (C) 1992-2017 Free Software Foundation, Inc.
+   Copyright (C) 1992-2018 Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
    This file is part of GCC.
@@ -110,7 +110,8 @@
 /* Common ASM definitions used by ASM_SPEC among the various targets for
    handling -mcpu=xxx switches.  There is a parallel list in driver-rs6000.c to
    provide the default assembler options if the user uses -mcpu=native, so if
-   you make changes here, make them also there.  */
+   you make changes here, make them also there.  PR63177: Do not pass -mpower8
+   to the assembler if -mpower9-vector was also used.  */
 #define ASM_CPU_SPEC \
 "%{!mcpu*: \
   %{mpowerpc64*: -mppc64} \
@@ -124,7 +125,7 @@
 %{mcpu=power6: %(asm_cpu_power6) -maltivec} \
 %{mcpu=power6x: %(asm_cpu_power6) -maltivec} \
 %{mcpu=power7: %(asm_cpu_power7)} \
-%{mcpu=power8: %(asm_cpu_power8)} \
+%{mcpu=power8: %{!mpower9-vector: %(asm_cpu_power8)}} \
 %{mcpu=power9: %(asm_cpu_power9)} \
 %{mcpu=a2: -ma2} \
 %{mcpu=powerpc: -mppc} \
@@ -173,6 +174,7 @@
 %{maltivec: -maltivec} \
 %{mvsx: -mvsx %{!maltivec: -maltivec} %{!mcpu*: %(asm_cpu_power7)}} \
 %{mpower8-vector|mcrypto|mdirect-move|mhtm: %{!mcpu*: %(asm_cpu_power8)}} \
+%{mpower9-vector: %{!mcpu*|mcpu=power8: %(asm_cpu_power9)}} \
 -many"
 
 #define CPP_DEFAULT_SPEC ""
@@ -2735,6 +2737,7 @@
 #define RS6000_BTM_HARD_FLOAT	MASK_SOFT_FLOAT	/* Hardware floating point.  */
 #define RS6000_BTM_LDBL128	MASK_MULTIPLE	/* 128-bit long double.  */
 #define RS6000_BTM_64BIT	MASK_64BIT	/* 64-bit addressing.  */
+#define RS6000_BTM_POWERPC64	MASK_POWERPC64	/* 64-bit registers.  */
 #define RS6000_BTM_FLOAT128	MASK_FLOAT128_TYPE /* IEEE 128-bit float.  */
 
 #define RS6000_BTM_COMMON	(RS6000_BTM_ALTIVEC			\
@@ -2754,6 +2757,7 @@
 				 | RS6000_BTM_DFP			\
 				 | RS6000_BTM_HARD_FLOAT		\
 				 | RS6000_BTM_LDBL128			\
+				 | RS6000_BTM_POWERPC64			\
 				 | RS6000_BTM_FLOAT128)
 
 /* Define builtin enum index.  */
diff -ruN gcc-7.3.0/gcc/config/rs6000/rs6000.md gcc-7.3.0-msp430/gcc/config/rs6000/rs6000.md
--- gcc-7.3.0/gcc/config/rs6000/rs6000.md	2018-01-21 05:32:58.843504000 -0800
+++ gcc-7.3.0-msp430/gcc/config/rs6000/rs6000.md	2019-06-25 02:27:21.097931448 -0700
@@ -1,5 +1,5 @@
 ;; Machine description for IBM RISC System 6000 (POWER) for GNU C compiler
-;; Copyright (C) 1990-2017 Free Software Foundation, Inc.
+;; Copyright (C) 1990-2018 Free Software Foundation, Inc.
 ;; Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
 ;; This file is part of GCC.
@@ -135,9 +135,7 @@
    UNSPEC_CDTBCD
    UNSPEC_CBCDTD
    UNSPEC_DIVE
-   UNSPEC_DIVEO
    UNSPEC_DIVEU
-   UNSPEC_DIVEUO
    UNSPEC_UNPACK_128BIT
    UNSPEC_PACK_128BIT
    UNSPEC_LSQ
@@ -544,7 +542,7 @@
 (define_code_attr su [(sign_extend	"s")
 		      (zero_extend	"u")
 		      (fix		"s")
-		      (unsigned_fix	"s")
+		      (unsigned_fix	"u")
 		      (float		"s")
 		      (unsigned_float	"u")])
 
@@ -4757,12 +4755,19 @@
 {
   if (FLOAT128_IEEE_P (<MODE>mode))
     {
+      rtx dest = operands[0];
+      rtx src = operands[1];
+      rtx tmp = gen_reg_rtx (DImode);
+      rtx dest_di = gen_lowpart (DImode, dest);
+
       if (<MODE>mode == KFmode)
-	emit_insn (gen_signbitkf2_dm (operands[0], operands[1]));
+	emit_insn (gen_signbitkf2_dm (tmp, src));
       else if (<MODE>mode == TFmode)
-	emit_insn (gen_signbittf2_dm (operands[0], operands[1]));
+	emit_insn (gen_signbittf2_dm (tmp, src));
       else
 	gcc_unreachable ();
+
+      emit_insn (gen_lshrdi3 (dest_di, tmp, GEN_INT (63)));
       DONE;
     }
   operands[2] = gen_reg_rtx (DFmode);
@@ -4783,6 +4788,66 @@
     }
 })
 
+;; Optimize IEEE 128-bit signbit on 64-bit systems with direct move to avoid
+;; multiple direct moves.  If we used a SUBREG:DI of the Floa128 type, the
+;; register allocator would typically move the entire _Float128 item to GPRs (2
+;; instructions on ISA 3.0, 3-4 instructions on ISA 2.07).
+;;
+;; After register allocation, if the _Float128 had originally been in GPRs, the
+;; split allows the post reload phases to eliminate the move, and do the shift
+;; directly with the register that contains the signbit.
+(define_insn_and_split "signbit<mode>2_dm"
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r")
+	(unspec:DI [(match_operand:SIGNBIT 1 "gpc_reg_operand" "wa,r")]
+		   UNSPEC_SIGNBIT))]
+  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
+  "@
+   mfvsrd %0,%x1
+   #"
+  "&& reload_completed && int_reg_operand (operands[1], <MODE>mode)"
+  [(set (match_dup 0)
+	(match_dup 2))]
+{
+  operands[2] = gen_highpart (DImode, operands[1]);
+}
+ [(set_attr "type" "mftgpr,*")])
+
+;; Optimize IEEE 128-bit signbit on to avoid loading the value into a vector
+;; register and then doing a direct move if the value comes from memory.  On
+;; little endian, we have to load the 2nd double-word to get the sign bit.
+(define_insn_and_split "*signbit<mode>2_dm_mem"
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=b")
+	(unspec:DI [(match_operand:SIGNBIT 1 "memory_operand" "m")]
+		   UNSPEC_SIGNBIT))]
+  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
+  "#"
+  "&& 1"
+  [(set (match_dup 0)
+	(match_dup 2))]
+{
+  rtx dest = operands[0];
+  rtx src = operands[1];
+  rtx addr = XEXP (src, 0);
+
+  if (WORDS_BIG_ENDIAN)
+    operands[2] = adjust_address (src, DImode, 0);
+
+  else if (REG_P (addr) || SUBREG_P (addr))
+    operands[2] = adjust_address (src, DImode, 8);
+
+  else if (GET_CODE (addr) == PLUS && REG_P (XEXP (addr, 0))
+	   && CONST_INT_P (XEXP (addr, 1)) && mem_operand_gpr (src, DImode))
+    operands[2] = adjust_address (src, DImode, 8);
+
+  else
+    {
+      rtx tmp = can_create_pseudo_p () ? gen_reg_rtx (DImode) : dest;
+      emit_insn (gen_rtx_SET (tmp, addr));
+      operands[2] = change_address (src, DImode,
+				    gen_rtx_PLUS (DImode, tmp, GEN_INT (8)));
+    }
+})
+
 (define_expand "copysign<mode>3"
   [(set (match_dup 3)
         (abs:SFDF (match_operand:SFDF 1 "gpc_reg_operand" "")))
@@ -4812,54 +4877,6 @@
    operands[5] = CONST0_RTX (<MODE>mode);
   })
 
-;; Optimize signbit on 64-bit systems with direct move to avoid doing the store
-;; and load.
-(define_insn_and_split "signbit<mode>2_dm"
-  [(set (match_operand:SI 0 "gpc_reg_operand" "=r,r,r")
-	(unspec:SI
-	 [(match_operand:SIGNBIT 1 "input_operand" "wa,m,r")]
-	 UNSPEC_SIGNBIT))]
-  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "#"
-  "&& reload_completed"
-  [(const_int 0)]
-{
-  rs6000_split_signbit (operands[0], operands[1]);
-  DONE;
-}
- [(set_attr "length" "8,8,4")
-  (set_attr "type" "mftgpr,load,integer")])
-
-(define_insn_and_split "*signbit<mode>2_dm_<su>ext"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r,r")
-	(any_extend:DI
-	 (unspec:SI
-	  [(match_operand:SIGNBIT 1 "input_operand" "wa,m,r")]
-	  UNSPEC_SIGNBIT)))]
-  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "#"
-  "&& reload_completed"
-  [(const_int 0)]
-{
-  rs6000_split_signbit (operands[0], operands[1]);
-  DONE;
-}
- [(set_attr "length" "8,8,4")
-  (set_attr "type" "mftgpr,load,integer")])
-
-;; MODES_TIEABLE_P doesn't allow DImode to be tied with the various floating
-;; point types, which makes normal SUBREG's problematical. Instead use a
-;; special pattern to avoid using a normal movdi.
-(define_insn "signbit<mode>2_dm2"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r")
-	(unspec:DI [(match_operand:SIGNBIT 1 "gpc_reg_operand" "wa")
-		    (const_int 0)]
-		   UNSPEC_SIGNBIT))]
-  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "mfvsrd %0,%x1"
- [(set_attr "type" "mftgpr")])
-
-
 ;; Use an unspec rather providing an if-then-else in RTL, to prevent the
 ;; compiler from optimizing -0.0
 (define_insn "copysign<mode>3_fcpsgn"
@@ -5694,45 +5711,59 @@
    xscvdpsxds %x0,%x1"
   [(set_attr "type" "fp")])
 
-(define_expand "fix_trunc<SFDF:mode><QHI:mode>2"
-  [(parallel [(set (match_operand:<QHI:MODE> 0 "nonimmediate_operand")
-		   (fix:QHI (match_operand:SFDF 1 "gpc_reg_operand")))
-	      (clobber (match_scratch:DI 2))])]
-  "TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT
-   && TARGET_VSX_SMALL_INTEGER"
+;; If we have ISA 3.0, QI/HImode values can go in both VSX registers and GPR
+;; registers.  If we have ISA 2.07, we don't allow QI/HImode values in the
+;; vector registers, so we need to do direct moves to the GPRs, but SImode
+;; values can go in VSX registers.  Keeping the direct move part through
+;; register allocation prevents the register allocator from doing a direct move
+;; of the SImode value to a GPR, and then a store/load.
+(define_insn_and_split "fix<uns>_trunc<SFDF:mode><QHI:mode>2"
+  [(set (match_operand:<QHI:MODE> 0 "gpc_reg_operand" "=wJ,wJwK,r")
+	(any_fix:QHI (match_operand:SFDF 1 "gpc_reg_operand" "wJ,wJwK,wa")))
+   (clobber (match_scratch:SI 2 "=X,X,wi"))]
+  "TARGET_DIRECT_MOVE"
+  "@
+   fctiw<u>z %0,%1
+   xscvdp<su>xws %x0,%x1
+   #"
+  "&& reload_completed && int_reg_operand (operands[0], <QHI:MODE>mode)"
+  [(set (match_dup 2)
+	(any_fix:SI (match_dup 1)))
+   (set (match_dup 3)
+	(match_dup 2))]
 {
-  if (MEM_P (operands[0]))
-    operands[0] = rs6000_address_for_fpconvert (operands[0]);
-})
+  operands[3] = gen_rtx_REG (SImode, REGNO (operands[0]));
+}
+  [(set_attr "length" "4,4,8")
+   (set_attr "type" "fp")])
 
-(define_insn_and_split "*fix_trunc<SFDF:mode><QHI:mode>2_internal"
-  [(set (match_operand:<QHI:MODE> 0 "reg_or_indexed_operand" "=wIwJ,rZ")
-	(fix:QHI
-	 (match_operand:SFDF 1 "gpc_reg_operand" "<SFDF:Fv>,<SFDF:Fv>")))
-   (clobber (match_scratch:DI 2 "=X,wi"))]
-  "TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT
-   && TARGET_VSX_SMALL_INTEGER"
+(define_insn "*fix<uns>_trunc<SFDF:mode>si2_p8"
+  [(set (match_operand:SI 0 "gpc_reg_operand" "=d,wa")
+	(any_fix:SI (match_operand:SFDF 1 "gpc_reg_operand" "d,wa")))]
+  "TARGET_DIRECT_MOVE"
+  "@
+   fctiw<u>z %0,%1
+   xscvdp<su>xws %x0,%x1"
+  [(set_attr "type" "fp")])
+
+;; Keep the convert and store together through register allocation to prevent
+;; the register allocator from getting clever and doing a direct move to a GPR
+;; and then store for reg+offset stores.
+(define_insn_and_split "*fix<uns>_trunc<SFDF:mode><QHSI:mode>2_mem"
+  [(set (match_operand:QHSI 0 "memory_operand" "=Z")
+	(any_fix:QHSI (match_operand:SFDF 1 "gpc_reg_operand" "wa")))
+   (clobber (match_scratch:SI 2 "=wa"))]
+    "(<QHSI:MODE>mode == SImode && TARGET_P8_VECTOR) || TARGET_P9_VECTOR"
   "#"
   "&& reload_completed"
-  [(const_int 0)]
+  [(set (match_dup 2)
+	(any_fix:SI (match_dup 1)))
+   (set (match_dup 0)
+	(match_dup 3))]
 {
-  rtx dest = operands[0];
-  rtx src = operands[1];
-
-  if (vsx_register_operand (dest, <QHI:MODE>mode))
-    {
-      rtx di_dest = gen_rtx_REG (DImode, REGNO (dest));
-      emit_insn (gen_fix_trunc<SFDF:mode>di2 (di_dest, src));
-    }
-  else
-    {
-      rtx tmp = operands[2];
-      rtx tmp2 = gen_rtx_REG (<QHI:MODE>mode, REGNO (tmp));
-
-      emit_insn (gen_fix_trunc<SFDF:mode>di2 (tmp, src));
-      emit_move_insn (dest, tmp2);
-    }
-  DONE;
+  operands[3] = (<QHSI:MODE>mode == SImode
+		 ? operands[2]
+		 : gen_rtx_REG (<QHSI:MODE>mode, REGNO (operands[2])));
 })
 
 (define_expand "fixuns_trunc<mode>si2"
@@ -5801,75 +5832,6 @@
    xscvdpuxds %x0,%x1"
   [(set_attr "type" "fp")])
 
-(define_expand "fixuns_trunc<SFDF:mode><QHI:mode>2"
-  [(parallel [(set (match_operand:<QHI:MODE> 0 "nonimmediate_operand")
-		   (unsigned_fix:QHI (match_operand:SFDF 1 "gpc_reg_operand")))
-	      (clobber (match_scratch:DI 2))])]
-  "TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT
-   && TARGET_VSX_SMALL_INTEGER"
-{
-  if (MEM_P (operands[0]))
-    operands[0] = rs6000_address_for_fpconvert (operands[0]);
-})
-
-(define_insn_and_split "*fixuns_trunc<SFDF:mode><QHI:mode>2_internal"
-  [(set (match_operand:<QHI:MODE> 0 "reg_or_indexed_operand" "=wIwJ,rZ")
-	(unsigned_fix:QHI
-	 (match_operand:SFDF 1 "gpc_reg_operand" "<SFDF:Fv>,<SFDF:Fv>")))
-   (clobber (match_scratch:DI 2 "=X,wi"))]
-  "TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT
-   && TARGET_VSX_SMALL_INTEGER"
-  "#"
-  "&& reload_completed"
-  [(const_int 0)]
-{
-  rtx dest = operands[0];
-  rtx src = operands[1];
-
-  if (vsx_register_operand (dest, <QHI:MODE>mode))
-    {
-      rtx di_dest = gen_rtx_REG (DImode, REGNO (dest));
-      emit_insn (gen_fixuns_trunc<SFDF:mode>di2 (di_dest, src));
-    }
-  else
-    {
-      rtx tmp = operands[2];
-      rtx tmp2 = gen_rtx_REG (<QHI:MODE>mode, REGNO (tmp));
-
-      emit_insn (gen_fixuns_trunc<SFDF:mode>di2 (tmp, src));
-      emit_move_insn (dest, tmp2);
-    }
-  DONE;
-})
-
-;; If -mvsx-small-integer, we can represent the FIX operation directly.  On
-;; older machines, we have to use an UNSPEC to produce a SImode and move it
-;; to another location, since SImode is not allowed in vector registers.
-(define_insn "*fctiw<u>z_<mode>_smallint"
-  [(set (match_operand:SI 0 "vsx_register_operand" "=d,wi")
-	(any_fix:SI (match_operand:SFDF 1 "gpc_reg_operand" "<Ff>,<Fv>")))]
-  "TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT
-   && TARGET_VSX_SMALL_INTEGER"
-  "@
-   fctiw<u>z %0,%1
-   xscvdp<su>xws %x0,%x1"
-  [(set_attr "type" "fp")])
-
-;; Combiner pattern to prevent moving the result of converting a floating point
-;; value to 32-bit integer to GPR in order to save it.
-(define_insn_and_split "*fctiw<u>z_<mode>_mem"
-  [(set (match_operand:SI 0 "memory_operand" "=Z")
-	(any_fix:SI (match_operand:SFDF 1 "gpc_reg_operand" "wa")))
-   (clobber (match_scratch:SI 2 "=wa"))]
-  "TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT
-   && TARGET_VSX_SMALL_INTEGER"
-  "#"
-  "&& reload_completed"
-  [(set (match_dup 2)
-	(any_fix:SI (match_dup 1)))
-   (set (match_dup 0)
-	(match_dup 2))])
-
 ;; Here, we use (set (reg) (unspec:DI [(fix:SI ...)] UNSPEC_FCTIWZ))
 ;; rather than (set (subreg:SI (reg)) (fix:SI ...))
 ;; because the first makes it clear that operand 0 is not live
@@ -8678,14 +8640,14 @@
 ;;              FPR->GPR   GPR->FPR   VSX->GPR   GPR->VSX
 (define_insn "*movdi_internal64"
   [(set (match_operand:DI 0 "nonimmediate_operand"
-               "=Y,        r,         r,         r,         r,          r,
+               "=YZ,       r,         r,         r,         r,          r,
                 ^m,        ^d,        ^d,        ^wY,       $Z,         $wb,
                 $wv,       ^wi,       *wo,       *wo,       *wv,        *wi,
                 *wi,       *wv,       *wv,       r,         *h,         *h,
                 ?*r,       ?*wg,      ?*r,       ?*wj")
 
 	(match_operand:DI 1 "input_operand"
-                "r,        Y,         r,         I,         L,          nF,
+                "r,        YZ,        r,         I,         L,          nF,
                  d,        m,         d,         wb,        wv,         wY,
                  Z,        wi,        Oj,        wM,        OjwM,       Oj,
                  wM,       wS,        wB,        *h,        r,          0,
@@ -14419,14 +14381,10 @@
    (set_attr "length" "4")])
 
 (define_int_iterator UNSPEC_DIV_EXTEND [UNSPEC_DIVE
-					UNSPEC_DIVEO
-					UNSPEC_DIVEU
-					UNSPEC_DIVEUO])
+					UNSPEC_DIVEU])
 
 (define_int_attr div_extend [(UNSPEC_DIVE	"e")
-			     (UNSPEC_DIVEO	"eo")
-			     (UNSPEC_DIVEU	"eu")
-			     (UNSPEC_DIVEUO	"euo")])
+			     (UNSPEC_DIVEU	"eu")])
 
 (define_insn "div<div_extend>_<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=r")
@@ -14505,16 +14463,14 @@
    (set_attr "length" "4")])
 
 (define_insn_and_split "pack<mode>"
-  [(set (match_operand:FMOVE128 0 "register_operand" "=d,&d")
+  [(set (match_operand:FMOVE128 0 "register_operand" "=&d")
 	(unspec:FMOVE128
-	 [(match_operand:<FP128_64> 1 "register_operand" "0,d")
-	  (match_operand:<FP128_64> 2 "register_operand" "d,d")]
+	 [(match_operand:<FP128_64> 1 "register_operand" "d")
+	  (match_operand:<FP128_64> 2 "register_operand" "d")]
 	 UNSPEC_PACK_128BIT))]
   "FLOAT128_2REG_P (<MODE>mode)"
-  "@
-   fmr %L0,%2
-   #"
-  "&& reload_completed && REGNO (operands[0]) != REGNO (operands[1])"
+  "#"
+  "&& reload_completed"
   [(set (match_dup 3) (match_dup 1))
    (set (match_dup 4) (match_dup 2))]
 {
@@ -14527,8 +14483,8 @@
   operands[3] = gen_rtx_REG (<FP128_64>mode, dest_hi);
   operands[4] = gen_rtx_REG (<FP128_64>mode, dest_lo);
 }
-  [(set_attr "type" "fpsimple,fp")
-   (set_attr "length" "4,8")])
+  [(set_attr "type" "fp")
+   (set_attr "length" "8")])
 
 (define_insn "unpack<mode>"
   [(set (match_operand:DI 0 "register_operand" "=d,d")
@@ -14803,49 +14759,45 @@
    (set_attr "length" "8")])
 
 ;; Conversion between IEEE 128-bit and integer types
-(define_insn "fix_<mode>di2_hw"
-  [(set (match_operand:DI 0 "altivec_register_operand" "=v")
-	(fix:DI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
-  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
-  "xscvqpsdz %0,%1"
-  [(set_attr "type" "vecfloat")
-   (set_attr "size" "128")])
 
-(define_insn "fixuns_<mode>di2_hw"
-  [(set (match_operand:DI 0 "altivec_register_operand" "=v")
-	(unsigned_fix:DI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
-  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
-  "xscvqpudz %0,%1"
-  [(set_attr "type" "vecfloat")
-   (set_attr "size" "128")])
-
-(define_insn "fix_<mode>si2_hw"
-  [(set (match_operand:SI 0 "altivec_register_operand" "=v")
-	(fix:SI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
-  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
-  "xscvqpswz %0,%1"
+;; The fix function for DImode and SImode was declared earlier as a
+;; define_expand.  It calls into rs6000_expand_float128_convert if we don't
+;; have IEEE 128-bit hardware support.  QImode and HImode are not provided
+;; unless we have the IEEE 128-bit hardware.
+;;
+;; Unlike the code for converting SFmode/DFmode to QImode/HImode, we don't have
+;; to provide a GPR target that used direct move and a conversion in the GPR
+;; which works around QImode/HImode not being allowed in vector registers in
+;; ISA 2.07 (power8).
+(define_insn "fix<uns>_<IEEE128:mode><SDI:mode>2_hw"
+  [(set (match_operand:SDI 0 "altivec_register_operand" "=v")
+	(any_fix:SDI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
+  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<IEEE128:MODE>mode)"
+  "xscvqp<su><wd>z %0,%1"
   [(set_attr "type" "vecfloat")
    (set_attr "size" "128")])
 
-(define_insn "fixuns_<mode>si2_hw"
-  [(set (match_operand:SI 0 "altivec_register_operand" "=v")
-	(unsigned_fix:SI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
-  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
-  "xscvqpuwz %0,%1"
+(define_insn "fix<uns>_trunc<IEEE128:mode><QHI:mode>2"
+  [(set (match_operand:QHI 0 "altivec_register_operand" "=v")
+	(any_fix:QHI
+	 (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
+  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<IEEE128:MODE>mode)"
+  "xscvqp<su>wz %0,%1"
   [(set_attr "type" "vecfloat")
    (set_attr "size" "128")])
 
-;; Combiner pattern to prevent moving the result of converting an IEEE 128-bit
-;; floating point value to 32-bit integer to GPR in order to save it.
-(define_insn_and_split "*fix<uns>_<mode>_mem"
-  [(set (match_operand:SI 0 "memory_operand" "=Z")
-	(any_fix:SI (match_operand:IEEE128 1 "altivec_register_operand" "v")))
-   (clobber (match_scratch:SI 2 "=v"))]
+;; Combiner patterns to prevent moving the result of converting an IEEE 128-bit
+;; floating point value to 8/16/32-bit integer to GPR in order to save it.
+(define_insn_and_split "*fix<uns>_trunc<IEEE128:mode><QHSI:mode>2_mem"
+  [(set (match_operand:QHSI 0 "memory_operand" "=Z")
+	(any_fix:QHSI
+	 (match_operand:IEEE128 1 "altivec_register_operand" "v")))
+   (clobber (match_scratch:QHSI 2 "=v"))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "#"
   "&& reload_completed"
   [(set (match_dup 2)
-	(any_fix:SI (match_dup 1)))
+	(any_fix:QHSI (match_dup 1)))
    (set (match_dup 0)
 	(match_dup 2))])
 
diff -ruN gcc-7.3.0/gcc/config/rs6000/rs6000-protos.h gcc-7.3.0-msp430/gcc/config/rs6000/rs6000-protos.h
--- gcc-7.3.0/gcc/config/rs6000/rs6000-protos.h	2017-12-14 09:43:32.480043000 -0800
+++ gcc-7.3.0-msp430/gcc/config/rs6000/rs6000-protos.h	2019-06-25 02:27:21.093931475 -0700
@@ -139,7 +139,6 @@
 extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);
 extern int rs6000_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);
 extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);
-extern void rs6000_split_signbit (rtx, rtx);
 extern void rs6000_expand_atomic_compare_and_swap (rtx op[]);
 extern void rs6000_expand_atomic_exchange (rtx op[]);
 extern void rs6000_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);
diff -ruN gcc-7.3.0/gcc/config/rs6000/sysv4.opt gcc-7.3.0-msp430/gcc/config/rs6000/sysv4.opt
--- gcc-7.3.0/gcc/config/rs6000/sysv4.opt	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/rs6000/sysv4.opt	2019-06-25 02:27:21.097931448 -0700
@@ -27,6 +27,10 @@
 Target RejectNegative Joined Var(rs6000_sdata_name)
 Select method for sdata handling.
 
+mreadonly-in-sdata
+Target Report Var(rs6000_readonly_in_sdata) Init(1) Save
+Allow readonly data in sdata.
+
 mtls-size=
 Target RejectNegative Joined Var(rs6000_tls_size) Enum(rs6000_tls_size)
 Specify bit size of immediate TLS offsets.
diff -ruN gcc-7.3.0/gcc/config/rs6000/vector.md gcc-7.3.0-msp430/gcc/config/rs6000/vector.md
--- gcc-7.3.0/gcc/config/rs6000/vector.md	2017-06-27 09:43:35.069357000 -0700
+++ gcc-7.3.0-msp430/gcc/config/rs6000/vector.md	2019-06-25 02:27:21.097931448 -0700
@@ -180,12 +180,7 @@
       operands[1] = rs6000_address_for_altivec (operands[1]);
       rtx and_op = XEXP (operands[1], 0);
       gcc_assert (GET_CODE (and_op) == AND);
-      rtx addr = XEXP (and_op, 0);
-      if (GET_CODE (addr) == PLUS)
-        emit_insn (gen_altivec_lvx_<mode>_2op (operands[0], XEXP (addr, 0),
-	                                       XEXP (addr, 1)));
-      else
-        emit_insn (gen_altivec_lvx_<mode>_1op (operands[0], operands[1]));
+      emit_insn (gen_altivec_lvx_<mode> (operands[0], operands[1]));
       DONE;
     }
 }")
@@ -203,12 +198,7 @@
       operands[0] = rs6000_address_for_altivec (operands[0]);
       rtx and_op = XEXP (operands[0], 0);
       gcc_assert (GET_CODE (and_op) == AND);
-      rtx addr = XEXP (and_op, 0);
-      if (GET_CODE (addr) == PLUS)
-        emit_insn (gen_altivec_stvx_<mode>_2op (operands[1], XEXP (addr, 0),
-	                                        XEXP (addr, 1)));
-      else
-        emit_insn (gen_altivec_stvx_<mode>_1op (operands[1], operands[0]));
+      emit_insn (gen_altivec_stvx_<mode> (operands[1], operands[0]));
       DONE;
     }
 }")
diff -ruN gcc-7.3.0/gcc/config/rs6000/vsx.md gcc-7.3.0-msp430/gcc/config/rs6000/vsx.md
--- gcc-7.3.0/gcc/config/rs6000/vsx.md	2017-08-29 18:12:21.048080000 -0700
+++ gcc-7.3.0-msp430/gcc/config/rs6000/vsx.md	2019-06-25 02:27:21.097931448 -0700
@@ -157,6 +157,22 @@
 			 (TF	"wp")
 			 (KF	"wq")])
 
+;; A mode attribute to disparage use of GPR registers, except for scalar
+;; interger modes.
+(define_mode_attr ??r	[(V16QI "??r")
+			 (V8HI  "??r")
+			 (V4SI  "??r")
+			 (V4SF  "??r")
+			 (V2DI  "??r")
+			 (V2DF  "??r")
+			 (DI    "r")
+			 (DF    "??r")
+			 (SF    "??r")
+			 (V1TI  "??r")
+			 (TI    "r")
+			 (TF    "??r")
+			 (KF    "??r")])
+
 ;; Same size integer type for floating point data
 (define_mode_attr VSi [(V4SF  "v4si")
 		       (V2DF  "v2di")
@@ -385,7 +401,7 @@
 ;; VSX moves so they match first.
 (define_insn_and_split "*vsx_le_perm_load_<mode>"
   [(set (match_operand:VSX_D 0 "vsx_register_operand" "=<VSa>")
-        (match_operand:VSX_D 1 "memory_operand" "Z"))]
+        (match_operand:VSX_D 1 "indexed_or_indirect_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
@@ -408,7 +424,7 @@
 
 (define_insn_and_split "*vsx_le_perm_load_<mode>"
   [(set (match_operand:VSX_W 0 "vsx_register_operand" "=<VSa>")
-        (match_operand:VSX_W 1 "memory_operand" "Z"))]
+        (match_operand:VSX_W 1 "indexed_or_indirect_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
@@ -433,7 +449,7 @@
 
 (define_insn_and_split "*vsx_le_perm_load_v8hi"
   [(set (match_operand:V8HI 0 "vsx_register_operand" "=wa")
-        (match_operand:V8HI 1 "memory_operand" "Z"))]
+        (match_operand:V8HI 1 "indexed_or_indirect_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
@@ -462,7 +478,7 @@
 
 (define_insn_and_split "*vsx_le_perm_load_v16qi"
   [(set (match_operand:V16QI 0 "vsx_register_operand" "=wa")
-        (match_operand:V16QI 1 "memory_operand" "Z"))]
+        (match_operand:V16QI 1 "indexed_or_indirect_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
@@ -498,7 +514,7 @@
    (set_attr "length" "8")])
 
 (define_insn "*vsx_le_perm_store_<mode>"
-  [(set (match_operand:VSX_D 0 "memory_operand" "=Z")
+  [(set (match_operand:VSX_D 0 "indexed_or_indirect_operand" "=Z")
         (match_operand:VSX_D 1 "vsx_register_operand" "+<VSa>"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
@@ -506,7 +522,7 @@
    (set_attr "length" "12")])
 
 (define_split
-  [(set (match_operand:VSX_D 0 "memory_operand" "")
+  [(set (match_operand:VSX_D 0 "indexed_or_indirect_operand" "")
         (match_operand:VSX_D 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && !reload_completed"
   [(set (match_dup 2)
@@ -525,7 +541,7 @@
 ;; The post-reload split requires that we re-permute the source
 ;; register in case it is still live.
 (define_split
-  [(set (match_operand:VSX_D 0 "memory_operand" "")
+  [(set (match_operand:VSX_D 0 "indexed_or_indirect_operand" "")
         (match_operand:VSX_D 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && reload_completed"
   [(set (match_dup 1)
@@ -543,7 +559,7 @@
   "")
 
 (define_insn "*vsx_le_perm_store_<mode>"
-  [(set (match_operand:VSX_W 0 "memory_operand" "=Z")
+  [(set (match_operand:VSX_W 0 "indexed_or_indirect_operand" "=Z")
         (match_operand:VSX_W 1 "vsx_register_operand" "+<VSa>"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
@@ -551,7 +567,7 @@
    (set_attr "length" "12")])
 
 (define_split
-  [(set (match_operand:VSX_W 0 "memory_operand" "")
+  [(set (match_operand:VSX_W 0 "indexed_or_indirect_operand" "")
         (match_operand:VSX_W 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && !reload_completed"
   [(set (match_dup 2)
@@ -572,7 +588,7 @@
 ;; The post-reload split requires that we re-permute the source
 ;; register in case it is still live.
 (define_split
-  [(set (match_operand:VSX_W 0 "memory_operand" "")
+  [(set (match_operand:VSX_W 0 "indexed_or_indirect_operand" "")
         (match_operand:VSX_W 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && reload_completed"
   [(set (match_dup 1)
@@ -593,7 +609,7 @@
   "")
 
 (define_insn "*vsx_le_perm_store_v8hi"
-  [(set (match_operand:V8HI 0 "memory_operand" "=Z")
+  [(set (match_operand:V8HI 0 "indexed_or_indirect_operand" "=Z")
         (match_operand:V8HI 1 "vsx_register_operand" "+wa"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
@@ -601,7 +617,7 @@
    (set_attr "length" "12")])
 
 (define_split
-  [(set (match_operand:V8HI 0 "memory_operand" "")
+  [(set (match_operand:V8HI 0 "indexed_or_indirect_operand" "")
         (match_operand:V8HI 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && !reload_completed"
   [(set (match_dup 2)
@@ -626,7 +642,7 @@
 ;; The post-reload split requires that we re-permute the source
 ;; register in case it is still live.
 (define_split
-  [(set (match_operand:V8HI 0 "memory_operand" "")
+  [(set (match_operand:V8HI 0 "indexed_or_indirect_operand" "")
         (match_operand:V8HI 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && reload_completed"
   [(set (match_dup 1)
@@ -653,7 +669,7 @@
   "")
 
 (define_insn "*vsx_le_perm_store_v16qi"
-  [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+  [(set (match_operand:V16QI 0 "indexed_or_indirect_operand" "=Z")
         (match_operand:V16QI 1 "vsx_register_operand" "+wa"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
@@ -661,7 +677,7 @@
    (set_attr "length" "12")])
 
 (define_split
-  [(set (match_operand:V16QI 0 "memory_operand" "")
+  [(set (match_operand:V16QI 0 "indexed_or_indirect_operand" "")
         (match_operand:V16QI 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && !reload_completed"
   [(set (match_dup 2)
@@ -694,7 +710,7 @@
 ;; The post-reload split requires that we re-permute the source
 ;; register in case it is still live.
 (define_split
-  [(set (match_operand:V16QI 0 "memory_operand" "")
+  [(set (match_operand:V16QI 0 "indexed_or_indirect_operand" "")
         (match_operand:V16QI 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && reload_completed"
   [(set (match_dup 1)
@@ -961,7 +977,7 @@
 (define_insn "*vsx_mov<mode>_64bit"
   [(set (match_operand:VSX_M 0 "nonimmediate_operand"
                "=ZwO,      <VSa>,     <VSa>,     r,         we,        ?wQ,
-                ?&r,       ??r,       ??Y,       ??r,       wo,        v,
+                ?&r,       ??r,       ??Y,       <??r>,     wo,        v,
                 ?<VSa>,    *r,        v,         ??r,       wZ,        v")
 
 	(match_operand:VSX_M 1 "input_operand" 
@@ -990,7 +1006,7 @@
 ;;              LVX (VMX)  STVX (VMX)
 (define_insn "*vsx_mov<mode>_32bit"
   [(set (match_operand:VSX_M 0 "nonimmediate_operand"
-               "=ZwO,      <VSa>,     <VSa>,     ??r,       ??Y,       ??r,
+               "=ZwO,      <VSa>,     <VSa>,     ??r,       ??Y,       <??r>,
                 wo,        v,         ?<VSa>,    *r,        v,         ??r,
                 wZ,        v")
 
@@ -3930,7 +3946,7 @@
 	  (match_operand:DI 2 "register_operand" "+r")]
 	 UNSPEC_STXVL))]
   "TARGET_P9_VECTOR && TARGET_64BIT"
-  "sldi %2,%2\;stxvl %x0,%1,%2"
+  "sldi %2,%2,56\;stxvl %x0,%1,%2"
   [(set_attr "length" "8")
    (set_attr "type" "vecstore")])
 
@@ -4084,46 +4100,21 @@
 
 ;; Vector insert/extract word at arbitrary byte values.  Note, the little
 ;; endian version needs to adjust the byte number, and the V4SI element in
-;; vinsert4b.
-(define_expand "vextract4b"
-  [(set (match_operand:DI 0 "gpc_reg_operand")
-	(unspec:DI [(match_operand:V16QI 1 "vsx_register_operand")
-		    (match_operand:QI 2 "const_0_to_12_operand")]
-		   UNSPEC_XXEXTRACTUW))]
+;; insert4b.
+(define_insn "extract4b"
+  [(set (match_operand:V2DI 0 "vsx_register_operand")
+       (unspec:V2DI [(match_operand:V16QI 1 "vsx_register_operand" "wa")
+                     (match_operand:QI 2 "const_0_to_12_operand" "n")]
+                    UNSPEC_XXEXTRACTUW))]
   "TARGET_P9_VECTOR"
 {
   if (!VECTOR_ELT_ORDER_BIG)
     operands[2] = GEN_INT (12 - INTVAL (operands[2]));
-})
 
-(define_insn_and_split "*vextract4b_internal"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=wj,r")
-	(unspec:DI [(match_operand:V16QI 1 "vsx_register_operand" "wa,v")
-		    (match_operand:QI 2 "const_0_to_12_operand" "n,n")]
-		   UNSPEC_XXEXTRACTUW))]
-  "TARGET_P9_VECTOR"
-  "@
-   xxextractuw %x0,%x1,%2
-   #"
-  "&& reload_completed && int_reg_operand (operands[0], DImode)"
-  [(const_int 0)]
-{
-  rtx op0 = operands[0];
-  rtx op1 = operands[1];
-  rtx op2 = operands[2];
-  rtx op0_si = gen_rtx_REG (SImode, REGNO (op0));
-  rtx op1_v4si = gen_rtx_REG (V4SImode, REGNO (op1));
-
-  emit_move_insn (op0, op2);
-  if (VECTOR_ELT_ORDER_BIG)
-    emit_insn (gen_vextuwlx (op0_si, op0_si, op1_v4si));
-  else
-    emit_insn (gen_vextuwrx (op0_si, op0_si, op1_v4si));
-  DONE;
-}
-  [(set_attr "type" "vecperm")])
+  return "xxextractuw %x0,%x1,%2";
+})
 
-(define_expand "vinsert4b"
+(define_expand "insert4b"
   [(set (match_operand:V16QI 0 "vsx_register_operand")
 	(unspec:V16QI [(match_operand:V4SI 1 "vsx_register_operand")
 		       (match_operand:V16QI 2 "vsx_register_operand")
@@ -4141,7 +4132,7 @@
     }
 })
 
-(define_insn "*vinsert4b_internal"
+(define_insn "*insert4b_internal"
   [(set (match_operand:V16QI 0 "vsx_register_operand" "=wa")
 	(unspec:V16QI [(match_operand:V4SI 1 "vsx_register_operand" "wa")
 		       (match_operand:V16QI 2 "vsx_register_operand" "0")
@@ -4151,26 +4142,42 @@
   "xxinsertw %x0,%x1,%3"
   [(set_attr "type" "vecperm")])
 
-(define_expand "vinsert4b_di"
-  [(set (match_operand:V16QI 0 "vsx_register_operand")
-	(unspec:V16QI [(match_operand:DI 1 "vsx_register_operand")
-		       (match_operand:V16QI 2 "vsx_register_operand")
-		       (match_operand:QI 3 "const_0_to_12_operand")]
-		   UNSPEC_XXINSERTW))]
+(define_expand "vextract4b"
+  [(set (match_operand:DI 0 "gpc_reg_operand")
+	(unspec:DI [(match_operand:V16QI 1 "vsx_register_operand")
+		    (match_operand:QI 2 "const_0_to_12_operand")]
+		   UNSPEC_XXEXTRACTUW))]
   "TARGET_P9_VECTOR"
 {
   if (!VECTOR_ELT_ORDER_BIG)
-    operands[3] = GEN_INT (12 - INTVAL (operands[3]));
+    operands[2] = GEN_INT (12 - INTVAL (operands[2]));
 })
 
-(define_insn "*vinsert4b_di_internal"
-  [(set (match_operand:V16QI 0 "vsx_register_operand" "=wa")
-	(unspec:V16QI [(match_operand:DI 1 "vsx_register_operand" "wj")
-		       (match_operand:V16QI 2 "vsx_register_operand" "0")
-		       (match_operand:QI 3 "const_0_to_12_operand" "n")]
-		   UNSPEC_XXINSERTW))]
+(define_insn_and_split "*vextract4b_internal"
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=wj,r")
+	(unspec:DI [(match_operand:V16QI 1 "vsx_register_operand" "wa,v")
+		    (match_operand:QI 2 "const_0_to_12_operand" "n,n")]
+		   UNSPEC_XXEXTRACTUW))]
   "TARGET_P9_VECTOR"
-  "xxinsertw %x0,%x1,%3"
+  "@
+   xxextractuw %x0,%x1,%2
+   #"
+  "&& reload_completed && int_reg_operand (operands[0], DImode)"
+  [(const_int 0)]
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx op2 = operands[2];
+  rtx op0_si = gen_rtx_REG (SImode, REGNO (op0));
+  rtx op1_v4si = gen_rtx_REG (V4SImode, REGNO (op1));
+
+  emit_move_insn (op0, op2);
+  if (VECTOR_ELT_ORDER_BIG)
+    emit_insn (gen_vextuwlx (op0_si, op0_si, op1_v4si));
+  else
+    emit_insn (gen_vextuwrx (op0_si, op0_si, op1_v4si));
+  DONE;
+}
   [(set_attr "type" "vecperm")])
 
 
diff -ruN gcc-7.3.0/gcc/config/rtems.h gcc-7.3.0-msp430/gcc/config/rtems.h
--- gcc-7.3.0/gcc/config/rtems.h	2017-07-26 01:31:09.591470000 -0700
+++ gcc-7.3.0-msp430/gcc/config/rtems.h	2019-06-25 02:27:21.097931448 -0700
@@ -48,3 +48,7 @@
  -latomic -lc -lgcc --end-group %{!qnolinkcmds: -T linkcmds%s}}}"
 
 #define TARGET_POSIX_IO
+
+/* Prefer int for int32_t (see stdint-newlib.h).  */
+#undef STDINT_LONG32
+#define STDINT_LONG32 (INT_TYPE_SIZE != 32 && LONG_TYPE_SIZE == 32)
diff -ruN gcc-7.3.0/gcc/config/s390/s390-builtins.def gcc-7.3.0-msp430/gcc/config/s390/s390-builtins.def
--- gcc-7.3.0/gcc/config/s390/s390-builtins.def	2017-03-24 07:04:12.686653000 -0700
+++ gcc-7.3.0-msp430/gcc/config/s390/s390-builtins.def	2019-06-25 02:27:21.097931448 -0700
@@ -294,7 +294,7 @@
    flags: Flags applying to all its variants should be mentioned in the OB_DEF line instead.  */
 
 
-B_DEF      (tbeginc,                    tbeginc,            0,                  B_HTM,              0,                  BT_FN_INT)
+B_DEF      (tbeginc,                    tbeginc,            0,                  B_HTM,              0,                  BT_FN_VOID)
 B_DEF      (tbegin,                     tbegin,             returns_twice_attr, B_HTM,              0,                  BT_FN_INT_VOIDPTR)
 B_DEF      (tbegin_nofloat,             tbegin_nofloat,     returns_twice_attr, B_HTM,              0,                  BT_FN_INT_VOIDPTR)
 B_DEF      (tbegin_retry,               tbegin_retry,       returns_twice_attr, B_HTM,              0,                  BT_FN_INT_VOIDPTR_INT)
diff -ruN gcc-7.3.0/gcc/config/s390/s390-builtin-types.def gcc-7.3.0-msp430/gcc/config/s390/s390-builtin-types.def
--- gcc-7.3.0/gcc/config/s390/s390-builtin-types.def	2017-03-24 07:04:12.686653000 -0700
+++ gcc-7.3.0-msp430/gcc/config/s390/s390-builtin-types.def	2019-06-25 02:27:21.097931448 -0700
@@ -124,6 +124,7 @@
 DEF_OPAQUE_VECTOR_TYPE (BT_BV4SI, BT_BINT, 4)
 DEF_FN_TYPE_0 (BT_FN_INT, BT_INT)
 DEF_FN_TYPE_0 (BT_FN_UINT, BT_UINT)
+DEF_FN_TYPE_0 (BT_FN_VOID, BT_VOID)
 DEF_FN_TYPE_1 (BT_FN_INT_INT, BT_INT, BT_INT)
 DEF_FN_TYPE_1 (BT_FN_INT_VOIDPTR, BT_INT, BT_VOIDPTR)
 DEF_FN_TYPE_1 (BT_FN_OV4SI_INT, BT_OV4SI, BT_INT)
diff -ruN gcc-7.3.0/gcc/config/s390/s390.c gcc-7.3.0-msp430/gcc/config/s390/s390.c
--- gcc-7.3.0/gcc/config/s390/s390.c	2017-07-31 04:33:18.182361000 -0700
+++ gcc-7.3.0-msp430/gcc/config/s390/s390.c	2019-06-25 02:27:21.101931418 -0700
@@ -377,84 +377,6 @@
   bool literal_pool;
 };
 
-/* The following structure is embedded in the machine
-   specific part of struct function.  */
-
-struct GTY (()) s390_frame_layout
-{
-  /* Offset within stack frame.  */
-  HOST_WIDE_INT gprs_offset;
-  HOST_WIDE_INT f0_offset;
-  HOST_WIDE_INT f4_offset;
-  HOST_WIDE_INT f8_offset;
-  HOST_WIDE_INT backchain_offset;
-
-  /* Number of first and last gpr where slots in the register
-     save area are reserved for.  */
-  int first_save_gpr_slot;
-  int last_save_gpr_slot;
-
-  /* Location (FP register number) where GPRs (r0-r15) should
-     be saved to.
-      0 - does not need to be saved at all
-     -1 - stack slot  */
-#define SAVE_SLOT_NONE   0
-#define SAVE_SLOT_STACK -1
-  signed char gpr_save_slots[16];
-
-  /* Number of first and last gpr to be saved, restored.  */
-  int first_save_gpr;
-  int first_restore_gpr;
-  int last_save_gpr;
-  int last_restore_gpr;
-
-  /* Bits standing for floating point registers. Set, if the
-     respective register has to be saved. Starting with reg 16 (f0)
-     at the rightmost bit.
-     Bit 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
-     fpr 15 13 11  9 14 12 10  8  7  5  3  1  6  4  2  0
-     reg 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16  */
-  unsigned int fpr_bitmap;
-
-  /* Number of floating point registers f8-f15 which must be saved.  */
-  int high_fprs;
-
-  /* Set if return address needs to be saved.
-     This flag is set by s390_return_addr_rtx if it could not use
-     the initial value of r14 and therefore depends on r14 saved
-     to the stack.  */
-  bool save_return_addr_p;
-
-  /* Size of stack frame.  */
-  HOST_WIDE_INT frame_size;
-};
-
-/* Define the structure for the machine field in struct function.  */
-
-struct GTY(()) machine_function
-{
-  struct s390_frame_layout frame_layout;
-
-  /* Literal pool base register.  */
-  rtx base_reg;
-
-  /* True if we may need to perform branch splitting.  */
-  bool split_branches_pending_p;
-
-  bool has_landing_pad_p;
-
-  /* True if the current function may contain a tbegin clobbering
-     FPRs.  */
-  bool tbegin_p;
-
-  /* For -fsplit-stack support: A stack local which holds a pointer to
-     the stack arguments for a function with a variable number of
-     arguments.  This is set at the start of the function and is used
-     to initialize the overflow_arg_area field of the va_list
-     structure.  */
-  rtx split_stack_varargs_pointer;
-};
-
 /* Few accessor macros for struct cfun->machine->s390_frame_layout.  */
 
 #define cfun_frame_layout (cfun->machine->frame_layout)
@@ -495,6 +417,33 @@
    bytes on a z10 (or higher) CPU.  */
 #define PREDICT_DISTANCE (TARGET_Z10 ? 384 : 2048)
 
+/* Masks per jump target register indicating which thunk need to be
+   generated.  */
+static GTY(()) int indirect_branch_prez10thunk_mask = 0;
+static GTY(()) int indirect_branch_z10thunk_mask = 0;
+
+#define INDIRECT_BRANCH_NUM_OPTIONS 4
+
+enum s390_indirect_branch_option
+  {
+    s390_opt_indirect_branch_jump = 0,
+    s390_opt_indirect_branch_call,
+    s390_opt_function_return_reg,
+    s390_opt_function_return_mem
+  };
+
+static GTY(()) int indirect_branch_table_label_no[INDIRECT_BRANCH_NUM_OPTIONS] = { 0 };
+const char *indirect_branch_table_label[INDIRECT_BRANCH_NUM_OPTIONS] = \
+  { "LJUMP", "LCALL", "LRETREG", "LRETMEM" };
+const char *indirect_branch_table_name[INDIRECT_BRANCH_NUM_OPTIONS] =	\
+  { ".s390_indirect_jump", ".s390_indirect_call",
+    ".s390_return_reg", ".s390_return_mem" };
+
+bool
+s390_return_addr_from_memory ()
+{
+  return cfun_gpr_save_slot(RETURN_REGNUM) == SAVE_SLOT_STACK;
+}
 
 /* Indicate which ABI has been used for passing vector args.
    0 - no vector type arguments have been passed where the ABI is relevant
@@ -1148,9 +1097,83 @@
   return NULL_TREE;
 }
 
+/* Check syntax of function decl attributes having a string type value.  */
+
+static tree
+s390_handle_string_attribute (tree *node, tree name ATTRIBUTE_UNUSED,
+			      tree args ATTRIBUTE_UNUSED,
+			      int flags ATTRIBUTE_UNUSED,
+			      bool *no_add_attrs)
+{
+  tree cst;
+
+  if (TREE_CODE (*node) != FUNCTION_DECL)
+    {
+      warning (OPT_Wattributes, "%qE attribute only applies to functions",
+	       name);
+      *no_add_attrs = true;
+    }
+
+  cst = TREE_VALUE (args);
+
+  if (TREE_CODE (cst) != STRING_CST)
+    {
+      warning (OPT_Wattributes,
+	       "%qE attribute requires a string constant argument",
+	       name);
+      *no_add_attrs = true;
+    }
+
+  if (is_attribute_p ("indirect_branch", name)
+      || is_attribute_p ("indirect_branch_call", name)
+      || is_attribute_p ("function_return", name)
+      || is_attribute_p ("function_return_reg", name)
+      || is_attribute_p ("function_return_mem", name))
+    {
+      if (strcmp (TREE_STRING_POINTER (cst), "keep") != 0
+	  && strcmp (TREE_STRING_POINTER (cst), "thunk") != 0
+	  && strcmp (TREE_STRING_POINTER (cst), "thunk-extern") != 0)
+      {
+	warning (OPT_Wattributes,
+		 "argument to %qE attribute is not "
+		 "(keep|thunk|thunk-extern)", name);
+	*no_add_attrs = true;
+      }
+    }
+
+  if (is_attribute_p ("indirect_branch_jump", name)
+      && strcmp (TREE_STRING_POINTER (cst), "keep") != 0
+      && strcmp (TREE_STRING_POINTER (cst), "thunk") != 0
+      && strcmp (TREE_STRING_POINTER (cst), "thunk-inline") != 0
+      && strcmp (TREE_STRING_POINTER (cst), "thunk-extern") != 0)
+    {
+      warning (OPT_Wattributes,
+	       "argument to %qE attribute is not "
+	       "(keep|thunk|thunk-inline|thunk-extern)", name);
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
 static const struct attribute_spec s390_attribute_table[] = {
-  { "hotpatch", 2, 2, true, false, false, s390_handle_hotpatch_attribute, false },
-  { "s390_vector_bool", 0, 0, false, true, false, s390_handle_vectorbool_attribute, true },
+  { "hotpatch", 2, 2, true, false, false,
+    s390_handle_hotpatch_attribute, false },
+  { "s390_vector_bool", 0, 0, false, true, false,
+    s390_handle_vectorbool_attribute, true },
+  { "indirect_branch", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "indirect_branch_jump", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "indirect_branch_call", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "function_return", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "function_return_reg", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "function_return_mem", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+
   /* End element.  */
   { NULL,        0, 0, false, false, false, NULL, false }
 };
@@ -8583,11 +8606,25 @@
 static rtx
 s390_execute_label (rtx insn)
 {
-  if (NONJUMP_INSN_P (insn)
+  if (INSN_P (insn)
       && GET_CODE (PATTERN (insn)) == PARALLEL
       && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == UNSPEC
-      && XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE)
-    return XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 2);
+      && (XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE
+	  || XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE_JUMP))
+    {
+      if (XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE)
+	return XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 2);
+      else
+	{
+	  gcc_assert (JUMP_P (insn));
+	  /* For jump insns as execute target:
+	     - There is one operand less in the parallel (the
+	       modification register of the execute is always 0).
+	     - The execute target label is wrapped into an
+	       if_then_else in order to hide it from jump analysis.  */
+	  return XEXP (XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 0), 0);
+	}
+    }
 
   return NULL_RTX;
 }
@@ -11273,7 +11310,6 @@
   rtx frame_pointer, return_reg, cfa_restores = NULL_RTX;
   int area_bottom, area_top, offset = 0;
   int next_offset;
-  rtvec p;
   int i;
 
   if (TARGET_TPF_PROFILING)
@@ -11427,10 +11463,15 @@
 	  if (cfun_gpr_save_slot (RETURN_REGNUM) == SAVE_SLOT_STACK)
 	    {
 	      int return_regnum = find_unused_clobbered_reg();
-	      if (!return_regnum)
-		return_regnum = 4;
+	      if (!return_regnum
+		  || (TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION
+		      && !TARGET_CPU_Z10
+		      && return_regnum == INDIRECT_BRANCH_THUNK_REGNUM))
+		{
+		  gcc_assert (INDIRECT_BRANCH_THUNK_REGNUM != 4);
+		  return_regnum = 4;
+		}
 	      return_reg = gen_rtx_REG (Pmode, return_regnum);
-
 	      addr = plus_constant (Pmode, frame_pointer,
 				    offset + cfun_frame_layout.gprs_offset
 				    + (RETURN_REGNUM
@@ -11466,16 +11507,7 @@
   s390_restore_gprs_from_fprs ();
 
   if (! sibcall)
-    {
-
-      /* Return to caller.  */
-
-      p = rtvec_alloc (2);
-
-      RTVEC_ELT (p, 0) = ret_rtx;
-      RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode, return_reg);
-      emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));
-    }
+    emit_jump_insn (gen_return_use (return_reg));
 }
 
 /* Implement TARGET_SET_UP_BY_PROLOGUE.  */
@@ -13053,6 +13085,112 @@
   final_end_function ();
 }
 
+/* Output either an indirect jump or a an indirect call
+   (RETURN_ADDR_REGNO != INVALID_REGNUM) with target register REGNO
+   using a branch trampoline disabling branch target prediction.  */
+
+void
+s390_indirect_branch_via_thunk (unsigned int regno,
+				unsigned int return_addr_regno,
+				rtx comparison_operator,
+				enum s390_indirect_branch_type type)
+{
+  enum s390_indirect_branch_option option;
+
+  if (type == s390_indirect_branch_type_return)
+    {
+      if (s390_return_addr_from_memory ())
+	option = s390_opt_function_return_mem;
+      else
+	option = s390_opt_function_return_reg;
+    }
+  else if (type == s390_indirect_branch_type_jump)
+    option = s390_opt_indirect_branch_jump;
+  else if (type == s390_indirect_branch_type_call)
+    option = s390_opt_indirect_branch_call;
+  else
+    gcc_unreachable ();
+
+  if (TARGET_INDIRECT_BRANCH_TABLE)
+    {
+      char label[32];
+
+      ASM_GENERATE_INTERNAL_LABEL (label,
+				   indirect_branch_table_label[option],
+				   indirect_branch_table_label_no[option]++);
+      ASM_OUTPUT_LABEL (asm_out_file, label);
+    }
+
+  if (return_addr_regno != INVALID_REGNUM)
+    {
+      gcc_assert (comparison_operator == NULL_RTX);
+      fprintf (asm_out_file, " \tbrasl\t%%r%d,", return_addr_regno);
+    }
+  else
+    {
+      fputs (" \tjg", asm_out_file);
+      if (comparison_operator != NULL_RTX)
+	print_operand (asm_out_file, comparison_operator, 'C');
+
+      fputs ("\t", asm_out_file);
+    }
+
+  if (TARGET_CPU_Z10)
+    fprintf (asm_out_file,
+	     TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL "\n",
+	     regno);
+  else
+    fprintf (asm_out_file,
+	     TARGET_INDIRECT_BRANCH_THUNK_NAME_EX "\n",
+	     INDIRECT_BRANCH_THUNK_REGNUM, regno);
+
+  if ((option == s390_opt_indirect_branch_jump
+       && cfun->machine->indirect_branch_jump == indirect_branch_thunk)
+      || (option == s390_opt_indirect_branch_call
+	  && cfun->machine->indirect_branch_call == indirect_branch_thunk)
+      || (option == s390_opt_function_return_reg
+	  && cfun->machine->function_return_reg == indirect_branch_thunk)
+      || (option == s390_opt_function_return_mem
+	  && cfun->machine->function_return_mem == indirect_branch_thunk))
+    {
+      if (TARGET_CPU_Z10)
+	indirect_branch_z10thunk_mask |= (1 << regno);
+      else
+	indirect_branch_prez10thunk_mask |= (1 << regno);
+    }
+}
+
+/* Output an inline thunk for indirect jumps.  EXECUTE_TARGET can
+   either be an address register or a label pointing to the location
+   of the jump instruction.  */
+
+void
+s390_indirect_branch_via_inline_thunk (rtx execute_target)
+{
+  if (TARGET_INDIRECT_BRANCH_TABLE)
+    {
+      char label[32];
+
+      ASM_GENERATE_INTERNAL_LABEL (label,
+				   indirect_branch_table_label[s390_opt_indirect_branch_jump],
+				   indirect_branch_table_label_no[s390_opt_indirect_branch_jump]++);
+      ASM_OUTPUT_LABEL (asm_out_file, label);
+    }
+
+  if (!TARGET_ZARCH)
+    fputs ("\t.machinemode zarch\n", asm_out_file);
+
+  if (REG_P (execute_target))
+    fprintf (asm_out_file, "\tex\t%%r0,0(%%r%d)\n", REGNO (execute_target));
+  else
+    output_asm_insn ("exrl\t%%r0,%0", &execute_target);
+
+  if (!TARGET_ZARCH)
+    fputs ("\t.machinemode esa\n", asm_out_file);
+
+  fputs ("0:\tj\t0b\n", asm_out_file);
+}
+
 static bool
 s390_valid_pointer_mode (machine_mode mode)
 {
@@ -13158,6 +13296,14 @@
   if (!TARGET_64BIT && flag_pic && decl && !targetm.binds_local_p (decl))
     return false;
 
+  /* The thunks for indirect branches require r1 if no exrl is
+     available.  r1 might not be available when doing a sibling
+     call.  */
+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL
+      && !TARGET_CPU_Z10
+      && !decl)
+    return false;
+
   /* Register 6 on s390 is available as an argument register but unfortunately
      "caller saved". This makes functions needing this register for arguments
      not suitable for sibcalls.  */
@@ -13191,9 +13337,13 @@
 {
   bool plt_call = false;
   rtx_insn *insn;
-  rtx call;
-  rtx clobber;
-  rtvec vec;
+  rtx vec[4] = { NULL_RTX };
+  int elts = 0;
+  rtx *call = &vec[0];
+  rtx *clobber_ret_reg = &vec[1];
+  rtx *use = &vec[2];
+  rtx *clobber_thunk_reg = &vec[3];
+  int i;
 
   /* Direct function calls need special treatment.  */
   if (GET_CODE (addr_location) == SYMBOL_REF)
@@ -13245,26 +13395,58 @@
       addr_location = gen_rtx_REG (Pmode, SIBCALL_REGNUM);
     }
 
+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL
+      && GET_CODE (addr_location) != SYMBOL_REF
+      && !plt_call)
+    {
+      /* Indirect branch thunks require the target to be a single GPR.  */
+      addr_location = force_reg (Pmode, addr_location);
+
+      /* Without exrl the indirect branch thunks need an additional
+	 register for larl;ex */
+      if (!TARGET_CPU_Z10)
+	{
+	  *clobber_thunk_reg = gen_rtx_REG (Pmode, INDIRECT_BRANCH_THUNK_REGNUM);
+	  *clobber_thunk_reg = gen_rtx_CLOBBER (VOIDmode, *clobber_thunk_reg);
+	}
+    }
+
   addr_location = gen_rtx_MEM (QImode, addr_location);
-  call = gen_rtx_CALL (VOIDmode, addr_location, const0_rtx);
+  *call = gen_rtx_CALL (VOIDmode, addr_location, const0_rtx);
 
   if (result_reg != NULL_RTX)
-    call = gen_rtx_SET (result_reg, call);
+    *call = gen_rtx_SET (result_reg, *call);
 
   if (retaddr_reg != NULL_RTX)
     {
-      clobber = gen_rtx_CLOBBER (VOIDmode, retaddr_reg);
+      *clobber_ret_reg = gen_rtx_CLOBBER (VOIDmode, retaddr_reg);
 
       if (tls_call != NULL_RTX)
-	vec = gen_rtvec (3, call, clobber,
-			 gen_rtx_USE (VOIDmode, tls_call));
-      else
-	vec = gen_rtvec (2, call, clobber);
+	*use = gen_rtx_USE (VOIDmode, tls_call);
+    }
+
+
+  for (i = 0; i < 4; i++)
+    if (vec[i] != NULL_RTX)
+      elts++;
+
+  if (elts > 1)
+    {
+      rtvec v;
+      int e = 0;
+
+      v = rtvec_alloc (elts);
+      for (i = 0; i < 4; i++)
+	if (vec[i] != NULL_RTX)
+	  {
+	    RTVEC_ELT (v, e) = vec[i];
+	    e++;
+	  }
 
-      call = gen_rtx_PARALLEL (VOIDmode, vec);
+      *call = gen_rtx_PARALLEL (VOIDmode, v);
     }
 
-  insn = emit_call_insn (call);
+  insn = emit_call_insn (*call);
 
   /* 31-bit PLT stubs and tls calls use the GOT register implicitly.  */
   if ((!TARGET_64BIT && plt_call) || tls_call != NULL_RTX)
@@ -14046,7 +14228,16 @@
 	  target = emit_label (XEXP (label, 0));
 	  INSN_ADDRESSES_NEW (target, -1);
 
-	  target = emit_insn (s390_execute_target (insn));
+	  if (JUMP_P (insn))
+	    {
+	      target = emit_jump_insn (s390_execute_target (insn));
+	      /* This is important in order to keep a table jump
+		 pointing at the jump table label.  Only this makes it
+		 being recognized as table jump.  */
+	      JUMP_LABEL (target) = JUMP_LABEL (insn);
+	    }
+	  else
+	    target = emit_insn (s390_execute_target (insn));
 	  INSN_ADDRESSES_NEW (target, -1);
 	}
     }
@@ -14699,6 +14890,42 @@
   if (TARGET_64BIT && !TARGET_ZARCH_P (opts->x_target_flags))
     error ("64-bit ABI not supported in ESA/390 mode");
 
+  if (opts->x_s390_indirect_branch == indirect_branch_thunk_inline
+      || opts->x_s390_indirect_branch_call == indirect_branch_thunk_inline
+      || opts->x_s390_function_return == indirect_branch_thunk_inline
+      || opts->x_s390_function_return_reg == indirect_branch_thunk_inline
+      || opts->x_s390_function_return_mem == indirect_branch_thunk_inline)
+    error ("thunk-inline is only supported with -mindirect-branch-jump");
+
+  if (opts->x_s390_indirect_branch != indirect_branch_keep)
+    {
+      if (!opts_set->x_s390_indirect_branch_call)
+	opts->x_s390_indirect_branch_call = opts->x_s390_indirect_branch;
+
+      if (!opts_set->x_s390_indirect_branch_jump)
+	opts->x_s390_indirect_branch_jump = opts->x_s390_indirect_branch;
+    }
+
+  if (opts->x_s390_function_return != indirect_branch_keep)
+    {
+      if (!opts_set->x_s390_function_return_reg)
+	opts->x_s390_function_return_reg = opts->x_s390_function_return;
+
+      if (!opts_set->x_s390_function_return_mem)
+	opts->x_s390_function_return_mem = opts->x_s390_function_return;
+    }
+
+  if (!TARGET_CPU_ZARCH)
+    {
+      if (opts->x_s390_indirect_branch_call != indirect_branch_keep
+	  || opts->x_s390_indirect_branch_jump != indirect_branch_keep)
+	error ("-mindirect-branch* options require -march=z900 or higher");
+      if (opts->x_s390_function_return_reg != indirect_branch_keep
+	  || opts->x_s390_function_return_mem != indirect_branch_keep)
+	error ("-mfunction-return* options require -march=z900 or higher");
+    }
+
+
   /* Enable hardware transactions if available and not explicitly
      disabled by user.  E.g. with -m31 -march=zEC12 -mzarch */
   if (!TARGET_OPT_HTM_P (opts_set->x_target_flags))
@@ -15267,6 +15494,79 @@
   return ret;
 }
 
+/* Set VAL to correct enum value according to the indirect-branch or
+   function-return attribute in ATTR.  */
+
+static inline void
+s390_indirect_branch_attrvalue (tree attr, enum indirect_branch *val)
+{
+  const char *str = TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr)));
+  if (strcmp (str, "keep") == 0)
+    *val = indirect_branch_keep;
+  else if (strcmp (str, "thunk") == 0)
+    *val = indirect_branch_thunk;
+  else if (strcmp (str, "thunk-inline") == 0)
+    *val = indirect_branch_thunk_inline;
+  else if (strcmp (str, "thunk-extern") == 0)
+    *val = indirect_branch_thunk_extern;
+}
+
+/* Memorize the setting for -mindirect-branch* and -mfunction-return*
+   from either the cmdline or the function attributes in
+   cfun->machine.  */
+
+static void
+s390_indirect_branch_settings (tree fndecl)
+{
+  tree attr;
+
+  if (!fndecl)
+    return;
+
+  /* Initialize with the cmdline options and let the attributes
+     override it.  */
+  cfun->machine->indirect_branch_jump = s390_indirect_branch_jump;
+  cfun->machine->indirect_branch_call = s390_indirect_branch_call;
+
+  cfun->machine->function_return_reg = s390_function_return_reg;
+  cfun->machine->function_return_mem = s390_function_return_mem;
+
+  if ((attr = lookup_attribute ("indirect_branch",
+				DECL_ATTRIBUTES (fndecl))))
+    {
+      s390_indirect_branch_attrvalue (attr,
+				      &cfun->machine->indirect_branch_jump);
+      s390_indirect_branch_attrvalue (attr,
+				      &cfun->machine->indirect_branch_call);
+    }
+
+  if ((attr = lookup_attribute ("indirect_branch_jump",
+				DECL_ATTRIBUTES (fndecl))))
+    s390_indirect_branch_attrvalue (attr, &cfun->machine->indirect_branch_jump);
+
+  if ((attr = lookup_attribute ("indirect_branch_call",
+				DECL_ATTRIBUTES (fndecl))))
+    s390_indirect_branch_attrvalue (attr, &cfun->machine->indirect_branch_call);
+
+  if ((attr = lookup_attribute ("function_return",
+				DECL_ATTRIBUTES (fndecl))))
+    {
+      s390_indirect_branch_attrvalue (attr,
+				      &cfun->machine->function_return_reg);
+      s390_indirect_branch_attrvalue (attr,
+				      &cfun->machine->function_return_mem);
+    }
+
+  if ((attr = lookup_attribute ("function_return_reg",
+				DECL_ATTRIBUTES (fndecl))))
+    s390_indirect_branch_attrvalue (attr, &cfun->machine->function_return_reg);
+
+  if ((attr = lookup_attribute ("function_return_mem",
+				DECL_ATTRIBUTES (fndecl))))
+    s390_indirect_branch_attrvalue (attr, &cfun->machine->function_return_mem);
+}
+
+
 /* Restore targets globals from NEW_TREE and invalidate s390_previous_fndecl
    cache.  */
 
@@ -15293,7 +15593,10 @@
      several times in the course of compiling a function, and we don't want to
      slow things down too much or call target_reinit when it isn't safe.  */
   if (fndecl == s390_previous_fndecl)
-    return;
+    {
+      s390_indirect_branch_settings (fndecl);
+      return;
+    }
 
   tree old_tree;
   if (s390_previous_fndecl == NULL_TREE)
@@ -15317,6 +15620,8 @@
   if (old_tree != new_tree)
     s390_activate_target_options (new_tree);
   s390_previous_fndecl = fndecl;
+
+  s390_indirect_branch_settings (fndecl);
 }
 #endif
 
@@ -15598,6 +15903,186 @@
   return TARGET_64BIT ? HOST_WIDE_INT_1U << 52 : HOST_WIDE_INT_UC (0x20000000);
 }
 
+#ifdef HAVE_GAS_HIDDEN
+# define USE_HIDDEN_LINKONCE 1
+#else
+# define USE_HIDDEN_LINKONCE 0
+#endif
+
+/* Output an indirect branch trampoline for target register REGNO.  */
+
+static void
+s390_output_indirect_thunk_function (unsigned int regno, bool z10_p)
+{
+  tree decl;
+  char thunk_label[32];
+  int i;
+
+  if (z10_p)
+    sprintf (thunk_label, TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL, regno);
+  else
+    sprintf (thunk_label, TARGET_INDIRECT_BRANCH_THUNK_NAME_EX,
+	     INDIRECT_BRANCH_THUNK_REGNUM, regno);
+
+  decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
+		     get_identifier (thunk_label),
+		     build_function_type_list (void_type_node, NULL_TREE));
+  DECL_RESULT (decl) = build_decl (BUILTINS_LOCATION, RESULT_DECL,
+				   NULL_TREE, void_type_node);
+  TREE_PUBLIC (decl) = 1;
+  TREE_STATIC (decl) = 1;
+  DECL_IGNORED_P (decl) = 1;
+
+  if (USE_HIDDEN_LINKONCE)
+    {
+      cgraph_node::create (decl)->set_comdat_group (DECL_ASSEMBLER_NAME (decl));
+
+      targetm.asm_out.unique_section (decl, 0);
+      switch_to_section (get_named_section (decl, NULL, 0));
+
+      targetm.asm_out.globalize_label (asm_out_file, thunk_label);
+      fputs ("\t.hidden\t", asm_out_file);
+      assemble_name (asm_out_file, thunk_label);
+      putc ('\n', asm_out_file);
+      ASM_DECLARE_FUNCTION_NAME (asm_out_file, thunk_label, decl);
+    }
+  else
+    {
+      switch_to_section (text_section);
+      ASM_OUTPUT_LABEL (asm_out_file, thunk_label);
+    }
+
+  DECL_INITIAL (decl) = make_node (BLOCK);
+  current_function_decl = decl;
+  allocate_struct_function (decl, false);
+  init_function_start (decl);
+  cfun->is_thunk = true;
+  first_function_block_is_cold = false;
+  final_start_function (emit_barrier (), asm_out_file, 1);
+
+  /* This makes CFI at least usable for indirect jumps.
+
+     Stopping in the thunk: backtrace will point to the thunk target
+     is if it was interrupted by a signal.  For a call this means that
+     the call chain will be: caller->callee->thunk   */
+  if (flag_asynchronous_unwind_tables && flag_dwarf2_cfi_asm)
+    {
+      fputs ("\t.cfi_signal_frame\n", asm_out_file);
+      fprintf (asm_out_file, "\t.cfi_return_column %d\n", regno);
+      for (i = 0; i < FPR15_REGNUM; i++)
+	fprintf (asm_out_file, "\t.cfi_same_value %s\n", reg_names[i]);
+    }
+
+  if (z10_p)
+    {
+      /* exrl  0,1f  */
+
+      /* We generate a thunk for z10 compiled code although z10 is
+	 currently not enabled.  Tell the assembler to accept the
+	 instruction.  */
+      if (!TARGET_CPU_Z10)
+	{
+	  fputs ("\t.machine push\n", asm_out_file);
+	  fputs ("\t.machine z10\n", asm_out_file);
+	}
+      /* We use exrl even if -mzarch hasn't been specified on the
+	 command line so we have to tell the assembler to accept
+	 it.  */
+      if (!TARGET_ZARCH)
+	fputs ("\t.machinemode zarch\n", asm_out_file);
+
+      fputs ("\texrl\t0,1f\n", asm_out_file);
+
+      if (!TARGET_ZARCH)
+	fputs ("\t.machinemode esa\n", asm_out_file);
+
+      if (!TARGET_CPU_Z10)
+	fputs ("\t.machine pop\n", asm_out_file);
+    }
+  else if (TARGET_CPU_ZARCH)
+    {
+      /* larl %r1,1f  */
+      fprintf (asm_out_file, "\tlarl\t%%r%d,1f\n",
+	       INDIRECT_BRANCH_THUNK_REGNUM);
+
+      /* ex 0,0(%r1)  */
+      fprintf (asm_out_file, "\tex\t0,0(%%r%d)\n",
+	       INDIRECT_BRANCH_THUNK_REGNUM);
+    }
+  else
+    gcc_unreachable ();
+
+  /* 0:    j 0b  */
+  fputs ("0:\tj\t0b\n", asm_out_file);
+
+  /* 1:    br <regno>  */
+  fprintf (asm_out_file, "1:\tbr\t%%r%d\n", regno);
+
+  final_end_function ();
+  init_insn_lengths ();
+  free_after_compilation (cfun);
+  set_cfun (NULL);
+  current_function_decl = NULL;
+}
+
+/* Implement the asm.code_end target hook.  */
+
+static void
+s390_code_end (void)
+{
+  int i;
+
+  for (i = 1; i < 16; i++)
+    {
+      if (indirect_branch_z10thunk_mask & (1 << i))
+	s390_output_indirect_thunk_function (i, true);
+
+      if (indirect_branch_prez10thunk_mask & (1 << i))
+	s390_output_indirect_thunk_function (i, false);
+    }
+
+  if (TARGET_INDIRECT_BRANCH_TABLE)
+    {
+      int o;
+      int i;
+
+      for (o = 0; o < INDIRECT_BRANCH_NUM_OPTIONS; o++)
+	{
+	  if (indirect_branch_table_label_no[o] == 0)
+	    continue;
+
+	  switch_to_section (get_section (indirect_branch_table_name[o],
+					  0,
+					  NULL_TREE));
+	  for (i = 0; i < indirect_branch_table_label_no[o]; i++)
+	    {
+	      char label_start[32];
+
+	      ASM_GENERATE_INTERNAL_LABEL (label_start,
+					   indirect_branch_table_label[o], i);
+
+	      fputs ("\t.long\t", asm_out_file);
+	      assemble_name_raw (asm_out_file, label_start);
+	      fputs ("-.\n", asm_out_file);
+	    }
+	  switch_to_section (current_function_section ());
+	}
+    }
+}
+
+/* Implement the TARGET_CASE_VALUES_THRESHOLD target hook.  */
+
+unsigned int
+s390_case_values_threshold (void)
+{
+  /* Disabling branch prediction for indirect jumps makes jump tables
+     much more expensive.  */
+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP)
+    return 20;
+
+  return default_case_values_threshold ();
+}
+
 /* Initialize GCC target structure.  */
 
 #undef  TARGET_ASM_ALIGNED_HI_OP
@@ -15854,6 +16339,12 @@
 #undef TARGET_OPTION_RESTORE
 #define TARGET_OPTION_RESTORE s390_function_specific_restore
 
+#undef TARGET_ASM_CODE_END
+#define TARGET_ASM_CODE_END s390_code_end
+
+#undef TARGET_CASE_VALUES_THRESHOLD
+#define TARGET_CASE_VALUES_THRESHOLD s390_case_values_threshold
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-s390.h"
diff -ruN gcc-7.3.0/gcc/config/s390/s390.h gcc-7.3.0-msp430/gcc/config/s390/s390.h
--- gcc-7.3.0/gcc/config/s390/s390.h	2017-03-24 06:59:51.032979000 -0700
+++ gcc-7.3.0-msp430/gcc/config/s390/s390.h	2019-06-25 02:27:21.101931418 -0700
@@ -205,7 +205,7 @@
 #define OPTION_DEFAULT_SPECS 					\
   { "mode", "%{!mesa:%{!mzarch:-m%(VALUE)}}" },			\
   { "arch", "%{!march=*:-march=%(VALUE)}" },			\
-  { "tune", "%{!mtune=*:-mtune=%(VALUE)}" }
+  { "tune", "%{!mtune=*:%{!march=*:-mtune=%(VALUE)}}" }
 
 #ifdef __s390__
 extern const char *s390_host_detect_local_cpu (int argc, const char **argv);
@@ -1120,4 +1120,124 @@
     s390_register_target_pragmas ();		\
   } while (0)
 
+#ifndef USED_FOR_TARGET
+/* The following structure is embedded in the machine
+   specific part of struct function.  */
+
+struct GTY (()) s390_frame_layout
+{
+  /* Offset within stack frame.  */
+  HOST_WIDE_INT gprs_offset;
+  HOST_WIDE_INT f0_offset;
+  HOST_WIDE_INT f4_offset;
+  HOST_WIDE_INT f8_offset;
+  HOST_WIDE_INT backchain_offset;
+
+  /* Number of first and last gpr where slots in the register
+     save area are reserved for.  */
+  int first_save_gpr_slot;
+  int last_save_gpr_slot;
+
+  /* Location (FP register number) where GPRs (r0-r15) should
+     be saved to.
+      0 - does not need to be saved at all
+     -1 - stack slot  */
+#define SAVE_SLOT_NONE   0
+#define SAVE_SLOT_STACK -1
+  signed char gpr_save_slots[16];
+
+  /* Number of first and last gpr to be saved, restored.  */
+  int first_save_gpr;
+  int first_restore_gpr;
+  int last_save_gpr;
+  int last_restore_gpr;
+
+  /* Bits standing for floating point registers. Set, if the
+     respective register has to be saved. Starting with reg 16 (f0)
+     at the rightmost bit.
+     Bit 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+     fpr 15 13 11  9 14 12 10  8  7  5  3  1  6  4  2  0
+     reg 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16  */
+  unsigned int fpr_bitmap;
+
+  /* Number of floating point registers f8-f15 which must be saved.  */
+  int high_fprs;
+
+  /* Set if return address needs to be saved.
+     This flag is set by s390_return_addr_rtx if it could not use
+     the initial value of r14 and therefore depends on r14 saved
+     to the stack.  */
+  bool save_return_addr_p;
+
+  /* Size of stack frame.  */
+  HOST_WIDE_INT frame_size;
+};
+
+
+/* Define the structure for the machine field in struct function.  */
+
+struct GTY(()) machine_function
+{
+  struct s390_frame_layout frame_layout;
+
+  /* Literal pool base register.  */
+  rtx base_reg;
+
+  /* True if we may need to perform branch splitting.  */
+  bool split_branches_pending_p;
+
+  bool has_landing_pad_p;
+
+  /* True if the current function may contain a tbegin clobbering
+     FPRs.  */
+  bool tbegin_p;
+
+  /* For -fsplit-stack support: A stack local which holds a pointer to
+     the stack arguments for a function with a variable number of
+     arguments.  This is set at the start of the function and is used
+     to initialize the overflow_arg_area field of the va_list
+     structure.  */
+  rtx split_stack_varargs_pointer;
+
+  enum indirect_branch indirect_branch_jump;
+  enum indirect_branch indirect_branch_call;
+
+  enum indirect_branch function_return_mem;
+  enum indirect_branch function_return_reg;
+};
+#endif
+
+#define TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION				\
+  (cfun->machine->function_return_reg != indirect_branch_keep		\
+   || cfun->machine->function_return_mem != indirect_branch_keep)
+
+#define TARGET_INDIRECT_BRANCH_NOBP_RET					\
+  ((cfun->machine->function_return_reg != indirect_branch_keep		\
+    && !s390_return_addr_from_memory ())				\
+   || (cfun->machine->function_return_mem != indirect_branch_keep	\
+       && s390_return_addr_from_memory ()))
+
+#define TARGET_INDIRECT_BRANCH_NOBP_JUMP				\
+  (cfun->machine->indirect_branch_jump != indirect_branch_keep)
+
+#define TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK				\
+  (cfun->machine->indirect_branch_jump == indirect_branch_thunk		\
+   || cfun->machine->indirect_branch_jump == indirect_branch_thunk_extern)
+
+#define TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK			\
+  (cfun->machine->indirect_branch_jump == indirect_branch_thunk_inline)
+
+#define TARGET_INDIRECT_BRANCH_NOBP_CALL			\
+  (cfun->machine->indirect_branch_call != indirect_branch_keep)
+
+#ifndef TARGET_DEFAULT_INDIRECT_BRANCH_TABLE
+#define TARGET_DEFAULT_INDIRECT_BRANCH_TABLE 0
+#endif
+
+#define TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL "__s390_indirect_jump_r%d"
+#define TARGET_INDIRECT_BRANCH_THUNK_NAME_EX   "__s390_indirect_jump_r%duse_r%d"
+
+#define TARGET_INDIRECT_BRANCH_TABLE s390_indirect_branch_table
+
+
 #endif /* S390_H */
diff -ruN gcc-7.3.0/gcc/config/s390/s390.md gcc-7.3.0-msp430/gcc/config/s390/s390.md
--- gcc-7.3.0/gcc/config/s390/s390.md	2017-07-27 03:42:22.596756000 -0700
+++ gcc-7.3.0-msp430/gcc/config/s390/s390.md	2019-06-25 02:27:21.101931418 -0700
@@ -89,6 +89,7 @@
    UNSPEC_LTREF
    UNSPEC_INSN
    UNSPEC_EXECUTE
+   UNSPEC_EXECUTE_JUMP
 
    ; Atomic Support
    UNSPEC_MB
@@ -302,6 +303,8 @@
   [
    ; Sibling call register.
    (SIBCALL_REGNUM		 1)
+   ; A call-clobbered reg which can be used in indirect branch thunks
+   (INDIRECT_BRANCH_THUNK_REGNUM 1)
    ; Literal pool base register.
    (BASE_REGNUM			13)
    ; Return address register.
@@ -471,7 +474,10 @@
                          z196_cracked"
              (const_string "none"))
 
-(define_attr "mnemonic" "bcr_flush,unknown" (const_string "unknown"))
+; mnemonics which only get defined through if_then_else currently
+; don't get added to the list values automatically and hence need to
+; be listed here.
+(define_attr "mnemonic" "b,bas,bc,bcr_flush,unknown" (const_string "unknown"))
 
 ;; Length in bytes.
 
@@ -9069,7 +9075,7 @@
           (match_operator 1 "s390_comparison" [(reg CC_REGNUM) (const_int 0)])
           (match_operand 0 "address_operand" "ZQZR")
           (pc)))]
-  ""
+  "!TARGET_INDIRECT_BRANCH_NOBP_JUMP"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "b%C1r\t%0";
@@ -9079,6 +9085,9 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 0 "register_operand" "")
+                      (const_string "bcr") (const_string "bc")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
@@ -9090,8 +9099,26 @@
           (ANY_RETURN)
           (pc)))]
   "s390_can_use_<code>_insn ()"
-  "b%C0r\t%%r14"
-  [(set_attr "op_type" "RR")
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)
+    {
+      s390_indirect_branch_via_thunk (RETURN_REGNUM,
+				      INVALID_REGNUM,
+				      operands[0],
+				      s390_indirect_branch_type_return);
+      return "";
+    }
+  else
+    return "b%C0r\t%%r14";
+}
+  [(set (attr "op_type")
+	(if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+		      (const_string "RIL")
+		      (const_string "RR")))
+   (set (attr "mnemonic")
+	(if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+		      (const_string "brcl")
+		      (const_string "bcr")))
    (set_attr "type"  "jsr")
    (set_attr "atype" "agen")])
 
@@ -9144,7 +9171,7 @@
           (match_operator 1 "s390_comparison" [(reg CC_REGNUM) (const_int 0)])
           (pc)
           (match_operand 0 "address_operand" "ZQZR")))]
-  ""
+  "!TARGET_INDIRECT_BRANCH_NOBP_JUMP"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "b%D1r\t%0";
@@ -9154,6 +9181,9 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 0 "register_operand" "")
+                      (const_string "bcr") (const_string "bc")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
@@ -9658,21 +9688,144 @@
     ;
   else
     operands[0] = force_reg (Pmode, operands[0]);
+
+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)
+    {
+      operands[0] = force_reg (Pmode, operands[0]);
+      if (TARGET_CPU_Z10)
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_indirect_jump_via_thunkdi_z10 (operands[0]));
+	  else
+	    emit_jump_insn (gen_indirect_jump_via_thunksi_z10 (operands[0]));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_indirect_jump_via_thunkdi (operands[0]));
+	  else
+	    emit_jump_insn (gen_indirect_jump_via_thunksi (operands[0]));
+	}
+      DONE;
+    }
+
+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)
+    {
+      operands[0] = force_reg (Pmode, operands[0]);
+      rtx label_ref = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+      if (TARGET_CPU_Z10)
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_indirect_jump_via_inlinethunkdi_z10 (operands[0],
+								     label_ref));
+	  else
+	    emit_jump_insn (gen_indirect_jump_via_inlinethunksi_z10 (operands[0],
+								     label_ref));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_indirect_jump_via_inlinethunkdi (operands[0],
+								 label_ref,
+								 force_reg (Pmode, label_ref)));
+	  else
+	    emit_jump_insn (gen_indirect_jump_via_inlinethunksi (operands[0],
+								 label_ref,
+								 force_reg (Pmode, label_ref)));
+	}
+      DONE;
+    }
 })
 
-; The first constraint must be an "extra address constraint" in order
-; to trigger address reloading in LRA/reload
 (define_insn "*indirect_jump"
   [(set (pc)
-	(match_operand 0 "address_operand" "ZR,a"))]
- ""
- "@
-  b\t%a0
-  br\t%0"
- [(set_attr "op_type" "RX,RR")
+	(match_operand 0 "address_operand" "ZR"))]
+ "!TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK"
+{
+  if (get_attr_op_type (insn) == OP_TYPE_RR)
+    return "br\t%0";
+  else
+    return "b\t%a0";
+}
+ [(set (attr "op_type")
+       (if_then_else (match_operand 0 "register_operand" "")
+		     (const_string "RR") (const_string "RX")))
+  (set (attr "mnemonic")
+       (if_then_else (match_operand 0 "register_operand" "")
+		     (const_string "br") (const_string "b")))
   (set_attr "type"  "branch")
-  (set_attr "atype" "agen")
-  (set_attr "cpu_facility" "*")])
+  (set_attr "atype" "agen")])
+
+(define_insn "indirect_jump_via_thunk<mode>_z10"
+  [(set (pc)
+	(match_operand:P 0 "register_operand" "a"))]
+ "TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK
+  && TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  INVALID_REGNUM,
+				  NULL_RTX,
+				  s390_indirect_branch_type_jump);
+  return "";
+}
+ [(set_attr "op_type"  "RIL")
+  (set_attr "mnemonic" "jg")
+  (set_attr "type"  "branch")
+  (set_attr "atype" "agen")])
+
+(define_insn "indirect_jump_via_thunk<mode>"
+  [(set (pc)
+	(match_operand:P 0 "register_operand" " a"))
+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+ "TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK
+  && !TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  INVALID_REGNUM,
+				  NULL_RTX,
+				  s390_indirect_branch_type_jump);
+  return "";
+}
+ [(set_attr "op_type"  "RIL")
+  (set_attr "mnemonic" "jg")
+  (set_attr "type"  "branch")
+  (set_attr "atype" "agen")])
+
+
+; The label_ref is wrapped into an if_then_else in order to hide it
+; from mark_jump_label.  Without this the label_ref would become the
+; ONLY jump target of that jump breaking the control flow graph.
+(define_insn "indirect_jump_via_inlinethunk<mode>_z10"
+  [(unspec [(if_then_else (match_operand:P 1 "larl_operand" "X")
+			  (const_int 0)
+			  (const_int 0))
+	    (const_int 0)] UNSPEC_EXECUTE_JUMP)
+   (set (pc) (match_operand:P 0 "register_operand" "a"))]
+  "TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK
+   && TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_inline_thunk (operands[1]);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "type"    "branch")
+   (set_attr "length"  "10")])
+
+(define_insn "indirect_jump_via_inlinethunk<mode>"
+  [(unspec [(if_then_else (match_operand:P 1 "larl_operand" "X")
+			  (const_int 0)
+			  (const_int 0))
+	    (match_operand:P 2 "register_operand" "a")] UNSPEC_EXECUTE_JUMP)
+   (set (pc) (match_operand:P 0 "register_operand" "a"))]
+  "TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK
+   && !TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_inline_thunk (operands[2]);
+  return "";
+}
+  [(set_attr "op_type" "RX")
+   (set_attr "type"    "branch")
+   (set_attr "length"  "8")])
 
 ; FIXME: LRA does not appear to be able to deal with MEMs being
 ; checked against address constraints like ZR above.  So make this a
@@ -9680,7 +9833,7 @@
 (define_insn "*indirect2_jump"
   [(set (pc)
 	(match_operand 0 "nonimmediate_operand" "a,T"))]
- ""
+ "!TARGET_INDIRECT_BRANCH_NOBP_JUMP"
  "@
   br\t%0
   bi\t%0"
@@ -9693,11 +9846,74 @@
 ; casesi instruction pattern(s).
 ;
 
-(define_insn "casesi_jump"
- [(set (pc) (match_operand 0 "address_operand" "ZR"))
-   (use (label_ref (match_operand 1 "" "")))]
+(define_expand "casesi_jump"
+  [(parallel
+    [(set (pc) (match_operand 0 "address_operand"))
+     (use (label_ref (match_operand 1 "")))])]
   ""
 {
+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)
+    {
+      operands[0] = force_reg (GET_MODE (operands[0]), operands[0]);
+
+      if (TARGET_CPU_Z10)
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_casesi_jump_via_thunkdi_z10 (operands[0],
+							     operands[1]));
+	  else
+	    emit_jump_insn (gen_casesi_jump_via_thunksi_z10 (operands[0],
+							     operands[1]));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_casesi_jump_via_thunkdi (operands[0],
+							 operands[1]));
+	  else
+	    emit_jump_insn (gen_casesi_jump_via_thunksi (operands[0],
+							 operands[1]));
+	}
+      DONE;
+    }
+
+    if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)
+    {
+      operands[0] = force_reg (Pmode, operands[0]);
+      rtx label_ref = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+      if (TARGET_CPU_Z10)
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_casesi_jump_via_inlinethunkdi_z10 (operands[0],
+								   operands[1],
+								   label_ref));
+	  else
+	    emit_jump_insn (gen_casesi_jump_via_inlinethunksi_z10 (operands[0],
+								   operands[1],
+								   label_ref));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_casesi_jump_via_inlinethunkdi (operands[0],
+							       operands[1],
+							       label_ref,
+							       force_reg (Pmode, label_ref)));
+	  else
+	    emit_jump_insn (gen_casesi_jump_via_inlinethunksi (operands[0],
+							       operands[1],
+							       label_ref,
+							       force_reg (Pmode, label_ref)));
+	}
+      DONE;
+    }
+})
+
+(define_insn "*casesi_jump"
+ [(set (pc) (match_operand 0 "address_operand" "ZR"))
+  (use (label_ref (match_operand 1 "" "")))]
+ "!TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK"
+{
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "br\t%0";
   else
@@ -9706,9 +9922,85 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 0 "register_operand" "")
+                      (const_string "br") (const_string "b")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
+(define_insn "casesi_jump_via_thunk<mode>_z10"
+ [(set (pc) (match_operand:P 0 "register_operand" "a"))
+  (use (label_ref (match_operand 1 "" "")))]
+ "TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK
+  && TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  INVALID_REGNUM,
+				  NULL_RTX,
+				  s390_indirect_branch_type_jump);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "jg")
+   (set_attr "type"  "branch")
+   (set_attr "atype" "agen")])
+
+(define_insn "casesi_jump_via_thunk<mode>"
+ [(set (pc) (match_operand:P 0 "register_operand" "a"))
+  (use (label_ref (match_operand 1 "" "")))
+  (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+ "TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK
+  && !TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  INVALID_REGNUM,
+				  NULL_RTX,
+				  s390_indirect_branch_type_jump);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "jg")
+   (set_attr "type"  "branch")
+   (set_attr "atype" "agen")])
+
+
+; The label_ref is wrapped into an if_then_else in order to hide it
+; from mark_jump_label.  Without this the label_ref would become the
+; ONLY jump target of that jump breaking the control flow graph.
+(define_insn "casesi_jump_via_inlinethunk<mode>_z10"
+  [(unspec [(if_then_else (match_operand:P 2 "larl_operand" "X")
+			  (const_int 0)
+			  (const_int 0))
+	    (const_int 0)] UNSPEC_EXECUTE_JUMP)
+   (set (pc) (match_operand:P 0 "register_operand" "a"))
+   (use (label_ref (match_operand 1 "" "")))]
+  "TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK
+   && TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_inline_thunk (operands[2]);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "type"    "cs")
+   (set_attr "length"  "10")])
+
+(define_insn "casesi_jump_via_inlinethunk<mode>"
+  [(unspec [(if_then_else (match_operand:P 2 "larl_operand" "X")
+			  (const_int 0)
+			  (const_int 0))
+	    (match_operand:P 3 "register_operand" "a")] UNSPEC_EXECUTE_JUMP)
+   (set (pc) (match_operand:P 0 "register_operand" "a"))
+   (use (label_ref (match_operand 1 "" "")))]
+  "TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK
+   && !TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_inline_thunk (operands[3]);
+  return "";
+}
+  [(set_attr "op_type" "RX")
+   (set_attr "type"    "cs")
+   (set_attr "length"  "8")])
+
 (define_expand "casesi"
   [(match_operand:SI 0 "general_operand" "")
    (match_operand:SI 1 "general_operand" "")
@@ -9813,8 +10105,27 @@
          (match_operand 0 "const_int_operand" "n"))]
   "SIBLING_CALL_P (insn)
    && GET_MODE (XEXP (XEXP (PATTERN (insn), 0), 0)) == Pmode"
-  "br\t%%r1"
-  [(set_attr "op_type" "RR")
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL)
+    {
+      gcc_assert (TARGET_CPU_Z10);
+      s390_indirect_branch_via_thunk (SIBCALL_REGNUM,
+				      INVALID_REGNUM,
+				      NULL_RTX,
+				      s390_indirect_branch_type_call);
+      return "";
+    }
+  else
+    return "br\t%%r1";
+}
+ [(set (attr "op_type")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_CALL")
+		     (const_string "RIL")
+		     (const_string "RR")))
+  (set (attr "mnemonic")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_CALL")
+		     (const_string "jg")
+		     (const_string "br")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
@@ -9854,8 +10165,27 @@
 	      (match_operand 1 "const_int_operand" "n")))]
   "SIBLING_CALL_P (insn)
    && GET_MODE (XEXP (XEXP (XEXP (PATTERN (insn), 1), 0), 0)) == Pmode"
-  "br\t%%r1"
-  [(set_attr "op_type" "RR")
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL)
+    {
+      gcc_assert (TARGET_CPU_Z10);
+      s390_indirect_branch_via_thunk (SIBCALL_REGNUM,
+				      INVALID_REGNUM,
+				      NULL_RTX,
+				      s390_indirect_branch_type_call);
+      return "";
+    }
+  else
+    return "br\t%%r1";
+}
+  [(set (attr "op_type")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_CALL")
+		     (const_string "RIL")
+		     (const_string "RR")))
+   (set (attr "mnemonic")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_CALL")
+		     (const_string "jg")
+		     (const_string "br")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
@@ -9921,7 +10251,9 @@
   [(call (mem:QI (match_operand 0 "address_operand" "ZR"))
          (match_operand 1 "const_int_operand" "n"))
    (clobber (match_operand 2 "register_operand" "=r"))]
-  "!SIBLING_CALL_P (insn) && GET_MODE (operands[2]) == Pmode"
+  "!TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && !SIBLING_CALL_P (insn)
+   && GET_MODE (operands[2]) == Pmode"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "basr\t%2,%0";
@@ -9931,6 +10263,50 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 0 "register_operand" "")
+                      (const_string "basr") (const_string "bas")))
+   (set_attr "type"  "jsr")
+   (set_attr "atype" "agen")
+   (set_attr "z196prop" "z196_cracked")])
+
+(define_insn "*basr_via_thunk<mode>_z10"
+  [(call (mem:QI (match_operand:P 0 "register_operand" "a"))
+         (match_operand 1 "const_int_operand"          "n"))
+   (clobber (match_operand:P 2 "register_operand"    "=&r"))]
+  "TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && TARGET_CPU_Z10
+   && !SIBLING_CALL_P (insn)"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  REGNO (operands[2]),
+				  NULL_RTX,
+				  s390_indirect_branch_type_call);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "brasl")
+   (set_attr "type"  "jsr")
+   (set_attr "atype" "agen")
+   (set_attr "z196prop" "z196_cracked")])
+
+(define_insn "*basr_via_thunk<mode>"
+  [(call (mem:QI (match_operand:P 0 "register_operand" "a"))
+         (match_operand 1 "const_int_operand"          "n"))
+   (clobber (match_operand:P 2 "register_operand"    "=&r"))
+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+  "TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && !TARGET_CPU_Z10
+   && !SIBLING_CALL_P (insn)"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  REGNO (operands[2]),
+				  NULL_RTX,
+				  s390_indirect_branch_type_call);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "brasl")
    (set_attr "type"  "jsr")
    (set_attr "atype" "agen")
    (set_attr "z196prop" "z196_cracked")])
@@ -9982,7 +10358,9 @@
         (call (mem:QI (match_operand 1 "address_operand" "ZR"))
               (match_operand 2 "const_int_operand" "n")))
    (clobber (match_operand 3 "register_operand" "=r"))]
-  "!SIBLING_CALL_P (insn) && GET_MODE (operands[3]) == Pmode"
+  "!TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && !SIBLING_CALL_P (insn)
+   && GET_MODE (operands[3]) == Pmode"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "basr\t%3,%1";
@@ -9992,6 +10370,54 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 1 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 1 "register_operand" "")
+                      (const_string "basr") (const_string "bas")))
+   (set_attr "type"  "jsr")
+   (set_attr "atype" "agen")
+   (set_attr "z196prop" "z196_cracked")])
+
+(define_insn "*basr_r_via_thunk_z10"
+  [(set (match_operand 0 "" "")
+        (call (mem:QI (match_operand 1 "register_operand" "a"))
+              (match_operand 2 "const_int_operand"        "n")))
+   (clobber (match_operand 3 "register_operand"         "=&r"))]
+  "TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && TARGET_CPU_Z10
+   && !SIBLING_CALL_P (insn)
+   && GET_MODE (operands[3]) == Pmode"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[1]),
+				  REGNO (operands[3]),
+				  NULL_RTX,
+				  s390_indirect_branch_type_call);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "brasl")
+   (set_attr "type"  "jsr")
+   (set_attr "atype" "agen")
+   (set_attr "z196prop" "z196_cracked")])
+
+(define_insn "*basr_r_via_thunk"
+  [(set (match_operand 0 "" "")
+        (call (mem:QI (match_operand 1 "register_operand" "a"))
+              (match_operand 2 "const_int_operand"        "n")))
+   (clobber (match_operand 3 "register_operand"         "=&r"))
+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+  "TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && !TARGET_CPU_Z10
+   && !SIBLING_CALL_P (insn)
+   && GET_MODE (operands[3]) == Pmode"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[1]),
+				  REGNO (operands[3]),
+				  NULL_RTX,
+				  s390_indirect_branch_type_call);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic"  "brasl")
    (set_attr "type"  "jsr")
    (set_attr "atype" "agen")
    (set_attr "z196prop" "z196_cracked")])
@@ -10737,17 +11163,101 @@
 (define_insn "<code>"
   [(ANY_RETURN)]
   "s390_can_use_<code>_insn ()"
-  "br\t%%r14"
-  [(set_attr "op_type" "RR")
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)
+    {
+      /* The target is always r14 so there is no clobber
+	 of r1 needed for pre z10 targets.  */
+      s390_indirect_branch_via_thunk (RETURN_REGNUM,
+				      INVALID_REGNUM,
+				      NULL_RTX,
+				      s390_indirect_branch_type_return);
+      return "";
+    }
+  else
+    return "br\t%%r14";
+}
+  [(set (attr "op_type")
+	(if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+		      (const_string "RIL")
+		      (const_string "RR")))
+   (set (attr "mnemonic")
+	(if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+		      (const_string "jg")
+		      (const_string "br")))
+   (set_attr "type"    "jsr")
+   (set_attr "atype"   "agen")])
+
+
+(define_expand "return_use"
+  [(parallel
+    [(return)
+     (use (match_operand 0 "register_operand" "a"))])]
+  ""
+{
+  if (!TARGET_CPU_Z10
+      && TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION)
+    {
+      if (TARGET_64BIT)
+        emit_jump_insn (gen_returndi_prez10 (operands[0]));
+      else
+        emit_jump_insn (gen_returnsi_prez10 (operands[0]));
+      DONE;
+    }
+})
+
+(define_insn "*return<mode>"
+  [(return)
+   (use (match_operand:P 0 "register_operand" "a"))]
+  "TARGET_CPU_Z10 || !TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION"
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)
+    {
+      s390_indirect_branch_via_thunk (REGNO (operands[0]),
+                                      INVALID_REGNUM,
+                                      NULL_RTX,
+                                      s390_indirect_branch_type_return);
+      return "";
+    }
+  else
+    return "br\t%0";
+}
+  [(set (attr "op_type")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+                     (const_string "RIL")
+                     (const_string "RR")))
+   (set (attr "mnemonic")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+                     (const_string "jg")
+                     (const_string "br")))
    (set_attr "type"    "jsr")
    (set_attr "atype"   "agen")])
 
-(define_insn "*return"
+(define_insn "return<mode>_prez10"
   [(return)
-   (use (match_operand 0 "register_operand" "a"))]
-  "GET_MODE (operands[0]) == Pmode"
-  "br\t%0"
-  [(set_attr "op_type" "RR")
+   (use (match_operand:P 0 "register_operand" "a"))
+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+  "!TARGET_CPU_Z10 && TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION"
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)
+    {
+      s390_indirect_branch_via_thunk (REGNO (operands[0]),
+                                      INVALID_REGNUM,
+                                      NULL_RTX,
+                                      s390_indirect_branch_type_return);
+      return "";
+    }
+  else
+    return "br\t%0";
+}
+  [(set (attr "op_type")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+                     (const_string "RIL")
+                     (const_string "RR")))
+   (set (attr "mnemonic")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+                     (const_string "jg")
+                     (const_string "br")))
    (set_attr "type"    "jsr")
    (set_attr "atype"   "agen")])
 
diff -ruN gcc-7.3.0/gcc/config/s390/s390.opt gcc-7.3.0-msp430/gcc/config/s390/s390.opt
--- gcc-7.3.0/gcc/config/s390/s390.opt	2017-07-31 04:33:18.182361000 -0700
+++ gcc-7.3.0-msp430/gcc/config/s390/s390.opt	2019-06-25 02:27:21.101931418 -0700
@@ -229,3 +229,62 @@
 mlra
 Target Report Var(s390_lra_flag) Init(1) Save
 Use LRA instead of reload.
+
+mindirect-branch=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_indirect_branch) Init(indirect_branch_keep)
+Wrap all indirect branches into execute in order to disable branch
+prediction.
+
+mindirect-branch-jump=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_indirect_branch_jump) Init(indirect_branch_keep)
+Wrap indirect table jumps and computed gotos into execute in order to
+disable branch prediction.  Using thunk or thunk-extern with this
+option requires the thunks to be considered signal handlers to order to
+generate correct CFI.  For environments where unwinding (e.g. for
+exceptions) is required please use thunk-inline instead.
+
+mindirect-branch-call=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_indirect_branch_call) Init(indirect_branch_keep)
+Wrap all indirect calls into execute in order to disable branch prediction.
+
+mfunction-return=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_function_return) Init(indirect_branch_keep)
+Wrap all indirect return branches into execute in order to disable branch
+prediction.
+
+mfunction-return-mem=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_function_return_mem) Init(indirect_branch_keep)
+Wrap indirect return branches into execute in order to disable branch
+prediction. This affects only branches where the return address is
+going to be restored from memory.
+
+mfunction-return-reg=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_function_return_reg) Init(indirect_branch_keep)
+Wrap indirect return branches into execute in order to disable branch
+prediction. This affects only branches where the return address
+doesn't need to be restored from memory.
+
+Enum
+Name(indirect_branch) Type(enum indirect_branch)
+Known indirect branch choices (for use with the -mindirect-branch=/-mfunction-return= options):
+
+EnumValue
+Enum(indirect_branch) String(keep) Value(indirect_branch_keep)
+
+EnumValue
+Enum(indirect_branch) String(thunk) Value(indirect_branch_thunk)
+
+EnumValue
+Enum(indirect_branch) String(thunk-inline) Value(indirect_branch_thunk_inline)
+
+EnumValue
+Enum(indirect_branch) String(thunk-extern) Value(indirect_branch_thunk_extern)
+
+mindirect-branch-table
+Target Report Var(s390_indirect_branch_table) Init(TARGET_DEFAULT_INDIRECT_BRANCH_TABLE)
+Generate sections .s390_indirect_jump, .s390_indirect_call,
+.s390_return_reg, and .s390_return_mem to contain the indirect branch
+locations which have been patched as part of using one of the
+-mindirect-branch* or -mfunction-return* options.  The sections
+consist of an array of 32 bit elements. Each entry holds the offset
+from the entry to the patched location.
diff -ruN gcc-7.3.0/gcc/config/s390/s390-opts.h gcc-7.3.0-msp430/gcc/config/s390/s390-opts.h
--- gcc-7.3.0/gcc/config/s390/s390-opts.h	2017-07-31 04:33:18.182361000 -0700
+++ gcc-7.3.0-msp430/gcc/config/s390/s390-opts.h	2019-06-25 02:27:21.097931448 -0700
@@ -43,4 +43,13 @@
   PROCESSOR_max
 };
 
+
+/* Values for -mindirect-branch and -mfunction-return options.  */
+enum indirect_branch {
+  indirect_branch_unset = 0,
+  indirect_branch_keep,
+  indirect_branch_thunk,
+  indirect_branch_thunk_inline,
+  indirect_branch_thunk_extern
+};
 #endif
diff -ruN gcc-7.3.0/gcc/config/s390/s390-protos.h gcc-7.3.0-msp430/gcc/config/s390/s390-protos.h
--- gcc-7.3.0/gcc/config/s390/s390-protos.h	2017-04-25 04:11:48.046616000 -0700
+++ gcc-7.3.0-msp430/gcc/config/s390/s390-protos.h	2019-06-25 02:27:21.097931448 -0700
@@ -53,6 +53,7 @@
 extern int s390_cannot_change_mode_class (machine_mode, machine_mode,
 					  enum reg_class);
 extern bool s390_function_arg_vector (machine_mode, const_tree);
+extern bool s390_return_addr_from_memory(void);
 #if S390_USE_TARGET_ATTRIBUTE
 extern tree s390_valid_target_attribute_tree (tree args,
 					      struct gcc_options *opts,
@@ -147,6 +148,17 @@
 extern bool s390_extzv_shift_ok (int, int, unsigned HOST_WIDE_INT);
 extern void s390_asm_output_function_label (FILE *, const char *, tree);
 
+enum s390_indirect_branch_type
+  {
+    s390_indirect_branch_type_jump = 0,
+    s390_indirect_branch_type_call,
+    s390_indirect_branch_type_return
+  };
+extern void s390_indirect_branch_via_thunk (unsigned int regno,
+					    unsigned int return_addr_regno,
+					    rtx comparison_operator,
+					    enum s390_indirect_branch_type type);
+extern void s390_indirect_branch_via_inline_thunk (rtx execute_target);
 #endif /* RTX_CODE */
 
 /* s390-c.c routines */
diff -ruN gcc-7.3.0/gcc/config/sparc/sparc.c gcc-7.3.0-msp430/gcc/config/sparc/sparc.c
--- gcc-7.3.0/gcc/config/sparc/sparc.c	2017-12-19 00:07:22.272408000 -0800
+++ gcc-7.3.0-msp430/gcc/config/sparc/sparc.c	2019-06-25 02:27:21.101931418 -0700
@@ -2188,7 +2188,7 @@
 	}
     }
 
-  /* Fixup TLS cases.  */
+  /* Fix up TLS cases.  */
   if (TARGET_HAVE_TLS
       && CONSTANT_P (operands[1])
       && sparc_tls_referenced_p (operands [1]))
@@ -2197,15 +2197,20 @@
       return false;
     }
 
-  /* Fixup PIC cases.  */
+  /* Fix up PIC cases.  */
   if (flag_pic && CONSTANT_P (operands[1]))
     {
       if (pic_address_needs_scratch (operands[1]))
 	operands[1] = sparc_legitimize_pic_address (operands[1], NULL_RTX);
 
       /* We cannot use the mov{si,di}_pic_label_ref patterns in all cases.  */
-      if (GET_CODE (operands[1]) == LABEL_REF
-	  && can_use_mov_pic_label_ref (operands[1]))
+      if ((GET_CODE (operands[1]) == LABEL_REF
+	   && can_use_mov_pic_label_ref (operands[1]))
+	  || (GET_CODE (operands[1]) == CONST
+	      && GET_CODE (XEXP (operands[1], 0)) == PLUS
+	      && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF
+	      && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == CONST_INT
+	      && can_use_mov_pic_label_ref (XEXP (XEXP (operands[1], 0), 0))))
 	{
 	  if (mode == SImode)
 	    {
@@ -2215,7 +2220,6 @@
 
 	  if (mode == DImode)
 	    {
-	      gcc_assert (TARGET_ARCH64);
 	      emit_insn (gen_movdi_pic_label_ref (operands[0], operands[1]));
 	      return true;
 	    }
@@ -4216,10 +4220,11 @@
 pic_address_needs_scratch (rtx x)
 {
   /* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */
-  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS
+  if (GET_CODE (x) == CONST
+      && GET_CODE (XEXP (x, 0)) == PLUS
       && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF
       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT
-      && ! SMALL_INT (XEXP (XEXP (x, 0), 1)))
+      && !SMALL_INT (XEXP (XEXP (x, 0), 1)))
     return 1;
 
   return 0;
@@ -4667,16 +4672,15 @@
 static rtx
 sparc_legitimize_pic_address (rtx orig, rtx reg)
 {
-  bool gotdata_op = false;
-
   if (GET_CODE (orig) == SYMBOL_REF
       /* See the comment in sparc_expand_move.  */
       || (GET_CODE (orig) == LABEL_REF && !can_use_mov_pic_label_ref (orig)))
     {
+      bool gotdata_op = false;
       rtx pic_ref, address;
       rtx_insn *insn;
 
-      if (reg == 0)
+      if (!reg)
 	{
 	  gcc_assert (can_create_pseudo_p ());
 	  reg = gen_reg_rtx (Pmode);
@@ -4687,8 +4691,7 @@
 	  /* If not during reload, allocate another temp reg here for loading
 	     in the address, so that these instructions can be optimized
 	     properly.  */
-	  rtx temp_reg = (! can_create_pseudo_p ()
-			  ? reg : gen_reg_rtx (Pmode));
+	  rtx temp_reg = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : reg;
 
 	  /* Must put the SYMBOL_REF inside an UNSPEC here so that cse
 	     won't get confused into thinking that these two instructions
@@ -4704,6 +4707,7 @@
 	      emit_insn (gen_movsi_high_pic (temp_reg, orig));
 	      emit_insn (gen_movsi_lo_sum_pic (temp_reg, temp_reg, orig));
 	    }
+
 	  address = temp_reg;
 	  gotdata_op = true;
 	}
@@ -4744,7 +4748,7 @@
 	  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)
 	return orig;
 
-      if (reg == 0)
+      if (!reg)
 	{
 	  gcc_assert (can_create_pseudo_p ());
 	  reg = gen_reg_rtx (Pmode);
@@ -4853,7 +4857,11 @@
       && XINT (XEXP (XEXP (x, 1), 1), 1) == UNSPEC_MOVE_PIC_LABEL)
     {
       x = XVECEXP (XEXP (XEXP (x, 1), 1), 0, 0);
-      gcc_assert (GET_CODE (x) == LABEL_REF);
+      gcc_assert (GET_CODE (x) == LABEL_REF
+		  || (GET_CODE (x) == CONST
+		      && GET_CODE (XEXP (x, 0)) == PLUS
+		      && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF
+		      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT));
     }
 
   return x;
diff -ruN gcc-7.3.0/gcc/config/sparc/sparc.md gcc-7.3.0-msp430/gcc/config/sparc/sparc.md
--- gcc-7.3.0/gcc/config/sparc/sparc.md	2017-12-06 00:38:32.304956000 -0800
+++ gcc-7.3.0-msp430/gcc/config/sparc/sparc.md	2019-06-25 02:27:21.105931389 -0700
@@ -1758,7 +1758,7 @@
 
 (define_expand "movsi_pic_label_ref"
   [(set (match_dup 3) (high:SI
-     (unspec:SI [(match_operand:SI 1 "label_ref_operand" "")
+     (unspec:SI [(match_operand:SI 1 "symbolic_operand" "")
 		 (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))
    (set (match_dup 4) (lo_sum:SI (match_dup 3)
      (unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))
@@ -1784,7 +1784,7 @@
 (define_insn "*movsi_high_pic_label_ref"
   [(set (match_operand:SI 0 "register_operand" "=r")
       (high:SI
-        (unspec:SI [(match_operand:SI 1 "label_ref_operand" "")
+        (unspec:SI [(match_operand:SI 1 "symbolic_operand" "")
 		    (match_operand:SI 2 "" "")] UNSPEC_MOVE_PIC_LABEL)))]
   "flag_pic"
   "sethi\t%%hi(%a2-(%a1-.)), %0")
@@ -1792,7 +1792,7 @@
 (define_insn "*movsi_lo_sum_pic_label_ref"
   [(set (match_operand:SI 0 "register_operand" "=r")
       (lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 2 "label_ref_operand" "")
+        (unspec:SI [(match_operand:SI 2 "symbolic_operand" "")
 		    (match_operand:SI 3 "" "")] UNSPEC_MOVE_PIC_LABEL)))]
   "flag_pic"
   "or\t%1, %%lo(%a3-(%a2-.)), %0")
@@ -1896,7 +1896,7 @@
 
 (define_expand "movdi_pic_label_ref"
   [(set (match_dup 3) (high:DI
-     (unspec:DI [(match_operand:DI 1 "label_ref_operand" "")
+     (unspec:DI [(match_operand:DI 1 "symbolic_operand" "")
                  (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))
    (set (match_dup 4) (lo_sum:DI (match_dup 3)
      (unspec:DI [(match_dup 1) (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))
@@ -1922,7 +1922,7 @@
 (define_insn "*movdi_high_pic_label_ref"
   [(set (match_operand:DI 0 "register_operand" "=r")
         (high:DI
-          (unspec:DI [(match_operand:DI 1 "label_ref_operand" "")
+          (unspec:DI [(match_operand:DI 1 "symbolic_operand" "")
                       (match_operand:DI 2 "" "")] UNSPEC_MOVE_PIC_LABEL)))]
   "TARGET_ARCH64 && flag_pic"
   "sethi\t%%hi(%a2-(%a1-.)), %0")
@@ -1930,7 +1930,7 @@
 (define_insn "*movdi_lo_sum_pic_label_ref"
   [(set (match_operand:DI 0 "register_operand" "=r")
       (lo_sum:DI (match_operand:DI 1 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 2 "label_ref_operand" "")
+        (unspec:DI [(match_operand:DI 2 "symbolic_operand" "")
                     (match_operand:DI 3 "" "")] UNSPEC_MOVE_PIC_LABEL)))]
   "TARGET_ARCH64 && flag_pic"
   "or\t%1, %%lo(%a3-(%a2-.)), %0")
diff -ruN gcc-7.3.0/gcc/config/xtensa/xtensa.md gcc-7.3.0-msp430/gcc/config/xtensa/xtensa.md
--- gcc-7.3.0/gcc/config/xtensa/xtensa.md	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/config/xtensa/xtensa.md	2019-06-25 02:27:21.105931389 -0700
@@ -38,6 +38,7 @@
   (UNSPEC_MEMW		11)
   (UNSPEC_LSETUP_START  12)
   (UNSPEC_LSETUP_END    13)
+  (UNSPEC_FRAME_BLOCKAGE 14)
 
   (UNSPECV_SET_FP	1)
   (UNSPECV_ENTRY	2)
@@ -1676,6 +1677,32 @@
 
 ;; Miscellaneous instructions.
 
+;; In windowed ABI stack pointer adjustment must happen before any access
+;; to the space allocated on stack is allowed, otherwise register spill
+;; area may be clobbered.  That's what frame blockage is supposed to enforce.
+
+(define_expand "allocate_stack"
+  [(set (match_operand 0 "nonimmed_operand")
+        (minus (reg A1_REG) (match_operand 1 "add_operand")))
+   (set (reg A1_REG)
+        (minus (reg A1_REG) (match_dup 1)))]
+  "TARGET_WINDOWED_ABI"
+{
+  if (CONST_INT_P (operands[1]))
+    {
+      rtx neg_op0 = GEN_INT (-INTVAL (operands[1]));
+      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, neg_op0));
+    }
+  else
+    {
+      emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,
+			     operands[1]));
+    }
+  emit_move_insn (operands[0], virtual_stack_dynamic_rtx);
+  emit_insn (gen_frame_blockage ());
+  DONE;
+})
+
 (define_expand "prologue"
   [(const_int 0)]
   ""
@@ -1767,6 +1794,25 @@
   [(set_attr "length" "0")
    (set_attr "type" "nop")])
 
+;; Do not schedule instructions accessing memory before this point.
+
+(define_expand "frame_blockage"
+  [(set (match_dup 0)
+        (unspec:BLK [(match_dup 1)] UNSPEC_FRAME_BLOCKAGE))]
+  ""
+{
+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[0]) = 1;
+  operands[1] = stack_pointer_rtx;
+})
+
+(define_insn "*frame_blockage"
+  [(set (match_operand:BLK 0 "" "")
+        (unspec:BLK [(match_operand:SI 1 "" "")] UNSPEC_FRAME_BLOCKAGE))]
+  ""
+  ""
+  [(set_attr "length" "0")])
+
 (define_insn "trap"
   [(trap_if (const_int 1) (const_int 0))]
   ""
diff -ruN gcc-7.3.0/gcc/config.gcc gcc-7.3.0-msp430/gcc/config.gcc
--- gcc-7.3.0/gcc/config.gcc	2018-01-08 05:39:11.754860000 -0800
+++ gcc-7.3.0-msp430/gcc/config.gcc	2019-06-25 02:27:21.069931647 -0700
@@ -1461,7 +1461,7 @@
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h"
 	;;
 x86_64-*-rtems*)
-	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h i386/rtemself.h"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h i386/rtemself.h rtems.h"
 	;;
 i[34567]86-*-rdos*)
     tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/rdos.h"
@@ -2046,10 +2046,17 @@
 	;;
 riscv*-*-elf* | riscv*-*-rtems*)
 	tm_file="elfos.h newlib-stdint.h ${tm_file} riscv/elf.h"
-	case "x${enable_multilib}" in
-	xno) ;;
-	xyes) tmake_file="${tmake_file} riscv/t-elf-multilib" ;;
-	*) echo "Unknown value for enable_multilib"; exit 1
+	case ${target} in
+	*-*-rtems*)
+	  tm_file="${tm_file} rtems.h riscv/rtems.h"
+	  tmake_file="${tmake_file} riscv/t-rtems"
+	  ;;
+	*)
+	  case "x${enable_multilib}" in
+	  xno) ;;
+	  xyes) tmake_file="${tmake_file} riscv/t-elf-multilib" ;;
+	  *) echo "Unknown value for enable_multilib"; exit 1
+	  esac
 	esac
 	tmake_file="${tmake_file} riscv/t-riscv"
 	gnu_ld=yes
@@ -2057,11 +2064,6 @@
 	# Force .init_array support.  The configure script cannot always
 	# automatically detect that GAS supports it, yet we require it.
 	gcc_cv_initfini_array=yes
-	case ${target} in
-	riscv*-*-rtems*)
-	  tm_file="${tm_file} rtems.h riscv/rtems.h"
-	  ;;
-	esac
 	;;
 mips*-*-netbsd*)			# NetBSD/mips, either endian.
 	target_cpu_default="MASK_ABICALLS"
@@ -2295,7 +2297,8 @@
 	c_target_objs="msp430-c.o"
 	cxx_target_objs="msp430-c.o"
 	tmake_file="${tmake_file} msp430/t-msp430"
-	extra_gcc_objs="driver-msp430.o"
+	extra_objs="${extra_objs} msp430-devices.o"
+	extra_gcc_objs="driver-msp430.o msp430-devices.o"
 	;;
 nds32le-*-*)
 	target_cpu_default="0"
diff -ruN gcc-7.3.0/gcc/configure gcc-7.3.0-msp430/gcc/configure
--- gcc-7.3.0/gcc/configure	2017-11-21 01:31:12.135035000 -0800
+++ gcc-7.3.0-msp430/gcc/configure	2019-06-25 02:27:21.105931389 -0700
@@ -11871,7 +11871,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
@@ -23571,6 +23571,14 @@
 
 
 fi
+case "$target" in
+  i?86-*-solaris2.10* | x86_64-*-solaris2.10*)
+    # SHF_MERGE support in Solaris 10/x86 ld is broken.
+    if test x"$gnu_ld" = xno; then
+      gcc_cv_as_shf_merge=no
+    fi
+    ;;
+esac
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_GAS_SHF_MERGE `if test $gcc_cv_as_shf_merge = yes; then echo 1; else echo 0; fi`
@@ -25217,6 +25225,7 @@
 
 fi
 
+
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for SPARC6 instructions" >&5
 $as_echo_n "checking assembler for SPARC6 instructions... " >&6; }
 if test "${gcc_cv_as_sparc_sparc6+set}" = set; then :
@@ -25253,6 +25262,7 @@
 
 fi
 
+
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for LEON instructions" >&5
 $as_echo_n "checking assembler for LEON instructions... " >&6; }
 if test "${gcc_cv_as_sparc_leon+set}" = set; then :
@@ -29777,8 +29787,10 @@
 
 # Generate gcc-driver-name.h containing GCC_DRIVER_NAME for the benefit
 # of jit/jit-playback.c.
+gcc_driver_version=`eval "${get_gcc_base_ver} $srcdir/BASE-VER"`
+echo "gcc_driver_version: ${gcc_driver_version}"
 cat > gcc-driver-name.h <<EOF
-#define GCC_DRIVER_NAME "${target_noncanonical}-gcc-${gcc_BASEVER}${exeext}"
+#define GCC_DRIVER_NAME "${target_noncanonical}-gcc-${gcc_driver_version}${exeext}"
 EOF
 
 # Check whether --enable-default-pie was given.
diff -ruN gcc-7.3.0/gcc/configure.ac gcc-7.3.0-msp430/gcc/configure.ac
--- gcc-7.3.0/gcc/configure.ac	2017-11-21 01:31:12.135035000 -0800
+++ gcc-7.3.0-msp430/gcc/configure.ac	2019-06-25 02:27:21.105931389 -0700
@@ -2946,6 +2946,14 @@
     [elf,2,12,0], [--fatal-warnings],
     [.section .rodata.str, "aMS", %progbits, 1])
 fi
+case "$target" in
+  i?86-*-solaris2.10* | x86_64-*-solaris2.10*)
+    # SHF_MERGE support in Solaris 10/x86 ld is broken.
+    if test x"$gnu_ld" = xno; then
+      gcc_cv_as_shf_merge=no
+    fi
+    ;;
+esac
 AC_DEFINE_UNQUOTED(HAVE_GAS_SHF_MERGE,
   [`if test $gcc_cv_as_shf_merge = yes; then echo 1; else echo 0; fi`],
 [Define 0/1 if your assembler supports marking sections with SHF_MERGE flag.])
@@ -6292,8 +6300,10 @@
 
 # Generate gcc-driver-name.h containing GCC_DRIVER_NAME for the benefit
 # of jit/jit-playback.c.
+gcc_driver_version=`eval "${get_gcc_base_ver} $srcdir/BASE-VER"`
+echo "gcc_driver_version: ${gcc_driver_version}"
 cat > gcc-driver-name.h <<EOF
-#define GCC_DRIVER_NAME "${target_noncanonical}-gcc-${gcc_BASEVER}${exeext}"
+#define GCC_DRIVER_NAME "${target_noncanonical}-gcc-${gcc_driver_version}${exeext}"
 EOF
 
 # Check whether --enable-default-pie was given.
diff -ruN gcc-7.3.0/gcc/cp/call.c gcc-7.3.0-msp430/gcc/cp/call.c
--- gcc-7.3.0/gcc/cp/call.c	2018-01-17 10:07:45.539009000 -0800
+++ gcc-7.3.0-msp430/gcc/cp/call.c	2019-06-25 02:27:21.109931362 -0700
@@ -375,18 +375,10 @@
 
   TREE_HAS_CONSTRUCTOR (function) = (decl && DECL_CONSTRUCTOR_P (decl));
 
-  if (current_function_decl && decl
-      && flag_new_inheriting_ctors
-      && DECL_INHERITED_CTOR (current_function_decl)
-      && (DECL_INHERITED_CTOR (current_function_decl)
-	  == DECL_CLONED_FUNCTION (decl)))
-    /* Pass arguments directly to the inherited constructor.  */
-    CALL_FROM_THUNK_P (function) = true;
-
   /* Don't pass empty class objects by value.  This is useful
      for tags in STL, which are used to control overload resolution.
      We don't need to handle other cases of copying empty classes.  */
-  else if (! decl || ! DECL_BUILT_IN (decl))
+  if (! decl || ! DECL_BUILT_IN (decl))
     for (i = 0; i < n; i++)
       {
 	tree arg = CALL_EXPR_ARG (function, i);
@@ -3267,10 +3259,10 @@
 			     tree return_type, tree access_path,
 			     tree conversion_path, tsubst_flags_t complain)
 {
-  /* Making this work broke PR 71117, so until the committee resolves core
-     issue 2189, let's disable this candidate if there are any viable call
+  /* Making this work broke PR 71117 and 85118, so until the committee resolves
+     core issue 2189, let's disable this candidate if there are any call
      operators.  */
-  if (any_strictly_viable (*candidates))
+  if (*candidates)
     return NULL;
 
   return
@@ -6886,6 +6878,11 @@
 	  && DECL_INHERITED_CTOR (current_function_decl))
 	return expr;
 
+      if (TREE_CODE (expr) == TARGET_EXPR
+	  && TARGET_EXPR_LIST_INIT_P (expr))
+	/* Copy-list-initialization doesn't actually involve a copy.  */
+	return expr;
+
       /* Fall through.  */
     case ck_base:
       if (convs->kind == ck_base && !convs->need_temporary_p)
@@ -6911,10 +6908,6 @@
 	flags |= LOOKUP_ONLYCONVERTING;
       if (convs->rvaluedness_matches_p)
 	flags |= LOOKUP_PREFER_RVALUE;
-      if (TREE_CODE (expr) == TARGET_EXPR
-	  && TARGET_EXPR_LIST_INIT_P (expr))
-	/* Copy-list-initialization doesn't actually involve a copy.  */
-	return expr;
       expr = build_temp (expr, totype, flags, &diag_kind, complain);
       if (diag_kind && complain)
 	{
@@ -7151,7 +7144,7 @@
 		     "passing objects of non-trivially-copyable "
 		     "type %q#T through %<...%> is conditionally supported",
 		     arg_type);
-	  return cp_build_addr_expr (arg, complain);
+	  return build1 (ADDR_EXPR, build_reference_type (arg_type), arg);
 	}
       /* Build up a real lvalue-to-rvalue conversion in case the
 	 copy constructor is trivial but not callable.  */
@@ -7525,6 +7518,15 @@
   /* build_compound_expr pushes COMPOUND_EXPR inside TARGET_EXPR.  */
   while (TREE_CODE (init) == COMPOUND_EXPR)
     init = TREE_OPERAND (init, 1);
+  if (TREE_CODE (init) == COND_EXPR)
+    {
+      /* We'll end up copying from each of the arms of the COND_EXPR directly
+	 into the target, so look at them. */
+      if (tree op = TREE_OPERAND (init, 1))
+	if (unsafe_copy_elision_p (target, op))
+	  return true;
+      return unsafe_copy_elision_p (target, TREE_OPERAND (init, 2));
+    }
   return (TREE_CODE (init) == AGGR_INIT_EXPR
 	  && !AGGR_INIT_VIA_CTOR_P (init));
 }
@@ -7566,6 +7568,10 @@
 
       if (undeduced_auto_decl (fn))
 	mark_used (fn, complain);
+      else
+	/* Otherwise set TREE_USED for the benefit of -Wunused-function.
+	   See PR80598.  */
+	TREE_USED (fn) = 1;
 
       return_type = TREE_TYPE (TREE_TYPE (fn));
       nargs = vec_safe_length (args);
@@ -7929,7 +7935,15 @@
       tree *fargs = (!nargs ? argarray
 			    : (tree *) alloca (nargs * sizeof (tree)));
       for (j = 0; j < nargs; j++)
-	fargs[j] = maybe_constant_value (argarray[j]);
+	{
+	  /* For -Wformat undo the implicit passing by hidden reference
+	     done by convert_arg_to_ellipsis.  */
+	  if (TREE_CODE (argarray[j]) == ADDR_EXPR
+	      && TREE_CODE (TREE_TYPE (argarray[j])) == REFERENCE_TYPE)
+	    fargs[j] = TREE_OPERAND (argarray[j], 0);
+	  else
+	    fargs[j] = maybe_constant_value (argarray[j]);
+	}
 
       warned_p = check_function_arguments (input_location, fn, TREE_TYPE (fn),
 					   nargs, fargs);
@@ -8399,6 +8413,9 @@
 	{
 	  if (is_dummy_object (instance))
 	    return arg;
+	  else if (TREE_CODE (arg) == TARGET_EXPR)
+	    TARGET_EXPR_DIRECT_INIT_P (arg) = true;
+
 	  if ((complain & tf_error)
 	      && (flags & LOOKUP_DELEGATING_CONS))
 	    check_self_delegation (arg);
@@ -8851,8 +8868,14 @@
 	      if (TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE
 		  && !is_dummy_object (instance)
 		  && TREE_SIDE_EFFECTS (instance))
-		call = build2 (COMPOUND_EXPR, TREE_TYPE (call),
-			       instance, call);
+		{
+		  /* But avoid the implicit lvalue-rvalue conversion when 'a'
+		     is volatile.  */
+		  tree a = instance;
+		  if (TREE_THIS_VOLATILE (a))
+		    a = build_this (a);
+		  call = build2 (COMPOUND_EXPR, TREE_TYPE (call), a, call);
+		}
 	      else if (call != error_mark_node
 		       && DECL_DESTRUCTOR_P (cand->fn)
 		       && !VOID_TYPE_P (TREE_TYPE (call)))
diff -ruN gcc-7.3.0/gcc/cp/ChangeLog gcc-7.3.0-msp430/gcc/cp/ChangeLog
--- gcc-7.3.0/gcc/cp/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/gcc/cp/ChangeLog	2019-06-25 02:27:21.105931389 -0700
@@ -1,3 +1,572 @@
+2018-08-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-08-02  Richard Biener  <rguenther@suse.de>
+
+	PR c++/86763
+	* class.c (layout_class_type): Copy TYPE_TYPELESS_STORAGE
+	to the CLASSTYPE_AS_BASE.
+
+2018-08-10  Jason Merrill  <jason@redhat.com>
+
+	PR c++/86728 - C variadic generic lambda.
+	* parser.c (cp_parser_parameter_declaration): Don't turn 'auto' into
+	a pack if it's followed by a declarator-id.
+
+2018-07-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/86378 - functional cast in noexcept-specifier.
+	* tree.c (strip_typedefs_expr) [TREE_LIST]: Fix iteration.
+
+2018-06-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/80290 - memory-hog with std::pair.
+	* pt.c (type_unification_real): Skip non-dependent conversion
+	check for a nested list argument.
+	(braced_init_depth): New.
+
+2018-06-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86291
+	* parser.c (cp_parser_omp_for_loop_init): Change for_block argument
+	type from vec<tree, va_gc> * to vec<tree, va_gc> *&.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85952
+	* init.c (build_aggr_init): For structured binding initialized from
+	array call mark_rvalue_use on the initializer.
+
+	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/85696
+	* cp-tree.h (cxx_omp_predetermined_sharing_1): New prototype.
+	* cp-gimplify.c (cxx_omp_predetermined_sharing): New wrapper around
+	cxx_omp_predetermined_sharing_1.  Rename old function to ...
+	(cxx_omp_predetermined_sharing_1): ... this.
+	* semantics.c (finish_omp_clauses): Use cxx_omp_predetermined_sharing_1
+	instead of cxx_omp_predetermined_sharing.
+
+	2018-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* cp-gimplify.c (cp_fold): Use fold_offsetof rather than
+	fold_offsetof_1, pass TREE_TYPE (x) as TYPE to it and drop the
+	fold_convert.
+
+	2018-04-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84463
+	* typeck.c (cp_build_addr_expr_1): Move handling of offsetof-like
+	tricks from here to ...
+	* cp-gimplify.c (cp_fold) <case ADDR_EXPR>: ... here.  Only use it
+	if INDIRECT_REF's operand is INTEGER_CST cast to pointer type.
+
+	2018-04-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85210
+	* pt.c (tsubst_decomp_names): Return error_mark_node and assert
+	errorcount is set if tsubst doesn't return a VAR_DECL.
+
+	2018-04-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85208
+	* decl.c (start_decl): For DECL_DECOMPOSITION_P decls, don't call
+	maybe_apply_pragma_weak here...
+	(cp_maybe_mangle_decomp): ... but call it here instead.
+
+	2018-04-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/85172
+	* constexpr.c (cxx_eval_builtin_function_call): For calls to
+	builtin_valid_in_constant_expr_p functions, don't call
+	cxx_eval_constant_expression if argument is not
+	potential_constant_expression.
+
+	2018-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85147
+	* pt.c (fixed_parameter_pack_p_1): Punt if parm is error_mark_node.
+
+	PR c++/85140
+	* name-lookup.c (handle_namespace_attrs): Return early if attributes
+	is error_mark_node.
+
+	2018-03-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84791
+	* semantics.c (finish_omp_reduction_clause): If
+	OMP_CLAUSE_REDUCTION_PLACEHOLDER is error_mark_node, return true
+	even if processing_template_decl.
+
+	2018-03-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85076
+	* tree.c (cp_build_reference_type): If to_type is error_mark_node,
+	return it right away.
+
+	PR c++/85068
+	* class.c (update_vtable_entry_for_fn): Don't ICE if base_binfo
+	is NULL.  Assert if thunk_binfo is NULL then errorcount is non-zero.
+
+	2018-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84961
+	* cp-tree.h (genericize_compound_lvalue): Declare.
+	* typeck.c (genericize_compound_lvalue): New function.
+	(unary_complex_lvalue, cp_build_modify_expr): Use it.
+	* semantics.c (finish_asm_stmt): Replace MODIFY_EXPR, PREINCREMENT_EXPR
+	and PREDECREMENT_EXPR in output and "m" constrained input operands with
+	COMPOUND_EXPR.  Call cxx_mark_addressable on the rightmost
+	COMPOUND_EXPR operand.
+
+	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84874
+	* decl.c (reshape_init_class): Don't assert d->cur->index == field
+	if d->cur->index is a FIELD_DECL, instead set field to d->cur->index.
+
+	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84222
+	* cp-tree.h (cp_warn_deprecated_use): Declare.
+	* tree.c (cp_warn_deprecated_use): New function.
+	* typeck2.c (build_functional_cast): Use it.
+	* decl.c (grokparms): Likewise.
+	(grokdeclarator): Likewise.  Temporarily push nested class scope
+	around grokparms call for out of class member definitions.
+
+	2018-03-09  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84076
+	* call.c (convert_arg_to_ellipsis): Instead of cp_build_addr_expr
+	build ADDR_EXPR with REFERENCE_TYPE.
+	(build_over_call): For purposes of check_function_arguments, if
+	argarray[j] is ADDR_EXPR with REFERENCE_TYPE created above, use
+	its operand rather than the argument itself.
+
+	2018-03-08  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/80598
+	* call.c (build_over_call): In templates set TREE_USED (first_fn) when
+	not calling mark_used for the benefit of -Wunused-function warning.
+
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84662
+	* pt.c (tsubst_copy_and_build) <case TEMPLATE_ID_EXPR>: Use
+	RETURN instead of return.
+	<case POINTER_PLUS_EXPR>: Likewise.
+	<case CONVERT_EXPR>: If op0 is error_mark_node, just return
+	it instead of wrapping it into CONVERT_EXPR.
+
+2018-06-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85815 - reference to member of enclosing template.
+	* parser.c (cp_parser_postfix_dot_deref_expression): Check
+	currently_open_class.
+
+	PR c++/86060 - ICE on range for with -std=c++98.
+	* parser.c (cp_parser_init_statement): Don't clobber *decl after
+	pedwarn.
+
+2018-05-07  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85646 - lambda visibility.
+	* decl2.c (determine_visibility): Don't mess with template arguments
+	from the containing scope.
+	(vague_linkage_p): Check DECL_ABSTRACT_P before looking at a 'tor
+	thunk.
+
+2018-04-23  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backport from mainline
+	2018-04-05  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Implement P0969
+	* decl.c (find_decomp_class_base): Check accessibility instead
+	of declared access, adjust diagnostic.
+
+2018-04-23  Jakub Jelinek  <jakub@redhat.com>
+	    Jason Merrill  <jason@redhat.com>
+
+	PR c++/85470 - wrong error with static data member.
+	* decl.c (check_initializer): Check DECL_INITIALIZED_IN_CLASS_P.
+	* typeck2.c (store_init_value): Likewise.
+
+2018-04-23  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backport from mainline
+	2018-04-05  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Implement P0961
+	* decl.c (get_tuple_decomp_init): Check the templatedness
+	of a member get.
+
+2018-04-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/85464 - missing location for -Wignored-qualifiers diagnostic
+	* decl.c (grokdeclarator): If declspecs->locations[ds_type_spec]
+	is UNKNOWN_LOCATION fall back to input_location.
+
+2018-04-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85279 - dump_expr doesn't understand decltype.
+	* error.c (dump_expr): Handle DECLTYPE_TYPE.
+
+2018-04-05  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82152 - ICE with class deduction and inherited ctor.
+	* pt.c (do_class_deduction): Ignore inherited ctors.
+
+	PR c++/84665 - ICE with array of empty class.
+	* decl2.c (cp_check_const_attributes): Use fold_non_dependent_expr.
+
+	PR c++/85006 - -fconcepts ICE with A<auto...> return type
+	* pt.c (tsubst_pack_expansion): Allow unsubstituted auto pack.
+
+2018-04-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85118 - wrong error with generic lambda and std::bind.
+	* call.c (add_template_conv_candidate): Disable if there are any
+	call operators.
+
+	PR c++/85148 - ICE with 'this' in array NSDMI.
+	* tree.c (replace_placeholders_r): Use handled_component_p.
+
+2018-04-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85113 - ICE with constexpr and __builtin_constant_p.
+	* constexpr.c (cxx_eval_builtin_function_call): Only defer
+	__builtin_constant_p if ctx->quiet.
+
+	* typeck.c (merge_types): Limit matching attribute shortcut to
+	the default case.
+
+	PR c++/64095 - auto... parameter pack.
+	* parser.c (cp_parser_parameter_declaration): Handle turning autos
+	into packs here.
+	(cp_parser_parameter_declaration_list): Not here.
+
+	PR c++/85060 - wrong-code with call to base member in template.
+	* search.c (any_dependent_bases_p): Check uses_template_parms
+	rather than processing_template_decl.
+
+2018-03-29  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backport from mainline
+	2018-03-23  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Implement P0962
+	* parser.c (cp_parser_perform_range_for_lookup): Change
+	the condition for deciding whether to use members.
+
+2018-03-23  Jason Merrill  <jason@redhat.com>
+
+	PR c++/78489 - Substitution in wrong order
+	PR c++/84489
+	* pt.c (type_unification_real): Revert last two changes.
+
+	PR c++/71834 - template-id with too few arguments.
+	* pt.c (coerce_template_parms): Make sure we gave an error.
+
+	PR c++/84937 - ICE with class deduction and auto.
+	* pt.c (rewrite_template_parm): Fix auto handling.
+
+	PR c++/80227 - SFINAE and negative array size.
+	* decl.c (compute_array_index_type): Convert to signed for negative
+	check.
+
+	PR c++/84839 - ICE with decltype of parameter pack.
+	* pt.c (tsubst_pack_expansion): Set cp_unevaluated_operand while
+	instantiating dummy parms.
+
+	PR c++/84798 - ICE with auto in abstract function declarator.
+	* parser.c (cp_parser_parameter_declaration_clause): Check
+	parser->default_arg_ok_p.
+
+	PR c++/84355 - ICE with deduction for member class template.
+	* pt.c (tsubst) [TEMPLATE_TYPE_PARM]: Always substitute into
+	CLASS_PLACEHOLDER_TEMPLATE.
+
+2018-03-23  Paolo Carlini  <paolo.carlini@oracle.com>
+	    Jason Merrill  <jason@redhat.com>
+
+	PR c++/82336 - link error with list-init default argument.
+	* decl.c (check_default_argument): Unshare an initializer list.
+
+2018-03-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2018-03-22  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/84854
+	* semantics.c (finish_if_stmt_cond): Check if the type of the condition
+	is boolean.
+
+	2018-03-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/84927
+	* constexpr.c (cxx_eval_bare_aggregate): Update constructor's flags
+	as we evaluate the elements.
+	(cxx_eval_constant_expression): Verify constructor's flags
+	unconditionally.
+
+	2018-03-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/71638, ICE with NSDMI and reference.
+	* constexpr.c (cxx_eval_bare_aggregate): Update constructor's flags
+	even when we replace an element.
+
+2018-03-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84785 - ICE with alias template and default targs.
+	* pt.c (type_unification_real): Set processing_template_decl if
+	saw_undeduced == 1.
+
+2018-03-07  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2018-03-06  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/84684
+	* constexpr.c (cxx_bind_parameters_in_call): Unshare evaluated
+	arguments.
+
+2018-03-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84686 - missing volatile loads.
+	* cvt.c (convert_to_void): Call maybe_undo_parenthesized_ref.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-02-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84558
+	* constexpr.c (cxx_eval_vec_init_1): For reuse, treat NULL eltinit like
+	a valid constant initializer.  Formatting fixes.
+
+	PR c++/84557
+	* parser.c (cp_parser_omp_var_list_no_open): Only call
+	cp_parser_lookup_name_simple on names satisfying identifier_p.
+	(cp_parser_oacc_routine): Likewise.
+
+	2018-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84445
+	* class.c (fixed_type_or_null) <case CALL_EXPR>: Only test
+	TREE_HAS_CONSTRUCTOR if instance is not an internal function call.
+
+	PR c++/84449
+	* tree.c (bot_manip): If build_cplus_new or break_out_target_exprs
+	returns error_mark_node, return it immediately.
+	(break_out_target_exprs): If cp_walk_tree with bot_manip returns
+	error_mark_node, return error_mark_node.
+
+	2018-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84448
+	* parser.c (cp_parser_binary_expression): For no_toplevel_fold_p, if
+	either operand is error_mark_node, set current.lhs to that instead of
+	creating a binary op with error_mark_node operands.
+
+	PR c++/84430
+	* constexpr.c (potential_constant_expression_1): Handle OMP_SIMD.
+
+	2018-02-16  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84192
+	* constexpr.c (cxx_eval_constant_expression) <case RETURN_EXPR>: Don't
+	set *jump_target to anything if jump_target is NULL.
+
+	2018-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84341
+	* parser.c (cp_parser_binary_expression): Use build_min instead of
+	build2_loc to build the no_toplevel_fold_p toplevel binary expression.
+
+	2018-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* tree.c (cp_free_lang_data): Revert 2018-01-23 change.
+
+	2018-02-09  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83659
+	* constexpr.c (cxx_fold_indirect_ref): Sync some changes from
+	fold_indirect_ref_1.  Verify first that tree_fits_shwi_p (op01).
+	Formatting fixes.
+
+	2018-02-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84082
+	* parser.c (cp_parser_dot_deref_incomplete): New function.
+	(cp_parser_postfix_dot_deref_expression): Use it.
+
+	2018-01-31  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83993
+	* constexpr.c (cxx_eval_outermost_constant_expr): Build NOP_EXPR
+	around non-constant ADDR_EXPRs rather than clearing TREE_CONSTANT
+	on ADDR_EXPR.
+
+	2018-01-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84031
+	* decl.c (find_decomp_class_base): Ignore unnamed bitfields.  Ignore
+	recursive calls that return ret.
+	(cp_finish_decomp): Ignore unnamed bitfields.
+
+	2018-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* tree.c (cp_free_lang_data): Change DECL_VALUE_EXPR of
+	DECL_OMP_PRIVATIZED_MEMBER vars to error_mark_node.
+
+	PR c++/83958
+	* decl.c (cp_finish_decomp): Diagnose if reference structure binding
+	refers to incomplete type.
+
+	2018-01-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83824
+	* parser.c (attr_chainon): New function.
+	(cp_parser_label_for_labeled_statement, cp_parser_decl_specifier_seq,
+	cp_parser_namespace_definition, cp_parser_init_declarator,
+	cp_parser_type_specifier_seq, cp_parser_parameter_declaration,
+	cp_parser_gnu_attributes_opt): Use it.
+	(cp_parser_member_declaration, cp_parser_objc_class_ivars,
+	cp_parser_objc_struct_declaration): Likewise.  Don't reset
+	prefix_attributes if attributes is error_mark_node.
+
+	2018-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83817
+	* pt.c (tsubst_copy_and_build) <case CALL_EXPR>: If function
+	is AGGR_INIT_EXPR rather than CALL_EXPR, set AGGR_INIT_FROM_THUNK_P
+	instead of CALL_FROM_THUNK_P.
+
+2018-03-02  Jason Merrill  <jason@redhat.com>
+
+	Fix MIPS16 ICE.
+	* pt.c (type_dependent_expression_p): Check DECL_LANG_SPECIFIC.
+
+2018-02-27  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84489 - dependent default template argument
+	* pt.c (type_unification_real): Handle early substitution failure.
+
+2018-03-01  Jason Merrill  <jason@redhat.com>
+
+	PR c++/71569 - decltype of template.
+	* parser.c (cp_parser_decltype_expr): Handle missing template args.
+
+2018-03-01  Jason Merrill  <jason@redhat.com>
+	    Alexandre Oliva <aoliva@redhat.com>
+
+	PR c++/71569 - ICE with redundant args on member variable template.
+	* decl.c (start_decl): Handle partial specialization of member
+	variable template.
+	* pt.c (determine_specialization): Allow partial specialization
+	of member variable template without specializing enclosing class.
+	(process_partial_specialization): Improve error message.
+
+2018-02-28  Jason Merrill  <jason@redhat.com>
+
+	PR c++/71784 - ICE with ref-qualifier and explicit specialization.
+	* pt.c (determine_specialization): Check ref-qualifier.
+
+2018-02-27  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84496 - ICE with generic lambda in lambda.
+	* pt.c (type_dependent_expression_p): Fix dependency checking of
+	functions without DECL_TEMPLATE_INFO.
+
+2018-02-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84441 - ICE with base initialized from ?:
+	* call.c (unsafe_copy_elision_p): Handle COND_EXPR.
+
+	PR c++/84520 - ICE with generic lambda in NSDMI.
+	* lambda.c (lambda_expr_this_capture): Don't look for fake NSDMI
+	'this' in a generic lambda instantiation.
+
+2018-02-26  Jason Merrill  <jason@redhat.com>
+	    Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	PR c++/81589 - error with is_trivially_constructible.
+	* method.c (constructible_expr): Set cp_unevaluated.
+
+2018-02-25  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84015 - ICE with class deduction and auto template parm.
+	* pt.c (rewrite_template_parm): Use tf_partial in first tsubst.
+
+2018-02-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2017-08-29  Jason Merrill  <jason@redhat.com>
+
+	Fix lambdas in template default argument of inherited ctor.
+	* method.c (synthesized_method_base_walk): Replace an inherited
+	template with its specialization.
+	(synthesized_method_walk): Make inheriting_ctor a pointer.
+	(maybe_explain_implicit_delete, explain_implicit_non_constexpr)
+	(deduce_inheriting_ctor, implicitly_declare_fn): Adjust.
+
+2018-02-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84151 - unnecessary volatile load with static member.
+	* call.c (build_new_method_call_1): Avoid loading from a volatile
+	lvalue used as the object argument for a static member function.
+
+	PR c++/81853 - using-directive and constexpr.
+	* constexpr.c (cxx_eval_constant_expression): Handle USING_STMT.
+
+	PR c++/84420 - ICE with structured binding in lambda.
+	* lambda.c (is_capture_proxy): Check DECL_DECOMPOSITION_P.
+
+	PR c++/83835 - C++17 error with constructor ctors.
+	* call.c (build_special_member_call): Set TARGET_EXPR_DIRECT_INIT_P.
+
+	PR c++/82664 - ICE with reference to function template parm.
+	* pt.c (convert_nontype_argument_function): Avoid obfuscationg
+	NOP_EXPRs.
+
+	PR c++/82764 - C++17 ICE with empty base
+	* class.c (build_base_field_1): Set DECL_SIZE to zero for empty base.
+
+	PR c++/83227 - C++17 ICE with init-list derived-to-base conversion.
+	* call.c (convert_like_real): Don't use the copy-list-initialization
+	shortcut for ck_base.
+
+	PR c++/84045 - ICE with typedef and noexcept.
+	* except.c (build_noexcept_spec): Use strip_typedefs_expr.
+
+2018-01-29  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82461 - constexpr list-initialized member
+	* constexpr.c (potential_constant_expression_1): Check
+	TARGET_EXPR_DIRECT_INIT_P.
+
+2018-01-26  Nathan Sidwell  <nathan@acm.org>
+
+	PR c++/82878
+	PR c++/78495
+	* call.c (build_call_a): Don't set CALL_FROM_THUNK_P for inherited
+	ctor.
+	* cp-gimplify.c	(cp_genericize_r): Restore THUNK dereference
+	inhibibition check removed in previous c++/78495 change.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/gcc/cp/class.c gcc-7.3.0-msp430/gcc/cp/class.c
--- gcc-7.3.0/gcc/cp/class.c	2017-05-31 10:53:06.289056000 -0700
+++ gcc-7.3.0-msp430/gcc/cp/class.c	2019-06-25 02:27:21.109931362 -0700
@@ -2732,19 +2732,20 @@
 	     order.  Of course it is lame that we have to repeat the
 	     search here anyway -- we should really be caching pieces
 	     of the vtable and avoiding this repeated work.  */
-	  tree thunk_binfo, base_binfo;
+	  tree thunk_binfo = NULL_TREE;
+	  tree base_binfo = TYPE_BINFO (base_return);
 
 	  /* Find the base binfo within the overriding function's
 	     return type.  We will always find a thunk_binfo, except
 	     when the covariancy is invalid (which we will have
 	     already diagnosed).  */
-	  for (base_binfo = TYPE_BINFO (base_return),
-	       thunk_binfo = TYPE_BINFO (over_return);
-	       thunk_binfo;
-	       thunk_binfo = TREE_CHAIN (thunk_binfo))
-	    if (SAME_BINFO_TYPE_P (BINFO_TYPE (thunk_binfo),
-				   BINFO_TYPE (base_binfo)))
-	      break;
+	  if (base_binfo)
+	    for (thunk_binfo = TYPE_BINFO (over_return); thunk_binfo;
+		 thunk_binfo = TREE_CHAIN (thunk_binfo))
+	      if (SAME_BINFO_TYPE_P (BINFO_TYPE (thunk_binfo),
+				     BINFO_TYPE (base_binfo)))
+		break;
+	  gcc_assert (thunk_binfo || errorcount);
 
 	  /* See if virtual inheritance is involved.  */
 	  for (virtual_offset = thunk_binfo;
@@ -4532,8 +4533,14 @@
   DECL_ARTIFICIAL (decl) = 1;
   DECL_IGNORED_P (decl) = 1;
   DECL_FIELD_CONTEXT (decl) = t;
-  DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);
-  DECL_SIZE_UNIT (decl) = CLASSTYPE_SIZE_UNIT (basetype);
+  if (is_empty_class (basetype))
+    /* CLASSTYPE_SIZE is one byte, but the field needs to have size zero.  */
+    DECL_SIZE (decl) = DECL_SIZE_UNIT (decl) = size_zero_node;
+  else
+    {
+      DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);
+      DECL_SIZE_UNIT (decl) = CLASSTYPE_SIZE_UNIT (basetype);
+    }
   SET_DECL_ALIGN (decl, CLASSTYPE_ALIGN (basetype));
   DECL_USER_ALIGN (decl) = CLASSTYPE_USER_ALIGN (basetype);
   SET_DECL_MODE (decl, TYPE_MODE (basetype));
@@ -6655,6 +6662,7 @@
 				  bitsize_int (BITS_PER_UNIT)));
       SET_TYPE_ALIGN (base_t, rli->record_align);
       TYPE_USER_ALIGN (base_t) = TYPE_USER_ALIGN (t);
+      TYPE_TYPELESS_STORAGE (base_t) = TYPE_TYPELESS_STORAGE (t);
 
       /* Copy the fields from T.  */
       next_field = &TYPE_FIELDS (base_t);
@@ -7592,7 +7600,8 @@
 
     case CALL_EXPR:
       /* This is a call to a constructor, hence it's never zero.  */
-      if (TREE_HAS_CONSTRUCTOR (instance))
+      if (CALL_EXPR_FN (instance)
+	  && TREE_HAS_CONSTRUCTOR (instance))
 	{
 	  if (nonnull)
 	    *nonnull = 1;
diff -ruN gcc-7.3.0/gcc/cp/constexpr.c gcc-7.3.0-msp430/gcc/cp/constexpr.c
--- gcc-7.3.0/gcc/cp/constexpr.c	2017-12-19 02:02:48.655807000 -0800
+++ gcc-7.3.0-msp430/gcc/cp/constexpr.c	2019-06-25 02:27:21.109931362 -0700
@@ -1140,7 +1140,10 @@
   /* Don't fold __builtin_constant_p within a constexpr function.  */
   bool bi_const_p = (DECL_FUNCTION_CODE (fun) == BUILT_IN_CONSTANT_P);
 
+  /* If we aren't requiring a constant expression, defer __builtin_constant_p
+     in a constexpr function until we have values for the parameters.  */
   if (bi_const_p
+      && ctx->quiet
       && current_function_decl
       && DECL_DECLARED_CONSTEXPR_P (current_function_decl))
     {
@@ -1155,8 +1158,14 @@
   bool dummy1 = false, dummy2 = false;
   for (i = 0; i < nargs; ++i)
     {
-      args[i] = cxx_eval_constant_expression (&new_ctx, CALL_EXPR_ARG (t, i),
-					      false, &dummy1, &dummy2);
+      args[i] = CALL_EXPR_ARG (t, i);
+      /* If builtin_valid_in_constant_expr_p is true,
+	 potential_constant_expression_1 has not recursed into the arguments
+	 of the builtin, verify it here.  */
+      if (!builtin_valid_in_constant_expr_p (fun)
+	  || potential_constant_expression (args[i]))
+	args[i] = cxx_eval_constant_expression (&new_ctx, args[i], false,
+						&dummy1, &dummy2);
       if (bi_const_p)
 	/* For __built_in_constant_p, fold all expressions with constant values
 	   even if they aren't C++ constant-expressions.  */
@@ -1274,6 +1283,8 @@
 
       if (!*non_constant_p)
 	{
+	  /* Don't share a CONSTRUCTOR that might be changed.  */
+	  arg = unshare_constructor (arg);
 	  /* Make sure the binding has the same type as the parm.  But
 	     only for constant args.  */
 	  if (TREE_CODE (type) != REFERENCE_TYPE)
@@ -2783,14 +2794,20 @@
 	  gcc_assert (is_empty_class (TREE_TYPE (TREE_TYPE (index))));
 	  changed = true;
 	}
-      else if (new_ctx.ctor != ctx->ctor)
+      else
 	{
-	  /* We appended this element above; update the value.  */
-	  gcc_assert ((*p)->last().index == index);
-	  (*p)->last().value = elt;
+	  if (new_ctx.ctor != ctx->ctor)
+	    {
+	      /* We appended this element above; update the value.  */
+	      gcc_assert ((*p)->last().index == index);
+	      (*p)->last().value = elt;
+	    }
+	  else
+	    CONSTRUCTOR_APPEND_ELT (*p, index, elt);
+	  /* Adding or replacing an element might change the ctor's flags.  */
+	  TREE_CONSTANT (ctx->ctor) = constant_p;
+	  TREE_SIDE_EFFECTS (ctx->ctor) = side_effects_p;
 	}
-      else
-	CONSTRUCTOR_APPEND_ELT (*p, index, elt);
     }
   if (*non_constant_p || !changed)
     return t;
@@ -2895,9 +2912,8 @@
 	  if (!lvalue_p (init))
 	    eltinit = move (eltinit);
 	  eltinit = force_rvalue (eltinit, tf_warning_or_error);
-	  eltinit = (cxx_eval_constant_expression
-		     (&new_ctx, eltinit, lval,
-		      non_constant_p, overflow_p));
+	  eltinit = cxx_eval_constant_expression (&new_ctx, eltinit, lval,
+						  non_constant_p, overflow_p);
 	}
       if (*non_constant_p && !ctx->quiet)
 	break;
@@ -2910,12 +2926,13 @@
       else
 	CONSTRUCTOR_APPEND_ELT (*p, idx, eltinit);
       /* Reuse the result of cxx_eval_constant_expression call
-	  from the first iteration to all others if it is a constant
-	  initializer that doesn't require relocations.  */
+	 from the first iteration to all others if it is a constant
+	 initializer that doesn't require relocations.  */
       if (reuse
 	  && max > 1
-	  && (initializer_constant_valid_p (eltinit, TREE_TYPE (eltinit))
-	      == null_pointer_node))
+	  && (eltinit == NULL_TREE
+	      || (initializer_constant_valid_p (eltinit, TREE_TYPE (eltinit))
+		  == null_pointer_node)))
 	{
 	  if (new_ctx.ctor != ctx->ctor)
 	    eltinit = new_ctx.ctor;
@@ -2966,9 +2983,9 @@
 static tree
 cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)
 {
-  tree sub, subtype;
+  tree sub = op0;
+  tree subtype;
 
-  sub = op0;
   STRIP_NOPS (sub);
   subtype = TREE_TYPE (sub);
   if (!POINTER_TYPE_P (subtype))
@@ -3023,7 +3040,8 @@
 	{
 	  tree part_width = TYPE_SIZE (type);
 	  tree index = bitsize_int (0);
-	  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width, index);
+	  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width,
+				  index);
 	}
       /* Also handle conversion to an empty base class, which
 	 is represented with a NOP_EXPR.  */
@@ -3063,19 +3081,31 @@
 	  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */
 	  if (VECTOR_TYPE_P (op00type)
 	      && (same_type_ignoring_top_level_qualifiers_p
-		  (type, TREE_TYPE (op00type))))
+						(type, TREE_TYPE (op00type)))
+	      /* POINTER_PLUS_EXPR second operand is sizetype, unsigned,
+		 but we want to treat offsets with MSB set as negative.
+		 For the code below negative offsets are invalid and
+		 TYPE_SIZE of the element is something unsigned, so
+		 check whether op01 fits into HOST_WIDE_INT, which
+		 implies it is from 0 to INTTYPE_MAXIMUM (HOST_WIDE_INT), and
+		 then just use unsigned HOST_WIDE_INT because we want to treat
+		 the value as unsigned.  */
+	      && tree_fits_shwi_p (op01))
 	    {
-	      HOST_WIDE_INT offset = tree_to_shwi (op01);
 	      tree part_width = TYPE_SIZE (type);
-	      unsigned HOST_WIDE_INT part_widthi = tree_to_shwi (part_width)/BITS_PER_UNIT;
-	      unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;
-	      tree index = bitsize_int (indexi);
-
-	      if (offset / part_widthi < TYPE_VECTOR_SUBPARTS (op00type))
-		return fold_build3_loc (loc,
-					BIT_FIELD_REF, type, op00,
-					part_width, index);
-
+	      unsigned HOST_WIDE_INT max_offset
+		= (tree_to_uhwi (part_width) / BITS_PER_UNIT
+		   * TYPE_VECTOR_SUBPARTS (op00type));
+	      if (tree_int_cst_sign_bit (op01) == 0
+		  && compare_tree_int (op01, max_offset) == -1)
+		{
+		  unsigned HOST_WIDE_INT offset = tree_to_uhwi (op01);
+		  unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;
+		  tree index = bitsize_int (indexi);
+		  return fold_build3_loc (loc,
+					  BIT_FIELD_REF, type, op00,
+					  part_width, index);
+		}
 	    }
 	  /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */
 	  else if (TREE_CODE (op00type) == COMPLEX_TYPE
@@ -3132,7 +3162,8 @@
     {
       tree type_domain;
       tree min_val = size_zero_node;
-      tree newsub = cxx_fold_indirect_ref (loc, TREE_TYPE (subtype), sub, NULL);
+      tree newsub
+	= cxx_fold_indirect_ref (loc, TREE_TYPE (subtype), sub, NULL);
       if (newsub)
 	sub = newsub;
       else
@@ -4170,7 +4201,16 @@
 	r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),
 					  lval,
 					  non_constant_p, overflow_p);
-      *jump_target = t;
+      if (jump_target)
+	*jump_target = t;
+      else
+	{
+	  /* Can happen with ({ return true; }) && false; passed to
+	     maybe_constant_value.  There is nothing to jump over in this
+	     case, and the bug will be diagnosed later.  */
+	  gcc_assert (ctx->quiet);
+	  *non_constant_p = true;
+	}
       break;
 
     case SAVE_EXPR:
@@ -4414,11 +4454,7 @@
 	{
 	  /* Don't re-process a constant CONSTRUCTOR, but do fold it to
 	     VECTOR_CST if applicable.  */
-	  /* FIXME after GCC 6 branches, make the verify unconditional.  */
-	  if (CHECKING_P)
-	    verify_constructor_flags (t);
-	  else
-	    recompute_constructor_flags (t);
+	  verify_constructor_flags (t);
 	  if (TREE_CONSTANT (t))
 	    return fold (t);
 	}
@@ -4640,6 +4676,10 @@
 					jump_target);
       break;
 
+    case USING_STMT:
+      r = void_node;
+      break;
+
     default:
       if (STATEMENT_CODE_P (TREE_CODE (t)))
 	{
@@ -4763,8 +4803,12 @@
     return error_mark_node;
   else if (non_constant_p && TREE_CONSTANT (r))
     {
-      /* This isn't actually constant, so unset TREE_CONSTANT.  */
-      if (EXPR_P (r))
+      /* This isn't actually constant, so unset TREE_CONSTANT.
+	 Don't clear TREE_CONSTANT on ADDR_EXPR, as the middle-end requires
+	 it to be set if it is invariant address, even when it is not
+	 a valid C++ constant expression.  Wrap it with a NOP_EXPR
+	 instead.  */
+      if (EXPR_P (r) && TREE_CODE (r) != ADDR_EXPR)
 	r = copy_node (r);
       else if (TREE_CODE (r) == CONSTRUCTOR)
 	r = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (r), r);
@@ -5453,6 +5497,7 @@
     case OMP_PARALLEL:
     case OMP_TASK:
     case OMP_FOR:
+    case OMP_SIMD:
     case OMP_DISTRIBUTE:
     case OMP_TASKLOOP:
     case OMP_TEAMS:
@@ -5627,7 +5672,8 @@
       return RECUR (TREE_OPERAND (t, 1), want_rval);
 
     case TARGET_EXPR:
-      if (!literal_type_p (TREE_TYPE (t)))
+      if (!TARGET_EXPR_DIRECT_INIT_P (t)
+	  && !literal_type_p (TREE_TYPE (t)))
 	{
 	  if (flags & tf_error)
 	    {
diff -ruN gcc-7.3.0/gcc/cp/cp-gimplify.c gcc-7.3.0-msp430/gcc/cp/cp-gimplify.c
--- gcc-7.3.0/gcc/cp/cp-gimplify.c	2017-12-15 14:06:16.801096000 -0800
+++ gcc-7.3.0-msp430/gcc/cp/cp-gimplify.c	2019-06-25 02:27:21.109931362 -0700
@@ -1107,6 +1107,14 @@
       && omp_var_to_track (stmt))
     omp_cxx_notice_variable (wtd->omp_ctx, stmt);
 
+  /* Don't dereference parms in a thunk, pass the references through. */
+  if ((TREE_CODE (stmt) == CALL_EXPR && CALL_FROM_THUNK_P (stmt))
+      || (TREE_CODE (stmt) == AGGR_INIT_EXPR && AGGR_INIT_FROM_THUNK_P (stmt)))
+    {
+      *walk_subtrees = 0;
+      return NULL;
+    }
+
   /* Dereference invisible reference parms.  */
   if (wtd->handle_invisiref_parm_p && is_invisiref_parm (stmt))
     {
@@ -1910,7 +1918,7 @@
 /* True if OpenMP sharing attribute of DECL is predetermined.  */
 
 enum omp_clause_default_kind
-cxx_omp_predetermined_sharing (tree decl)
+cxx_omp_predetermined_sharing_1 (tree decl)
 {
   /* Static data members are predetermined shared.  */
   if (TREE_STATIC (decl))
@@ -1928,6 +1936,32 @@
   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
 }
 
+/* Likewise, but also include the artificial vars.  We don't want to
+   disallow the artificial vars being mentioned in explicit clauses,
+   as we use artificial vars e.g. for loop constructs with random
+   access iterators other than pointers, but during gimplification
+   we want to treat them as predetermined.  */
+
+enum omp_clause_default_kind
+cxx_omp_predetermined_sharing (tree decl)
+{
+  enum omp_clause_default_kind ret = cxx_omp_predetermined_sharing_1 (decl);
+  if (ret != OMP_CLAUSE_DEFAULT_UNSPECIFIED)
+    return ret;
+
+  /* Predetermine artificial variables holding integral values, those
+     are usually result of gimplify_one_sizepos or SAVE_EXPR
+     gimplification.  */
+  if (VAR_P (decl)
+      && DECL_ARTIFICIAL (decl)
+      && INTEGRAL_TYPE_P (TREE_TYPE (decl))
+      && !(DECL_LANG_SPECIFIC (decl)
+	   && DECL_OMP_PRIVATIZED_MEMBER (decl)))
+    return OMP_CLAUSE_DEFAULT_SHARED;
+
+  return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
+}
+
 /* Finalize an implicitly determined clause.  */
 
 void
@@ -2148,6 +2182,28 @@
       goto unary;
 
     case ADDR_EXPR:
+      loc = EXPR_LOCATION (x);
+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), false);
+
+      /* Cope with user tricks that amount to offsetof.  */
+      if (op0 != error_mark_node
+	  && TREE_CODE (TREE_TYPE (op0)) != FUNCTION_TYPE
+	  && TREE_CODE (TREE_TYPE (op0)) != METHOD_TYPE)
+	{
+	  tree val = get_base_address (op0);
+	  if (val
+	      && INDIRECT_REF_P (val)
+	      && COMPLETE_TYPE_P (TREE_TYPE (val))
+	      && TREE_CONSTANT (TREE_OPERAND (val, 0)))
+	    {
+	      val = TREE_OPERAND (val, 0);
+	      STRIP_NOPS (val);
+	      if (TREE_CODE (val) == INTEGER_CST)
+		return fold_offsetof (op0, TREE_TYPE (x));
+	    }
+	}
+      goto finish_unary;
+
     case REALPART_EXPR:
     case IMAGPART_EXPR:
       rval_ops = false;
@@ -2165,6 +2221,7 @@
       loc = EXPR_LOCATION (x);
       op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);
 
+    finish_unary:
       if (op0 != TREE_OPERAND (x, 0))
 	{
 	  if (op0 == error_mark_node)
diff -ruN gcc-7.3.0/gcc/cp/cp-tree.h gcc-7.3.0-msp430/gcc/cp/cp-tree.h
--- gcc-7.3.0/gcc/cp/cp-tree.h	2017-12-15 16:40:14.867034000 -0800
+++ gcc-7.3.0-msp430/gcc/cp/cp-tree.h	2019-06-25 02:27:21.109931362 -0700
@@ -6708,6 +6708,7 @@
 
 extern void cxx_print_statistics		(void);
 extern bool maybe_warn_zero_as_null_pointer_constant (tree, location_t);
+extern void cp_warn_deprecated_use		(tree);
 
 /* in ptree.c */
 extern void cxx_print_xnode			(FILE *, tree, int);
@@ -6777,6 +6778,7 @@
 extern tree cp_build_addr_expr			(tree, tsubst_flags_t);
 extern tree cp_build_unary_op                   (enum tree_code, tree, bool,
                                                  tsubst_flags_t);
+extern tree genericize_compound_lvalue		(tree);
 extern tree unary_complex_lvalue		(enum tree_code, tree);
 extern tree build_x_conditional_expr		(location_t, tree, tree, tree, 
                                                  tsubst_flags_t);
@@ -6941,6 +6943,7 @@
 						 gimple_seq *);
 extern void cp_genericize			(tree);
 extern bool cxx_omp_const_qual_no_mutable	(tree);
+extern enum omp_clause_default_kind cxx_omp_predetermined_sharing_1 (tree);
 extern enum omp_clause_default_kind cxx_omp_predetermined_sharing (tree);
 extern tree cxx_omp_clause_default_ctor		(tree, tree, tree);
 extern tree cxx_omp_clause_copy_ctor		(tree, tree, tree);
diff -ruN gcc-7.3.0/gcc/cp/cvt.c gcc-7.3.0-msp430/gcc/cp/cvt.c
--- gcc-7.3.0/gcc/cp/cvt.c	2017-02-10 08:33:45.537937000 -0800
+++ gcc-7.3.0-msp430/gcc/cp/cvt.c	2019-06-25 02:27:21.109931362 -0700
@@ -1053,6 +1053,8 @@
       || TREE_TYPE (expr) == error_mark_node)
     return error_mark_node;
 
+  expr = maybe_undo_parenthesized_ref (expr);
+
   if (implicit == ICV_CAST)
     mark_exp_read (expr);
   else
diff -ruN gcc-7.3.0/gcc/cp/decl2.c gcc-7.3.0-msp430/gcc/cp/decl2.c
--- gcc-7.3.0/gcc/cp/decl2.c	2017-12-15 14:10:40.226025000 -0800
+++ gcc-7.3.0-msp430/gcc/cp/decl2.c	2019-06-25 02:27:21.113931332 -0700
@@ -1360,7 +1360,7 @@
 	{
 	  tree expr = TREE_VALUE (arg);
 	  if (EXPR_P (expr))
-	    TREE_VALUE (arg) = maybe_constant_value (expr);
+	    TREE_VALUE (arg) = fold_non_dependent_expr (expr);
 	}
     }
 }
@@ -1829,10 +1829,13 @@
 {
   if (!TREE_PUBLIC (decl))
     {
-      /* maybe_thunk_body clears TREE_PUBLIC on the maybe-in-charge 'tor
-	 variants, check one of the "clones" for the real linkage.  */
+      /* maybe_thunk_body clears TREE_PUBLIC and DECL_ABSTRACT_P on the
+	 maybe-in-charge 'tor variants; in that case we need to check one of
+	 the "clones" for the real linkage.  But only in that case; before
+	 maybe_clone_body we haven't yet copied the linkage to the clones.  */
       if ((DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl)
 	   || DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl))
+	  && !DECL_ABSTRACT_P (decl)
 	  && DECL_CHAIN (decl)
 	  && DECL_CLONED_FUNCTION (DECL_CHAIN (decl)))
 	return vague_linkage_p (DECL_CHAIN (decl));
@@ -2310,11 +2313,8 @@
 	    }
 
 	  /* Local classes in templates have CLASSTYPE_USE_TEMPLATE set,
-	     but have no TEMPLATE_INFO.  Their containing template
-	     function does, and the local class could be constrained
-	     by that.  */
-	  if (template_decl)
-	    template_decl = fn;
+	     but have no TEMPLATE_INFO, so don't try to check it.  */
+	  template_decl = NULL_TREE;
 	}
       else if (VAR_P (decl) && DECL_TINFO_P (decl)
 	       && flag_visibility_ms_compat)
diff -ruN gcc-7.3.0/gcc/cp/decl.c gcc-7.3.0-msp430/gcc/cp/decl.c
--- gcc-7.3.0/gcc/cp/decl.c	2017-12-15 16:41:10.275950000 -0800
+++ gcc-7.3.0-msp430/gcc/cp/decl.c	2019-06-25 02:27:21.109931362 -0700
@@ -5022,7 +5022,7 @@
     }
 
   /* If #pragma weak was used, mark the decl weak now.  */
-  if (!processing_template_decl)
+  if (!processing_template_decl && !DECL_DECOMPOSITION_P (decl))
     maybe_apply_pragma_weak (decl);
 
   if (TREE_CODE (decl) == FUNCTION_DECL
@@ -5042,19 +5042,17 @@
 	  if (field == NULL_TREE
 	      || !(VAR_P (field) || variable_template_p (field)))
 	    error ("%q+#D is not a static data member of %q#T", decl, context);
+	  else if (variable_template_p (field)
+		   && (DECL_LANG_SPECIFIC (decl)
+		       && DECL_TEMPLATE_SPECIALIZATION (decl)))
+	    /* OK, specialization was already checked.  */;
 	  else if (variable_template_p (field) && !this_tmpl)
 	    {
-	      if (DECL_LANG_SPECIFIC (decl)
-		  && DECL_TEMPLATE_SPECIALIZATION (decl))
-		/* OK, specialization was already checked.  */;
-	      else
-		{
-		  error_at (DECL_SOURCE_LOCATION (decl),
-			    "non-member-template declaration of %qD", decl);
-		  inform (DECL_SOURCE_LOCATION (field), "does not match "
-			  "member template declaration here");
-		  return error_mark_node;
-		}
+	      error_at (DECL_SOURCE_LOCATION (decl),
+			"non-member-template declaration of %qD", decl);
+	      inform (DECL_SOURCE_LOCATION (field), "does not match "
+		      "member template declaration here");
+	      return error_mark_node;
 	    }
 	  else
 	    {
@@ -5798,8 +5796,18 @@
 	    return error_mark_node;
 
 	  if (TREE_CODE (d->cur->index) == FIELD_DECL)
-	    /* We already reshaped this.  */
-	    gcc_assert (d->cur->index == field);
+	    {
+	      /* We already reshaped this.  */
+	      if (field != d->cur->index)
+		{
+		  tree id = DECL_NAME (d->cur->index);
+		  gcc_assert (id);
+		  gcc_checking_assert (lookup_field_1 (type, id,
+						       /*want_type=*/false)
+				       == d->cur->index);
+		  field = d->cur->index;
+		}
+	    }
 	  else if (TREE_CODE (d->cur->index) == IDENTIFIER_NODE)
 	    field = lookup_field_1 (type, d->cur->index, /*want_type=*/false);
 	  else
@@ -6402,7 +6410,9 @@
     }
 
   if (init_code
-      && (DECL_IN_AGGR_P (decl) && !DECL_VAR_DECLARED_INLINE_P (decl)))
+      && (DECL_IN_AGGR_P (decl)
+	  && DECL_INITIALIZED_IN_CLASS_P (decl)
+	  && !DECL_VAR_DECLARED_INLINE_P (decl)))
     {
       static int explained = 0;
 
@@ -7213,7 +7223,9 @@
 {
   bool member_seen = false;
   for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))
-    if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))
+    if (TREE_CODE (field) != FIELD_DECL
+	|| DECL_ARTIFICIAL (field)
+	|| (DECL_C_BIT_FIELD (field) && !DECL_NAME (field)))
       continue;
     else if (ret)
       return type;
@@ -7228,9 +7240,9 @@
 	inform (DECL_SOURCE_LOCATION (field), "declared here");
 	return error_mark_node;
       }
-    else if (TREE_PRIVATE (field) || TREE_PROTECTED (field))
+    else if (!accessible_p (type, field, true))
       {
-	error_at (loc, "cannot decompose non-public member %qD of %qT",
+	error_at (loc, "cannot decompose inaccessible member %qD of %qT",
 		  field, type);
 	inform (DECL_SOURCE_LOCATION (field),
 		TREE_PRIVATE (field)
@@ -7252,7 +7264,7 @@
       tree t = find_decomp_class_base (loc, TREE_TYPE (base_binfo), ret);
       if (t == error_mark_node)
 	return error_mark_node;
-      if (t != NULL_TREE)
+      if (t != NULL_TREE && t != ret)
 	{
 	  if (ret == type)
 	    {
@@ -7263,9 +7275,6 @@
 	    }
 	  else if (orig_ret != NULL_TREE)
 	    return t;
-	  else if (ret == t)
-	    /* OK, found the same base along another path.  We'll complain
-	       in convert_to_base if it's ambiguous.  */;
 	  else if (ret != NULL_TREE)
 	    {
 	      error_at (loc, "cannot decompose class type %qT: its base "
@@ -7341,7 +7350,29 @@
 
   tree fns = lookup_qualified_name (TREE_TYPE (e), get_id,
 				    /*type*/false, /*complain*/false);
-  if (fns != error_mark_node)
+  bool use_member_get = false;
+
+  /* To use a member get, member lookup must find at least one
+     declaration that is a function template
+     whose first template parameter is a non-type parameter.  */
+  for (tree iter = BASELINK_P (fns) ? BASELINK_FUNCTIONS (fns) : fns;
+       iter;
+       iter = OVL_NEXT (iter))
+    {
+      tree fn = OVL_CURRENT (iter);
+      if (TREE_CODE (fn) == TEMPLATE_DECL)
+	{
+	  tree tparms = DECL_TEMPLATE_PARMS (fn);
+	  tree parm = TREE_VEC_ELT (INNERMOST_TEMPLATE_PARMS (tparms), 0);
+	  if (TREE_CODE (TREE_VALUE (parm)) == PARM_DECL)
+	    {
+	      use_member_get = true;
+	      break;
+	    }
+	}
+    }
+
+  if (use_member_get)
     {
       fns = lookup_template_function (fns, targs);
       return build_new_method_call (e, fns, /*args*/NULL,
@@ -7391,6 +7422,7 @@
       for (unsigned int i = 0; i < count; i++, d = DECL_CHAIN (d))
 	v[count - i - 1] = d;
       SET_DECL_ASSEMBLER_NAME (decl, mangle_decomp (decl, v));
+      maybe_apply_pragma_weak (decl);
     }
 }
 
@@ -7466,6 +7498,12 @@
       type = complete_type (TREE_TYPE (type));
       if (type == error_mark_node)
 	goto error_out;
+      if (!COMPLETE_TYPE_P (type))
+	{
+	  error_at (loc, "structured binding refers to incomplete type %qT",
+		    type);
+	  goto error_out;
+	}
     }
 
   tree eltype = NULL_TREE;
@@ -7640,7 +7678,9 @@
 	  goto error_out;
 	}
       for (tree field = TYPE_FIELDS (btype); field; field = TREE_CHAIN (field))
-	if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))
+	if (TREE_CODE (field) != FIELD_DECL
+	    || DECL_ARTIFICIAL (field)
+	    || (DECL_C_BIT_FIELD (field) && !DECL_NAME (field)))
 	  continue;
 	else
 	  eltscnt++;
@@ -7655,7 +7695,9 @@
 	}
       unsigned int i = 0;
       for (tree field = TYPE_FIELDS (btype); field; field = TREE_CHAIN (field))
-	if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))
+	if (TREE_CODE (field) != FIELD_DECL
+	    || DECL_ARTIFICIAL (field)
+	    || (DECL_C_BIT_FIELD (field) && !DECL_NAME (field)))
 	  continue;
 	else
 	  {
@@ -9517,7 +9559,8 @@
       constant_expression_error (size);
 
       /* An array must have a positive number of elements.  */
-      if (tree_int_cst_lt (size, integer_zero_node))
+      tree signed_size = fold_convert (ssizetype, size);
+      if (tree_int_cst_lt (signed_size, integer_zero_node))
 	{
 	  if (!(complain & tf_error))
 	    return error_mark_node;
@@ -10097,6 +10140,8 @@
 						      declspecs->locations);
   if (typespec_loc == UNKNOWN_LOCATION)
     typespec_loc = declspecs->locations[ds_type_spec];
+  if (typespec_loc == UNKNOWN_LOCATION)
+    typespec_loc = input_location;
 
   /* Look inside a declarator for the name being declared
      and get it as a string, for an error message.  */
@@ -10366,7 +10411,7 @@
      suppress reports of deprecated items.  */
   if (type && TREE_DEPRECATED (type)
       && deprecated_state != DEPRECATED_SUPPRESS)
-    warn_deprecated_use (type, NULL_TREE);
+    cp_warn_deprecated_use (type);
   if (type && TREE_CODE (type) == TYPE_DECL)
     {
       typedef_decl = type;
@@ -10374,7 +10419,7 @@
       if (TREE_DEPRECATED (type)
 	  && DECL_ARTIFICIAL (typedef_decl)
 	  && deprecated_state != DEPRECATED_SUPPRESS)
-	warn_deprecated_use (type, NULL_TREE);
+	cp_warn_deprecated_use (type);
     }
   /* No type at all: default to `int', and set DEFAULTED_INT
      because it was not a user-defined typedef.  */
@@ -11169,8 +11214,18 @@
 		  explicitp = 2;
 	      }
 
-	    arg_types = grokparms (declarator->u.function.parameters,
-				   &parms);
+	    tree pushed_scope = NULL_TREE;
+	    if (funcdecl_p
+		&& decl_context != FIELD
+		&& inner_declarator->u.id.qualifying_scope
+		&& CLASS_TYPE_P (inner_declarator->u.id.qualifying_scope))
+	      pushed_scope
+		= push_scope (inner_declarator->u.id.qualifying_scope);
+
+	    arg_types = grokparms (declarator->u.function.parameters, &parms);
+
+	    if (pushed_scope)
+	      pop_scope (pushed_scope);
 
 	    if (inner_declarator
 		&& inner_declarator->kind == cdk_id
@@ -12556,7 +12611,9 @@
      A default argument expression is implicitly converted to the
      parameter type.  */
   ++cp_unevaluated_operand;
-  perform_implicit_conversion_flags (decl_type, arg, complain,
+  /* Avoid digest_init clobbering the initializer.  */
+  tree carg = BRACE_ENCLOSED_INITIALIZER_P (arg) ? unshare_expr (arg): arg;
+  perform_implicit_conversion_flags (decl_type, carg, complain,
 				     LOOKUP_IMPLICIT);
   --cp_unevaluated_operand;
 
@@ -12685,7 +12742,7 @@
 	    {
 	      tree deptype = type_is_deprecated (type);
 	      if (deptype)
-		warn_deprecated_use (deptype, NULL_TREE);
+		cp_warn_deprecated_use (deptype);
 	    }
 
 	  /* Top-level qualifiers on the parameters are
diff -ruN gcc-7.3.0/gcc/cp/error.c gcc-7.3.0-msp430/gcc/cp/error.c
--- gcc-7.3.0/gcc/cp/error.c	2017-10-27 13:34:22.526400000 -0700
+++ gcc-7.3.0-msp430/gcc/cp/error.c	2019-06-25 02:27:21.113931332 -0700
@@ -2695,6 +2695,7 @@
     case INTEGER_TYPE:
     case COMPLEX_TYPE:
     case VECTOR_TYPE:
+    case DECLTYPE_TYPE:
       pp_type_specifier_seq (pp, t);
       break;
 
diff -ruN gcc-7.3.0/gcc/cp/except.c gcc-7.3.0-msp430/gcc/cp/except.c
--- gcc-7.3.0/gcc/cp/except.c	2017-03-20 08:02:09.070187000 -0700
+++ gcc-7.3.0-msp430/gcc/cp/except.c	2019-06-25 02:27:21.113931332 -0700
@@ -1218,6 +1218,10 @@
     {
       gcc_assert (processing_template_decl
 		  || TREE_CODE (expr) == DEFERRED_NOEXCEPT);
+      if (TREE_CODE (expr) != DEFERRED_NOEXCEPT)
+	/* Avoid problems with a function type built with a dependent typedef
+	   being reused in another scope (c++/84045).  */
+	expr = strip_typedefs_expr (expr);
       return build_tree_list (expr, NULL_TREE);
     }
 }
diff -ruN gcc-7.3.0/gcc/cp/init.c gcc-7.3.0-msp430/gcc/cp/init.c
--- gcc-7.3.0/gcc/cp/init.c	2017-04-20 11:36:27.233320000 -0700
+++ gcc-7.3.0-msp430/gcc/cp/init.c	2019-06-25 02:27:21.113931332 -0700
@@ -1632,6 +1632,7 @@
       if (VAR_P (exp) && DECL_DECOMPOSITION_P (exp))
 	{
 	  from_array = 1;
+	  init = mark_rvalue_use (init);
 	  if (init && DECL_P (init)
 	      && !(flags & LOOKUP_ONLYCONVERTING))
 	    {
diff -ruN gcc-7.3.0/gcc/cp/lambda.c gcc-7.3.0-msp430/gcc/cp/lambda.c
--- gcc-7.3.0/gcc/cp/lambda.c	2017-07-27 02:36:37.932152000 -0700
+++ gcc-7.3.0-msp430/gcc/cp/lambda.c	2019-06-25 02:27:21.113931332 -0700
@@ -262,6 +262,7 @@
   return (VAR_P (decl)
 	  && DECL_HAS_VALUE_EXPR_P (decl)
 	  && !DECL_ANON_UNION_VAR_P (decl)
+	  && !DECL_DECOMPOSITION_P (decl)
 	  && LAMBDA_FUNCTION_P (DECL_CONTEXT (decl)));
 }
 
@@ -712,11 +713,14 @@
                                     lambda_stack);
 
 	  if (LAMBDA_EXPR_EXTRA_SCOPE (tlambda)
+	      && !COMPLETE_TYPE_P (LAMBDA_EXPR_CLOSURE (tlambda))
 	      && TREE_CODE (LAMBDA_EXPR_EXTRA_SCOPE (tlambda)) == FIELD_DECL)
 	    {
 	      /* In an NSDMI, we don't have a function to look up the decl in,
 		 but the fake 'this' pointer that we're using for parsing is
-		 in scope_chain.  */
+		 in scope_chain.  But if the closure is already complete, we're
+	         in an instantiation of a generic lambda, and the fake 'this'
+	         is gone.  */
 	      init = scope_chain->x_current_class_ptr;
 	      gcc_checking_assert
 		(init && (TREE_TYPE (TREE_TYPE (init))
@@ -1072,7 +1076,6 @@
       }
   }
 
-
   if (generic_lambda_p)
     {
       if (decltype_call)
diff -ruN gcc-7.3.0/gcc/cp/method.c gcc-7.3.0-msp430/gcc/cp/method.c
--- gcc-7.3.0/gcc/cp/method.c	2017-08-09 13:17:47.916618000 -0700
+++ gcc-7.3.0-msp430/gcc/cp/method.c	2019-06-25 02:27:21.113931332 -0700
@@ -1165,6 +1165,7 @@
     {
       tree ctype = to;
       vec<tree, va_gc> *args = NULL;
+      cp_unevaluated cp_uneval_guard;
       if (TREE_CODE (to) != REFERENCE_TYPE)
 	to = cp_build_reference_type (to, /*rval*/false);
       tree ob = build_stub_object (to);
@@ -1430,7 +1431,7 @@
 synthesized_method_base_walk (tree binfo, tree base_binfo, 
 			      int quals, bool copy_arg_p,
 			      bool move_p, bool ctor_p,
-			      tree inheriting_ctor, tree inherited_parms,
+			      tree *inheriting_ctor, tree inherited_parms,
 			      tree fnname, int flags, bool diag,
 			      tree *spec_p, bool *trivial_p,
 			      bool *deleted_p, bool *constexpr_p)
@@ -1441,8 +1442,9 @@
 
   if (copy_arg_p)
     argtype = build_stub_type (BINFO_TYPE (base_binfo), quals, move_p);
-  else if ((inherited_binfo
-	    = binfo_inherited_from (binfo, base_binfo, inheriting_ctor)))
+  else if (inheriting_ctor
+	   && (inherited_binfo
+	       = binfo_inherited_from (binfo, base_binfo, *inheriting_ctor)))
     {
       argtype = inherited_parms;
       /* Don't check access on the inherited constructor.  */
@@ -1464,6 +1466,12 @@
   if (defer != dk_no_deferred)
     pop_deferring_access_checks ();
 
+  /* Replace an inherited template with the appropriate specialization.  */
+  if (inherited_binfo && rval
+      && DECL_P (*inheriting_ctor) && DECL_P (rval)
+      && DECL_CONTEXT (*inheriting_ctor) == DECL_CONTEXT (rval))
+    *inheriting_ctor = DECL_CLONED_FUNCTION (rval);
+
   process_subob_fn (rval, spec_p, trivial_p, deleted_p,
 		    constexpr_p, diag, BINFO_TYPE (base_binfo));
   if (ctor_p &&
@@ -1498,7 +1506,7 @@
 synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,
 			 tree *spec_p, bool *trivial_p, bool *deleted_p,
 			 bool *constexpr_p, bool diag,
-			 tree inheriting_ctor, tree inherited_parms)
+			 tree *inheriting_ctor, tree inherited_parms)
 {
   tree binfo, base_binfo, fnname;
   int i;
@@ -1553,7 +1561,7 @@
     }
 
   gcc_assert ((sfk == sfk_inheriting_constructor)
-	      == (inheriting_ctor != NULL_TREE));
+	      == (inheriting_ctor && *inheriting_ctor != NULL_TREE));
 
   /* If that user-written default constructor would satisfy the
      requirements of a constexpr constructor (7.1.5), the
@@ -1628,7 +1636,7 @@
   tree scope = push_scope (ctype);
 
   int flags = LOOKUP_NORMAL | LOOKUP_SPECULATIVE;
-  if (!inheriting_ctor)
+  if (sfk != sfk_inheriting_constructor)
     flags |= LOOKUP_DEFAULTED;
 
   tsubst_flags_t complain = diag ? tf_warning_or_error : tf_none;
@@ -1731,9 +1739,9 @@
   tree parm_type = TREE_VALUE (parms);
   bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));
   tree spec = empty_except_spec;
+  tree inh = DECL_INHERITED_CTOR (decl);
   synthesized_method_walk (ctype, sfk, const_p, &spec, NULL, NULL,
-			   NULL, false, DECL_INHERITED_CTOR (decl),
-			   parms);
+			   NULL, false, &inh, parms);
   return spec;
 }
 
@@ -1810,10 +1818,11 @@
 	  tree raises = NULL_TREE;
 	  bool deleted_p = false;
 	  tree scope = push_scope (ctype);
+	  tree inh = DECL_INHERITED_CTOR (decl);
 
 	  synthesized_method_walk (ctype, sfk, const_p,
 				   &raises, NULL, &deleted_p, NULL, false,
-				   DECL_INHERITED_CTOR (decl), parms);
+				   &inh, parms);
 	  if (deleted_p)
 	    {
 	      inform (DECL_SOURCE_LOCATION (decl),
@@ -1821,7 +1830,7 @@
 		      "definition would be ill-formed:", decl);
 	      synthesized_method_walk (ctype, sfk, const_p,
 				       NULL, NULL, NULL, NULL, true,
-				       DECL_INHERITED_CTOR (decl), parms);
+				       &inh, parms);
 	    }
 	  else if (!comp_except_specs
 		   (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (decl)),
@@ -1850,11 +1859,12 @@
 {
   tree parm_type = TREE_VALUE (FUNCTION_FIRST_USER_PARMTYPE (decl));
   bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));
+  tree inh = DECL_INHERITED_CTOR (decl);
   bool dummy;
   synthesized_method_walk (DECL_CLASS_CONTEXT (decl),
 			   special_function_p (decl), const_p,
 			   NULL, NULL, NULL, &dummy, true,
-			   DECL_INHERITED_CTOR (decl),
+			   &inh,
 			   FUNCTION_FIRST_USER_PARMTYPE (decl));
 }
 
@@ -1869,22 +1879,25 @@
   gcc_assert (DECL_INHERITED_CTOR (decl));
   tree spec;
   bool trivial, constexpr_, deleted;
+  tree inh = DECL_INHERITED_CTOR (decl);
   synthesized_method_walk (DECL_CONTEXT (decl), sfk_inheriting_constructor,
 			   false, &spec, &trivial, &deleted, &constexpr_,
 			   /*diag*/false,
-			   DECL_INHERITED_CTOR (decl),
+			   &inh,
 			   FUNCTION_FIRST_USER_PARMTYPE (decl));
   if (TREE_CODE (inherited_ctor_binfo (decl)) != TREE_BINFO)
     /* Inherited the same constructor from different base subobjects.  */
     deleted = true;
   DECL_DELETED_FN (decl) = deleted;
   TREE_TYPE (decl) = build_exception_variant (TREE_TYPE (decl), spec);
+  SET_DECL_INHERITED_CTOR (decl, inh);
 
   tree clone;
   FOR_EACH_CLONE (clone, decl)
     {
       DECL_DELETED_FN (clone) = deleted;
       TREE_TYPE (clone) = build_exception_variant (TREE_TYPE (clone), spec);
+      SET_DECL_INHERITED_CTOR (clone, inh);
     }
 }
 
@@ -1999,12 +2012,12 @@
       raises = unevaluated_noexcept_spec ();
       synthesized_method_walk (type, kind, const_p, NULL, &trivial_p,
 			       &deleted_p, &constexpr_p, false,
-			       inherited_ctor, inherited_parms);
+			       &inherited_ctor, inherited_parms);
     }
   else
     synthesized_method_walk (type, kind, const_p, &raises, &trivial_p,
 			     &deleted_p, &constexpr_p, false,
-			     inherited_ctor, inherited_parms);
+			     &inherited_ctor, inherited_parms);
   /* Don't bother marking a deleted constructor as constexpr.  */
   if (deleted_p)
     constexpr_p = false;
@@ -2120,7 +2133,7 @@
       input_location = DECL_SOURCE_LOCATION (fn);
       synthesized_method_walk (type, kind, const_p,
 			       NULL, NULL, NULL, NULL, true,
-			       NULL_TREE, NULL_TREE);
+			       NULL, NULL_TREE);
       input_location = loc;
     }
 
diff -ruN gcc-7.3.0/gcc/cp/name-lookup.c gcc-7.3.0-msp430/gcc/cp/name-lookup.c
--- gcc-7.3.0/gcc/cp/name-lookup.c	2017-06-29 09:46:29.689466000 -0700
+++ gcc-7.3.0-msp430/gcc/cp/name-lookup.c	2019-06-25 02:27:21.113931332 -0700
@@ -3684,6 +3684,9 @@
   tree d;
   bool saw_vis = false;
 
+  if (attributes == error_mark_node)
+    return false;
+
   for (d = attributes; d; d = TREE_CHAIN (d))
     {
       tree name = get_attribute_name (d);
diff -ruN gcc-7.3.0/gcc/cp/parser.c gcc-7.3.0-msp430/gcc/cp/parser.c
--- gcc-7.3.0/gcc/cp/parser.c	2017-12-15 16:40:14.867034000 -0800
+++ gcc-7.3.0-msp430/gcc/cp/parser.c	2019-06-25 02:27:21.117931304 -0700
@@ -7252,6 +7252,60 @@
   return postfix_expression;
 }
 
+/* A subroutine of cp_parser_postfix_dot_deref_expression.  Handle dot
+   dereference of incomplete type, returns true if error_mark_node should
+   be returned from caller, otherwise adjusts *SCOPE, *POSTFIX_EXPRESSION
+   and *DEPENDENT_P.  */
+
+bool
+cp_parser_dot_deref_incomplete (tree *scope, cp_expr *postfix_expression,
+				bool *dependent_p)
+{
+  /* In a template, be permissive by treating an object expression
+     of incomplete type as dependent (after a pedwarn).  */
+  diagnostic_t kind = (processing_template_decl
+		       && MAYBE_CLASS_TYPE_P (*scope) ? DK_PEDWARN : DK_ERROR);
+
+  switch (TREE_CODE (*postfix_expression))
+    {
+    case CAST_EXPR:
+    case REINTERPRET_CAST_EXPR:
+    case CONST_CAST_EXPR:
+    case STATIC_CAST_EXPR:
+    case DYNAMIC_CAST_EXPR:
+    case IMPLICIT_CONV_EXPR:
+    case VIEW_CONVERT_EXPR:
+    case NON_LVALUE_EXPR:
+      kind = DK_ERROR;
+      break;
+    case OVERLOAD:
+      /* Don't emit any diagnostic for OVERLOADs.  */
+      kind = DK_IGNORED;
+      break;
+    default:
+      /* Avoid clobbering e.g. DECLs.  */
+      if (!EXPR_P (*postfix_expression))
+	kind = DK_ERROR;
+      break;
+    }
+
+  if (kind == DK_IGNORED)
+    return false;
+
+  location_t exploc = location_of (*postfix_expression);
+  cxx_incomplete_type_diagnostic (exploc, *postfix_expression, *scope, kind);
+  if (!MAYBE_CLASS_TYPE_P (*scope))
+    return true;
+  if (kind == DK_ERROR)
+    *scope = *postfix_expression = error_mark_node;
+  else if (processing_template_decl)
+    {
+      *dependent_p = true;
+      *scope = TREE_TYPE (*postfix_expression) = NULL_TREE;
+    }
+  return false;
+}
+
 /* A subroutine of cp_parser_postfix_expression that also gets hijacked
    by cp_parser_builtin_offsetof.  We're looking for
 
@@ -7310,29 +7364,13 @@
       if (postfix_expression != current_class_ref
 	  && scope != error_mark_node
 	  && !(processing_template_decl
-	       && current_class_type
-	       && (same_type_ignoring_top_level_qualifiers_p
-		   (scope, current_class_type))))
+	       && currently_open_class (scope)))
 	{
 	  scope = complete_type (scope);
 	  if (!COMPLETE_TYPE_P (scope)
-	      /* Avoid clobbering e.g. OVERLOADs or DECLs.  */
-	      && EXPR_P (postfix_expression))
-	    {
-	      /* In a template, be permissive by treating an object expression
-		 of incomplete type as dependent (after a pedwarn).  */
-	      diagnostic_t kind = (processing_template_decl
-				   ? DK_PEDWARN
-				   : DK_ERROR);
-	      cxx_incomplete_type_diagnostic
-		(location_of (postfix_expression),
-		 postfix_expression, scope, kind);
-	      if (processing_template_decl)
-		{
-		  dependent_p = true;
-		  scope = TREE_TYPE (postfix_expression) = NULL_TREE;
-		}
-	    }
+	      && cp_parser_dot_deref_incomplete (&scope, &postfix_expression,
+						 &dependent_p))
+	    return error_mark_node;
 	}
 
       if (!dependent_p)
@@ -9030,12 +9068,20 @@
       if (no_toplevel_fold_p
 	  && lookahead_prec <= current.prec
 	  && sp == stack)
-	current.lhs = build2_loc (combined_loc,
-				  current.tree_type,
-				  TREE_CODE_CLASS (current.tree_type)
-				  == tcc_comparison
-				  ? boolean_type_node : TREE_TYPE (current.lhs),
-				  current.lhs, rhs);
+	{
+	  if (current.lhs == error_mark_node || rhs == error_mark_node)
+	    current.lhs = error_mark_node;
+	  else
+	    {
+	      current.lhs
+		= build_min (current.tree_type,
+			     TREE_CODE_CLASS (current.tree_type)
+			     == tcc_comparison
+			     ? boolean_type_node : TREE_TYPE (current.lhs),
+			     current.lhs.get_value (), rhs.get_value ());
+	      SET_EXPR_LOCATION (current.lhs, combined_loc);
+	    }
+	}
       else
         {
           current.lhs = build_x_binary_op (combined_loc, current.tree_type,
@@ -10743,6 +10789,18 @@
 		"attributes at the beginning of statement are ignored");
 }
 
+/* Append ATTR to attribute list ATTRS.  */
+
+static tree
+attr_chainon (tree attrs, tree attr)
+{
+  if (attrs == error_mark_node)
+    return error_mark_node;
+  if (attr == error_mark_node)
+    return error_mark_node;
+  return chainon (attrs, attr);
+}
+
 /* Parse the label for a labeled-statement, i.e.
 
    identifier :
@@ -10862,7 +10920,7 @@
       else if (!cp_parser_parse_definitely (parser))
 	;
       else
-	attributes = chainon (attributes, attrs);
+	attributes = attr_chainon (attributes, attrs);
     }
 
   if (attributes != NULL_TREE)
@@ -11798,7 +11856,7 @@
 				  /*protect=*/2, /*want_type=*/false,
 				  tf_warning_or_error);
 
-      if (member_begin != NULL_TREE || member_end != NULL_TREE)
+      if (member_begin != NULL_TREE && member_end != NULL_TREE)
 	{
 	  /* Use the member functions.  */
 	  if (member_begin != NULL_TREE)
@@ -12043,12 +12101,9 @@
 	  cp_lexer_consume_token (parser->lexer);
 	  is_range_for = true;
 	  if (cxx_dialect < cxx11)
-	    {
-	      pedwarn (cp_lexer_peek_token (parser->lexer)->location, 0,
-		       "range-based %<for%> loops only available with "
-		       "-std=c++11 or -std=gnu++11");
-	      *decl = error_mark_node;
-	    }
+	    pedwarn (cp_lexer_peek_token (parser->lexer)->location, 0,
+		     "range-based %<for%> loops only available with "
+		     "-std=c++11 or -std=gnu++11");
 	}
       else
 	  /* The ';' is not consumed yet because we told
@@ -13194,8 +13249,7 @@
 		  else
 		    {
 		      decl_specs->std_attributes
-			= chainon (decl_specs->std_attributes,
-				   attrs);
+			= attr_chainon (decl_specs->std_attributes, attrs);
 		      if (decl_specs->locations[ds_std_attribute] == 0)
 			decl_specs->locations[ds_std_attribute] = token->location;
 		    }
@@ -13203,9 +13257,8 @@
 		}
 	    }
 
-	    decl_specs->attributes
-	      = chainon (decl_specs->attributes,
-			 attrs);
+	  decl_specs->attributes
+	    = attr_chainon (decl_specs->attributes, attrs);
 	  if (decl_specs->locations[ds_attribute] == 0)
 	    decl_specs->locations[ds_attribute] = token->location;
 	  continue;
@@ -13688,6 +13741,10 @@
 	expr = cp_parser_lookup_name_simple (parser, expr,
 					     id_expr_start_token->location);
 
+      if (expr && TREE_CODE (expr) == TEMPLATE_DECL)
+	/* A template without args is not a complete id-expression.  */
+	expr = error_mark_node;
+
       if (expr
           && expr != error_mark_node
           && TREE_CODE (expr) != TYPE_DECL
@@ -13753,6 +13810,9 @@
          expression.  */
       cp_parser_abort_tentative_parse (parser);
 
+      /* Commit to the tentative_firewall so we get syntax errors.  */
+      cp_parser_commit_to_tentative_parse (parser);
+
       /* Parse a full expression.  */
       expr = cp_parser_expression (parser, /*pidk=*/NULL, /*cast_p=*/false,
 				   /*decltype_p=*/true);
@@ -18220,7 +18280,7 @@
   if (post_ident_attribs)
     {
       if (attribs)
-        attribs = chainon (attribs, post_ident_attribs);
+        attribs = attr_chainon (attribs, post_ident_attribs);
       else
         attribs = post_ident_attribs;
     }
@@ -19394,7 +19454,7 @@
       decl = grokfield (declarator, decl_specifiers,
 			initializer, !is_non_constant_init,
 			/*asmspec=*/NULL_TREE,
-			chainon (attributes, prefix_attributes));
+			attr_chainon (attributes, prefix_attributes));
       if (decl && TREE_CODE (decl) == FUNCTION_DECL)
 	cp_parser_save_default_args (parser, decl);
       cp_finalize_omp_declare_simd (parser, decl);
@@ -20789,9 +20849,9 @@
       /* Check for attributes first.  */
       if (cp_next_tokens_can_be_attribute_p (parser))
 	{
-	  type_specifier_seq->attributes =
-	    chainon (type_specifier_seq->attributes,
-		     cp_parser_attributes_opt (parser));
+	  type_specifier_seq->attributes
+	    = attr_chainon (type_specifier_seq->attributes,
+			    cp_parser_attributes_opt (parser));
 	  continue;
 	}
 
@@ -20904,7 +20964,10 @@
 
   if (!processing_specialization
       && !processing_template_parmlist
-      && !processing_explicit_instantiation)
+      && !processing_explicit_instantiation
+      /* default_arg_ok_p tracks whether this is a parameter-clause for an
+         actual function or a random abstract declarator.  */
+      && parser->default_arg_ok_p)
     if (!current_function_decl
 	|| (current_class_type && LAMBDA_TYPE_P (current_class_type)))
       parser->auto_is_implicit_function_template_parm_p = true;
@@ -21013,9 +21076,6 @@
       cp_parameter_declarator *parameter;
       tree decl = error_mark_node;
       bool parenthesized_p = false;
-      int template_parm_idx = (function_being_declared_is_template_p (parser)?
-			       TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS
-						(current_template_parms)) : 0);
 
       /* Parse the parameter.  */
       parameter
@@ -21029,22 +21089,6 @@
 
       if (parameter)
 	{
-	  /* If a function parameter pack was specified and an implicit template
-	     parameter was introduced during cp_parser_parameter_declaration,
-	     change any implicit parameters introduced into packs.  */
-	  if (parser->implicit_template_parms
-	      && parameter->declarator
-	      && parameter->declarator->parameter_pack_p)
-	    {
-	      int latest_template_parm_idx = TREE_VEC_LENGTH
-		(INNERMOST_TEMPLATE_PARMS (current_template_parms));
-
-	      if (latest_template_parm_idx != template_parm_idx)
-		parameter->decl_specifiers.type = convert_generic_types_to_packs
-		  (parameter->decl_specifiers.type,
-		   template_parm_idx, latest_template_parm_idx);
-	    }
-
 	  decl = grokdeclarator (parameter->declarator,
 				 &parameter->decl_specifiers,
 				 PARM,
@@ -21202,6 +21246,10 @@
   parser->type_definition_forbidden_message
     = G_("types may not be defined in parameter types");
 
+  int template_parm_idx = (function_being_declared_is_template_p (parser) ?
+			   TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS
+					    (current_template_parms)) : 0);
+
   /* Parse the declaration-specifiers.  */
   cp_parser_decl_specifier_seq (parser,
 				CP_PARSER_FLAGS_NONE,
@@ -21270,8 +21318,8 @@
       parser->default_arg_ok_p = saved_default_arg_ok_p;
       /* After the declarator, allow more attributes.  */
       decl_specifiers.attributes
-	= chainon (decl_specifiers.attributes,
-		   cp_parser_attributes_opt (parser));
+	= attr_chainon (decl_specifiers.attributes,
+			cp_parser_attributes_opt (parser));
 
       /* If the declarator is a template parameter pack, remember that and
 	 clear the flag in the declarator itself so we don't get errors
@@ -21290,6 +21338,24 @@
      parameter pack expansion expression. Otherwise, leave the ellipsis
      for a C-style variadic function. */
   token = cp_lexer_peek_token (parser->lexer);
+
+  /* If a function parameter pack was specified and an implicit template
+     parameter was introduced during cp_parser_parameter_declaration,
+     change any implicit parameters introduced into packs.  */
+  if (parser->implicit_template_parms
+      && ((token->type == CPP_ELLIPSIS
+	   && declarator_can_be_parameter_pack (declarator))
+	  || (declarator && declarator->parameter_pack_p)))
+    {
+      int latest_template_parm_idx = TREE_VEC_LENGTH
+	(INNERMOST_TEMPLATE_PARMS (current_template_parms));
+
+      if (latest_template_parm_idx != template_parm_idx)
+	decl_specifiers.type = convert_generic_types_to_packs
+	  (decl_specifiers.type,
+	   template_parm_idx, latest_template_parm_idx);
+    }
+
   if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))
     {
       tree type = decl_specifiers.type;
@@ -23261,7 +23327,7 @@
 		 which are not.  */
 	      first_attribute = attributes;
 	      /* Combine the attributes.  */
-	      attributes = chainon (prefix_attributes, attributes);
+	      attributes = attr_chainon (prefix_attributes, attributes);
 
 	      /* Create the bitfield declaration.  */
 	      decl = grokbitfield (identifier
@@ -23318,7 +23384,7 @@
 		 which are not.  */
 	      first_attribute = attributes;
 	      /* Combine the attributes.  */
-	      attributes = chainon (prefix_attributes, attributes);
+	      attributes = attr_chainon (prefix_attributes, attributes);
 
 	      /* If it's an `=', then we have a constant-initializer or a
 		 pure-specifier.  It is not correct to parse the
@@ -23432,10 +23498,13 @@
 	  cp_finalize_oacc_routine (parser, decl, false);
 
 	  /* Reset PREFIX_ATTRIBUTES.  */
-	  while (attributes && TREE_CHAIN (attributes) != first_attribute)
-	    attributes = TREE_CHAIN (attributes);
-	  if (attributes)
-	    TREE_CHAIN (attributes) = NULL_TREE;
+	  if (attributes != error_mark_node)
+	    {
+	      while (attributes && TREE_CHAIN (attributes) != first_attribute)
+		attributes = TREE_CHAIN (attributes);
+	      if (attributes)
+		TREE_CHAIN (attributes) = NULL_TREE;
+	    }
 
 	  /* If there is any qualification still in effect, clear it
 	     now; we will be starting fresh with the next declarator.  */
@@ -24547,7 +24616,7 @@
 	cp_parser_skip_to_end_of_statement (parser);
 
       /* Add these new attributes to the list.  */
-      attributes = chainon (attributes, attribute_list);
+      attributes = attr_chainon (attributes, attribute_list);
     }
 
   return attributes;
@@ -24602,7 +24671,8 @@
 	       parsed identifier.  */
 	    ? ridpointers[(int) token->keyword]
 	    : id_token->u.value;
-	  
+
+	  identifier = canonicalize_attr_name (identifier);
 	  attribute = build_tree_list (identifier, NULL_TREE);
 
 	  /* Peek at the next token.  */
@@ -24748,6 +24818,8 @@
 		    "expected an identifier for the attribute name");
 	  return error_mark_node;
 	}
+
+      attr_id = canonicalize_attr_name (attr_id);
       attribute = build_tree_list (build_tree_list (attr_ns, attr_id),
 				   NULL_TREE);
       token = cp_lexer_peek_token (parser->lexer);
@@ -24757,6 +24829,7 @@
 				 NULL_TREE);
   else
     {
+      attr_id = canonicalize_attr_name (attr_id);
       attribute = build_tree_list (build_tree_list (NULL_TREE, attr_id),
 				   NULL_TREE);
       /* C++11 noreturn attribute is equivalent to GNU's.  */
@@ -29725,7 +29798,7 @@
 	     which are not.  */
 	  first_attribute = attributes;
 	  /* Combine the attributes.  */
-	  attributes = chainon (prefix_attributes, attributes);
+	  attributes = attr_chainon (prefix_attributes, attributes);
 
 	  if (width)
 	      /* Create the bitfield declaration.  */
@@ -29742,10 +29815,13 @@
 	    objc_add_instance_variable (decl);
 
 	  /* Reset PREFIX_ATTRIBUTES.  */
-	  while (attributes && TREE_CHAIN (attributes) != first_attribute)
-	    attributes = TREE_CHAIN (attributes);
-	  if (attributes)
-	    TREE_CHAIN (attributes) = NULL_TREE;
+	  if (attributes != error_mark_node)
+	    {
+	      while (attributes && TREE_CHAIN (attributes) != first_attribute)
+		attributes = TREE_CHAIN (attributes);
+	      if (attributes)
+		TREE_CHAIN (attributes) = NULL_TREE;
+	    }
 
 	  token = cp_lexer_peek_token (parser->lexer);
 
@@ -30275,8 +30351,8 @@
 	 which are not.  */
       first_attribute = attributes;
       /* Combine the attributes.  */
-      attributes = chainon (prefix_attributes, attributes);
-      
+      attributes = attr_chainon (prefix_attributes, attributes);
+
       decl = grokfield (declarator, &declspecs,
 			NULL_TREE, /*init_const_expr_p=*/false,
 			NULL_TREE, attributes);
@@ -30285,10 +30361,13 @@
 	return error_mark_node;
       
       /* Reset PREFIX_ATTRIBUTES.  */
-      while (attributes && TREE_CHAIN (attributes) != first_attribute)
-	attributes = TREE_CHAIN (attributes);
-      if (attributes)
-	TREE_CHAIN (attributes) = NULL_TREE;
+      if (attributes != error_mark_node)
+	{
+	  while (attributes && TREE_CHAIN (attributes) != first_attribute)
+	    attributes = TREE_CHAIN (attributes);
+	  if (attributes)
+	    TREE_CHAIN (attributes) = NULL_TREE;
+	}
 
       DECL_CHAIN (decl) = decls;
       decls = decl;
@@ -30888,7 +30967,10 @@
 	  if (name == error_mark_node)
 	    goto skip_comma;
 
-	  decl = cp_parser_lookup_name_simple (parser, name, token->location);
+	  if (identifier_p (name))
+	    decl = cp_parser_lookup_name_simple (parser, name, token->location);
+	  else
+	    decl = name;
 	  if (decl == error_mark_node)
 	    cp_parser_name_lookup_error (parser, name, decl, NLE_NULL,
 					 token->location);
@@ -34209,7 +34291,7 @@
 cp_parser_omp_for_loop_init (cp_parser *parser,
 			     enum tree_code code,
 			     tree &this_pre_body,
-			     vec<tree, va_gc> *for_block,
+			     vec<tree, va_gc> *&for_block,
 			     tree &init,
 			     tree &orig_init,
 			     tree &decl,
@@ -37448,7 +37530,9 @@
 					   /*template_p=*/NULL,
 					   /*declarator_p=*/false,
 					   /*optional_p=*/false);
-      tree decl = cp_parser_lookup_name_simple (parser, name, name_loc);
+      tree decl = (identifier_p (name)
+		   ? cp_parser_lookup_name_simple (parser, name, name_loc)
+		   : name);
       if (name != error_mark_node && decl == error_mark_node)
 	cp_parser_name_lookup_error (parser, name, decl, NLE_NULL, name_loc);
 
diff -ruN gcc-7.3.0/gcc/cp/pt.c gcc-7.3.0-msp430/gcc/cp/pt.c
--- gcc-7.3.0/gcc/cp/pt.c	2018-01-17 10:08:05.935248000 -0800
+++ gcc-7.3.0-msp430/gcc/cp/pt.c	2019-06-25 02:27:21.117931304 -0700
@@ -2072,7 +2072,8 @@
   /* We shouldn't be specializing a member template of an
      unspecialized class template; we already gave an error in
      check_specialization_scope, now avoid crashing.  */
-  if (template_count && DECL_CLASS_SCOPE_P (decl)
+  if (!VAR_P (decl)
+      && template_count && DECL_CLASS_SCOPE_P (decl)
       && template_class_depth (DECL_CONTEXT (decl)) > 0)
     {
       gcc_assert (errorcount);
@@ -2175,10 +2176,17 @@
 	     that the const qualification is the same.  Since
 	     get_bindings does not try to merge the "this" parameter,
 	     we must do the comparison explicitly.  */
-	  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)
-	      && !same_type_p (TREE_VALUE (fn_arg_types),
-			       TREE_VALUE (decl_arg_types)))
-	    continue;
+	  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))
+	    {
+	      if (!same_type_p (TREE_VALUE (fn_arg_types),
+				TREE_VALUE (decl_arg_types)))
+		continue;
+
+	      /* And the ref-qualification.  */
+	      if (type_memfn_rqual (TREE_TYPE (decl))
+		  != type_memfn_rqual (TREE_TYPE (fn)))
+		continue;
+	    }
 
 	  /* Skip the "this" parameter and, for constructors of
 	     classes with virtual bases, the VTT parameter.  A
@@ -2284,6 +2292,11 @@
 			 decl_arg_types))
             continue;
 
+	  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)
+	      && (type_memfn_rqual (TREE_TYPE (decl))
+		  != type_memfn_rqual (TREE_TYPE (fn))))
+	    continue;
+
           // If the deduced arguments do not satisfy the constraints,
           // this is not a candidate.
           if (flag_concepts && !constraints_satisfied_p (fn))
@@ -4601,10 +4614,13 @@
     {
       if (!flag_concepts)
         error ("partial specialization %q+D does not specialize "
-	       "any template arguments", decl);
+	       "any template arguments; to define the primary template, "
+	       "remove the template argument list", decl);
       else
         error ("partial specialization %q+D does not specialize any "
-	       "template arguments and is not more constrained than", decl);
+	       "template arguments and is not more constrained than "
+	       "the primary template; to define the primary template, "
+	       "remove the template argument list", decl);
       inform (DECL_SOURCE_LOCATION (maintmpl), "primary template here");
     }
 
@@ -4848,7 +4864,7 @@
 fixed_parameter_pack_p_1 (tree parm, struct find_parameter_pack_data *ppd)
 {
   /* A type parm can't refer to another parm.  */
-  if (TREE_CODE (parm) == TYPE_DECL)
+  if (TREE_CODE (parm) == TYPE_DECL || parm == error_mark_node)
     return;
   else if (TREE_CODE (parm) == PARM_DECL)
     {
@@ -6032,7 +6048,12 @@
 
  accept:
   if (TREE_CODE (type) == REFERENCE_TYPE)
-    fn = build_address (fn);
+    {
+      if (REFERENCE_REF_P (fn))
+	fn = TREE_OPERAND (fn, 0);
+      else
+	fn = build_address (fn);
+    }
   if (!same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (fn)))
     fn = build_nop (type, fn);
 
@@ -8244,7 +8265,11 @@
     }
 
   if (lost)
-    return error_mark_node;
+    {
+      if ((complain & tf_error) && !seen_error())
+	error ("wrong number of template arguments");
+      return error_mark_node;
+    }
 
   if (CHECKING_P && !NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args))
     SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args,
@@ -11454,7 +11479,9 @@
 	    {
 	      /* This parameter pack was used in an unevaluated context.  Just
 		 make a dummy decl, since it's only used for its type.  */
+	      ++cp_unevaluated_operand;
 	      arg_pack = tsubst_decl (parm_pack, args, complain);
+	      --cp_unevaluated_operand;
 	      if (arg_pack && DECL_PACK_P (arg_pack))
 		/* Partial instantiation of the parm_pack, we can't build
 		   up an argument pack yet.  */
@@ -11524,7 +11551,7 @@
 	  /* We can't substitute for this parameter pack.  We use a flag as
 	     well as the missing_level counter because function parameter
 	     packs don't have a level.  */
-	  gcc_assert (processing_template_decl);
+	  gcc_assert (processing_template_decl || is_auto (parm_pack));
 	  unsubstituted_packs = true;
 	}
     }
@@ -13755,8 +13782,7 @@
 			= tsubst_constraint (constr, args, complain, in_decl);
 		    else if (tree pl = CLASS_PLACEHOLDER_TEMPLATE (t))
 		      {
-			if (DECL_TEMPLATE_TEMPLATE_PARM_P (pl))
-			  pl = tsubst (pl, args, complain, in_decl);
+			pl = tsubst_copy (pl, args, complain, in_decl);
 			CLASS_PLACEHOLDER_TEMPLATE (r) = pl;
 		      }
 		  }
@@ -15778,6 +15804,12 @@
       DECL_HAS_VALUE_EXPR_P (decl2) = 1;
       if (VAR_P (decl3))
 	DECL_TEMPLATE_INSTANTIATED (decl3) = 1;
+      else
+	{
+	  gcc_assert (errorcount);
+	  decl = error_mark_node;
+	  continue;
+	}
       maybe_push_decl (decl3);
       if (error_operand_p (decl3))
 	decl = error_mark_node;
@@ -16766,14 +16798,14 @@
 	if (targs)
 	  targs = tsubst_template_args (targs, args, complain, in_decl);
 	if (targs == error_mark_node)
-	  return error_mark_node;
+	  RETURN (error_mark_node);
 
 	if (TREE_CODE (templ) == SCOPE_REF)
 	  {
 	    tree name = TREE_OPERAND (templ, 1);
 	    tree tid = lookup_template_function (name, targs);
 	    TREE_OPERAND (templ, 1) = tid;
-	    return templ;
+	    RETURN (templ);
 	  }
 
 	if (variable_template_p (templ))
@@ -16838,6 +16870,8 @@
       {
 	tree type = tsubst (TREE_TYPE (t), args, complain, in_decl);
 	tree op0 = RECUR (TREE_OPERAND (t, 0));
+	if (op0 == error_mark_node)
+	  RETURN (error_mark_node);
 	RETURN (build1 (CONVERT_EXPR, type, op0));
       }
 
@@ -16985,7 +17019,7 @@
       {
 	tree op0 = RECUR (TREE_OPERAND (t, 0));
 	tree op1 = RECUR (TREE_OPERAND (t, 1));
-	return fold_build_pointer_plus (op0, op1);
+	RETURN (fold_build_pointer_plus (op0, op1));
       }
 
     case SCOPE_REF:
@@ -17492,7 +17526,10 @@
 		CALL_EXPR_REVERSE_ARGS (function) = rev;
 		if (thk)
 		  {
-		    CALL_FROM_THUNK_P (function) = true;
+		    if (TREE_CODE (function) == CALL_EXPR)
+		      CALL_FROM_THUNK_P (function) = true;
+		    else
+		      AGGR_INIT_FROM_THUNK_P (function) = true;
 		    /* The thunk location is not interesting.  */
 		    SET_EXPR_LOCATION (function, UNKNOWN_LOCATION);
 		  }
@@ -19205,6 +19242,24 @@
 			  /*nondeduced*/false, array_deduction_r);
 }
 
+/* Returns how many levels of { } INIT contains.  */
+
+static int
+braced_init_depth (tree init)
+{
+  if (!init || !BRACE_ENCLOSED_INITIALIZER_P (init))
+    return 0;
+  unsigned i; tree val;
+  unsigned max = 0;
+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, val)
+    {
+      unsigned elt_d = braced_init_depth (val);
+      if (elt_d > max)
+	max = elt_d;
+    }
+  return max + 1;
+}
+
 /* Most parms like fn_type_unification.
 
    If SUBR is 1, we're being called recursively (to unify the
@@ -19441,6 +19496,10 @@
 
 	    if (uses_template_parms (parm))
 	      continue;
+	    /* Workaround for c++/80290: avoid combinatorial explosion on
+	       deeply nested braced init-lists.  */
+	    if (braced_init_depth (arg) > 2)
+	      continue;
 	    if (check_non_deducible_conversion (parm, arg, strict, flags,
 						explain_p))
 	      return 1;
@@ -24065,20 +24124,21 @@
 	  && (any_dependent_template_arguments_p
 	      (INNERMOST_TEMPLATE_ARGS (DECL_TI_ARGS (expression)))))
 	return true;
+    }
 
-      /* Otherwise, if the decl isn't from a dependent scope, it can't be
-	 type-dependent.  Checking this is important for functions with auto
-	 return type, which looks like a dependent type.  */
-      if (TREE_CODE (expression) == FUNCTION_DECL
-	  && undeduced_auto_decl (expression)
-	  && (!DECL_CLASS_SCOPE_P (expression)
-	      || !dependent_type_p (DECL_CONTEXT (expression)))
-	  && (!DECL_FRIEND_CONTEXT (expression)
-	      || !dependent_type_p (DECL_FRIEND_CONTEXT (expression)))
-	  && !DECL_LOCAL_FUNCTION_P (expression))
-	{
-	  return false;
-	}
+  /* Otherwise, if the decl isn't from a dependent scope, it can't be
+     type-dependent.  Checking this is important for functions with auto
+     return type, which looks like a dependent type.  */
+  if (TREE_CODE (expression) == FUNCTION_DECL
+      && undeduced_auto_decl (expression)
+      && (!DECL_CLASS_SCOPE_P (expression)
+	  || !dependent_type_p (DECL_CONTEXT (expression)))
+      && (!DECL_LANG_SPECIFIC (expression)
+	  || !DECL_FRIEND_CONTEXT (expression)
+	  || !dependent_type_p (DECL_FRIEND_CONTEXT (expression)))
+      && !DECL_LOCAL_FUNCTION_P (expression))
+    {
+      return false;
     }
 
   /* Always dependent, on the number of arguments if nothing else.  */
@@ -25105,8 +25165,21 @@
 	  = TEMPLATE_TYPE_PARM_FOR_CLASS (oldtype);
     }
   else
-    newtype = tsubst (TREE_TYPE (olddecl), tsubst_args,
-		      complain, NULL_TREE);
+    {
+      newtype = TREE_TYPE (olddecl);
+      if (type_uses_auto (newtype))
+	{
+	  // Substitute once to fix references to other template parameters.
+	  newtype = tsubst (newtype, tsubst_args,
+			    complain|tf_partial, NULL_TREE);
+	  // Now substitute again to reduce the level of the auto.
+	  newtype = tsubst (newtype, current_template_args (),
+			    complain, NULL_TREE);
+	}
+      else
+	newtype = tsubst (newtype, tsubst_args,
+			  complain, NULL_TREE);
+    }
 
   tree newdecl
     = build_decl (DECL_SOURCE_LOCATION (olddecl), TREE_CODE (olddecl),
@@ -25145,7 +25218,7 @@
 	  // Substitute ttargs into ttparms to fix references to
 	  // other template parameters.
 	  ttparms = tsubst_template_parms_level (ttparms, ttargs,
-						 complain);
+						 complain|tf_partial);
 	  // Now substitute again with args based on tparms, to reduce
 	  // the level of the ttparms.
 	  ttargs = current_template_args ();
@@ -25386,6 +25459,9 @@
     // FIXME cache artificial deduction guides
     for (tree fns = CLASSTYPE_CONSTRUCTORS (type); fns; fns = OVL_NEXT (fns))
       {
+	if (TREE_CODE (fns) == OVERLOAD && OVL_USED (fns))
+	  continue;
+
 	tree fn = OVL_CURRENT (fns);
 	tree guide = build_deduction_guide (fn, outer_args, complain);
 	cands = ovl_cons (guide, cands);
diff -ruN gcc-7.3.0/gcc/cp/search.c gcc-7.3.0-msp430/gcc/cp/search.c
--- gcc-7.3.0/gcc/cp/search.c	2017-06-29 09:46:29.689466000 -0700
+++ gcc-7.3.0-msp430/gcc/cp/search.c	2019-06-25 02:27:21.117931304 -0700
@@ -2879,7 +2879,7 @@
 bool
 any_dependent_bases_p (tree type)
 {
-  if (!type || !CLASS_TYPE_P (type) || !processing_template_decl)
+  if (!type || !CLASS_TYPE_P (type) || !uses_template_parms (type))
     return false;
 
   unsigned i;
diff -ruN gcc-7.3.0/gcc/cp/semantics.c gcc-7.3.0-msp430/gcc/cp/semantics.c
--- gcc-7.3.0/gcc/cp/semantics.c	2017-09-18 11:37:16.648563000 -0700
+++ gcc-7.3.0-msp430/gcc/cp/semantics.c	2019-06-25 02:27:21.117931304 -0700
@@ -730,7 +730,10 @@
   cond = maybe_convert_cond (cond);
   if (IF_STMT_CONSTEXPR_P (if_stmt)
       && require_potential_rvalue_constant_expression (cond)
-      && !value_dependent_expression_p (cond))
+      && !value_dependent_expression_p (cond)
+      /* Wait until instantiation time, since only then COND has been
+	 converted to bool.  */
+      && TREE_TYPE (cond) == boolean_type_node)
     {
       cond = instantiate_non_dependent_expr (cond);
       cond = cxx_constant_value (cond, NULL_TREE);
@@ -1480,6 +1483,21 @@
 		      && C_TYPE_FIELDS_READONLY (TREE_TYPE (operand)))))
 	    cxx_readonly_error (operand, lv_asm);
 
+	  tree *op = &operand;
+	  while (TREE_CODE (*op) == COMPOUND_EXPR)
+	    op = &TREE_OPERAND (*op, 1);
+	  switch (TREE_CODE (*op))
+	    {
+	    case PREINCREMENT_EXPR:
+	    case PREDECREMENT_EXPR:
+	    case MODIFY_EXPR:
+	      *op = genericize_compound_lvalue (*op);
+	      op = &TREE_OPERAND (*op, 1);
+	      break;
+	    default:
+	      break;
+	    }
+
 	  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));
 	  oconstraints[i] = constraint;
 
@@ -1488,7 +1506,7 @@
 	    {
 	      /* If the operand is going to end up in memory,
 		 mark it addressable.  */
-	      if (!allows_reg && !cxx_mark_addressable (operand))
+	      if (!allows_reg && !cxx_mark_addressable (*op))
 		operand = error_mark_node;
 	    }
 	  else
@@ -1530,7 +1548,23 @@
 		  /* Strip the nops as we allow this case.  FIXME, this really
 		     should be rejected or made deprecated.  */
 		  STRIP_NOPS (operand);
-		  if (!cxx_mark_addressable (operand))
+
+		  tree *op = &operand;
+		  while (TREE_CODE (*op) == COMPOUND_EXPR)
+		    op = &TREE_OPERAND (*op, 1);
+		  switch (TREE_CODE (*op))
+		    {
+		    case PREINCREMENT_EXPR:
+		    case PREDECREMENT_EXPR:
+		    case MODIFY_EXPR:
+		      *op = genericize_compound_lvalue (*op);
+		      op = &TREE_OPERAND (*op, 1);
+		      break;
+		    default:
+		      break;
+		    }
+
+		  if (!cxx_mark_addressable (*op))
 		    operand = error_mark_node;
 		}
 	      else if (!allows_reg && !allows_mem)
@@ -5604,7 +5638,11 @@
       return false;
     }
   else if (processing_template_decl)
-    return false;
+    {
+      if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) == error_mark_node)
+	return true;
+      return false;
+    }
 
   tree id = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);
 
@@ -7333,7 +7371,7 @@
 
 	  if (VAR_P (t) && CP_DECL_THREAD_LOCAL_P (t))
 	    share_name = "threadprivate";
-	  else switch (cxx_omp_predetermined_sharing (t))
+	  else switch (cxx_omp_predetermined_sharing_1 (t))
 	    {
 	    case OMP_CLAUSE_DEFAULT_UNSPECIFIED:
 	      break;
diff -ruN gcc-7.3.0/gcc/cp/tree.c gcc-7.3.0-msp430/gcc/cp/tree.c
--- gcc-7.3.0/gcc/cp/tree.c	2018-01-02 10:07:41.402032000 -0800
+++ gcc-7.3.0-msp430/gcc/cp/tree.c	2019-06-25 02:27:21.121931274 -0700
@@ -32,6 +32,7 @@
 #include "debug.h"
 #include "convert.h"
 #include "gimplify.h"
+#include "stringpool.h"
 #include "attribs.h"
 
 static tree bot_manip (tree *, int *, void *);
@@ -1050,6 +1051,9 @@
 {
   tree lvalue_ref, t;
 
+  if (to_type == error_mark_node)
+    return error_mark_node;
+
   if (TREE_CODE (to_type) == REFERENCE_TYPE)
     {
       rval = rval && TYPE_REF_IS_RVALUE (to_type);
@@ -1667,9 +1671,9 @@
 	tree it;
 	for (it = t; it; it = TREE_CHAIN (it))
 	  {
-	    tree val = strip_typedefs_expr (TREE_VALUE (t), remove_attributes);
+	    tree val = strip_typedefs_expr (TREE_VALUE (it), remove_attributes);
 	    vec_safe_push (vec, val);
-	    if (val != TREE_VALUE (t))
+	    if (val != TREE_VALUE (it))
 	      changed = true;
 	    gcc_assert (TREE_PURPOSE (it) == NULL_TREE);
 	  }
@@ -2589,6 +2593,8 @@
 	{
 	  u = build_cplus_new (TREE_TYPE (t), TREE_OPERAND (t, 1),
 			       tf_warning_or_error);
+	  if (u == error_mark_node)
+	    return u;
 	  if (AGGR_INIT_ZERO_FIRST (TREE_OPERAND (t, 1)))
 	    AGGR_INIT_ZERO_FIRST (TREE_OPERAND (u, 1)) = true;
 	}
@@ -2606,6 +2612,8 @@
 			 (splay_tree_value) TREE_OPERAND (u, 0));
 
       TREE_OPERAND (u, 1) = break_out_target_exprs (TREE_OPERAND (u, 1));
+      if (TREE_OPERAND (u, 1) == error_mark_node)
+	return error_mark_node;
 
       /* Replace the old expression with the new version.  */
       *tp = u;
@@ -2718,7 +2726,8 @@
     target_remap = splay_tree_new (splay_tree_compare_pointers,
 				   /*splay_tree_delete_key_fn=*/NULL,
 				   /*splay_tree_delete_value_fn=*/NULL);
-  cp_walk_tree (&t, bot_manip, target_remap, NULL);
+  if (cp_walk_tree (&t, bot_manip, target_remap, NULL) == error_mark_node)
+    t = error_mark_node;
   cp_walk_tree (&t, bot_replace, target_remap, NULL);
 
   if (!--target_remap_count)
@@ -2793,7 +2802,7 @@
 	for (; !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (*t),
 							   TREE_TYPE (x));
 	     x = TREE_OPERAND (x, 0))
-	  gcc_assert (TREE_CODE (x) == COMPONENT_REF);
+	  gcc_assert (handled_component_p (x));
 	*t = x;
 	*walk_subtrees = false;
 	d->seen = true;
@@ -4895,6 +4904,19 @@
     }
 }
 
+/* Wrapper around warn_deprecated_use that doesn't warn for
+   current_class_type.  */
+
+void
+cp_warn_deprecated_use (tree node)
+{
+  if (TYPE_P (node)
+      && current_class_type
+      && TYPE_MAIN_VARIANT (node) == current_class_type)
+    return;
+  warn_deprecated_use (node, NULL_TREE);
+}
+
 /* Implement -Wzero_as_null_pointer_constant.  Return true if the
    conditions for the warning hold, false otherwise.  */
 bool
diff -ruN gcc-7.3.0/gcc/cp/typeck2.c gcc-7.3.0-msp430/gcc/cp/typeck2.c
--- gcc-7.3.0/gcc/cp/typeck2.c	2017-04-07 11:09:55.156704000 -0700
+++ gcc-7.3.0-msp430/gcc/cp/typeck2.c	2019-06-25 02:27:21.121931274 -0700
@@ -817,9 +817,12 @@
       bool const_init;
       value = instantiate_non_dependent_expr (value);
       if (DECL_DECLARED_CONSTEXPR_P (decl)
-	  || (DECL_IN_AGGR_P (decl) && !DECL_VAR_DECLARED_INLINE_P (decl)))
+	  || (DECL_IN_AGGR_P (decl)
+	      && DECL_INITIALIZED_IN_CLASS_P (decl)
+	      && !DECL_VAR_DECLARED_INLINE_P (decl)))
 	{
-	  /* Diagnose a non-constant initializer for constexpr.  */
+	  /* Diagnose a non-constant initializer for constexpr variable or
+	     non-inline in-class-initialized static data member.  */
 	  if (processing_template_decl
 	      && !require_potential_constant_expression (value))
 	    value = error_mark_node;
@@ -1954,7 +1957,7 @@
       if (complain & tf_warning
 	  && TREE_DEPRECATED (type)
 	  && DECL_ARTIFICIAL (exp))
-	warn_deprecated_use (type, NULL_TREE);
+	cp_warn_deprecated_use (type);
     }
   else
     type = exp;
diff -ruN gcc-7.3.0/gcc/cp/typeck.c gcc-7.3.0-msp430/gcc/cp/typeck.c
--- gcc-7.3.0/gcc/cp/typeck.c	2017-10-06 11:00:54.115245000 -0700
+++ gcc-7.3.0-msp430/gcc/cp/typeck.c	2019-06-25 02:27:21.121931274 -0700
@@ -905,14 +905,14 @@
       return t1;
 
     default:;
+      if (attribute_list_equal (TYPE_ATTRIBUTES (t1), attributes))
+	return t1;
+      else if (attribute_list_equal (TYPE_ATTRIBUTES (t2), attributes))
+	return t2;
+      break;
     }
 
-  if (attribute_list_equal (TYPE_ATTRIBUTES (t1), attributes))
-    return t1;
-  else if (attribute_list_equal (TYPE_ATTRIBUTES (t2), attributes))
-    return t2;
-  else
-    return cp_build_type_attribute_variant (t1, attributes);
+  return cp_build_type_attribute_variant (t1, attributes);
 }
 
 /* Return the ARRAY_TYPE type without its domain.  */
@@ -5713,19 +5713,6 @@
       return arg;
     }
 
-  /* ??? Cope with user tricks that amount to offsetof.  */
-  if (TREE_CODE (argtype) != FUNCTION_TYPE
-      && TREE_CODE (argtype) != METHOD_TYPE
-      && argtype != unknown_type_node
-      && (val = get_base_address (arg))
-      && COMPLETE_TYPE_P (TREE_TYPE (val))
-      && INDIRECT_REF_P (val)
-      && TREE_CONSTANT (TREE_OPERAND (val, 0)))
-    {
-      tree type = build_pointer_type (argtype);
-      return fold_convert (type, fold_offsetof_1 (arg));
-    }
-
   /* Handle complex lvalues (when permitted)
      by reduction to simpler cases.  */
   val = unary_complex_lvalue (ADDR_EXPR, arg);
@@ -6177,6 +6164,25 @@
   return cp_build_unary_op (code, xarg, noconvert, tf_warning_or_error);
 }
 
+/* Adjust LVALUE, an MODIFY_EXPR, PREINCREMENT_EXPR or PREDECREMENT_EXPR,
+   so that it is a valid lvalue even for GENERIC by replacing
+   (lhs = rhs) with ((lhs = rhs), lhs)
+   (--lhs) with ((--lhs), lhs)
+   (++lhs) with ((++lhs), lhs)
+   and if lhs has side-effects, calling cp_stabilize_reference on it, so
+   that it can be evaluated multiple times.  */
+
+tree
+genericize_compound_lvalue (tree lvalue)
+{
+  if (TREE_SIDE_EFFECTS (TREE_OPERAND (lvalue, 0)))
+    lvalue = build2 (TREE_CODE (lvalue), TREE_TYPE (lvalue),
+		     cp_stabilize_reference (TREE_OPERAND (lvalue, 0)),
+		     TREE_OPERAND (lvalue, 1));
+  return build2 (COMPOUND_EXPR, TREE_TYPE (TREE_OPERAND (lvalue, 0)),
+		 lvalue, TREE_OPERAND (lvalue, 0));
+}
+
 /* Apply unary lvalue-demanding operator CODE to the expression ARG
    for certain kinds of expressions which are not really lvalues
    but which we can accept as lvalues.
@@ -6211,17 +6217,7 @@
   if (TREE_CODE (arg) == MODIFY_EXPR
       || TREE_CODE (arg) == PREINCREMENT_EXPR
       || TREE_CODE (arg) == PREDECREMENT_EXPR)
-    {
-      tree lvalue = TREE_OPERAND (arg, 0);
-      if (TREE_SIDE_EFFECTS (lvalue))
-	{
-	  lvalue = cp_stabilize_reference (lvalue);
-	  arg = build2 (TREE_CODE (arg), TREE_TYPE (arg),
-			lvalue, TREE_OPERAND (arg, 1));
-	}
-      return unary_complex_lvalue
-	(code, build2 (COMPOUND_EXPR, TREE_TYPE (lvalue), arg, lvalue));
-    }
+    return unary_complex_lvalue (code, genericize_compound_lvalue (arg));
 
   if (code != ADDR_EXPR)
     return NULL_TREE;
@@ -7617,11 +7613,7 @@
     case PREINCREMENT_EXPR:
       if (compound_side_effects_p)
 	newrhs = rhs = stabilize_expr (rhs, &preeval);
-      if (TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0)))
-	lhs = build2 (TREE_CODE (lhs), TREE_TYPE (lhs),
-		      cp_stabilize_reference (TREE_OPERAND (lhs, 0)),
-		      TREE_OPERAND (lhs, 1));
-      lhs = build2 (COMPOUND_EXPR, lhstype, lhs, TREE_OPERAND (lhs, 0));
+      lhs = genericize_compound_lvalue (lhs);
     maybe_add_compound:
       /* If we had (bar, --foo) = 5; or (bar, (baz, --foo)) = 5;
 	 and looked through the COMPOUND_EXPRs, readd them now around
@@ -7644,11 +7636,7 @@
     case MODIFY_EXPR:
       if (compound_side_effects_p)
 	newrhs = rhs = stabilize_expr (rhs, &preeval);
-      if (TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0)))
-	lhs = build2 (TREE_CODE (lhs), TREE_TYPE (lhs),
-		      cp_stabilize_reference (TREE_OPERAND (lhs, 0)),
-		      TREE_OPERAND (lhs, 1));
-      lhs = build2 (COMPOUND_EXPR, lhstype, lhs, TREE_OPERAND (lhs, 0));
+      lhs = genericize_compound_lvalue (lhs);
       goto maybe_add_compound;
 
     case MIN_EXPR:
diff -ruN gcc-7.3.0/gcc/DATESTAMP gcc-7.3.0-msp430/gcc/DATESTAMP
--- gcc-7.3.0/gcc/DATESTAMP	2018-01-24 16:16:09.174689000 -0800
+++ gcc-7.3.0-msp430/gcc/DATESTAMP	2019-06-25 02:27:21.057931733 -0700
@@ -1 +1 @@
-20180125
+20180829
diff -ruN gcc-7.3.0/gcc/dce.c gcc-7.3.0-msp430/gcc/dce.c
--- gcc-7.3.0/gcc/dce.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/dce.c	2019-06-25 02:27:21.121931274 -0700
@@ -131,6 +131,12 @@
 	     && REGNO (pic_offset_table_rtx) >= FIRST_PSEUDO_REGISTER)
       return false;
 
+  /* Callee-save restores are needed.  */
+  if (RTX_FRAME_RELATED_P (insn)
+      && crtl->shrink_wrapped_separate
+      && find_reg_note (insn, REG_CFA_RESTORE, NULL))
+    return false;
+
   body = PATTERN (insn);
   switch (GET_CODE (body))
     {
@@ -560,9 +566,19 @@
     FOR_BB_INSNS_REVERSE_SAFE (bb, insn, next)
       if (NONDEBUG_INSN_P (insn))
 	{
+	  rtx turn_into_use = NULL_RTX;
+
 	  /* Always delete no-op moves.  */
 	  if (noop_move_p (insn))
-	    ;
+	    {
+	      if (RTX_FRAME_RELATED_P (insn))
+		turn_into_use
+		  = find_reg_note (insn, REG_CFA_RESTORE, NULL);
+	      if (turn_into_use && REG_P (XEXP (turn_into_use, 0)))
+		turn_into_use = XEXP (turn_into_use, 0);
+	      else
+		turn_into_use = NULL_RTX;
+	    }
 
 	  /* Otherwise rely only on the DCE algorithm.  */
 	  else if (marked_insn_p (insn))
@@ -589,15 +605,6 @@
 	  if (!dbg_cnt (dce))
 	    continue;
 
-	  if (crtl->shrink_wrapped_separate
-	      && find_reg_note (insn, REG_CFA_RESTORE, NULL))
-	    {
-	      if (dump_file)
-		fprintf (dump_file, "DCE: NOT deleting insn %d, it's a "
-				    "callee-save restore\n", INSN_UID (insn));
-	      continue;
-	    }
-
 	  if (dump_file)
 	    fprintf (dump_file, "DCE: Deleting insn %d\n", INSN_UID (insn));
 
@@ -611,8 +618,19 @@
 	  if (CALL_P (insn))
 	    must_clean = true;
 
-	  /* Now delete the insn.  */
-	  delete_insn_and_edges (insn);
+	  if (turn_into_use)
+	    {
+	      /* Don't remove frame related noop moves if they cary
+		 REG_CFA_RESTORE note, while we don't need to emit any code,
+		 we need it to emit the CFI restore note.  */
+	      PATTERN (insn)
+		= gen_rtx_USE (GET_MODE (turn_into_use), turn_into_use);
+	      INSN_CODE (insn) = -1;
+	      df_insn_rescan (insn);
+	    }
+	  else
+	    /* Now delete the insn.  */
+	    delete_insn_and_edges (insn);
 	}
 
   /* Deleted a pure or const call.  */
diff -ruN gcc-7.3.0/gcc/ddg.c gcc-7.3.0-msp430/gcc/ddg.c
--- gcc-7.3.0/gcc/ddg.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/ddg.c	2019-06-25 02:27:21.121931274 -0700
@@ -295,11 +295,14 @@
   /* Create inter-loop true dependences and anti dependences.  */
   for (r_use = DF_REF_CHAIN (last_def); r_use != NULL; r_use = r_use->next)
     {
-      rtx_insn *use_insn = DF_REF_INSN (r_use->ref);
-
-      if (BLOCK_FOR_INSN (use_insn) != g->bb)
+      if (DF_REF_BB (r_use->ref) != g->bb)
 	continue;
 
+      gcc_assert (!DF_REF_IS_ARTIFICIAL (r_use->ref)
+		  && DF_REF_INSN_INFO (r_use->ref) != NULL);
+
+      rtx_insn *use_insn = DF_REF_INSN (r_use->ref);
+
       /* ??? Do not handle uses with DF_REF_IN_NOTE notes.  */
       use_node = get_node_of_insn (g, use_insn);
       gcc_assert (use_node);
diff -ruN gcc-7.3.0/gcc/doc/extend.texi gcc-7.3.0-msp430/gcc/doc/extend.texi
--- gcc-7.3.0/gcc/doc/extend.texi	2018-01-16 03:19:51.169148000 -0800
+++ gcc-7.3.0-msp430/gcc/doc/extend.texi	2019-06-25 02:27:21.121931274 -0700
@@ -1,4 +1,4 @@
-@c Copyright (C) 1988-2017 Free Software Foundation, Inc.
+@c Copyright (C) 1988-2018 Free Software Foundation, Inc.
 
 @c This is part of the GCC manual.
 @c For copying conditions, see the file gcc.texi.
@@ -15165,21 +15165,16 @@
 @smallexample
 long __builtin_bpermd (long, long);
 int __builtin_divwe (int, int);
-int __builtin_divweo (int, int);
 unsigned int __builtin_divweu (unsigned int, unsigned int);
-unsigned int __builtin_divweuo (unsigned int, unsigned int);
 long __builtin_divde (long, long);
-long __builtin_divdeo (long, long);
 unsigned long __builtin_divdeu (unsigned long, unsigned long);
-unsigned long __builtin_divdeuo (unsigned long, unsigned long);
 unsigned int cdtbcd (unsigned int);
 unsigned int cbcdtd (unsigned int);
 unsigned int addg6s (unsigned int, unsigned int);
 @end smallexample
 
-The @code{__builtin_divde}, @code{__builtin_divdeo},
-@code{__builtin_divdeu}, @code{__builtin_divdeou} functions require a
-64-bit environment support ISA 2.06 or later.
+The @code{__builtin_divde} and @code{__builtin_divdeu} functions
+require a 64-bit environment supporting ISA 2.06 or later.
 
 The following built-in functions are available for the PowerPC family
 of processors, starting with ISA 3.0 or later (@option{-mcpu=power9}):
@@ -18124,14 +18119,11 @@
 vector int vec_vctzw (vector int);
 vector unsigned int vec_vctzw (vector int);
 
-long long vec_vextract4b (const vector signed char, const int);
-long long vec_vextract4b (const vector unsigned char, const int);
-
-vector signed char vec_insert4b (vector int, vector signed char, const int);
+long long vec_extract4b (const vector unsigned char, const int);
+vector unsigned char vec_insert4b (vector signed int, vector unsigned char,
+                                   const int);
 vector unsigned char vec_insert4b (vector unsigned int, vector unsigned char,
                                    const int);
-vector signed char vec_insert4b (long long, vector signed char, const int);
-vector unsigned char vec_insert4b (long long, vector unsigned char, const int);
 
 vector int vec_vprtyb (vector int);
 vector unsigned int vec_vprtyb (vector unsigned int);
diff -ruN gcc-7.3.0/gcc/doc/gcov.texi gcc-7.3.0-msp430/gcc/doc/gcov.texi
--- gcc-7.3.0/gcc/doc/gcov.texi	2017-11-21 08:01:16.538902000 -0800
+++ gcc-7.3.0-msp430/gcc/doc/gcov.texi	2019-06-25 02:27:21.121931274 -0700
@@ -322,7 +322,7 @@
 Additional block information may succeed each line, when requested by
 command line option.  The @var{execution_count} is @samp{-} for lines
 containing no code.  Unexecuted lines are marked @samp{#####} or
-@samp{====}, depending on whether they are reachable by
+@samp{=====}, depending on whether they are reachable by
 non-exceptional paths or only exceptional paths such as C++ exception
 handlers, respectively. Given @samp{-a} option, unexecuted blocks are
 marked @samp{$$$$$} or @samp{%%%%%}, depending on whether a basic block
@@ -618,6 +618,8 @@
 to invoke the @code{__gcov_dump} function. Thus @code{__gcov_dump}
 is executed after all user defined static destructors,
 as well as handlers registered with @code{atexit}.
+If an executable loads a dynamic shared object via dlopen functionality,
+@option{-Wl,--dynamic-list-data} is needed to dump all profile data.
 
 @c man end
 
diff -ruN gcc-7.3.0/gcc/doc/install.texi2html gcc-7.3.0-msp430/gcc/doc/install.texi2html
--- gcc-7.3.0/gcc/doc/install.texi2html	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/doc/install.texi2html	2019-06-25 02:27:21.121931274 -0700
@@ -52,7 +52,10 @@
 do
     define=`echo $x | sed -e 's/\.//g'`
     echo "define = $define"
-    $MAKEINFO --no-number-sections -I $SOURCEDIR -I $SOURCEDIR/include -I $DESTDIR $SOURCEDIR/install.texi --html --no-split -D$define -o$DESTDIR/$x
+    $MAKEINFO --no-number-sections -I $SOURCEDIR -I $SOURCEDIR/include -I $DESTDIR $SOURCEDIR/install.texi --html --no-split -D$define -o$DESTDIR/temp.html
+    # Use sed to work around makeinfo 4.7 brokenness.
+    sed -e 's/_002d/-/g' -e 's/_002a/*/g' $DESTDIR/temp.html > $DESTDIR/$x
+    rm $DESTDIR/temp.html
 done
 
 rm $DESTDIR/gcc-vers.texi
diff -ruN gcc-7.3.0/gcc/doc/invoke.texi gcc-7.3.0-msp430/gcc/doc/invoke.texi
--- gcc-7.3.0/gcc/doc/invoke.texi	2018-01-16 03:22:01.161048000 -0800
+++ gcc-7.3.0-msp430/gcc/doc/invoke.texi	2019-06-25 02:27:21.125931246 -0700
@@ -1025,7 +1025,7 @@
 -mfloat-gprs=yes  -mfloat-gprs=no  -mfloat-gprs=single  -mfloat-gprs=double @gol
 -mprototype  -mno-prototype @gol
 -msim  -mmvme  -mads  -myellowknife  -memb  -msdata @gol
--msdata=@var{opt}  -mvxworks  -G @var{num} @gol
+-msdata=@var{opt}  -mreadonly-in-sdata  -mvxworks  -G @var{num} @gol
 -mrecip  -mrecip=@var{opt}  -mno-recip  -mrecip-precision @gol
 -mno-recip-precision @gol
 -mveclibabi=@var{type}  -mfriz  -mno-friz @gol
@@ -1211,7 +1211,7 @@
 -mavx256-split-unaligned-load  -mavx256-split-unaligned-store @gol
 -malign-data=@var{type}  -mstack-protector-guard=@var{guard} @gol
 -mmitigate-rop  -mgeneral-regs-only @gol
--mindirect-branch=@var{choice} -mfunction-return==@var{choice} @gol
+-mindirect-branch=@var{choice} -mfunction-return=@var{choice} @gol
 -mindirect-branch-register}
 
 @emph{x86 Windows Options}
@@ -5171,6 +5171,9 @@
 may end in one of the standard suffixes designating a multiple of bytes
 such as @code{kB} and @code{KiB} for kilobyte and kibibyte, respectively,
 @code{MB} and @code{MiB} for megabyte and mebibyte, and so on.
+@option{-Walloc-size-larger-than=}@var{PTRDIFF_MAX} is enabled by default.
+Warnings controlled by the option can be disabled by specifying @var{n}
+of @var{SIZE_MAX} or more.
 @xref{Function Attributes}.
 
 @item -Walloca
@@ -8132,7 +8135,7 @@
 
 @item -fisolate-erroneous-paths-attribute
 @opindex fisolate-erroneous-paths-attribute
-Detect paths that trigger erroneous or undefined behavior due a null value
+Detect paths that trigger erroneous or undefined behavior due to a null value
 being used in a way forbidden by a @code{returns_nonnull} or @code{nonnull}
 attribute.  Isolate those paths from the main control flow and turn the
 statement with erroneous or undefined behavior into a trap.  This is not
@@ -8690,6 +8693,7 @@
 in that case, it is rounded up.
 
 If @var{n} is not specified or is zero, use a machine-dependent default.
+The maximum allowed @var{n} option value is 65536.
 
 Enabled at levels @option{-O2}, @option{-O3}.
 
@@ -8715,6 +8719,7 @@
 
 If @var{n} is not specified or is zero, use a machine-dependent default
 which is very likely to be @samp{1}, meaning no alignment.
+The maximum allowed @var{n} option value is 65536.
 
 Enabled at levels @option{-O2}, @option{-O3}.
 
@@ -8728,6 +8733,7 @@
 
 @option{-fno-align-loops} and @option{-falign-loops=1} are
 equivalent and mean that loops are not aligned.
+The maximum allowed @var{n} option value is 65536.
 
 If @var{n} is not specified or is zero, use a machine-dependent default.
 
@@ -8745,6 +8751,7 @@
 equivalent and mean that loops are not aligned.
 
 If @var{n} is not specified or is zero, use a machine-dependent default.
+The maximum allowed @var{n} option value is 65536.
 
 Enabled at levels @option{-O2}, @option{-O3}.
 
@@ -22070,6 +22077,13 @@
 in the @code{.data} section, and all uninitialized data in the
 @code{.bss} section.
 
+@item -mreadonly-in-sdata
+@itemx -mreadonly-in-sdata
+@opindex mreadonly-in-sdata
+@opindex mno-readonly-in-sdata
+Put read-only objects in the @code{.sdata} section as well.  This is the
+default.
+
 @item -mblock-move-inline-limit=@var{num}
 @opindex mblock-move-inline-limit
 Inline all block moves (such as calls to @code{memcpy} or structure
@@ -25091,8 +25105,8 @@
 @itemx -mpclmul
 @opindex mpclmul
 @need 200
-@itemx -mclfushopt
-@opindex mclfushopt
+@itemx -mclflushopt
+@opindex mclflushopt
 @need 200
 @itemx -mfsgsbase
 @opindex mfsgsbase
diff -ruN gcc-7.3.0/gcc/doc/rtl.texi gcc-7.3.0-msp430/gcc/doc/rtl.texi
--- gcc-7.3.0/gcc/doc/rtl.texi	2017-03-21 14:37:29.998848000 -0700
+++ gcc-7.3.0-msp430/gcc/doc/rtl.texi	2019-06-25 02:27:21.125931246 -0700
@@ -1291,10 +1291,11 @@
 @findex CDImode
 @findex CTImode
 @findex COImode
-@item CQImode, CHImode, CSImode, CDImode, CTImode, COImode
+@findex CPSImode
+@item CQImode, CHImode, CSImode, CDImode, CTImode, COImode, CPSImode
 These modes stand for a complex number represented as a pair of integer
 values.  The integer values are in @code{QImode}, @code{HImode},
-@code{SImode}, @code{DImode}, @code{TImode}, and @code{OImode},
+@code{SImode}, @code{DImode}, @code{TImode}, @code{OImode}, and @code{PSImode},
 respectively.
 
 @findex BND32mode
diff -ruN gcc-7.3.0/gcc/doc/tm.texi gcc-7.3.0-msp430/gcc/doc/tm.texi
--- gcc-7.3.0/gcc/doc/tm.texi	2017-04-04 10:52:27.193766000 -0700
+++ gcc-7.3.0-msp430/gcc/doc/tm.texi	2019-06-25 02:27:21.125931246 -0700
@@ -10645,8 +10645,12 @@
 
 @defmac WORD_REGISTER_OPERATIONS
 Define this macro to 1 if operations between registers with integral mode
-smaller than a word are always performed on the entire register.
-Most RISC machines have this property and most CISC machines do not.
+smaller than a word are always performed on the entire register.  To be
+more explicit, if you start with a pair of @code{word_mode} registers with
+known values and you do a subword, for example @code{QImode}, addition on
+the low part of the registers, then the compiler may consider that the
+result has a known value in @code{word_mode} too if the macro is defined
+to 1.  Most RISC machines have this property and most CISC machines do not.
 @end defmac
 
 @deftypefn {Target Hook} {unsigned int} TARGET_MIN_ARITHMETIC_PRECISION (void)
diff -ruN gcc-7.3.0/gcc/doc/tm.texi.in gcc-7.3.0-msp430/gcc/doc/tm.texi.in
--- gcc-7.3.0/gcc/doc/tm.texi.in	2017-04-04 10:52:27.193766000 -0700
+++ gcc-7.3.0-msp430/gcc/doc/tm.texi.in	2019-06-25 02:27:21.125931246 -0700
@@ -7581,8 +7581,12 @@
 
 @defmac WORD_REGISTER_OPERATIONS
 Define this macro to 1 if operations between registers with integral mode
-smaller than a word are always performed on the entire register.
-Most RISC machines have this property and most CISC machines do not.
+smaller than a word are always performed on the entire register.  To be
+more explicit, if you start with a pair of @code{word_mode} registers with
+known values and you do a subword, for example @code{QImode}, addition on
+the low part of the registers, then the compiler may consider that the
+result has a known value in @code{word_mode} too if the macro is defined
+to 1.  Most RISC machines have this property and most CISC machines do not.
 @end defmac
 
 @hook TARGET_MIN_ARITHMETIC_PRECISION
diff -ruN gcc-7.3.0/gcc/dse.c gcc-7.3.0-msp430/gcc/dse.c
--- gcc-7.3.0/gcc/dse.c	2017-11-22 01:04:47.611260000 -0800
+++ gcc-7.3.0-msp430/gcc/dse.c	2019-06-25 02:27:21.125931246 -0700
@@ -1342,6 +1342,9 @@
   else
     width = GET_MODE_SIZE (GET_MODE (mem));
 
+  if (width == 0)
+    return 0;
+
   if (group_id >= 0)
     {
       /* In the restrictive case where the base is a constant or the
diff -ruN gcc-7.3.0/gcc/dwarf2asm.c gcc-7.3.0-msp430/gcc/dwarf2asm.c
--- gcc-7.3.0/gcc/dwarf2asm.c	2017-07-28 06:25:40.198635000 -0700
+++ gcc-7.3.0-msp430/gcc/dwarf2asm.c	2019-06-25 02:27:21.125931246 -0700
@@ -33,6 +33,7 @@
 #include "dwarf2.h"
 #include "function.h"
 #include "emit-rtl.h"
+#include "fold-const.h"
 
 #ifndef XCOFF_DEBUGGING_INFO
 #define XCOFF_DEBUGGING_INFO 0
@@ -925,7 +926,7 @@
   SET_DECL_ASSEMBLER_NAME (decl, id);
   DECL_ARTIFICIAL (decl) = 1;
   DECL_IGNORED_P (decl) = 1;
-  DECL_INITIAL (decl) = decl;
+  DECL_INITIAL (decl) = build_fold_addr_expr (decl);
   TREE_READONLY (decl) = 1;
   TREE_STATIC (decl) = 1;
 
@@ -938,8 +939,23 @@
     }
 
   sym_ref = gen_rtx_SYMBOL_REF (Pmode, sym);
+  /* Disable ASan for decl because redzones cause ABI breakage between GCC and
+     libstdc++ for `.LDFCM*' variables.  See PR 78651 for details.  */
+  unsigned int save_flag_sanitize = flag_sanitize;
+  flag_sanitize &= ~(SANITIZE_ADDRESS | SANITIZE_USER_ADDRESS
+		     | SANITIZE_KERNEL_ADDRESS);
+  /* And also temporarily disable -fsection-anchors.  These indirect constants
+     are never referenced from code, so it doesn't make any sense to aggregate
+     them in blocks.  */
+  int save_flag_section_anchors = flag_section_anchors;
+  flag_section_anchors = 0;
   assemble_variable (decl, 1, 1, 1);
+  flag_section_anchors = save_flag_section_anchors;
+  flag_sanitize = save_flag_sanitize;
   assemble_integer (sym_ref, POINTER_SIZE_UNITS, POINTER_SIZE, 1);
+  /* The following is a hack recognized by use_blocks_for_decl_p to disable
+     section anchor handling of the decl.  */
+  DECL_INITIAL (decl) = decl;
 
   return 0;
 }
diff -ruN gcc-7.3.0/gcc/dwarf2out.c gcc-7.3.0-msp430/gcc/dwarf2out.c
--- gcc-7.3.0/gcc/dwarf2out.c	2017-11-15 03:54:11.986064000 -0800
+++ gcc-7.3.0-msp430/gcc/dwarf2out.c	2019-06-25 02:27:21.129931218 -0700
@@ -18749,6 +18749,8 @@
 
       if (GET_MODE_CLASS (mode) == MODE_INT && GET_MODE_SIZE (mode) == 1
 	  && domain
+	  && TYPE_MAX_VALUE (domain)
+	  && TREE_CODE (TYPE_MAX_VALUE (domain)) == INTEGER_CST
 	  && integer_zerop (TYPE_MIN_VALUE (domain))
 	  && compare_tree_int (TYPE_MAX_VALUE (domain),
 			       TREE_STRING_LENGTH (init) - 1) == 0
diff -ruN gcc-7.3.0/gcc/emit-rtl.c gcc-7.3.0-msp430/gcc/emit-rtl.c
--- gcc-7.3.0/gcc/emit-rtl.c	2017-02-02 04:39:09.589196000 -0800
+++ gcc-7.3.0-msp430/gcc/emit-rtl.c	2019-06-25 02:27:21.129931218 -0700
@@ -1606,6 +1606,11 @@
       && (offset + 1) * UNITS_PER_WORD > GET_MODE_SIZE (mode))
     return const0_rtx;
 
+  /* TER can cause SYMBOL_REFs to arrive here.  Don't pass them to
+     simplify_gen_subreg.  */
+  if (SYMBOL_REF_P (op))
+    return 0;
+
   /* Form a new MEM at the requested address.  */
   if (MEM_P (op))
     {
@@ -5851,7 +5856,7 @@
       attrs = ggc_cleared_alloc<mem_attrs> ();
       attrs->align = BITS_PER_UNIT;
       attrs->addrspace = ADDR_SPACE_GENERIC;
-      if (mode != BLKmode)
+      if (mode != BLKmode && mode != VOIDmode)
 	{
 	  attrs->size_known_p = true;
 	  attrs->size = GET_MODE_SIZE (mode);
diff -ruN gcc-7.3.0/gcc/expmed.c gcc-7.3.0-msp430/gcc/expmed.c
--- gcc-7.3.0/gcc/expmed.c	2018-01-01 03:27:17.652040000 -0800
+++ gcc-7.3.0-msp430/gcc/expmed.c	2019-06-25 02:27:21.129931218 -0700
@@ -5886,6 +5886,18 @@
   if (tem != 0)
     return tem;
 
+  /* If one operand is constant, make it the second one.  Only do this
+     if the other operand is not constant as well.  */
+
+  if (swap_commutative_operands_p (op0, op1))
+    {
+      std::swap (op0, op1);
+      code = swap_condition (code);
+    }
+
+  if (mode == VOIDmode)
+    mode = GET_MODE (op0);
+
   if (!target)
     target = gen_reg_rtx (word_mode);
 
diff -ruN gcc-7.3.0/gcc/expr.c gcc-7.3.0-msp430/gcc/expr.c
--- gcc-7.3.0/gcc/expr.c	2018-01-01 03:30:28.610819000 -0800
+++ gcc-7.3.0-msp430/gcc/expr.c	2019-06-25 02:27:21.129931218 -0700
@@ -5109,7 +5109,10 @@
 	      && bitpos == 0
 	      && bitsize == mode_bitsize)
 	    result = store_expr (from, to_rtx, false, nontemporal, reversep);
-	  else if (bitsize == mode_bitsize / 2
+	  else if (COMPLEX_MODE_P (GET_MODE (to_rtx))
+		   && (TYPE_MODE (TREE_TYPE (from))
+		       == GET_MODE_INNER (GET_MODE (to_rtx)))
+		   && bitsize == mode_bitsize / 2
 		   && (bitpos == 0 || bitpos == mode_bitsize / 2))
 	    result = store_expr (from, XEXP (to_rtx, bitpos != 0), false,
 				 nontemporal, reversep);
@@ -6893,8 +6896,9 @@
       if (GET_CODE (temp) == PARALLEL)
 	{
 	  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));
-	  machine_mode temp_mode
-	    = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);
+	  machine_mode temp_mode = GET_MODE (temp);
+	  if (temp_mode == BLKmode || temp_mode == VOIDmode)
+	    temp_mode = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);
 	  rtx temp_target = gen_reg_rtx (temp_mode);
 	  emit_group_store (temp_target, temp, TREE_TYPE (exp), size);
 	  temp = temp_target;
@@ -10862,18 +10866,30 @@
 	tree fndecl = get_callee_fndecl (exp), attr;
 
 	if (fndecl
+	    /* Don't diagnose the error attribute in thunks, those are
+	       artificially created.  */
+	    && !CALL_FROM_THUNK_P (exp)
 	    && (attr = lookup_attribute ("error",
 					 DECL_ATTRIBUTES (fndecl))) != NULL)
-	  error ("%Kcall to %qs declared with attribute error: %s",
-		 exp, identifier_to_locale (lang_hooks.decl_printable_name (fndecl, 1)),
-		 TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+	  {
+	    const char *ident = lang_hooks.decl_printable_name (fndecl, 1);
+	    error ("%Kcall to %qs declared with attribute error: %s", exp,
+		   identifier_to_locale (ident),
+		   TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+	  }
 	if (fndecl
+	    /* Don't diagnose the warning attribute in thunks, those are
+	       artificially created.  */
+	    && !CALL_FROM_THUNK_P (exp)
 	    && (attr = lookup_attribute ("warning",
 					 DECL_ATTRIBUTES (fndecl))) != NULL)
-	  warning_at (tree_nonartificial_location (exp),
-		      0, "%Kcall to %qs declared with attribute warning: %s",
-		      exp, identifier_to_locale (lang_hooks.decl_printable_name (fndecl, 1)),
-		      TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+	  {
+	    const char *ident = lang_hooks.decl_printable_name (fndecl, 1);
+	    warning_at (tree_nonartificial_location (exp), 0,
+			"%Kcall to %qs declared with attribute warning: %s",
+			exp, identifier_to_locale (ident),
+			TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+	  }
 
 	/* Check for a built-in function.  */
 	if (fndecl && DECL_BUILT_IN (fndecl))
diff -ruN gcc-7.3.0/gcc/final.c gcc-7.3.0-msp430/gcc/final.c
--- gcc-7.3.0/gcc/final.c	2017-02-18 08:11:40.783193000 -0800
+++ gcc-7.3.0-msp430/gcc/final.c	2019-06-25 02:27:21.129931218 -0700
@@ -906,7 +906,7 @@
   char *varying_length;
   rtx body;
   int uid;
-  rtx align_tab[MAX_CODE_ALIGN];
+  rtx align_tab[MAX_CODE_ALIGN + 1];
 
   /* Compute maximum UID and allocate label_align / uid_shuid.  */
   max_uid = get_max_uid ();
@@ -1015,7 +1015,7 @@
      alignment of n.  */
   uid_align = XCNEWVEC (rtx, max_uid);
 
-  for (i = MAX_CODE_ALIGN; --i >= 0;)
+  for (i = MAX_CODE_ALIGN + 1; --i >= 0;)
     align_tab[i] = NULL_RTX;
   seq = get_last_insn ();
   for (; seq; seq = PREV_INSN (seq))
diff -ruN gcc-7.3.0/gcc/fold-const.c gcc-7.3.0-msp430/gcc/fold-const.c
--- gcc-7.3.0/gcc/fold-const.c	2017-12-23 00:43:10.778897000 -0800
+++ gcc-7.3.0-msp430/gcc/fold-const.c	2019-06-25 02:27:21.133931189 -0700
@@ -473,12 +473,15 @@
     case EXACT_DIV_EXPR:
       if (TYPE_UNSIGNED (type))
 	break;
-      if (negate_expr_p (TREE_OPERAND (t, 0)))
+      /* In general we can't negate A in A / B, because if A is INT_MIN and
+         B is not 1 we change the sign of the result.  */
+      if (TREE_CODE (TREE_OPERAND (t, 0)) == INTEGER_CST
+	  && negate_expr_p (TREE_OPERAND (t, 0)))
 	return true;
       /* In general we can't negate B in A / B, because if A is INT_MIN and
 	 B is 1, we may turn this into INT_MIN / -1 which is undefined
 	 and actually traps on some architectures.  */
-      if (! INTEGRAL_TYPE_P (TREE_TYPE (t))
+      if (! ANY_INTEGRAL_TYPE_P (TREE_TYPE (t))
 	  || TYPE_OVERFLOW_WRAPS (TREE_TYPE (t))
 	  || (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST
 	      && ! integer_onep (TREE_OPERAND (t, 1))))
@@ -652,14 +655,17 @@
     case EXACT_DIV_EXPR:
       if (TYPE_UNSIGNED (type))
 	break;
-      if (negate_expr_p (TREE_OPERAND (t, 0)))
+      /* In general we can't negate A in A / B, because if A is INT_MIN and
+	 B is not 1 we change the sign of the result.  */
+      if (TREE_CODE (TREE_OPERAND (t, 0)) == INTEGER_CST
+	  && negate_expr_p (TREE_OPERAND (t, 0)))
 	return fold_build2_loc (loc, TREE_CODE (t), type,
 				negate_expr (TREE_OPERAND (t, 0)),
 				TREE_OPERAND (t, 1));
       /* In general we can't negate B in A / B, because if A is INT_MIN and
 	 B is 1, we may turn this into INT_MIN / -1 which is undefined
 	 and actually traps on some architectures.  */
-      if ((! INTEGRAL_TYPE_P (TREE_TYPE (t))
+      if ((! ANY_INTEGRAL_TYPE_P (TREE_TYPE (t))
 	   || TYPE_OVERFLOW_WRAPS (TREE_TYPE (t))
 	   || (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST
 	       && ! integer_onep (TREE_OPERAND (t, 1))))
@@ -7199,7 +7205,7 @@
 	return 0;
       offset += res;
       if (offset >= len)
-	return offset;
+	return (off == -1 && i < count - 1) ? 0 : offset;
       if (off != -1)
 	off = 0;
     }
@@ -14082,6 +14088,7 @@
     {
       tree op = TREE_OPERAND (sub, 0);
       tree optype = TREE_TYPE (op);
+
       /* *&CONST_DECL -> to the value of the const decl.  */
       if (TREE_CODE (op) == CONST_DECL)
 	return DECL_INITIAL (op);
@@ -14115,12 +14122,13 @@
 	       && type == TREE_TYPE (optype))
 	return fold_build1_loc (loc, REALPART_EXPR, type, op);
       /* *(foo *)&vectorfoo => BIT_FIELD_REF<vectorfoo,...> */
-      else if (TREE_CODE (optype) == VECTOR_TYPE
+      else if (VECTOR_TYPE_P (optype)
 	       && type == TREE_TYPE (optype))
 	{
 	  tree part_width = TYPE_SIZE (type);
 	  tree index = bitsize_int (0);
-	  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width, index);
+	  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width,
+				  index);
 	}
     }
 
@@ -14138,8 +14146,17 @@
 	  op00type = TREE_TYPE (op00);
 
 	  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */
-	  if (TREE_CODE (op00type) == VECTOR_TYPE
-	      && type == TREE_TYPE (op00type))
+	  if (VECTOR_TYPE_P (op00type)
+	      && type == TREE_TYPE (op00type)
+	      /* POINTER_PLUS_EXPR second operand is sizetype, unsigned,
+		 but we want to treat offsets with MSB set as negative.
+		 For the code below negative offsets are invalid and
+		 TYPE_SIZE of the element is something unsigned, so
+		 check whether op01 fits into HOST_WIDE_INT, which
+		 implies it is from 0 to INTTYPE_MAXIMUM (HOST_WIDE_INT), and
+		 then just use unsigned HOST_WIDE_INT because we want to treat
+		 the value as unsigned.  */
+	      && tree_fits_shwi_p (op01))
 	    {
 	      tree part_width = TYPE_SIZE (type);
 	      unsigned HOST_WIDE_INT max_offset
diff -ruN gcc-7.3.0/gcc/fortran/arith.c gcc-7.3.0-msp430/gcc/fortran/arith.c
--- gcc-7.3.0/gcc/fortran/arith.c	2017-01-23 11:43:28.124445000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/arith.c	2019-06-25 02:27:21.133931189 -0700
@@ -555,10 +555,10 @@
       val = ARITH_OK;
     }
 
-  if (val != ARITH_OK)
-    gfc_free_expr (r);
-  else
+  if (val == ARITH_OK || val == ARITH_OVERFLOW)
     *rp = r;
+  else
+    gfc_free_expr (r);
 
   return val;
 }
@@ -1603,9 +1603,13 @@
   if (rc != ARITH_OK)
     {
       gfc_error (gfc_arith_error (rc), &op1->where);
+      if (rc == ARITH_OVERFLOW)
+	goto done;
       return NULL;
     }
 
+done:
+
   gfc_free_expr (op1);
   gfc_free_expr (op2);
   return result;
diff -ruN gcc-7.3.0/gcc/fortran/array.c gcc-7.3.0-msp430/gcc/fortran/array.c
--- gcc-7.3.0/gcc/fortran/array.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/array.c	2019-06-25 02:27:21.133931189 -0700
@@ -1079,6 +1079,15 @@
   if (m != MATCH_YES)
     return m;
 
+  if (expr->expr_type == EXPR_FUNCTION
+      && expr->ts.type == BT_UNKNOWN
+      && strcmp(expr->symtree->name, "null") == 0)
+   {
+      gfc_error ("NULL() at %C cannot appear in an array constructor");
+      gfc_free_expr (expr);
+      return MATCH_ERROR;
+   }
+
   gfc_constructor_append_expr (result, expr, &gfc_current_locus);
   return MATCH_YES;
 }
@@ -1998,7 +2007,9 @@
 	  gfc_ref *ref;
 	  for (ref = p->expr->ref; ref; ref = ref->next)
 	    if (ref->type == REF_SUBSTRING
+		&& ref->u.ss.start
 		&& ref->u.ss.start->expr_type == EXPR_CONSTANT
+		&& ref->u.ss.end
 		&& ref->u.ss.end->expr_type == EXPR_CONSTANT)
 	      break;
 
@@ -2021,7 +2032,8 @@
 	  else
 	    return true;
 
-	  gcc_assert (current_length != -1);
+	  if (current_length < 0)
+	    current_length = 0;
 
 	  if (found_length == -1)
 	    found_length = current_length;
diff -ruN gcc-7.3.0/gcc/fortran/ChangeLog gcc-7.3.0-msp430/gcc/fortran/ChangeLog
--- gcc-7.3.0/gcc/fortran/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/ChangeLog	2019-06-25 02:27:21.133931189 -0700
@@ -1,3 +1,522 @@
+2018-07-16  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/83184
+	Backport from trunk.
+	* decl.c (match_old_style_init): Initialize locus of variable expr when
+	creating a data variable.
+	(match_clist_expr): Verify array is explicit shape/size before
+	attempting to allocate constant array constructor.
+
+2018-07-16  Fritz Reese  <fritzoreese@gmail.com>
+
+	Backport from trunk:
+
+	PR fortran/86417
+	* module.c (mio_component): Set component->loc when loading from module.
+
+	PR fortran/83183
+	PR fortran/86325
+	* expr.c (class_allocatable, class_pointer, comp_allocatable,
+	comp_pointer): New helpers.
+	(component_initializer): Generate EXPR_NULL for allocatable or pointer
+	components. Do not generate initializers for components within BT_CLASS.
+	Do not assign to comp->initializer.
+	(gfc_generate_initializer): Use new helpers; move code to generate
+	EXPR_NULL for class allocatable components into component_initializer().
+
+2018-07-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82969
+	PR fortran/86242
+	* trans-array.c (structure_alloc_comps): Do not explicitly copy
+	procedure pointer components.
+
+2018-06-25  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/82972
+	PR fortran/83088
+	PR fortran/85851
+	Backport from trunk.
+	* expr.c (component_initializer): Assign init expr to c->initializer.
+	(generate_isocbinding_initializer): New.
+	(gfc_generate_initializer): Call generate_isocbinding_initializer to
+	generate initializers for c_ptr and c_funptr with -finit-derived.
+
+2018-06-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83118
+	Back port from trunk
+	* resolve.c (resolve_ordinary_assign): Force the creation of a
+	vtable for assignment of non-polymorphic expressions to an
+	unlimited polymorphic object.
+	* trans-array.c (gfc_alloc_allocatable_for_assignment): Use the
+	size of the rhs type for such assignments. Set the dtype, _len
+	and vptrs appropriately.
+	* trans-expr.c (gfc_trans_assignment): Force the use of the
+	_copy function for these assignments.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/85313
+	* openmp.c (resolve_omp_do): Remove bogus if (j < i) break;.
+	(resolve_oacc_nested_loops): Likewise.  Formatting fix.
+
+2018-06-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86110
+	* array.c (gfc_resolve_character_array_constructor): Avoid NULL
+	pointer dereference.
+
+2018-06-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/44491
+	* expr.c (gfc_check_assign): Select non-NULL locus.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/38351
+	* resolve.c (resolve_operator): Provide better error message for
+	derived type entity used in an binary intrinsic numeric operator.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/63514
+	* symbol.c (gfc_add_volatile): Enforce F2008:C1282 and F2018:C1588.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78278
+	* data.c (gfc_assign_data_value): Re-arrange code to allow for
+	an error for double initialization of CHARACTER entities.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86059
+	* array.c (match_array_cons_element): NULL() cannot be in an
+	array constructor.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85138
+	PR fortran/85996
+	PR fortran/86051
+	* decl.c (gfc_match_char_spec): Use private namespace in attempt to
+	reduce a charlen to a constant.
+
+2018-06-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86045
+	Backport from trunk.
+	* simplify.c (gfc_simplify_mod): Re-arrange code to test whether
+	'P' is zero and issue an error if it is.
+
+2018-06-07  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/85641
+	Backport from trunk.
+	* frontend-passes.c (is_fe_temp): Add prototype.
+	(realloc_string_callback): Early return for frontend-generated
+	temporary.
+
+2018-06-04  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85981
+	* resolve.c (resolve_allocate_deallocate): Check errmsg is default
+	character kind.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85543
+	Backport from trunk
+	* resolve.c (update_current_proc_array_outer_dependency): Avoid NULL
+	pointer dereference.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85779
+	Backport from trunk
+	* decl.c (gfc_match_derived_decl): Fix NULL point dereference.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85780
+	Backport from trunk
+	* resolve.c (resolve_fl_procedure): Avoid NULL dereference.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85895
+	Backport from trunk
+	* resolve.c (resolve_sync): Resolve expression before checking for
+	an error.
+
+2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/80657
+	Backport from trunk
+	* resolve.c (flag_fn_result_spec): Use the 'sym' argument to
+	test for self refs to the function result in the character len
+	expression. If a self reference is found, emit an error and
+	return true.
+	(resolve_fntype): Use the function symbol in the calls to the
+	above.
+
+2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82275
+	Backport from trunk
+	* match.c (gfc_match_type_spec): Go through the array ref and
+	decrement 'rank' for every dimension that is an element.
+
+2018-05-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82923
+	PR fortran/66694
+	PR fortran/82617
+	Backport from trunk
+	* trans-array.c (gfc_alloc_allocatable_for_assignment): Set the
+	charlen backend_decl of the rhs expr to ss->info->string_length
+	so that the value in the current scope is used.
+
+2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83149
+	Backport from trunk
+	* trans-decl.c (gfc_finish_var_decl): Test sym->ns->proc_name
+	before accessing its components.
+	* trans-types.c (gfc_sym_type): If a character result has null
+	backend_decl, try the procedure symbol..
+
+2018-16-05  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83898
+	Backport from trunk
+	* trans-stmt.c (trans_associate_var): Do not set cst_array_ctor
+	for characters.
+
+2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/84546
+	Backport from trunk
+	* trans-array.c (structure_alloc_comps): Make sure that the
+	vptr is copied and that the unlimited polymorphic _len is used
+	to compute the size to be allocated.
+	(build_array_ref): Set the 'unlimited' argument false in the
+	call to gfc_get_class_array_ref.
+	* trans-expr.c (gfc_get_class_array_ref): If unlimited, use the
+	unlimited polymorphic _len for the offset to the element.
+	(gfc_copy_class_to_class): Set the new 'unlimited' argument.
+	* trans.h : Add the boolean 'unlimited' to the prototype.
+
+2018-05-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85542
+	Backport from trunk
+	* expr.c (check_inquiry): Avoid NULL pointer dereference.
+
+2018-05-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/68846
+	PR fortran/70864
+	Backport from trunk
+	* resolve.c (get_temp_from_expr): The temporary must not have
+	dummy or intent attributes.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/70870
+	Backport from trunk
+	* data.c (gfc_assign_data_value): Check that a data object does
+	not also have default initialization.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85521
+	Backport from trunk
+	* array.c (gfc_resolve_character_array_constructor): Substrings
+	with upper bound smaller than lower bound are zero length strings.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85687
+	Backport from trunk
+	* check.c (gfc_check_rank): Check that the argument is a data object.
+
+2018-05-06  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/85507
+	Backport from trunk.
+	* dependency.c (gfc_dep_resolver): Revert looking at coarray dimension
+	introduced by r259385.
+	* trans-intrinsic.c (conv_caf_send): Always report a dependency for
+	same variables in coarray assignments.
+
+2018-04-28  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/81773
+	PR fortran/83606
+	Backport from trunk.
+	* dependency.c (gfc_dep_resolver): Coarray indexes are to be ignored
+	during dependency computation.  They define no data dependency.
+	* trans-array.c (conv_array_index_offset): The stride can not be set
+	here, prevent fail.
+	* trans-intrinsic.c (conv_caf_send): Add creation of temporary array
+	for caf_get's result and copying to the array with vectorial
+	indexing.
+
+2018-04-24  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85520
+	* decl.c (gfc_match_char_spec): Check for negative length and set to 0.
+
+2018-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/85084
+	Backport from trunk.
+	* frontend-passes.c (gfc_run_passes): Do not run front-end
+	optimizations if a previous error occurred.
+
+2018-03-20  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85001
+	* interface.c (symbol_rank): Remove bogus null pointer check that
+	crept in when translating a ternary operator into an if-else
+	constructor.
+
+2018-03-19  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84931
+	Backport from trunk
+	* simplify.c (gfc_convert_constant): Correctly handle iterators
+	for type conversion.
+
+2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/77414
+	* decl.c (get_proc_name):  Check for a subroutine re-defined in
+	the contain portion of a subroutine.  Change language of existing
+	error message to better describe the issue. While here fix whitespace
+	issues.
+
+2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/65453
+	* decl.c (get_proc_name): Catch clash between a procedure statement
+	and a contained subprogram
+
+2018-03-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78741
+	* decl.c (get_proc_name):  Check for clash of entry name with
+	subroutine name.
+
+2018-03-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/83939
+	* resolve.c (resolve_fl_procedure): Enforce F2018:C15100.
+
+2018-03-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84734
+	* arith.c (check_result, eval_intrinsic):  If result overflows, pass
+	the expression up the chain instead of a NULL pointer.
+
+2018-03-08  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/64124
+	PR fortran/70409
+	* decl.c (gfc_match_char_spec): Try to reduce a charlen to a constant.
+
+2018-03-06  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/56667
+	* primary.c (match_sym_complex_part): Give the matcher for an implied
+	do-loop a chance to run.
+
+2018-03-04  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83076
+	* resolve.c (resolve_fl_derived0): Add caf_token fields for
+	allocatable and pointer scalars, when -fcoarray selected.
+	* trans-types.c (gfc_copy_dt_decls_ifequal): Copy the token
+	field as well as the backend_decl.
+	(gfc_get_derived_type): Flag GFC_FCOARRAY_LIB for module
+	derived types that are not vtypes. Components with caf_token
+	attribute are pvoid types. For a component requiring it, find
+	the caf_token field and have the component token field point to
+	its backend_decl.
+
+2018-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/71085
+	* trans-expr.c (gfc_apply_interface_mapping_to_expr): Do not
+	dereference NULL pointer.
+
+2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/51434
+	* simplify.c (gfc_simplify_transfer): Resolve mold.
+
+2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/80965
+	* resolve.c (build_loc_call): Change symtree name from 'loc' to
+	'_loc'.
+
+2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from trunk.
+	PR fortran/78990
+	* expr.c (gfc_is_class_array_function): Renamed from
+	'gfc_is_alloc_class_array_function' and modified to return true
+	for pointers as well as allocatable results.
+	* gfortran.h : Change of name for prototype of above function.
+	* trans-array.c (gfc_add_loop_ss_code): Force finalization of
+	class array results.
+	(build_class_array_ref): Change assertion into a condition.
+	(build_class_array_ref): Set the se class_vptr for class array
+	function results.
+	(gfc_walk_function_expr): Reference gfc_is_class_array_function
+	as above.
+	* trans-decl.c (get_proc_result): Move it up before
+	gfc_trans_deferred_vars.
+	(gfc_trans_deferred_vars): Nullify explicit return class arrays
+	on entry.
+	* trans-expr.c (gfc_conv_class_to_class): Allow conversion of
+	class array functions that have an se class_vptr and use it
+	for the result vptr.
+	(gfc_conv_subref_array_arg): Rename reference to the above
+	function.
+	(gfc_conv_procedure_call): Ditto. Add the se pre block to the
+	loop pre block before the function is evaluated. Do not
+	finalize class pointer results.
+	(arrayfunc_assign_needs_temporary, gfc_trans_assignment_1) More
+	renamed references.
+	* trans-intrinsic.c (gfc_conv_intrinsic_size): Ditto.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/84418
+	* trans-openmp.c (gfc_trans_omp_clauses): For OMP_CLAUSE_LINEAR_REF
+	kind set OMP_CLAUSE_LINEAR_STEP to TYPE_SIZE_UNIT times last_step.
+
+	2018-01-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/84116
+	* openmp.c (gfc_match_omp_clauses): If all the linear
+	gfc_match_omp_variable_list calls failed, don't gfc_free_omp_namelist
+	nor set *head = NULL.  Formatting fixes.
+
+2018-02-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	ChangeLog for r257972
+	PR fortran/83633
+	* decl.c (variable_decl): Check that an explicit-shape-array with
+	nonconstant bounds is allowed.
+
+2018-02-25  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/78238
+	Backport from trunk
+	* gfortran.h (gfc_integer_4_kind): Define.
+	* resolve.c (resolve_select_type): Make sure that the
+	kind of c->high is gfc_integer_4_kind.
+
+2018-02-24  Steven G. Kargl <kargl@gcc.gnu.org>
+
+	PR fortran/30792
+	* decl.c (gfc_match_data): Check for invalid substring in
+	data-implied-do
+
+2018-02-23  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84511
+	* trans-io.c (transfer_expr): Deal with C_LOC in transfer statement.
+
+2018-02-23  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84346
+	* interface.c (compare_actual_formal): Issue error if keyword is
+	used in a statement function.
+
+2018-02-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84506
+	* trans-io.c (set_parameter_value_inquire): Adjust range check of
+	negative unit values for kind=8 units to the kind=4 negative limit.
+
+2018-02-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/81116
+	PR fortran/84495
+	* gfortran.dg/realloc_on_assignment_29.f90:  New test.
+
+2018-02-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/82007
+	* resolve.c (resolve_transfer): Delete code looking for 'DT'
+	format specifiers in format strings. Set formatted to true if a
+	format string or format label is present.
+	* trans-io.c (get_dtio_proc): Likewise. (transfer_expr): Fix
+	whitespace.
+
+2018-02-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84270
+	* frontend-passes (scalarized_expr):  If the expression
+	is an assumed size array, leave in the last reference
+	and pass AR_SECTION instead of AR_FULL to gfc_resolve
+	in order to avoid an error.
+
+2018-02-13  Alastair McKinstry  <alastair.mckinstry@sceal.ie>
+	    Janne Blomqvist  <jb@gcc.gnu.org>
+
+	* module.c (dump_module): Use lbasename to ensure that module
+	files are reproducible.
+
+2018-02-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/68560
+	* trans-intrinsic.c (gfc_conv_intrinsic_shape): New function.
+	(gfc_conv_intrinsic_function): Call it.
+
+2018-02-12  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	PR fortran/35299
+	ChangeLog for r257566
+	* resolve.c (resolve_formal_arglist): Update error message.
+
+2018-02-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/54223
+	PR fortran/84276
+	* interface.c (compare_actual_formal): Add in_statement_function
+	bool parameter.  Skip check of INTENT attribute for statement
+	functions.  Arguments to a statement function cannot be optional,
+	issue error for missing argument.
+	(gfc_procedure_use, gfc_ppc_use, gfc_arglist_matches_symbol): Use
+	in_statement_function.
+
+2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82994
+	* match.c (gfc_match_deallocate): Check for NULL pointer.
+
+2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82049
+	* match.c (gfc_match_type_spec): If the charlen is non-NULL, then
+	try to resolve it.  While here return early if possible.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/gcc/fortran/check.c gcc-7.3.0-msp430/gcc/fortran/check.c
--- gcc-7.3.0/gcc/fortran/check.c	2018-01-19 15:37:29.245834000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/check.c	2019-06-25 02:27:21.133931189 -0700
@@ -3764,8 +3764,11 @@
 		  ? a->value.function.esym->result->attr.pointer
 		  : a->symtree->n.sym->result->attr.pointer;
 
-  if (a->expr_type == EXPR_OP || a->expr_type == EXPR_NULL
-      || a->expr_type == EXPR_COMPCALL|| a->expr_type == EXPR_PPC
+  if (a->expr_type == EXPR_OP
+      || a->expr_type == EXPR_NULL
+      || a->expr_type == EXPR_COMPCALL
+      || a->expr_type == EXPR_PPC
+      || a->ts.type == BT_PROCEDURE
       || !is_variable)
     {
       gfc_error ("The argument of the RANK intrinsic at %L must be a data "
diff -ruN gcc-7.3.0/gcc/fortran/data.c gcc-7.3.0-msp430/gcc/fortran/data.c
--- gcc-7.3.0/gcc/fortran/data.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/data.c	2019-06-25 02:27:21.133931189 -0700
@@ -481,6 +481,21 @@
   mpz_clear (offset);
   gcc_assert (repeat == NULL);
 
+  /* Overwriting an existing initializer is non-standard but usually only
+     provokes a warning from other compilers.  */
+  if (init != NULL && init->where.lb && rvalue->where.lb)
+    {
+      /* Order in which the expressions arrive here depends on whether
+	 they are from data statements or F95 style declarations.
+	 Therefore, check which is the most recent.  */
+      expr = (LOCATION_LINE (init->where.lb->location)
+	      > LOCATION_LINE (rvalue->where.lb->location))
+	   ? init : rvalue;
+      if (gfc_notify_std (GFC_STD_GNU, "re-initialization of %qs at %L",
+			  symbol->name, &expr->where) == false)
+	return false;
+    }
+
   if (ref || last_ts->type == BT_CHARACTER)
     {
       /* An initializer has to be constant.  */
@@ -492,20 +507,13 @@
     }
   else
     {
-      /* Overwriting an existing initializer is non-standard but usually only
-	 provokes a warning from other compilers.  */
-      if (init != NULL)
+      if (lvalue->ts.type == BT_DERIVED
+	  && gfc_has_default_initializer (lvalue->ts.u.derived))
 	{
-	  /* Order in which the expressions arrive here depends on whether
-	     they are from data statements or F95 style declarations.
-	     Therefore, check which is the most recent.  */
-	  expr = (LOCATION_LINE (init->where.lb->location)
-		  > LOCATION_LINE (rvalue->where.lb->location))
-	       ? init : rvalue;
-	  if (gfc_notify_std (GFC_STD_GNU,
-			      "re-initialization of %qs at %L",
-			      symbol->name, &expr->where) == false)
-	    return false;
+	  gfc_error ("Nonpointer object %qs with default initialization "
+		     "shall not appear in a DATA statement at %L", 
+		     symbol->name, &lvalue->where);
+	  return false;
 	}
 
       expr = gfc_copy_expr (rvalue);
diff -ruN gcc-7.3.0/gcc/fortran/decl.c gcc-7.3.0-msp430/gcc/fortran/decl.c
--- gcc-7.3.0/gcc/fortran/decl.c	2018-01-17 16:30:42.054922000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/decl.c	2019-06-25 02:27:21.133931189 -0700
@@ -509,6 +509,7 @@
   newdata = gfc_get_data ();
   newdata->var = gfc_get_data_variable ();
   newdata->var->expr = gfc_get_variable_expr (st);
+  newdata->var->expr->where = sym->declared_at;
   newdata->where = gfc_current_locus;
 
   /* Match initial value list. This also eats the terminal '/'.  */
@@ -573,6 +574,20 @@
       if (m != MATCH_YES)
 	goto cleanup;
 
+      if (new_data->var->iter.var
+	  && new_data->var->iter.var->ts.type == BT_INTEGER
+	  && new_data->var->iter.var->symtree->n.sym->attr.implied_index == 1
+	  && new_data->var->list
+	  && new_data->var->list->expr
+	  && new_data->var->list->expr->ts.type == BT_CHARACTER
+	  && new_data->var->list->expr->ref
+	  && new_data->var->list->expr->ref->type == REF_SUBSTRING)
+	{
+	  gfc_error ("Invalid substring in data-implied-do at %L in DATA "
+		     "statement", &new_data->var->list->expr->where);
+	  goto cleanup;
+	}
+
       m = top_val_list (new_data);
       if (m != MATCH_YES)
 	goto cleanup;
@@ -620,27 +635,35 @@
 {
   gfc_constructor_base array_head = NULL;
   gfc_expr *expr = NULL;
-  match m;
+  match m = MATCH_ERROR;
   locus where;
-  mpz_t repeat, size;
+  mpz_t repeat, cons_size, as_size;
   bool scalar;
   int cmp;
 
   gcc_assert (ts);
 
-  mpz_init_set_ui (repeat, 0);
-  mpz_init (size);
-  scalar = !as || !as->rank;
-
   /* We have already matched '/' - now look for a constant list, as with
      top_val_list from decl.c, but append the result to an array.  */
   if (gfc_match ("/") == MATCH_YES)
     {
       gfc_error ("Empty old style initializer list at %C");
-      goto cleanup;
+      return MATCH_ERROR;
     }
 
   where = gfc_current_locus;
+  scalar = !as || !as->rank;
+
+  if (!scalar && !spec_size (as, &as_size))
+    {
+      gfc_error ("Array in initializer list at %L must have an explicit shape",
+		 as->type == AS_EXPLICIT ? &as->upper[0]->where : &where);
+      /* Nothing to cleanup yet.  */
+      return MATCH_ERROR;
+    }
+
+  mpz_init_set_ui (repeat, 0);
+
   for (;;)
     {
       m = match_data_constant (&expr);
@@ -670,7 +693,10 @@
 
           m = match_data_constant (&expr);
           if (m == MATCH_NO)
-            gfc_error ("Expected data constant after repeat spec at %C");
+	    {
+	      m = MATCH_ERROR;
+	      gfc_error ("Expected data constant after repeat spec at %C");
+	    }
           if (m != MATCH_YES)
             goto cleanup;
         }
@@ -713,6 +739,9 @@
         goto syntax;
     }
 
+  /* If we break early from here out, we encountered an error.  */
+  m = MATCH_ERROR;
+
   /* Set up expr as an array constructor. */
   if (!scalar)
     {
@@ -723,16 +752,18 @@
       expr->rank = as->rank;
       expr->shape = gfc_get_shape (expr->rank);
 
-      /* Validate sizes. */
-      gcc_assert (gfc_array_size (expr, &size));
-      gcc_assert (spec_size (as, &repeat));
-      cmp = mpz_cmp (size, repeat);
+      /* Validate sizes.  We built expr ourselves, so cons_size will be
+	 constant (we fail above for non-constant expressions).
+	 We still need to verify that the sizes match.  */
+      gcc_assert (gfc_array_size (expr, &cons_size));
+      cmp = mpz_cmp (cons_size, as_size);
       if (cmp < 0)
-        gfc_error ("Not enough elements in array initializer at %C");
+	gfc_error ("Not enough elements in array initializer at %C");
       else if (cmp > 0)
-        gfc_error ("Too many elements in array initializer at %C");
+	gfc_error ("Too many elements in array initializer at %C");
+      mpz_clear (cons_size);
       if (cmp)
-        goto cleanup;
+	goto cleanup;
     }
 
   /* Make sure scalar types match. */
@@ -744,11 +775,11 @@
     expr->ts.u.cl->length_from_typespec = 1;
 
   *result = expr;
-  mpz_clear (size);
-  mpz_clear (repeat);
-  return MATCH_YES;
+  m = MATCH_YES;
+  goto done;
 
 syntax:
+  m = MATCH_ERROR;
   gfc_error ("Syntax error in old style initializer list at %C");
 
 cleanup:
@@ -756,9 +787,12 @@
     expr->value.constructor = NULL;
   gfc_free_expr (expr);
   gfc_constructor_free (array_head);
-  mpz_clear (size);
+
+done:
   mpz_clear (repeat);
-  return MATCH_ERROR;
+  if (!scalar)
+    mpz_clear (as_size);
+  return m;
 }
 
 
@@ -1115,14 +1149,12 @@
   if (sym->attr.proc == PROC_ST_FUNCTION)
     return rc;
 
-  if (sym->attr.module_procedure
-      && sym->attr.if_source == IFSRC_IFBODY)
+  if (sym->attr.module_procedure && sym->attr.if_source == IFSRC_IFBODY)
     {
       /* Create a partially populated interface symbol to carry the
 	 characteristics of the procedure and the result.  */
       sym->tlink = gfc_new_symbol (name, sym->ns);
-      gfc_add_type (sym->tlink, &(sym->ts),
-		    &gfc_current_locus);
+      gfc_add_type (sym->tlink, &(sym->ts), &gfc_current_locus);
       gfc_copy_attr (&sym->tlink->attr, &sym->attr, NULL);
       if (sym->attr.dimension)
 	sym->tlink->as = gfc_copy_array_spec (sym->as);
@@ -1152,11 +1184,22 @@
 	 accessible names.  */
       if (sym->attr.flavor != 0
 	  && sym->attr.proc != 0
-	  && (sym->attr.subroutine || sym->attr.function)
+	  && (sym->attr.subroutine || sym->attr.function || sym->attr.entry)
 	  && sym->attr.if_source != IFSRC_UNKNOWN)
 	gfc_error_now ("Procedure %qs at %C is already defined at %L",
 		       name, &sym->declared_at);
 
+      if (sym->attr.flavor != 0
+	  && sym->attr.entry && sym->attr.if_source != IFSRC_UNKNOWN)
+	gfc_error_now ("Procedure %qs at %C is already defined at %L",
+		       name, &sym->declared_at);
+
+      if (sym->attr.external && sym->attr.procedure
+	  && gfc_current_state () == COMP_CONTAINS)
+	gfc_error_now ("Contained procedure %qs at %C clashes with "
+			"procedure defined at %L",
+		       name, &sym->declared_at);
+
       /* Trap a procedure with a name the same as interface in the
 	 encompassing scope.  */
       if (sym->attr.generic != 0
@@ -1176,7 +1219,16 @@
 	  && sym->attr.access == 0
 	  && !module_fcn_entry)
 	gfc_error_now ("Procedure %qs at %C has an explicit interface "
-		       "and must not have attributes declared at %L",
+		       "from a previous declaration",  name);
+    }
+
+    if (sym && !sym->gfc_new
+	&& sym->attr.flavor != FL_UNKNOWN
+	&& sym->attr.referenced == 0 && sym->attr.subroutine == 1
+	&& gfc_state_stack->state == COMP_CONTAINS
+	&& gfc_state_stack->previous->state == COMP_SUBROUTINE)
+    {
+	gfc_error_now ("Procedure %qs at %C is already defined at %L",
 		       name, &sym->declared_at);
     }
 
@@ -1201,10 +1253,10 @@
   /* See if the procedure should be a module procedure.  */
 
   if (((sym->ns->proc_name != NULL
-		&& sym->ns->proc_name->attr.flavor == FL_MODULE
-		&& sym->attr.proc != PROC_MODULE)
-	    || (module_fcn_entry && sym->attr.proc != PROC_MODULE))
-	&& !gfc_add_procedure (&sym->attr, PROC_MODULE, sym->name, NULL))
+	&& sym->ns->proc_name->attr.flavor == FL_MODULE
+	&& sym->attr.proc != PROC_MODULE)
+       || (module_fcn_entry && sym->attr.proc != PROC_MODULE))
+      && !gfc_add_procedure (&sym->attr, PROC_MODULE, sym->name, NULL))
     rc = 2;
 
   return rc;
@@ -2183,7 +2235,10 @@
   /* At this point, we know for sure if the symbol is PARAMETER and can thus
      determine (and check) whether it can be implied-shape.  If it
      was parsed as assumed-size, change it because PARAMETERs can not
-     be assumed-size.  */
+     be assumed-size.
+
+     An explicit-shape-array cannot appear under several conditions.
+     That check is done here as well.  */
   if (as)
     {
       if (as->type == AS_IMPLIED_SHAPE && current_attr.flavor != FL_PARAMETER)
@@ -2205,6 +2260,50 @@
 	  m = MATCH_ERROR;
 	  goto cleanup;
 	}
+
+      /* F2018:C830 (R816) An explicit-shape-spec whose bounds are not
+	 constant expressions shall appear only in a subprogram, derived
+	 type definition, BLOCK construct, or interface body.  */
+      if (as->type == AS_EXPLICIT
+	  && gfc_current_state () != COMP_BLOCK
+	  && gfc_current_state () != COMP_DERIVED
+	  && gfc_current_state () != COMP_FUNCTION
+	  && gfc_current_state () != COMP_INTERFACE
+	  && gfc_current_state () != COMP_SUBROUTINE)
+	{
+	  gfc_expr *e;
+	  bool not_constant = false;
+
+	  for (int i = 0; i < as->rank; i++)
+	    {
+	      e = gfc_copy_expr (as->lower[i]);
+	      gfc_resolve_expr (e);
+	      gfc_simplify_expr (e, 0);
+	      if (e && (e->expr_type != EXPR_CONSTANT))
+		{
+		  not_constant = true;
+		  break;
+		}
+	      gfc_free_expr (e);
+
+	      e = gfc_copy_expr (as->upper[i]);
+	      gfc_resolve_expr (e);
+	      gfc_simplify_expr (e, 0);
+	      if (e && (e->expr_type != EXPR_CONSTANT))
+		{
+		  not_constant = true;
+		  break;
+		}
+	      gfc_free_expr (e);
+	    }
+
+	  if (not_constant)
+	    { 
+	      gfc_error ("Explicit shaped array with nonconstant bounds at %C");
+	      m = MATCH_ERROR;
+	      goto cleanup;
+	    }
+	}
     }
 
   char_len = NULL;
@@ -2918,7 +3017,38 @@
   if (seen_length == 0)
     cl->length = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);
   else
-    cl->length = len;
+    {
+      /* If gfortran ends up here, then len may be reducible to a constant.
+	 Try to do that here.  If it does not reduce, simply assign len to
+	 charlen.  A complication occurs with user-defined generic functions,
+	 which are not resolved.  Use a private namespace to deal with
+	 generic functions.  */
+
+      if (len && len->expr_type != EXPR_CONSTANT)
+	{
+	  gfc_namespace *old_ns;
+	  gfc_expr *e;
+
+	  old_ns = gfc_current_ns;
+	  gfc_current_ns = gfc_get_namespace (NULL, 0);
+
+	  e = gfc_copy_expr (len);
+	  gfc_reduce_init_expr (e);
+	  if (e->expr_type == EXPR_CONSTANT)
+	    {
+	      gfc_replace_expr (len, e);
+	      if (mpz_cmp_si (len->value.integer, 0) < 0)
+		mpz_set_ui (len->value.integer, 0);
+	    }
+	  else
+	    gfc_free_expr (e);
+
+	  gfc_free_namespace (gfc_current_ns);
+	  gfc_current_ns = old_ns;
+	}
+
+      cl->length = len;
+    }
 
   ts->u.cl = cl;
   ts->kind = kind == 0 ? gfc_default_character_kind : kind;
@@ -8935,8 +9065,12 @@
 
   if (!gensym->attr.generic && gensym->ts.type != BT_UNKNOWN)
     {
-      gfc_error ("Derived type name %qs at %C already has a basic type "
-		 "of %s", gensym->name, gfc_typename (&gensym->ts));
+      if (gensym->ts.u.derived)
+	gfc_error ("Derived type name %qs at %C already has a basic type "
+		   "of %s", gensym->name, gfc_typename (&gensym->ts));
+      else
+	gfc_error ("Derived type name %qs at %C already has a basic type",
+		   gensym->name);
       return MATCH_ERROR;
     }
 
diff -ruN gcc-7.3.0/gcc/fortran/expr.c gcc-7.3.0-msp430/gcc/fortran/expr.c
--- gcc-7.3.0/gcc/fortran/expr.c	2018-01-18 10:27:22.733408000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/expr.c	2019-06-25 02:27:21.133931189 -0700
@@ -2315,7 +2315,7 @@
 
 	/* Assumed character length will not reduce to a constant expression
 	   with LEN, as required by the standard.  */
-	if (i == 5 && not_restricted
+	if (i == 5 && not_restricted && ap->expr->symtree
 	    && ap->expr->symtree->n.sym->ts.type == BT_CHARACTER
 	    && (ap->expr->symtree->n.sym->ts.u.cl->length == NULL
 		|| ap->expr->symtree->n.sym->ts.deferred))
@@ -3288,6 +3288,8 @@
   /* Only DATA Statements come here.  */
   if (!conform)
     {
+      locus *where;
+
       /* Numeric can be converted to any other numeric. And Hollerith can be
 	 converted to any other type.  */
       if ((gfc_numeric_ts (&lvalue->ts) && gfc_numeric_ts (&rvalue->ts))
@@ -3297,8 +3299,9 @@
       if (lvalue->ts.type == BT_LOGICAL && rvalue->ts.type == BT_LOGICAL)
 	return true;
 
+      where = lvalue->where.lb ? &lvalue->where : &rvalue->where;
       gfc_error ("Incompatible types in DATA statement at %L; attempted "
-		 "conversion of %s to %s", &lvalue->where,
+		 "conversion of %s to %s", where,
 		 gfc_typename (&rvalue->ts), gfc_typename (&lvalue->ts));
 
       return false;
@@ -4274,21 +4277,60 @@
   return init;
 }
 
+static bool
+class_allocatable (gfc_component *comp)
+{
+  return comp->ts.type == BT_CLASS && CLASS_DATA (comp)
+    && CLASS_DATA (comp)->attr.allocatable;
+}
+
+static bool
+class_pointer (gfc_component *comp)
+{
+  return comp->ts.type == BT_CLASS && CLASS_DATA (comp)
+    && CLASS_DATA (comp)->attr.pointer;
+}
+
+static bool
+comp_allocatable (gfc_component *comp)
+{
+  return comp->attr.allocatable || class_allocatable (comp);
+}
+
+static bool
+comp_pointer (gfc_component *comp)
+{
+  return comp->attr.pointer
+    || comp->attr.pointer
+    || comp->attr.proc_pointer
+    || comp->attr.class_pointer
+    || class_pointer (comp);
+}
+
 /* Fetch or generate an initializer for the given component.
    Only generate an initializer if generate is true.  */
 
 static gfc_expr *
-component_initializer (gfc_typespec *ts, gfc_component *c, bool generate)
+component_initializer (gfc_component *c, bool generate)
 {
   gfc_expr *init = NULL;
 
+  /* Allocatable components always get EXPR_NULL.
+     Pointer components are only initialized when generating, and only if they
+     do not already have an initializer.  */
+  if (comp_allocatable (c) || (generate && comp_pointer (c) && !c->initializer))
+    {
+      init = gfc_get_null_expr (&c->loc);
+      init->ts = c->ts;
+      return init;
+    }
+
   /* See if we can find the initializer immediately.  */
-  if (c->initializer || !generate
-      || (ts->type == BT_CLASS && !c->attr.allocatable))
+  if (c->initializer || !generate)
     return c->initializer;
 
   /* Recursively handle derived type components.  */
-  if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)
+  else if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)
     init = gfc_generate_initializer (&c->ts, true);
 
   else if (c->ts.type == BT_UNION && c->ts.u.derived->components)
@@ -4347,6 +4389,32 @@
   return gfc_generate_initializer (ts, false);
 }
 
+/* Generate an initializer expression for an iso_c_binding type
+   such as c_[fun]ptr. The appropriate initializer is c_null_[fun]ptr.  */
+
+static gfc_expr *
+generate_isocbinding_initializer (gfc_symbol *derived)
+{
+  /* The initializers have already been built into the c_null_[fun]ptr symbols
+     from gen_special_c_interop_ptr.  */
+  gfc_symtree *npsym = NULL;
+  if (0 == strcmp (derived->name, "c_ptr"))
+    gfc_find_sym_tree ("c_null_ptr", gfc_current_ns, true, &npsym);
+  else if (0 == strcmp (derived->name, "c_funptr"))
+    gfc_find_sym_tree ("c_null_funptr", gfc_current_ns, true, &npsym);
+  else
+    gfc_internal_error ("generate_isocbinding_initializer(): bad iso_c_binding"
+			" type, expected %<c_ptr%> or %<c_funptr%>");
+  if (npsym)
+    {
+      gfc_expr *init = gfc_copy_expr (npsym->n.sym->value);
+      init->symtree = npsym;
+      init->ts.is_iso_c = true;
+      return init;
+    }
+
+  return NULL;
+}
 
 /* Get or generate an expression for a default initializer of a derived type.
    If -finit-derived is specified, generate default initialization expressions
@@ -4357,8 +4425,12 @@
 {
   gfc_expr *init, *tmp;
   gfc_component *comp;
+
   generate = flag_init_derived && generate;
 
+  if (ts->u.derived->ts.is_iso_c && generate)
+    return generate_isocbinding_initializer (ts->u.derived);
+
   /* See if we have a default initializer in this, but not in nested
      types (otherwise we could use gfc_has_default_initializer()).
      We don't need to check if we are going to generate them.  */
@@ -4366,9 +4438,7 @@
   if (!generate)
     {
       for (; comp; comp = comp->next)
-        if (comp->initializer || comp->attr.allocatable
-            || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)
-                && CLASS_DATA (comp)->attr.allocatable))
+	if (comp->initializer || comp_allocatable (comp))
           break;
     }
 
@@ -4384,7 +4454,7 @@
       gfc_constructor *ctor = gfc_constructor_get();
 
       /* Fetch or generate an initializer for the component.  */
-      tmp = component_initializer (ts, comp, generate);
+      tmp = component_initializer (comp, generate);
       if (tmp)
 	{
 	  /* Save the component ref for STRUCTUREs and UNIONs.  */
@@ -4394,8 +4464,7 @@
 
           /* If the initializer was not generated, we need a copy.  */
           ctor->expr = comp->initializer ? gfc_copy_expr (tmp) : tmp;
-	  if ((comp->ts.type != tmp->ts.type
-	       || comp->ts.kind != tmp->ts.kind)
+	  if ((comp->ts.type != tmp->ts.type || comp->ts.kind != tmp->ts.kind)
 	      && !comp->attr.pointer && !comp->attr.proc_pointer)
 	    {
 	      bool val;
@@ -4405,15 +4474,6 @@
 	    }
 	}
 
-      if (comp->attr.allocatable
-	  || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)->attr.allocatable))
-	{
-	  ctor->expr = gfc_get_expr ();
-	  ctor->expr->expr_type = EXPR_NULL;
-	  ctor->expr->where = init->where;
-	  ctor->expr->ts = comp->ts;
-	}
-
       gfc_constructor_append (&init->value.constructor, ctor);
     }
 
@@ -4762,14 +4822,15 @@
 /* Determine if an expression is a function with an allocatable class array
    result.  */
 bool
-gfc_is_alloc_class_array_function (gfc_expr *expr)
+gfc_is_class_array_function (gfc_expr *expr)
 {
   if (expr->expr_type == EXPR_FUNCTION
       && expr->value.function.esym
       && expr->value.function.esym->result
       && expr->value.function.esym->result->ts.type == BT_CLASS
       && CLASS_DATA (expr->value.function.esym->result)->attr.dimension
-      && CLASS_DATA (expr->value.function.esym->result)->attr.allocatable)
+      && (CLASS_DATA (expr->value.function.esym->result)->attr.allocatable
+	  || CLASS_DATA (expr->value.function.esym->result)->attr.pointer))
     return true;
 
   return false;
diff -ruN gcc-7.3.0/gcc/fortran/frontend-passes.c gcc-7.3.0-msp430/gcc/fortran/frontend-passes.c
--- gcc-7.3.0/gcc/fortran/frontend-passes.c	2017-06-02 10:44:19.180575000 -0700
+++ gcc-7.3.0-msp430/gcc/fortran/frontend-passes.c	2019-06-25 02:27:21.133931189 -0700
@@ -48,6 +48,8 @@
 				  locus *, gfc_namespace *,
 				  char *vname=NULL);
 
+static bool is_fe_temp (gfc_expr *e);
+
 #ifdef CHECKING_P
 static void check_locus (gfc_namespace *);
 #endif
@@ -135,6 +137,10 @@
   check_locus (ns);
 #endif
 
+  gfc_get_errors (&w, &e);
+  if (e > 0)
+   return;
+
   if (flag_frontend_optimize)
     {
       optimize_namespace (ns);
@@ -145,10 +151,6 @@
       expr_array.release ();
     }
 
-  gfc_get_errors (&w, &e);
-  if (e > 0)
-   return;
-
   if (flag_realloc_lhs)
     realloc_strings (ns);
 }
@@ -231,22 +233,29 @@
       || !expr1->ts.deferred)
     return 0;
 
-  expr2 = gfc_discard_nops (co->expr2);
-  if (expr2->expr_type != EXPR_VARIABLE)
+  if (is_fe_temp (expr1))
     return 0;
 
-  found_substr = false;
-  for (ref = expr2->ref; ref; ref = ref->next)
+  expr2 = gfc_discard_nops (co->expr2);
+
+  if (expr2->expr_type == EXPR_VARIABLE)
     {
-      if (ref->type == REF_SUBSTRING)
+      found_substr = false;
+      for (ref = expr2->ref; ref; ref = ref->next)
 	{
-	  found_substr = true;
-	  break;
+	  if (ref->type == REF_SUBSTRING)
+	    {
+	      found_substr = true;
+	      break;
+	    }
 	}
+      if (!found_substr)
+	return 0;
     }
-  if (!found_substr)
+  else if (expr2->expr_type != EXPR_OP
+	   || expr2->value.op.op != INTRINSIC_CONCAT)
     return 0;
-
+  
   if (!gfc_check_dependency (expr1, expr2, true))
     return 0;
 
@@ -619,7 +628,8 @@
 
   /* Return length of char symbol, if constant.  */
 
-  if (e->symtree->n.sym->ts.u.cl && e->symtree->n.sym->ts.u.cl->length
+  if (e->symtree && e->symtree->n.sym->ts.u.cl
+      && e->symtree->n.sym->ts.u.cl->length
       && e->symtree->n.sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)
     return gfc_copy_expr (e->symtree->n.sym->ts.u.cl->length);
 
@@ -2750,10 +2760,26 @@
 			 is the lbound of a full ref.  */
 		      int j;
 		      gfc_array_ref *ar;
+		      int to;
 
 		      ar = &ref->u.ar;
-		      ar->type = AR_FULL;
-		      for (j = 0; j < ar->dimen; j++)
+
+		      /* For assumed size, we need to keep around the final
+			 reference in order not to get an error on resolution
+			 below, and we cannot use AR_FULL.  */
+			 
+		      if (ar->as->type == AS_ASSUMED_SIZE)
+			{
+			  ar->type = AR_SECTION;
+			  to = ar->dimen - 1;
+			}
+		      else
+			{
+			  to = ar->dimen;
+			  ar->type = AR_FULL;
+			}
+
+		      for (j = 0; j < to; j++)
 			{
 			  gfc_free_expr (ar->start[j]);
 			  ar->start[j] = NULL;
diff -ruN gcc-7.3.0/gcc/fortran/gfortran.h gcc-7.3.0-msp430/gcc/fortran/gfortran.h
--- gcc-7.3.0/gcc/fortran/gfortran.h	2017-03-05 03:35:47.879152000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/gfortran.h	2019-06-25 02:27:21.133931189 -0700
@@ -863,7 +863,7 @@
   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,
 	   private_comp:1, zero_comp:1, coarray_comp:1, lock_comp:1,
 	   event_comp:1, defined_assign_comp:1, unlimited_polymorphic:1,
-	   has_dtio_procs:1;
+	   has_dtio_procs:1, caf_token:1;
 
   /* This is a temporary selector for SELECT TYPE or an associate
      variable for SELECT_TYPE or ASSOCIATE.  */
@@ -2856,6 +2856,8 @@
 extern int gfc_numeric_storage_size;
 extern int gfc_character_storage_size;
 
+#define gfc_integer_4_kind 4
+
 /* symbol.c */
 void gfc_clear_new_implicit (void);
 bool gfc_add_new_implicit_range (int, int);
@@ -3145,7 +3147,7 @@
 gfc_component * gfc_get_proc_ptr_comp (gfc_expr *);
 bool gfc_is_proc_ptr_comp (gfc_expr *);
 bool gfc_is_alloc_class_scalar_function (gfc_expr *);
-bool gfc_is_alloc_class_array_function (gfc_expr *);
+bool gfc_is_class_array_function (gfc_expr *);
 
 bool gfc_ref_this_image (gfc_ref *ref);
 bool gfc_is_coindexed (gfc_expr *);
diff -ruN gcc-7.3.0/gcc/fortran/interface.c gcc-7.3.0-msp430/gcc/fortran/interface.c
--- gcc-7.3.0/gcc/fortran/interface.c	2018-01-13 10:58:56.305178000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/interface.c	2019-06-25 02:27:21.137931160 -0700
@@ -1263,7 +1263,7 @@
 {
   gfc_array_spec *as = NULL;
 
-  if (sym->ts.type == BT_CLASS && CLASS_DATA (sym) && CLASS_DATA (sym)->as)
+  if (sym->ts.type == BT_CLASS && CLASS_DATA (sym))
     as = CLASS_DATA (sym)->as;
   else
     as = sym->as;
@@ -2791,7 +2791,8 @@
 
 static bool
 compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,
-	 	       int ranks_must_agree, int is_elemental, locus *where)
+	 	       int ranks_must_agree, int is_elemental,
+		       bool in_statement_function, locus *where)
 {
   gfc_actual_arglist **new_arg, *a, *actual;
   gfc_formal_arglist *f;
@@ -2820,6 +2821,13 @@
 
   for (a = actual; a; a = a->next, f = f->next)
     {
+      if (a->name != NULL && in_statement_function)
+	{
+	  gfc_error ("Keyword argument %qs at %L is invalid in "
+		     "a statement function", a->name, &a->expr->where);
+	  return false;
+	}
+
       /* Look for keywords but ignore g77 extensions like %VAL.  */
       if (a->name != NULL && a->name[0] != '%')
 	{
@@ -3143,8 +3151,9 @@
 	}
 
       /* Check intent = OUT/INOUT for definable actual argument.  */
-      if ((f->sym->attr.intent == INTENT_OUT
-	  || f->sym->attr.intent == INTENT_INOUT))
+      if (!in_statement_function
+	  && (f->sym->attr.intent == INTENT_OUT
+	      || f->sym->attr.intent == INTENT_INOUT))
 	{
 	  const char* context = (where
 				 ? _("actual argument to INTENT = OUT/INOUT")
@@ -3249,7 +3258,8 @@
 		       "at %L", where);
 	  return false;
 	}
-      if (!f->sym->attr.optional)
+      if (!f->sym->attr.optional
+	  || (in_statement_function && f->sym->attr.optional))
 	{
 	  if (where)
 	    gfc_error ("Missing actual argument for argument %qs at %L",
@@ -3535,6 +3545,7 @@
 bool
 gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)
 {
+  gfc_actual_arglist *a;
   gfc_formal_arglist *dummy_args;
 
   /* Warn about calls with an implicit interface.  Special case
@@ -3561,8 +3572,6 @@
 
   if (sym->attr.if_source == IFSRC_UNKNOWN)
     {
-      gfc_actual_arglist *a;
-
       if (sym->attr.pointer)
 	{
 	  gfc_error ("The pointer object %qs at %L must have an explicit "
@@ -3654,9 +3663,12 @@
 
   dummy_args = gfc_sym_get_dummy_args (sym);
 
-  if (!compare_actual_formal (ap, dummy_args, 0, sym->attr.elemental, where))
+  /* For a statement function, check that types and type parameters of actual
+     arguments and dummy arguments match.  */
+  if (!compare_actual_formal (ap, dummy_args, 0, sym->attr.elemental,
+			      sym->attr.proc == PROC_ST_FUNCTION, where))
     return false;
-
+ 
   if (!check_intents (dummy_args, *ap))
     return false;
 
@@ -3703,7 +3715,7 @@
     }
 
   if (!compare_actual_formal (ap, comp->ts.interface->formal, 0,
-			      comp->attr.elemental, where))
+			      comp->attr.elemental, false, where))
     return;
 
   check_intents (comp->ts.interface->formal, *ap);
@@ -3728,7 +3740,7 @@
   dummy_args = gfc_sym_get_dummy_args (sym);
 
   r = !sym->attr.elemental;
-  if (compare_actual_formal (args, dummy_args, r, !r, NULL))
+  if (compare_actual_formal (args, dummy_args, r, !r, false, NULL))
     {
       check_intents (dummy_args, *args);
       if (warn_aliasing)
diff -ruN gcc-7.3.0/gcc/fortran/match.c gcc-7.3.0-msp430/gcc/fortran/match.c
--- gcc-7.3.0/gcc/fortran/match.c	2017-12-28 12:43:38.824131000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/match.c	2019-06-25 02:27:21.137931160 -0700
@@ -2001,12 +2001,17 @@
 {
   match m;
   locus old_locus;
-  char name[GFC_MAX_SYMBOL_LEN + 1];
+  char c, name[GFC_MAX_SYMBOL_LEN + 1];
 
   gfc_clear_ts (ts);
   gfc_gobble_whitespace ();
   old_locus = gfc_current_locus;
 
+  /* If c isn't [a-z], then return immediately.  */
+  c = gfc_peek_ascii_char ();
+  if (!ISALPHA(c))
+    return MATCH_NO;
+
   if (match_derived_type_spec (ts) == MATCH_YES)
     {
       /* Enforce F03:C401.  */
@@ -2045,6 +2050,8 @@
       ts->type = BT_CHARACTER;
 
       m = gfc_match_char_spec (ts);
+      if (ts->u.cl && ts->u.cl->length)
+	gfc_resolve_expr (ts->u.cl->length);
 
       if (m == MATCH_NO)
 	m = MATCH_YES;
@@ -2056,7 +2063,7 @@
      or list item in a type-list of an OpenMP reduction clause.  Need to
      differentiate REAL([KIND]=scalar-int-initialization-expr) from
      REAL(A,[KIND]) and REAL(KIND,A).  Logically, when this code was
-     written the use of LOGICAL as a type-spec or intrinsic subprogram 
+     written the use of LOGICAL as a type-spec or intrinsic subprogram
      was overlooked.  */
 
   m = gfc_match (" %n", name);
@@ -4404,8 +4411,8 @@
 	   && (tail->expr->ref->type == REF_COMPONENT
 	       || tail->expr->ref->type == REF_ARRAY));
       if (sym && sym->ts.type == BT_CLASS)
-	b2 = !(CLASS_DATA (sym)->attr.allocatable
-	       || CLASS_DATA (sym)->attr.class_pointer);
+	b2 = !(CLASS_DATA (sym) && (CLASS_DATA (sym)->attr.allocatable
+	       || CLASS_DATA (sym)->attr.class_pointer));
       else
 	b2 = sym && !(sym->attr.allocatable || sym->attr.pointer
 		      || sym->attr.proc_pointer);
@@ -5707,6 +5714,7 @@
 {
   gfc_ref *ref;
   gfc_symbol *assoc_sym;
+  int rank = 0;
 
   assoc_sym = associate->symtree->n.sym;
 
@@ -5743,14 +5751,28 @@
 	selector->rank = ref->u.ar.dimen;
       else
 	selector->rank = 0;
+
+      rank = selector->rank;
     }
 
-  if (selector->rank)
+  if (rank)
     {
-      assoc_sym->attr.dimension = 1;
-      assoc_sym->as = gfc_get_array_spec ();
-      assoc_sym->as->rank = selector->rank;
-      assoc_sym->as->type = AS_DEFERRED;
+      for (int i = 0; i < ref->u.ar.dimen + ref->u.ar.codimen; i++)
+	if (ref->u.ar.dimen_type[i] == DIMEN_ELEMENT
+	    || (ref->u.ar.dimen_type[i] == DIMEN_UNKNOWN
+		&& ref->u.ar.end[i] == NULL
+		&& ref->u.ar.stride[i] == NULL))
+	  rank--;
+
+      if (rank)
+	{
+	  assoc_sym->attr.dimension = 1;
+	  assoc_sym->as = gfc_get_array_spec ();
+	  assoc_sym->as->rank = rank;
+	  assoc_sym->as->type = AS_DEFERRED;
+	}
+      else
+	assoc_sym->as = NULL;
     }
   else
     assoc_sym->as = NULL;
diff -ruN gcc-7.3.0/gcc/fortran/module.c gcc-7.3.0-msp430/gcc/fortran/module.c
--- gcc-7.3.0/gcc/fortran/module.c	2017-05-04 11:45:50.350578000 -0700
+++ gcc-7.3.0-msp430/gcc/fortran/module.c	2019-06-25 02:27:21.137931160 -0700
@@ -2791,6 +2791,8 @@
   if (c->attr.proc_pointer)
     mio_typebound_proc (&c->tb);
 
+  c->loc = gfc_current_locus;
+
   mio_rparen ();
 }
 
@@ -6063,8 +6065,10 @@
     gfc_fatal_error ("Can't open module file %qs for writing at %C: %s",
 		     filename_tmp, xstrerror (errno));
 
+  /* Use lbasename to ensure module files are reproducible regardless
+     of the build path (see the reproducible builds project).  */
   gzprintf (module_fp, "GFORTRAN module version '%s' created from %s\n",
-	    MOD_VERSION, gfc_source_file);
+	    MOD_VERSION, lbasename (gfc_source_file));
 
   /* Write the module itself.  */
   iomode = IO_OUTPUT;
diff -ruN gcc-7.3.0/gcc/fortran/openmp.c gcc-7.3.0-msp430/gcc/fortran/openmp.c
--- gcc-7.3.0/gcc/fortran/openmp.c	2017-06-02 00:10:10.712770000 -0700
+++ gcc-7.3.0-msp430/gcc/fortran/openmp.c	2019-06-25 02:27:21.137931160 -0700
@@ -1312,23 +1312,21 @@
 	      else if (gfc_match_omp_variable_list (" val (",
 						    &c->lists[OMP_LIST_LINEAR],
 						    false, NULL, &head)
-		  == MATCH_YES)
+		       == MATCH_YES)
 		linear_op = OMP_LINEAR_VAL;
 	      else if (gfc_match_omp_variable_list (" uval (",
 						    &c->lists[OMP_LIST_LINEAR],
 						    false, NULL, &head)
-		  == MATCH_YES)
+		       == MATCH_YES)
 		linear_op = OMP_LINEAR_UVAL;
 	      else if (gfc_match_omp_variable_list ("",
 						    &c->lists[OMP_LIST_LINEAR],
 						    false, &end_colon, &head)
-		  == MATCH_YES)
+		       == MATCH_YES)
 		linear_op = OMP_LINEAR_DEFAULT;
 	      else
 		{
-		  gfc_free_omp_namelist (*head);
 		  gfc_current_locus = old_loc;
-		  *head = NULL;
 		  break;
 		}
 	      if (linear_op != OMP_LINEAR_DEFAULT)
@@ -5577,8 +5575,6 @@
 			     "iteration space at %L", name, &do_code->loc);
 		  break;
 		}
-	      if (j < i)
-		break;
 	      do_code2 = do_code2->block->next;
 	    }
 	}
@@ -5742,12 +5738,10 @@
 		  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->end)
 		  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->step))
 		{
-		  gfc_error ("!$ACC LOOP %s loops don't form rectangular iteration space at %L",
-			     clause, &do_code->loc);
+		  gfc_error ("!$ACC LOOP %s loops don't form rectangular "
+			     "iteration space at %L", clause, &do_code->loc);
 		  break;
 		}
-	      if (j < i)
-		break;
 	      do_code2 = do_code2->block->next;
 	    }
 	}
diff -ruN gcc-7.3.0/gcc/fortran/primary.c gcc-7.3.0-msp430/gcc/fortran/primary.c
--- gcc-7.3.0/gcc/fortran/primary.c	2017-10-16 12:44:04.299991000 -0700
+++ gcc-7.3.0-msp430/gcc/fortran/primary.c	2019-06-25 02:27:21.137931160 -0700
@@ -1247,8 +1247,22 @@
 
   if (sym->attr.flavor != FL_PARAMETER)
     {
-      gfc_error ("Expected PARAMETER symbol in complex constant at %C");
-      return MATCH_ERROR;
+      /* Give the matcher for implied do-loops a chance to run.  This yields
+	 a much saner error message for "write(*,*) (i, i=1, 6" where the 
+	 right parenthesis is missing.  */
+      char c;
+      gfc_gobble_whitespace ();
+      c = gfc_peek_ascii_char ();
+      if (c == '=' || c == ',')
+	{
+	  m = MATCH_NO;
+	}
+      else
+	{
+	  gfc_error ("Expected PARAMETER symbol in complex constant at %C");
+	  m = MATCH_ERROR;
+	}
+      return m;
     }
 
   if (!sym->value)
diff -ruN gcc-7.3.0/gcc/fortran/resolve.c gcc-7.3.0-msp430/gcc/fortran/resolve.c
--- gcc-7.3.0/gcc/fortran/resolve.c	2018-01-10 15:41:48.992167000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/resolve.c	2019-06-25 02:27:21.137931160 -0700
@@ -512,8 +512,11 @@
 	{
 	  if (sym->as != NULL)
 	    {
-	      gfc_error ("Argument %qs of statement function at %L must "
-			 "be scalar", sym->name, &sym->declared_at);
+	      /* F03:C1263 (R1238) The function-name and each dummy-arg-name
+		 shall be specified, explicitly or implicitly, to be scalar.  */
+	      gfc_error ("Argument '%s' of statement function '%s' at %L "
+			 "must be scalar", sym->name, proc->name,
+			 &proc->declared_at);
 	      continue;
 	    }
 
@@ -2903,8 +2906,8 @@
 
   /* If SYM has references to outer arrays, so has the procedure calling
      SYM.  If SYM is a procedure pointer, we can assume the worst.  */
-  if (sym->attr.array_outer_dependency
-      || sym->attr.proc_pointer)
+  if ((sym->attr.array_outer_dependency || sym->attr.proc_pointer)
+      && gfc_current_ns->proc_name)
     gfc_current_ns->proc_name->attr.array_outer_dependency = 1;
 }
 
@@ -3682,7 +3685,13 @@
 	  break;
 	}
 
-      sprintf (msg,
+      if (op1->ts.type == BT_DERIVED || op2->ts.type == BT_DERIVED)
+	sprintf (msg,
+	       _("Unexpected derived-type entities in binary intrinsic "
+		 "numeric operator %%<%s%%> at %%L"),
+	       gfc_op2string (e->value.op.op));
+      else
+      	sprintf (msg,
 	       _("Operands of binary numeric operator %%<%s%%> at %%L are %s/%s"),
 	       gfc_op2string (e->value.op.op), gfc_typename (&op1->ts),
 	       gfc_typename (&op2->ts));
@@ -7551,12 +7560,17 @@
       gfc_check_vardef_context (errmsg, false, false, false,
 				_("ERRMSG variable"));
 
+      /* F18:R928  alloc-opt             is ERRMSG = errmsg-variable
+	 F18:R930  errmsg-variable       is scalar-default-char-variable
+	 F18:R906  default-char-variable is variable
+	 F18:C906  default-char-variable shall be default character.  */
       if ((errmsg->ts.type != BT_CHARACTER
 	   && !(errmsg->ref
 		&& (errmsg->ref->type == REF_ARRAY
 		    || errmsg->ref->type == REF_COMPONENT)))
-	  || errmsg->rank > 0 )
-	gfc_error ("Errmsg-variable at %L must be a scalar CHARACTER "
+	  || errmsg->rank > 0
+	  || errmsg->ts.kind != gfc_default_character_kind)
+	gfc_error ("ERRMSG variable at %L shall be a scalar default CHARACTER "
 		   "variable", &errmsg->where);
 
       for (p = code->ext.alloc.list; p; p = p->next)
@@ -8495,7 +8509,7 @@
   gfc_expr *loc_call;
   loc_call = gfc_get_expr ();
   loc_call->expr_type = EXPR_FUNCTION;
-  gfc_get_sym_tree ("loc", gfc_current_ns, &loc_call->symtree, false);
+  gfc_get_sym_tree ("_loc", gfc_current_ns, &loc_call->symtree, false);
   loc_call->symtree->n.sym->attr.flavor = FL_PROCEDURE;
   loc_call->symtree->n.sym->attr.intrinsic = 1;
   loc_call->symtree->n.sym->result = loc_call->symtree->n.sym;
@@ -8548,6 +8562,9 @@
 	code->expr1->symtree->n.sym->ts = code->expr2->ts;
       selector_type = CLASS_DATA (code->expr2)->ts.u.derived;
 
+      if (code->expr2->rank && CLASS_DATA (code->expr1)->as)
+	CLASS_DATA (code->expr1)->as->rank = code->expr2->rank;
+
       /* F2008: C803 The selector expression must not be coindexed.  */
       if (gfc_is_coindexed (code->expr2))
 	{
@@ -8742,7 +8759,7 @@
 	    {
 	      vtab = gfc_find_derived_vtab (c->ts.u.derived);
 	      gcc_assert (vtab);
-	      c->high = gfc_get_int_expr (gfc_default_integer_kind, NULL,
+	      c->high = gfc_get_int_expr (gfc_integer_4_kind, NULL,
 					  c->ts.u.derived->hash_value);
 	    }
 	  else
@@ -8751,6 +8768,13 @@
 	      gcc_assert (vtab && CLASS_DATA (vtab)->initializer);
 	      e = CLASS_DATA (vtab)->initializer;
 	      c->high = gfc_copy_expr (e);
+	      if (c->high->ts.kind != gfc_integer_4_kind)
+		{
+		  gfc_typespec ts;
+		  ts.kind = gfc_integer_4_kind;
+		  ts.type = BT_INTEGER;
+		  gfc_convert_type_warn (c->high, &ts, 2, 0);
+		}
 	    }
 
 	  e = gfc_lval_expr_from_sym (vtab);
@@ -8996,19 +9020,9 @@
       else
 	derived = ts->u.derived->components->ts.u.derived;
 
-      if (dt->format_expr)
-	{
-	  char *fmt;
-	  fmt = gfc_widechar_to_char (dt->format_expr->value.character.string,
-				      -1);
-	  if (strtok (fmt, "DT") != NULL)
-	    formatted = true;
-	}
-      else if (dt->format_label == &format_asterisk)
-	{
-	  /* List directed io must call the formatted DTIO procedure.  */
-	  formatted = true;
-	}
+      /* Determine when to use the formatted DTIO procedure.  */
+      if (dt && (dt->format_expr || dt->format_label))
+	formatted = true;
 
       write = dt->dt_io_kind->value.iokind == M_WRITE
 	      || dt->dt_io_kind->value.iokind == M_PRINT;
@@ -9296,6 +9310,7 @@
     }
 
   /* Check STAT.  */
+  gfc_resolve_expr (code->expr2);
   if (code->expr2
       && (code->expr2->ts.type != BT_INTEGER || code->expr2->rank != 0
 	  || code->expr2->expr_type != EXPR_VARIABLE))
@@ -9303,6 +9318,7 @@
 	       &code->expr2->where);
 
   /* Check ERRMSG.  */
+  gfc_resolve_expr (code->expr3);
   if (code->expr3
       && (code->expr3->ts.type != BT_CHARACTER || code->expr3->rank != 0
 	  || code->expr3->expr_type != EXPR_VARIABLE))
@@ -10135,6 +10151,11 @@
       && rhs->expr_type != EXPR_ARRAY)
     gfc_add_data_component (rhs);
 
+  /* Make sure there is a vtable and, in particular, a _copy for the
+     rhs type.  */
+  if (UNLIMITED_POLY (lhs) && lhs->rank && rhs->ts.type != BT_CLASS)
+    gfc_find_vtab (&rhs->ts);
+
   bool caf_convert_to_send = flag_coarray == GFC_FCOARRAY_LIB
       && (lhs_coindexed
 	  || (code->expr2->expr_type == EXPR_FUNCTION
@@ -10273,6 +10294,8 @@
   tmp->n.sym->attr.function = 0;
   tmp->n.sym->attr.result = 0;
   tmp->n.sym->attr.flavor = FL_VARIABLE;
+  tmp->n.sym->attr.dummy = 0;
+  tmp->n.sym->attr.intent = INTENT_UNKNOWN;
 
   if (as)
     {
@@ -12225,6 +12248,19 @@
 	}
     }
 
+  /* F2018, C15100: "The result of an elemental function shall be scalar,
+     and shall not have the POINTER or ALLOCATABLE attribute."  The scalar
+     pointer is tested and caught elsewhere.  */
+  if (sym->attr.elemental && sym->result
+      && (sym->result->attr.allocatable || sym->result->attr.pointer))
+    {
+      gfc_error ("Function result variable %qs at %L of elemental "
+		 "function %qs shall not have an ALLOCATABLE or POINTER "
+		 "attribute", sym->result->name,
+		 &sym->result->declared_at, sym->name);
+      return false;
+    }
+
   if (sym->attr.is_bind_c && sym->attr.is_c_interop != 1)
     {
       gfc_formal_arglist *curr_arg;
@@ -12250,7 +12286,7 @@
       while (curr_arg != NULL)
         {
           /* Skip implicitly typed dummy args here.  */
-	  if (curr_arg->sym->attr.implicit_type == 0)
+	  if (curr_arg->sym && curr_arg->sym->attr.implicit_type == 0)
 	    if (!gfc_verify_c_interop_param (curr_arg->sym))
 	      /* If something is found to fail, record the fact so we
 		 can mark the symbol for the procedure as not being
@@ -13799,6 +13835,31 @@
   if (!success)
     return false;
 
+  /* Now add the caf token field, where needed.  */
+  if (flag_coarray != GFC_FCOARRAY_NONE
+      && !sym->attr.is_class && !sym->attr.vtype)
+    {
+      for (c = sym->components; c; c = c->next)
+	if (!c->attr.dimension && !c->attr.codimension
+	    && (c->attr.allocatable || c->attr.pointer))
+	  {
+	    char name[GFC_MAX_SYMBOL_LEN+9];
+	    gfc_component *token;
+	    sprintf (name, "_caf_%s", c->name);
+	    token = gfc_find_component (sym, name, true, true, NULL);
+	    if (token == NULL)
+	      {
+		if (!gfc_add_component (sym, name, &token))
+		  return false;
+		token->ts.type = BT_VOID;
+		token->ts.kind = gfc_default_integer_kind;
+		token->attr.access = ACCESS_PRIVATE;
+		token->attr.artificial = 1;
+		token->attr.caf_token = 1;
+	      }
+	  }
+    }
+
   check_defined_assignments (sym);
 
   if (!sym->attr.defined_assign_comp && super_type)
@@ -15827,7 +15888,7 @@
 
 static bool
 flag_fn_result_spec (gfc_expr *expr,
-                     gfc_symbol *sym ATTRIBUTE_UNUSED,
+                     gfc_symbol *sym,
                      int *f ATTRIBUTE_UNUSED)
 {
   gfc_namespace *ns;
@@ -15840,6 +15901,13 @@
 	if (!ns->parent)
 	  break;
 
+      if (sym == s)
+	{
+	  gfc_error ("Self reference in character length expression "
+		     "for %qs at %L", sym->name, &expr->where);
+	  return true;
+	}
+
       if (!s->fn_result_spec
 	  && s->attr.flavor == FL_PARAMETER)
 	{
@@ -15922,7 +15990,7 @@
       }
 
   if (sym->ts.type == BT_CHARACTER)
-    gfc_traverse_expr (sym->ts.u.cl->length, NULL, flag_fn_result_spec, 0);
+    gfc_traverse_expr (sym->ts.u.cl->length, sym, flag_fn_result_spec, 0);
 }
 
 
diff -ruN gcc-7.3.0/gcc/fortran/simplify.c gcc-7.3.0-msp430/gcc/fortran/simplify.c
--- gcc-7.3.0/gcc/fortran/simplify.c	2018-01-20 12:45:50.331436000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/simplify.c	2019-06-25 02:27:21.137931160 -0700
@@ -25,6 +25,7 @@
 #include "gfortran.h"
 #include "arith.h"
 #include "intrinsic.h"
+#include "match.h"
 #include "target-memory.h"
 #include "constructor.h"
 #include "version.h"	/* For version_string.  */
@@ -4641,43 +4642,48 @@
   gfc_expr *result;
   int kind;
 
-  if (a->expr_type != EXPR_CONSTANT || p->expr_type != EXPR_CONSTANT)
+  /* First check p.  */
+  if (p->expr_type != EXPR_CONSTANT)
     return NULL;
 
-  kind = a->ts.kind > p->ts.kind ? a->ts.kind : p->ts.kind;
-  result = gfc_get_constant_expr (a->ts.type, kind, &a->where);
-
-  switch (a->ts.type)
+  /* p shall not be 0.  */
+  switch (p->ts.type)
     {
       case BT_INTEGER:
 	if (mpz_cmp_ui (p->value.integer, 0) == 0)
 	  {
-	    /* Result is processor-dependent.  */
-	    gfc_error ("Second argument MOD at %L is zero", &a->where);
-	    gfc_free_expr (result);
+	    gfc_error ("Argument %qs of MOD at %L shall not be zero",
+			"P", &p->where);
 	    return &gfc_bad_expr;
 	  }
-	mpz_tdiv_r (result->value.integer, a->value.integer, p->value.integer);
 	break;
-
       case BT_REAL:
 	if (mpfr_cmp_ui (p->value.real, 0) == 0)
 	  {
-	    /* Result is processor-dependent.  */
-	    gfc_error ("Second argument of MOD at %L is zero", &p->where);
-	    gfc_free_expr (result);
+	    gfc_error ("Argument %qs of MOD at %L shall not be zero",
+			"P", &p->where);
 	    return &gfc_bad_expr;
 	  }
-
-	gfc_set_model_kind (kind);
-	mpfr_fmod (result->value.real, a->value.real, p->value.real,
-		   GFC_RND_MODE);
 	break;
-
       default:
 	gfc_internal_error ("gfc_simplify_mod(): Bad arguments");
     }
 
+  if (a->expr_type != EXPR_CONSTANT)
+    return NULL;
+
+  kind = a->ts.kind > p->ts.kind ? a->ts.kind : p->ts.kind;
+  result = gfc_get_constant_expr (a->ts.type, kind, &a->where);
+
+  if (a->ts.type == BT_INTEGER)
+    mpz_tdiv_r (result->value.integer, a->value.integer, p->value.integer);
+  else
+    {
+      gfc_set_model_kind (kind);
+      mpfr_fmod (result->value.real, a->value.real, p->value.real,
+		 GFC_RND_MODE);
+    }
+
   return range_check (result, "MOD");
 }
 
@@ -6579,10 +6585,12 @@
   unsigned char *buffer;
   size_t result_length;
 
+  if (!gfc_is_constant_expr (source) || !gfc_is_constant_expr (size))
+    return NULL;
 
-  if (!gfc_is_constant_expr (source)
-	|| (gfc_init_expr_flag && !gfc_is_constant_expr (mold))
-	|| !gfc_is_constant_expr (size))
+  if (!gfc_resolve_expr (mold))
+    return NULL;
+  if (gfc_init_expr_flag && !gfc_is_constant_expr (mold))
     return NULL;
 
   if (!gfc_calculate_transfer_sizes (source, mold, size, &source_size, 
@@ -7172,26 +7180,32 @@
 	{
 	  gfc_expr *tmp;
 	  if (c->iterator == NULL)
-	    tmp = f (c->expr, kind);
+	    {
+	      tmp = f (c->expr, kind);
+	      if (tmp == NULL)
+		{
+		  gfc_free_expr (result);
+		  return NULL;
+		}
+
+	      gfc_constructor_append_expr (&result->value.constructor,
+					   tmp, &c->where);
+	    }
 	  else
 	    {
+	      gfc_constructor *n;
 	      g = gfc_convert_constant (c->expr, type, kind);
-	      if (g == &gfc_bad_expr)
+	      if (g == NULL || g == &gfc_bad_expr)
 	        {
 		  gfc_free_expr (result);
 		  return g;
 		}
-	      tmp = g;
-	    }
-
-	  if (tmp == NULL)
-	    {
-	      gfc_free_expr (result);
-	      return NULL;
+	      n = gfc_constructor_get ();
+	      n->expr = g;
+	      n->iterator = gfc_copy_iterator (c->iterator);
+	      n->where = c->where;
+	      gfc_constructor_append (&result->value.constructor, n);
 	    }
-
-	  gfc_constructor_append_expr (&result->value.constructor,
-				       tmp, &c->where);
 	}
 
       break;
diff -ruN gcc-7.3.0/gcc/fortran/symbol.c gcc-7.3.0-msp430/gcc/fortran/symbol.c
--- gcc-7.3.0/gcc/fortran/symbol.c	2017-04-04 06:41:41.044537000 -0700
+++ gcc-7.3.0-msp430/gcc/fortran/symbol.c	2019-06-25 02:27:21.137931160 -0700
@@ -1259,6 +1259,20 @@
 			 where))
       return false;
 
+  /* F2008:  C1282 A designator of a variable with the VOLATILE attribute
+     shall not appear in a pure subprogram.
+
+     F2018: C1588 A local variable of a pure subprogram, or of a BLOCK
+     construct within a pure subprogram, shall not have the SAVE or
+     VOLATILE attribute.  */
+  if (gfc_pure (NULL))
+    {
+      gfc_error ("VOLATILE attribute at %L cannot be specified in a "
+		 "PURE procedure", where);
+      return false;
+    }
+
+
   attr->volatile_ = 1;
   attr->volatile_ns = gfc_current_ns;
   return check_conflict (attr, name, where);
diff -ruN gcc-7.3.0/gcc/fortran/trans-array.c gcc-7.3.0-msp430/gcc/fortran/trans-array.c
--- gcc-7.3.0/gcc/fortran/trans-array.c	2017-11-13 12:01:20.128076000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/trans-array.c	2019-06-25 02:27:21.141931133 -0700
@@ -2652,6 +2652,8 @@
 	  gfc_init_se (&se, NULL);
 	  se.loop = loop;
 	  se.ss = ss;
+	  if (gfc_is_class_array_function (expr))
+	    expr->must_finalize = 1;
 	  gfc_conv_expr (&se, expr);
 	  gfc_add_block_to_block (&outer_loop->pre, &se.pre);
 	  gfc_add_block_to_block (&outer_loop->post, &se.post);
@@ -3071,7 +3073,7 @@
     }
 
   /* Multiply by the stride.  */
-  if (!integer_onep (stride))
+  if (stride != NULL && !integer_onep (stride))
     index = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,
 			     index, stride);
 
@@ -3102,7 +3104,7 @@
     {
       if (expr == NULL
 	  || (expr->ts.type != BT_CLASS
-	      && !gfc_is_alloc_class_array_function (expr)
+	      && !gfc_is_class_array_function (expr)
 	      && !gfc_is_class_array_ref (expr, NULL)))
 	return false;
 
@@ -3132,12 +3134,12 @@
     }
 
   if (class_ref == NULL && expr && expr->symtree->n.sym->attr.function
-      && expr->symtree->n.sym == expr->symtree->n.sym->result)
+      && expr->symtree->n.sym == expr->symtree->n.sym->result
+      && expr->symtree->n.sym->backend_decl == current_function_decl)
     {
-      gcc_assert (expr->symtree->n.sym->backend_decl == current_function_decl);
       decl = gfc_get_fake_result_decl (expr->symtree->n.sym, 0);
     }
-  else if (expr && gfc_is_alloc_class_array_function (expr))
+  else if (expr && gfc_is_class_array_function (expr))
     {
       size = NULL_TREE;
       decl = NULL_TREE;
@@ -3160,6 +3162,8 @@
 
       if (decl == NULL_TREE)
 	return false;
+
+      se->class_vptr = gfc_evaluate_now (gfc_class_vptr_get (decl), &se->pre);
     }
   else if (class_ref == NULL)
     {
@@ -3334,7 +3338,10 @@
     {
       type = gfc_get_element_type (type);
       tmp = TREE_OPERAND (cdecl, 0);
-      tmp = gfc_get_class_array_ref (offset, tmp, NULL_TREE);
+      /* Note that the fourth argument in this call has been set false.
+	 should any character dynamic types come this way, the 'len'
+	 field of the unlimited object will not be used.  */
+      tmp = gfc_get_class_array_ref (offset, tmp, NULL_TREE, false);
       tmp = fold_convert (build_pointer_type (type), tmp);
       tmp = build_fold_indirect_ref_loc (input_location, tmp);
       return tmp;
@@ -7125,7 +7132,11 @@
       else
 	{
 	  /* Otherwise make a new one.  */
-	  parmtype = gfc_get_element_type (TREE_TYPE (desc));
+	  if (expr->ts.type == BT_CHARACTER && expr->ts.deferred)
+	    parmtype = gfc_typenode_for_spec (&expr->ts);
+	  else
+	    parmtype = gfc_get_element_type (TREE_TYPE (desc));
+
 	  parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen, codim,
 						loop.from, loop.to, 0,
 						GFC_ARRAY_UNKNOWN, false);
@@ -8598,7 +8609,7 @@
 	  break;
 
 	case COPY_ALLOC_COMP:
-	  if (c->attr.pointer)
+	  if (c->attr.pointer || c->attr.proc_pointer)
 	    continue;
 
 	  /* We need source and destination components.  */
@@ -8642,6 +8653,31 @@
 
 	      gfc_init_block (&tmpblock);
 
+	      gfc_add_modify (&tmpblock, gfc_class_vptr_get (dcmp),
+			      gfc_class_vptr_get (comp));
+
+	      /* Copy the unlimited '_len' field. If it is greater than zero
+		 (ie. a character(_len)), multiply it by size and use this
+		 for the malloc call.  */
+	      if (UNLIMITED_POLY (c))
+		{
+		  tree ctmp;
+		  gfc_add_modify (&tmpblock, gfc_class_len_get (dcmp),
+				  gfc_class_len_get (comp));
+
+		  size = gfc_evaluate_now (size, &tmpblock);
+		  tmp = gfc_class_len_get (comp);
+		  ctmp = fold_build2_loc (input_location, MULT_EXPR,
+					  size_type_node, size,
+					  fold_convert (size_type_node, tmp));
+		  tmp = fold_build2_loc (input_location, GT_EXPR,
+					 logical_type_node, tmp,
+					 build_zero_cst (TREE_TYPE (tmp)));
+		  size = fold_build3_loc (input_location, COND_EXPR,
+					  size_type_node, tmp, ctmp, size);
+		  size = gfc_evaluate_now (size, &tmpblock);
+		}
+
 	      /* Coarray component have to have the same allocation status and
 		 shape/type-parameter/effective-type on the LHS and RHS of an
 		 intrinsic assignment. Hence, we did not deallocated them - and
@@ -9096,6 +9132,12 @@
   if (expr2 && rss == gfc_ss_terminator)
     return NULL_TREE;
 
+  /* Ensure that the string length from the current scope is used.  */
+  if (expr2->ts.type == BT_CHARACTER
+      && expr2->expr_type == EXPR_FUNCTION
+      && !expr2->value.function.isym)
+    expr2->ts.u.cl->backend_decl = rss->info->string_length;
+
   gfc_start_block (&fblock);
 
   /* Since the lhs is allocatable, this must be a descriptor type.
@@ -9340,6 +9382,8 @@
 			     gfc_array_index_type, tmp,
 			     expr1->ts.u.cl->backend_decl);
     }
+  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)
+    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr2->ts));
   else
     tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr1->ts));
   tmp = fold_convert (gfc_array_index_type, tmp);
@@ -9366,6 +9410,28 @@
       gfc_add_modify (&fblock, tmp,
 		      gfc_get_dtype_rank_type (expr1->rank,type));
     }
+  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)
+    {
+      tree type;
+      tmp = gfc_conv_descriptor_dtype (desc);
+      type = gfc_typenode_for_spec (&expr2->ts);
+      gfc_add_modify (&fblock, tmp,
+		      gfc_get_dtype_rank_type (expr2->rank,type));
+      /* Set the _len field as well...  */
+      tmp = gfc_class_len_get (TREE_OPERAND (desc, 0));
+      if (expr2->ts.type == BT_CHARACTER)
+	gfc_add_modify (&fblock, tmp,
+			fold_convert (TREE_TYPE (tmp),
+				      TYPE_SIZE_UNIT (type)));
+      else
+	gfc_add_modify (&fblock, tmp,
+			build_int_cst (TREE_TYPE (tmp), 0));
+      /* ...and the vptr.  */
+      tmp = gfc_class_vptr_get (TREE_OPERAND (desc, 0));
+      tmp2 = gfc_get_symbol_decl (gfc_find_vtab (&expr2->ts));
+      tmp2 = gfc_build_addr_expr (TREE_TYPE (tmp), tmp2);
+      gfc_add_modify (&fblock, tmp, tmp2);
+    }
   else if (coarray && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))
     {
       gfc_add_modify (&fblock, gfc_conv_descriptor_dtype (desc),
@@ -9471,10 +9537,11 @@
 
 
   /* We already set the dtype in the case of deferred character
-     length arrays.  */
+     length arrays and unlimited polymorphic arrays.  */
   if (!(GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))
 	&& ((expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)
-	    || coarray)))
+	    || coarray))
+      && !UNLIMITED_POLY (expr1))
     {
       tmp = gfc_conv_descriptor_dtype (desc);
       gfc_add_modify (&alloc_block, tmp, gfc_get_dtype (TREE_TYPE (desc)));
@@ -10007,7 +10074,7 @@
   if (!sym)
     sym = expr->symtree->n.sym;
 
-  if (gfc_is_alloc_class_array_function (expr))
+  if (gfc_is_class_array_function (expr))
     return gfc_get_array_ss (ss, expr,
 			     CLASS_DATA (expr->value.function.esym->result)->as->rank,
 			     GFC_SS_FUNCTION);
diff -ruN gcc-7.3.0/gcc/fortran/trans-decl.c gcc-7.3.0-msp430/gcc/fortran/trans-decl.c
--- gcc-7.3.0/gcc/fortran/trans-decl.c	2017-11-13 12:01:20.128076000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/trans-decl.c	2019-06-25 02:27:21.141931133 -0700
@@ -603,10 +603,12 @@
      function scope.  */
   if (current_function_decl != NULL_TREE)
     {
-      if (sym->ns->proc_name->backend_decl == current_function_decl
-	  || sym->result == sym)
+      if (sym->ns->proc_name
+	  && (sym->ns->proc_name->backend_decl == current_function_decl
+	      || sym->result == sym))
 	gfc_add_decl_to_function (decl);
-      else if (sym->ns->proc_name->attr.flavor == FL_LABEL)
+      else if (sym->ns->proc_name
+	       && sym->ns->proc_name->attr.flavor == FL_LABEL)
 	/* This is a BLOCK construct.  */
 	add_decl_as_local (decl);
       else
@@ -698,7 +700,8 @@
     }
 
   /* Keep variables larger than max-stack-var-size off stack.  */
-  if (!sym->ns->proc_name->attr.recursive && !sym->attr.automatic
+  if (!(sym->ns->proc_name && sym->ns->proc_name->attr.recursive)
+      && !sym->attr.automatic
       && INTEGER_CST_P (DECL_SIZE_UNIT (decl))
       && !gfc_can_put_var_on_stack (DECL_SIZE_UNIT (decl))
 	 /* Put variable length auto array pointers always into stack.  */
@@ -4142,6 +4145,24 @@
   return tmp;
 }
 
+
+/* Get the result expression for a procedure.  */
+
+static tree
+get_proc_result (gfc_symbol* sym)
+{
+  if (sym->attr.subroutine || sym == sym->result)
+    {
+      if (current_fake_result_decl != NULL)
+	return TREE_VALUE (current_fake_result_decl);
+
+      return NULL_TREE;
+    }
+
+  return sym->result->backend_decl;
+}
+
+
 /* Generate function entry and exit code, and add it to the function body.
    This includes:
     Allocation and initialization of array variables.
@@ -4251,6 +4272,21 @@
       else
 	gcc_assert (flag_f2c && proc_sym->ts.type == BT_COMPLEX);
     }
+  else if (proc_sym == proc_sym->result && IS_CLASS_ARRAY (proc_sym))
+    {
+      /* Nullify explicit return class arrays on entry.  */
+      tree type;
+      tmp = get_proc_result (proc_sym);
+	if (tmp && GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))
+	  {
+	    gfc_start_block (&init);
+	    tmp = gfc_class_data_get (tmp);
+	    type = TREE_TYPE (gfc_conv_descriptor_data_get (tmp));
+	    gfc_conv_descriptor_data_set (&init, tmp, build_int_cst (type, 0));
+	    gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);
+	  }
+    }
+
 
   /* Initialize the INTENT(OUT) derived type dummy arguments.  This
      should be done here so that the offsets and lbounds of arrays
@@ -5981,23 +6017,6 @@
 }
 
 
-/* Get the result expression for a procedure.  */
-
-static tree
-get_proc_result (gfc_symbol* sym)
-{
-  if (sym->attr.subroutine || sym == sym->result)
-    {
-      if (current_fake_result_decl != NULL)
-	return TREE_VALUE (current_fake_result_decl);
-
-      return NULL_TREE;
-    }
-
-  return sym->result->backend_decl;
-}
-
-
 /* Generate an appropriate return-statement for a procedure.  */
 
 tree
diff -ruN gcc-7.3.0/gcc/fortran/trans-expr.c gcc-7.3.0-msp430/gcc/fortran/trans-expr.c
--- gcc-7.3.0/gcc/fortran/trans-expr.c	2017-11-23 13:02:48.877901000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/trans-expr.c	2019-06-25 02:27:21.141931133 -0700
@@ -960,6 +960,7 @@
     }
 
   if ((ref == NULL || class_ref == ref)
+      && !(gfc_is_class_array_function (e) && parmse->class_vptr != NULL_TREE)
       && (!class_ts.u.derived->components->as
 	  || class_ts.u.derived->components->as->rank != -1))
     return;
@@ -1030,8 +1031,11 @@
      First we have to find the corresponding class reference.  */
 
   tmp = NULL_TREE;
-  if (class_ref == NULL
-	&& e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)
+  if (gfc_is_class_array_function (e)
+      && parmse->class_vptr != NULL_TREE)
+    tmp = parmse->class_vptr;
+  else if (class_ref == NULL
+	   && e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)
     {
       tmp = e->symtree->n.sym->backend_decl;
 
@@ -1063,7 +1067,11 @@
   if (TREE_CODE (TREE_TYPE (tmp)) == REFERENCE_TYPE)
     tmp = build_fold_indirect_ref_loc (input_location, tmp);
 
-  vptr = gfc_class_vptr_get (tmp);
+  if (!(gfc_is_class_array_function (e) && parmse->class_vptr))
+    vptr = gfc_class_vptr_get (tmp);
+  else
+    vptr = tmp;
+
   gfc_add_modify (&block, ctree,
 		  fold_convert (TREE_TYPE (ctree), vptr));
 
@@ -1148,15 +1156,32 @@
    of the referenced element.  */
 
 tree
-gfc_get_class_array_ref (tree index, tree class_decl, tree data_comp)
+gfc_get_class_array_ref (tree index, tree class_decl, tree data_comp,
+			 bool unlimited)
 {
-  tree data = data_comp != NULL_TREE ? data_comp :
-				       gfc_class_data_get (class_decl);
-  tree size = gfc_class_vtab_size_get (class_decl);
-  tree offset = fold_build2_loc (input_location, MULT_EXPR,
-				 gfc_array_index_type,
-				 index, size);
-  tree ptr;
+  tree data, size, tmp, ctmp, offset, ptr;
+
+  data = data_comp != NULL_TREE ? data_comp :
+				  gfc_class_data_get (class_decl);
+  size = gfc_class_vtab_size_get (class_decl);
+
+  if (unlimited)
+    {
+      tmp = fold_convert (gfc_array_index_type,
+			  gfc_class_len_get (class_decl));
+      ctmp = fold_build2_loc (input_location, MULT_EXPR,
+			      gfc_array_index_type, size, tmp);
+      tmp = fold_build2_loc (input_location, GT_EXPR,
+			     logical_type_node, tmp,
+			     build_zero_cst (TREE_TYPE (tmp)));
+      size = fold_build3_loc (input_location, COND_EXPR,
+			      gfc_array_index_type, tmp, ctmp, size);
+    }
+
+  offset = fold_build2_loc (input_location, MULT_EXPR,
+			    gfc_array_index_type,
+			    index, size);
+
   data = gfc_conv_descriptor_data_get (data);
   ptr = fold_convert (pvoid_type_node, data);
   ptr = fold_build_pointer_plus_loc (input_location, ptr, offset);
@@ -1258,14 +1283,15 @@
 
       if (is_from_desc)
 	{
-	  from_ref = gfc_get_class_array_ref (index, from, from_data);
+	  from_ref = gfc_get_class_array_ref (index, from, from_data,
+					      unlimited);
 	  vec_safe_push (args, from_ref);
 	}
       else
         vec_safe_push (args, from_data);
 
       if (is_to_class)
-	to_ref = gfc_get_class_array_ref (index, to, to_data);
+	to_ref = gfc_get_class_array_ref (index, to, to_data, unlimited);
       else
 	{
 	  tmp = gfc_conv_array_data (to);
@@ -4307,6 +4333,8 @@
 
       if (expr->value.function.esym == NULL
 	    && expr->value.function.isym != NULL
+	    && expr->value.function.actual
+	    && expr->value.function.actual->expr
 	    && expr->value.function.actual->expr->symtree
 	    && gfc_map_intrinsic_function (expr, mapping))
 	break;
@@ -4435,7 +4463,7 @@
   /* Reset the offset for the function call since the loop
      is zero based on the data pointer.  Note that the temp
      comes first in the loop chain since it is added second.  */
-  if (gfc_is_alloc_class_array_function (expr))
+  if (gfc_is_class_array_function (expr))
     {
       tmp = loop.ss->loop_chain->info->data.array.descriptor;
       gfc_conv_descriptor_offset_set (&loop.pre, tmp,
@@ -4484,7 +4512,7 @@
   dimen = rse.ss->dimen;
 
   /* Skip the write-out loop for this case.  */
-  if (gfc_is_alloc_class_array_function (expr))
+  if (gfc_is_class_array_function (expr))
     goto class_array_fcn;
 
   /* Calculate the bounds of the scalarization.  */
@@ -4778,7 +4806,7 @@
 	      gcc_assert ((!comp && gfc_return_by_reference (sym)
 			   && sym->result->attr.dimension)
 			  || (comp && comp->attr.dimension)
-			  || gfc_is_alloc_class_array_function (expr));
+			  || gfc_is_class_array_function (expr));
 	      gcc_assert (se->loop != NULL);
 	      /* Access the previously obtained result.  */
 	      gfc_conv_tmp_array_ref (se);
@@ -5461,7 +5489,7 @@
 				fsym ? fsym->attr.intent : INTENT_INOUT,
 				fsym && fsym->attr.pointer);
 
-	      else if (gfc_is_alloc_class_array_function (e)
+	      else if (gfc_is_class_array_function (e)
 			 && fsym && fsym->ts.type == BT_DERIVED)
 		/* See previous comment.  For function actual argument,
 		   the write out is not needed so the intent is set as
@@ -6302,7 +6330,7 @@
 	 call the finalization function of the temporary. Note that the
 	 nullification of allocatable components needed by the result
 	 is done in gfc_trans_assignment_1.  */
-      if (expr && ((gfc_is_alloc_class_array_function (expr)
+      if (expr && ((gfc_is_class_array_function (expr)
 		    && se->ss && se->ss->loop)
 		   || gfc_is_alloc_class_scalar_function (expr))
 	  && se->expr && GFC_CLASS_TYPE_P (TREE_TYPE (se->expr))
@@ -6313,6 +6341,7 @@
 	  int n;
 	  if (se->ss && se->ss->loop)
 	    {
+	      gfc_add_block_to_block (&se->ss->loop->pre, &se->pre);
 	      se->expr = gfc_evaluate_now (se->expr, &se->ss->loop->pre);
 	      tmp = gfc_class_data_get (se->expr);
 	      info->descriptor = tmp;
@@ -6335,6 +6364,11 @@
 			CLASS_DATA (expr->value.function.esym->result)->attr);
 	    }
 
+	  if ((gfc_is_class_array_function (expr)
+	       || gfc_is_alloc_class_scalar_function (expr))
+	      && CLASS_DATA (expr->value.function.esym->result)->attr.pointer)
+	    goto no_finalization;
+
 	  final_fndecl = gfc_class_vtab_final_get (se->expr);
 	  is_final = fold_build2_loc (input_location, NE_EXPR,
 				      logical_type_node,
@@ -6365,6 +6399,8 @@
 	      tmp = gfc_call_free (tmp);
 	      gfc_add_expr_to_block (&se->post, tmp);
 	    }
+
+no_finalization:
 	  expr->must_finalize = 0;
 	}
 
@@ -8835,7 +8871,7 @@
 	  gfc_add_expr_to_block (&block, tmp);
 	}
     }
-  else if (gfc_bt_struct (ts.type) || ts.type == BT_CLASS)
+  else if (gfc_bt_struct (ts.type) || ts.type == BT_CLASS || ts.type == BT_COMPLEX)
     {
       gfc_add_block_to_block (&block, &lse->pre);
       gfc_add_block_to_block (&block, &rse->pre);
@@ -8871,7 +8907,7 @@
   gfc_symbol *sym = expr1->symtree->n.sym;
 
   /* Play it safe with class functions assigned to a derived type.  */
-  if (gfc_is_alloc_class_array_function (expr2)
+  if (gfc_is_class_array_function (expr2)
       && expr1->ts.type == BT_DERIVED)
     return true;
 
@@ -9878,7 +9914,7 @@
   rss = NULL;
 
   if ((expr1->ts.type == BT_DERIVED)
-      && (gfc_is_alloc_class_array_function (expr2)
+      && (gfc_is_class_array_function (expr2)
 	  || gfc_is_alloc_class_scalar_function (expr2)))
     expr2->must_finalize = 1;
 
@@ -10085,7 +10121,7 @@
      a scalar to array assignment, this is done in gfc_trans_scalar_assign
      as part of the deep copy.  */
   if (!scalar_to_array && expr1->ts.type == BT_DERIVED
-		       && (gfc_is_alloc_class_array_function (expr2)
+		       && (gfc_is_class_array_function (expr2)
 			   || gfc_is_alloc_class_scalar_function (expr2)))
     {
       tmp = rse.expr;
@@ -10294,6 +10330,10 @@
 	return tmp;
     }
 
+  if (UNLIMITED_POLY (expr1) && expr1->rank
+      && expr2->ts.type != BT_CLASS)
+    use_vptr_copy = true;
+
   /* Fallback to the scalarizer to generate explicit loops.  */
   return gfc_trans_assignment_1 (expr1, expr2, init_flag, dealloc,
 				 use_vptr_copy, may_alias);
diff -ruN gcc-7.3.0/gcc/fortran/trans.h gcc-7.3.0-msp430/gcc/fortran/trans.h
--- gcc-7.3.0/gcc/fortran/trans.h	2017-03-05 03:35:47.879152000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/trans.h	2019-06-25 02:27:21.145931103 -0700
@@ -431,7 +431,7 @@
 void gfc_reset_vptr (stmtblock_t *, gfc_expr *);
 void gfc_reset_len (stmtblock_t *, gfc_expr *);
 tree gfc_get_vptr_from_expr (tree);
-tree gfc_get_class_array_ref (tree, tree, tree);
+tree gfc_get_class_array_ref (tree, tree, tree, bool);
 tree gfc_copy_class_to_class (tree, tree, tree, bool);
 bool gfc_add_finalizer_call (stmtblock_t *, gfc_expr *);
 bool gfc_add_comp_finalizer_call (stmtblock_t *, tree, gfc_component *, bool);
diff -ruN gcc-7.3.0/gcc/fortran/trans-intrinsic.c gcc-7.3.0-msp430/gcc/fortran/trans-intrinsic.c
--- gcc-7.3.0/gcc/fortran/trans-intrinsic.c	2017-11-13 12:01:20.128076000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/trans-intrinsic.c	2019-06-25 02:27:21.141931133 -0700
@@ -1860,7 +1860,7 @@
 
   lhs_expr = code->ext.actual->expr;
   rhs_expr = code->ext.actual->next->expr;
-  may_require_tmp = gfc_check_dependency (lhs_expr, rhs_expr, false) == 0
+  may_require_tmp = gfc_check_dependency (lhs_expr, rhs_expr, true) == 0
 		    ? boolean_false_node : boolean_true_node;
   gfc_init_block (&block);
 
@@ -1906,34 +1906,124 @@
     }
   else
     {
-      /* If has_vector, pass descriptor for whole array and the
-         vector bounds separately.  */
-      gfc_array_ref *ar, ar2;
-      bool has_vector = false;
+      bool has_vector = gfc_has_vector_subscript (lhs_expr);
 
-      if (gfc_is_coindexed (lhs_expr) && gfc_has_vector_subscript (lhs_expr))
+      if (gfc_is_coindexed (lhs_expr) || !has_vector)
 	{
-          has_vector = true;
-          ar = gfc_find_array_ref (lhs_expr);
-	  ar2 = *ar;
-	  memset (ar, '\0', sizeof (*ar));
-	  ar->as = ar2.as;
-	  ar->type = AR_FULL;
+	  /* If has_vector, pass descriptor for whole array and the
+	     vector bounds separately.  */
+	  gfc_array_ref *ar, ar2;
+	  bool has_tmp_lhs_array = false;
+	  if (has_vector)
+	    {
+	      has_tmp_lhs_array = true;
+	      ar = gfc_find_array_ref (lhs_expr);
+	      ar2 = *ar;
+	      memset (ar, '\0', sizeof (*ar));
+	      ar->as = ar2.as;
+	      ar->type = AR_FULL;
+	    }
+	  lhs_se.want_pointer = 1;
+	  gfc_conv_expr_descriptor (&lhs_se, lhs_expr);
+	  /* Using gfc_conv_expr_descriptor, we only get the descriptor, but
+	     that has the wrong type if component references are done.  */
+	  lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);
+	  tmp = build_fold_indirect_ref_loc (input_location, lhs_se.expr);
+	  gfc_add_modify (&lhs_se.pre, gfc_conv_descriptor_dtype (tmp),
+			  gfc_get_dtype_rank_type (has_vector ? ar2.dimen
+							      : lhs_expr->rank,
+						   lhs_type));
+	  if (has_tmp_lhs_array)
+	    {
+	      vec = conv_caf_vector_subscript (&block, lhs_se.expr, &ar2);
+	      *ar = ar2;
+	    }
 	}
-      lhs_se.want_pointer = 1;
-      gfc_conv_expr_descriptor (&lhs_se, lhs_expr);
-      /* Using gfc_conv_expr_descriptor, we only get the descriptor, but that
-         has the wrong type if component references are done.  */
-      lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);
-      tmp = build_fold_indirect_ref_loc (input_location, lhs_se.expr);
-      gfc_add_modify (&lhs_se.pre, gfc_conv_descriptor_dtype (tmp),
-                      gfc_get_dtype_rank_type (has_vector ? ar2.dimen
-							  : lhs_expr->rank,
-		      lhs_type));
-      if (has_vector)
+      else
 	{
-	  vec = conv_caf_vector_subscript (&block, lhs_se.expr, &ar2);
-	  *ar = ar2;
+	  /* Special casing for arr1 ([...]) = arr2[...], i.e. caf_get to
+	     indexed array expression.  This is rewritten to:
+
+	     tmp_array = arr2[...]
+	     arr1 ([...]) = tmp_array
+
+	     because using the standard gfc_conv_expr (lhs_expr) did the
+	     assignment with lhs and rhs exchanged.  */
+
+	  gfc_ss *lss_for_tmparray, *lss_real;
+	  gfc_loopinfo loop;
+	  gfc_se se;
+	  stmtblock_t body;
+	  tree tmparr_desc, src;
+	  tree index = gfc_index_zero_node;
+	  tree stride = gfc_index_zero_node;
+	  int n;
+
+	  /* Walk both sides of the assignment, once to get the shape of the
+	     temporary array to create right.  */
+	  lss_for_tmparray = gfc_walk_expr (lhs_expr);
+	  /* And a second time to be able to create an assignment of the
+	     temporary to the lhs_expr.  gfc_trans_create_temp_array replaces
+	     the tree in the descriptor with the one for the temporary
+	     array.  */
+	  lss_real = gfc_walk_expr (lhs_expr);
+	  gfc_init_loopinfo (&loop);
+	  gfc_add_ss_to_loop (&loop, lss_for_tmparray);
+	  gfc_add_ss_to_loop (&loop, lss_real);
+	  gfc_conv_ss_startstride (&loop);
+	  gfc_conv_loop_setup (&loop, &lhs_expr->where);
+	  lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);
+	  gfc_trans_create_temp_array (&lhs_se.pre, &lhs_se.post,
+				       lss_for_tmparray, lhs_type, NULL_TREE,
+				       false, true, false,
+				       &lhs_expr->where);
+	  tmparr_desc = lss_for_tmparray->info->data.array.descriptor;
+	  gfc_start_scalarized_body (&loop, &body);
+	  gfc_init_se (&se, NULL);
+	  gfc_copy_loopinfo_to_se (&se, &loop);
+	  se.ss = lss_real;
+	  gfc_conv_expr (&se, lhs_expr);
+	  gfc_add_block_to_block (&body, &se.pre);
+
+	  /* Walk over all indexes of the loop.  */
+	  for (n = loop.dimen - 1; n > 0; --n)
+	    {
+	      tmp = loop.loopvar[n];
+	      tmp = fold_build2_loc (input_location, MINUS_EXPR,
+				     gfc_array_index_type, tmp, loop.from[n]);
+	      tmp = fold_build2_loc (input_location, PLUS_EXPR,
+				     gfc_array_index_type, tmp, index);
+
+	      stride = fold_build2_loc (input_location, MINUS_EXPR,
+					gfc_array_index_type,
+					loop.to[n - 1], loop.from[n - 1]);
+	      stride = fold_build2_loc (input_location, PLUS_EXPR,
+					gfc_array_index_type,
+					stride, gfc_index_one_node);
+
+	      index = fold_build2_loc (input_location, MULT_EXPR,
+				       gfc_array_index_type, tmp, stride);
+	    }
+
+	  index = fold_build2_loc (input_location, MINUS_EXPR,
+				   gfc_array_index_type,
+				   index, loop.from[0]);
+
+	  index = fold_build2_loc (input_location, PLUS_EXPR,
+				   gfc_array_index_type,
+				   loop.loopvar[0], index);
+
+	  src = build_fold_indirect_ref (gfc_conv_array_data (tmparr_desc));
+	  src = gfc_build_array_ref (src, index, NULL);
+	  /* Now create the assignment of lhs_expr = tmp_array.  */
+	  gfc_add_modify (&body, se.expr, src);
+	  gfc_add_block_to_block (&body, &se.post);
+	  lhs_se.expr = gfc_build_addr_expr (NULL_TREE, tmparr_desc);
+	  gfc_trans_scalarizing_loops (&loop, &body);
+	  gfc_add_block_to_block (&loop.pre, &loop.post);
+	  gfc_add_expr_to_block (&lhs_se.post, gfc_finish_block (&loop.pre));
+	  gfc_free_ss (lss_for_tmparray);
+	  gfc_free_ss (lss_real);
 	}
     }
 
@@ -5478,6 +5568,22 @@
 }
 
 static void
+gfc_conv_intrinsic_shape (gfc_se *se, gfc_expr *expr)
+{
+  gfc_actual_arglist *s, *k;
+  gfc_expr *e;
+
+  /* Remove the KIND argument, if present. */
+  s = expr->value.function.actual;
+  k = s->next;
+  e = k->expr;
+  gfc_free_expr (e);
+  k->expr = NULL;
+
+  gfc_conv_intrinsic_funcall (se, expr);
+}
+
+static void
 gfc_conv_intrinsic_shift (gfc_se * se, gfc_expr * expr, bool right_shift,
 			  bool arithmetic)
 {
@@ -6601,7 +6707,7 @@
     gfc_add_class_array_ref (actual->expr);
 
   argse.data_not_needed = 1;
-  if (gfc_is_alloc_class_array_function (actual->expr))
+  if (gfc_is_class_array_function (actual->expr))
     {
       /* For functions that return a class array conv_expr_descriptor is not
 	 able to get the descriptor right.  Therefore this special case.  */
@@ -8589,6 +8695,10 @@
 	      conv_generic_with_optional_char_arg (se, expr, 1, 3);
 	      break;
 
+	    case GFC_ISYM_SHAPE:
+	      gfc_conv_intrinsic_shape (se, expr);
+	      break;
+
 	    default:
 	      gfc_conv_intrinsic_funcall (se, expr);
 	      break;
diff -ruN gcc-7.3.0/gcc/fortran/trans-io.c gcc-7.3.0-msp430/gcc/fortran/trans-io.c
--- gcc-7.3.0/gcc/fortran/trans-io.c	2017-11-13 12:01:20.128076000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/trans-io.c	2019-06-25 02:27:21.141931133 -0700
@@ -639,12 +639,12 @@
       /* Don't evaluate the UNIT number multiple times.  */
       se.expr = gfc_evaluate_now (se.expr, &se.pre);
 
-      /* UNIT numbers should be greater than zero.  */
+      /* UNIT numbers should be greater than the min.  */
       i = gfc_validate_kind (BT_INTEGER, 4, false);
+      val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].pedantic_min_int, 4);
       cond1 = build2_loc (input_location, LT_EXPR, logical_type_node,
 			  se.expr,
-			  fold_convert (TREE_TYPE (se.expr),
-			  integer_zero_node));
+			  fold_convert (TREE_TYPE (se.expr), val));
       /* UNIT numbers should be less than the max.  */
       val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, 4);
       cond2 = build2_loc (input_location, GT_EXPR, logical_type_node,
@@ -2214,25 +2214,9 @@
   bool formatted = false;
   gfc_dt *dt = code->ext.dt;
 
-  if (dt)
-    {
-      char *fmt = NULL;
-
-      if (dt->format_label == &format_asterisk)
-	{
-	  /* List directed io must call the formatted DTIO procedure.  */
-	  formatted = true;
-	}
-      else if (dt->format_expr)
-	fmt = gfc_widechar_to_char (dt->format_expr->value.character.string,
-				      -1);
-      else if (dt->format_label)
-	fmt = gfc_widechar_to_char (dt->format_label->format->value.character.string,
-				      -1);
-      if (fmt && strtok (fmt, "DT") != NULL)
-	formatted = true;
-
-    }
+  /* Determine when to use the formatted DTIO procedure.  */
+  if (dt && (dt->format_expr || dt->format_label))
+    formatted = true;
 
   if (ts->type == BT_CLASS)
     derived = ts->u.derived->components->ts.u.derived;
@@ -2293,6 +2277,16 @@
       ts->kind = gfc_index_integer_kind;
     }
 
+  /* gfortran reaches here for "print *, c_loc(xxx)".  */
+  if (ts->type == BT_VOID
+      && code->expr1 && code->expr1->ts.type == BT_VOID
+      && code->expr1->symtree
+      && strcmp (code->expr1->symtree->name, "c_loc") == 0)
+    {
+      ts->type = BT_INTEGER;
+      ts->kind = gfc_index_integer_kind;
+    }
+
   kind = ts->kind;
   function = NULL;
   arg2 = NULL;
@@ -2442,8 +2436,7 @@
 	    {
 	      /* Recurse into the elements of the derived type.  */
 	      expr = gfc_evaluate_now (addr_expr, &se->pre);
-	      expr = build_fold_indirect_ref_loc (input_location,
-				      expr);
+	      expr = build_fold_indirect_ref_loc (input_location, expr);
 
 	      /* Make sure that the derived type has been built.  An external
 		 function, if only referenced in an io statement, requires this
diff -ruN gcc-7.3.0/gcc/fortran/trans-openmp.c gcc-7.3.0-msp430/gcc/fortran/trans-openmp.c
--- gcc-7.3.0/gcc/fortran/trans-openmp.c	2017-12-15 14:00:48.082705000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/trans-openmp.c	2019-06-25 02:27:21.141931133 -0700
@@ -1949,9 +1949,32 @@
 			  }
 			else
 			  {
-			    tree type = gfc_typenode_for_spec (&n->sym->ts);
-			    OMP_CLAUSE_LINEAR_STEP (node)
-			      = fold_convert (type, last_step);
+			    if (kind == OMP_CLAUSE_LINEAR_REF)
+			      {
+				tree type;
+				if (n->sym->attr.flavor == FL_PROCEDURE)
+				  {
+				    type = gfc_get_function_type (n->sym);
+				    type = build_pointer_type (type);
+				  }
+				else
+				  type = gfc_sym_type (n->sym);
+				if (POINTER_TYPE_P (type))
+				  type = TREE_TYPE (type);
+				/* Otherwise to be determined what exactly
+				   should be done.  */
+				tree t = fold_convert (sizetype, last_step);
+				t = size_binop (MULT_EXPR, t,
+						TYPE_SIZE_UNIT (type));
+				OMP_CLAUSE_LINEAR_STEP (node) = t;
+			      }
+			    else
+			      {
+				tree type
+				  = gfc_typenode_for_spec (&n->sym->ts);
+				OMP_CLAUSE_LINEAR_STEP (node)
+				  = fold_convert (type, last_step);
+			      }
 			  }
 			if (n->sym->attr.dimension || n->sym->attr.allocatable)
 			  OMP_CLAUSE_LINEAR_ARRAY (node) = 1;
diff -ruN gcc-7.3.0/gcc/fortran/trans-stmt.c gcc-7.3.0-msp430/gcc/fortran/trans-stmt.c
--- gcc-7.3.0/gcc/fortran/trans-stmt.c	2017-11-23 13:02:48.877901000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/trans-stmt.c	2019-06-25 02:27:21.141931133 -0700
@@ -1566,7 +1566,8 @@
 
       desc = sym->backend_decl;
       cst_array_ctor = e->expr_type == EXPR_ARRAY
-	      && gfc_constant_array_constructor_p (e->value.constructor);
+	      && gfc_constant_array_constructor_p (e->value.constructor)
+	      && e->ts.type != BT_CHARACTER;
 
       /* If association is to an expression, evaluate it and create temporary.
 	 Otherwise, get descriptor of target for pointer assignment.  */
diff -ruN gcc-7.3.0/gcc/fortran/trans-types.c gcc-7.3.0-msp430/gcc/fortran/trans-types.c
--- gcc-7.3.0/gcc/fortran/trans-types.c	2017-11-13 12:01:20.128076000 -0800
+++ gcc-7.3.0-msp430/gcc/fortran/trans-types.c	2019-06-25 02:27:21.145931103 -0700
@@ -1804,7 +1804,7 @@
       TREE_NO_WARNING (decl) = 1;
     }
 
-  if (flag_coarray == GFC_FCOARRAY_LIB && codimen)
+  if (flag_coarray == GFC_FCOARRAY_LIB)
     {
       decl = gfc_add_field_to_struct_1 (fat_type,
 					get_identifier ("token"),
@@ -2168,6 +2168,14 @@
   if (sym->backend_decl && !sym->attr.function)
     return TREE_TYPE (sym->backend_decl);
 
+  if (sym->attr.result
+      && sym->ts.type == BT_CHARACTER
+      && sym->ts.u.cl->backend_decl == NULL_TREE
+      && sym->ns->proc_name
+      && sym->ns->proc_name->ts.u.cl
+      && sym->ns->proc_name->ts.u.cl->backend_decl != NULL_TREE)
+    sym->ts.u.cl->backend_decl = sym->ns->proc_name->ts.u.cl->backend_decl;
+
   if (sym->ts.type == BT_CHARACTER
       && ((sym->attr.function && sym->attr.is_bind_c)
 	  || (sym->attr.result
@@ -2334,6 +2342,7 @@
   for (; to_cm; to_cm = to_cm->next, from_cm = from_cm->next)
     {
       to_cm->backend_decl = from_cm->backend_decl;
+      to_cm->caf_token = from_cm->caf_token;
       if (from_cm->ts.type == BT_UNION)
         gfc_get_union_type (to_cm->ts.u.derived);
       else if (from_cm->ts.type == BT_DERIVED
@@ -2444,6 +2453,10 @@
   gfc_dt_list *dt;
   gfc_namespace *ns;
   tree tmp;
+  bool coarray_flag;
+
+  coarray_flag = flag_coarray == GFC_FCOARRAY_LIB
+		 && derived->module && !derived->attr.vtype;
 
   if (derived->attr.unlimited_polymorphic
       || (flag_coarray == GFC_FCOARRAY_LIB
@@ -2636,7 +2649,9 @@
 	  field_type = build_pointer_type (tmp);
 	}
       else if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)
-        field_type = c->ts.u.derived->backend_decl;
+	field_type = c->ts.u.derived->backend_decl;
+      else if (c->attr.caf_token)
+	field_type = pvoid_type_node;
       else
 	{
 	  if (c->ts.type == BT_CHARACTER && !c->ts.deferred)
@@ -2715,19 +2730,6 @@
       gcc_assert (field);
       if (!c->backend_decl)
 	c->backend_decl = field;
-
-      /* Do not add a caf_token field for classes' data components.  */
-      if (codimen && !c->attr.dimension && !c->attr.codimension
-	  && (c->attr.allocatable || c->attr.pointer)
-	  && c->caf_token == NULL_TREE && strcmp ("_data", c->name) != 0)
-	{
-	  char caf_name[GFC_MAX_SYMBOL_LEN];
-	  snprintf (caf_name, GFC_MAX_SYMBOL_LEN, "_caf_%s", c->name);
-	  c->caf_token = gfc_add_field_to_struct (typenode,
-						  get_identifier (caf_name),
-						  pvoid_type_node, &chain);
-	  TREE_NO_WARNING (c->caf_token) = 1;
-	}
     }
 
   /* Now lay out the derived type, including the fields.  */
@@ -2753,6 +2755,24 @@
 
 copy_derived_types:
 
+  for (c = derived->components; c; c = c->next)
+    {
+      /* Do not add a caf_token field for class container components.  */
+      if ((codimen || coarray_flag)
+	  && !c->attr.dimension && !c->attr.codimension
+	  && (c->attr.allocatable || c->attr.pointer)
+	  && !derived->attr.is_class)
+	{
+	  char caf_name[GFC_MAX_SYMBOL_LEN];
+	  gfc_component *token;
+	  snprintf (caf_name, GFC_MAX_SYMBOL_LEN, "_caf_%s", c->name);
+	  token = gfc_find_component (derived, caf_name, true, true, NULL);
+	  gcc_assert (token);
+	  c->caf_token = token->backend_decl;
+	  TREE_NO_WARNING (c->caf_token) = 1;
+	}
+    }
+
   for (dt = gfc_derived_types; dt; dt = dt->next)
     gfc_copy_dt_decls_ifequal (derived, dt->derived, false);
 
diff -ruN gcc-7.3.0/gcc/function.c gcc-7.3.0-msp430/gcc/function.c
--- gcc-7.3.0/gcc/function.c	2017-08-08 06:21:12.755378000 -0700
+++ gcc-7.3.0-msp430/gcc/function.c	2019-06-25 02:27:21.145931103 -0700
@@ -6576,8 +6576,9 @@
       /* Only do the transformation for pseudos.  */
       if (! REG_P (output)
 	  || rtx_equal_p (output, input)
-	  || (GET_MODE (input) != VOIDmode
-	      && GET_MODE (input) != GET_MODE (output)))
+	  || !(REG_P (input) || SUBREG_P (input)
+	       || MEM_P (input) || CONSTANT_P (input))
+	  || !general_operand (input, GET_MODE (output)))
 	continue;
 
       /* We can't do anything if the output is also used as input,
diff -ruN gcc-7.3.0/gcc/gcc.c gcc-7.3.0-msp430/gcc/gcc.c
--- gcc-7.3.0/gcc/gcc.c	2017-09-15 01:18:34.015147000 -0700
+++ gcc-7.3.0-msp430/gcc/gcc.c	2019-06-25 02:27:21.145931103 -0700
@@ -677,7 +677,7 @@
 
 #ifndef LIBASAN_SPEC
 #define STATIC_LIBASAN_LIBS \
-  " %{static-libasan:%:include(libsanitizer.spec)%(link_libasan)}"
+  " %{static-libasan|static:%:include(libsanitizer.spec)%(link_libasan)}"
 #ifdef LIBASAN_EARLY_SPEC
 #define LIBASAN_SPEC STATIC_LIBASAN_LIBS
 #elif defined(HAVE_LD_STATIC_DYNAMIC)
@@ -695,7 +695,7 @@
 
 #ifndef LIBTSAN_SPEC
 #define STATIC_LIBTSAN_LIBS \
-  " %{static-libtsan:%:include(libsanitizer.spec)%(link_libtsan)}"
+  " %{static-libtsan|static:%:include(libsanitizer.spec)%(link_libtsan)}"
 #ifdef LIBTSAN_EARLY_SPEC
 #define LIBTSAN_SPEC STATIC_LIBTSAN_LIBS
 #elif defined(HAVE_LD_STATIC_DYNAMIC)
@@ -713,7 +713,7 @@
 
 #ifndef LIBLSAN_SPEC
 #define STATIC_LIBLSAN_LIBS \
-  " %{static-liblsan:%:include(libsanitizer.spec)%(link_liblsan)}"
+  " %{static-liblsan|static:%:include(libsanitizer.spec)%(link_liblsan)}"
 #ifdef LIBLSAN_EARLY_SPEC
 #define LIBLSAN_SPEC STATIC_LIBLSAN_LIBS
 #elif defined(HAVE_LD_STATIC_DYNAMIC)
@@ -731,7 +731,7 @@
 
 #ifndef LIBUBSAN_SPEC
 #define STATIC_LIBUBSAN_LIBS \
-  " %{static-libubsan:%:include(libsanitizer.spec)%(link_libubsan)}"
+  " %{static-libubsan|static:%:include(libsanitizer.spec)%(link_libubsan)}"
 #ifdef HAVE_LD_STATIC_DYNAMIC
 #define LIBUBSAN_SPEC "%{static-libubsan:" LD_STATIC_OPTION \
 		     "} -lubsan %{static-libubsan:" LD_DYNAMIC_OPTION "}" \
@@ -6970,8 +6970,8 @@
 
     /* In final attempt we append compiler options and preprocesssed code to last
        generated .out file with configuration and backtrace.  */
-    char **output = &temp_stdout_files[RETRY_ICE_ATTEMPTS - 1];
-    do_report_bug (new_argv, nargs, stderr_commented, output);
+    char **err = &temp_stderr_files[RETRY_ICE_ATTEMPTS - 1];
+    do_report_bug (new_argv, nargs, stderr_commented, err);
   }
 
 out:
diff -ruN gcc-7.3.0/gcc/genmatch.c gcc-7.3.0-msp430/gcc/genmatch.c
--- gcc-7.3.0/gcc/genmatch.c	2017-04-04 12:14:47.739247000 -0700
+++ gcc-7.3.0-msp430/gcc/genmatch.c	2019-06-25 02:27:21.145931103 -0700
@@ -2054,7 +2054,11 @@
       if (c->what
 	  && (e = dyn_cast <expr *> (c->what)))
 	{
-	  info[where].expr_p = true;
+	  /* Zero-operand expression captures like ADDR_EXPR@0 are
+	     similar as predicates -- if they are not mentioned in
+	     the result we have to force them to have no side-effects.  */
+	  if (e->ops.length () != 0)
+	    info[where].expr_p = true;
 	  info[where].force_single_use |= e->force_single_use;
 	}
     }
diff -ruN gcc-7.3.0/gcc/genmodes.c gcc-7.3.0-msp430/gcc/genmodes.c
--- gcc-7.3.0/gcc/genmodes.c	2017-03-24 07:09:33.117713000 -0700
+++ gcc-7.3.0-msp430/gcc/genmodes.c	2019-06-25 02:27:21.145931103 -0700
@@ -116,6 +116,7 @@
   switch (c)
     {
     case MODE_INT: return MODE_COMPLEX_INT;
+    case MODE_PARTIAL_INT: return MODE_COMPLEX_INT;
     case MODE_FLOAT: return MODE_COMPLEX_FLOAT;
     default:
       error ("no complex class for class %s", mode_class_names[c]);
diff -ruN gcc-7.3.0/gcc/gimple-ssa-backprop.c gcc-7.3.0-msp430/gcc/gimple-ssa-backprop.c
--- gcc-7.3.0/gcc/gimple-ssa-backprop.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/gimple-ssa-backprop.c	2019-06-25 02:27:21.145931103 -0700
@@ -260,6 +260,11 @@
      post-order walk.  */
   auto_sbitmap m_visited_blocks;
 
+  /* A bitmap of phis that we have finished processing in the initial
+     post-order walk, excluding those from blocks mentioned in
+     M_VISITED_BLOCKS.  */
+  auto_bitmap m_visited_phis;
+
   /* A worklist of SSA names whose definitions need to be reconsidered.  */
   auto_vec <tree, 64> m_worklist;
 
@@ -500,8 +505,11 @@
     {
       if (is_gimple_debug (stmt))
 	continue;
-      if (is_a <gphi *> (stmt)
-	  && !bitmap_bit_p (m_visited_blocks, gimple_bb (stmt)->index))
+      gphi *phi = dyn_cast <gphi *> (stmt);
+      if (phi
+	  && !bitmap_bit_p (m_visited_blocks, gimple_bb (phi)->index)
+	  && !bitmap_bit_p (m_visited_phis,
+			    SSA_NAME_VERSION (gimple_phi_result (phi))))
 	{
 	  /* Skip unprocessed phis.  */
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -509,7 +517,7 @@
 	      fprintf (dump_file, "[BACKEDGE] ");
 	      print_generic_expr (dump_file, var, 0);
 	      fprintf (dump_file, " in ");
-	      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);
+	      print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);
 	    }
 	}
       else
@@ -633,7 +641,12 @@
     }
   for (gphi_iterator gpi = gsi_start_phis (bb); !gsi_end_p (gpi);
        gsi_next (&gpi))
-    process_var (gimple_phi_result (gpi.phi ()));
+    {
+      tree result = gimple_phi_result (gpi.phi ());
+      process_var (result);
+      bitmap_set_bit (m_visited_phis, SSA_NAME_VERSION (result));
+    }
+  bitmap_clear (m_visited_phis);
 }
 
 /* Delete the definition of VAR, which has no uses.  */
diff -ruN gcc-7.3.0/gcc/gimple-ssa-store-merging.c gcc-7.3.0-msp430/gcc/gimple-ssa-store-merging.c
--- gcc-7.3.0/gcc/gimple-ssa-store-merging.c	2017-03-17 06:14:42.514280000 -0700
+++ gcc-7.3.0-msp430/gcc/gimple-ssa-store-merging.c	2019-06-25 02:27:21.145931103 -0700
@@ -812,12 +812,14 @@
 	{
 	  struct store_immediate_info *info;
 	  unsigned int i;
+	  tree store_lhs
+	    = gimple_store_p (stmt) ? gimple_get_lhs (stmt) : NULL_TREE;
 	  FOR_EACH_VEC_ELT ((*chain_info)->m_store_info, i, info)
 	    {
-	      if (ref_maybe_used_by_stmt_p (stmt,
-					    gimple_assign_lhs (info->stmt))
-		  || stmt_may_clobber_ref_p (stmt,
-					     gimple_assign_lhs (info->stmt)))
+	      tree lhs = gimple_assign_lhs (info->stmt);
+	      if (ref_maybe_used_by_stmt_p (stmt, lhs)
+		  || stmt_may_clobber_ref_p (stmt, lhs)
+		  || (store_lhs && refs_output_dependent_p (store_lhs, lhs)))
 		{
 		  if (dump_file && (dump_flags & TDF_DETAILS))
 		    {
diff -ruN gcc-7.3.0/gcc/gimple-ssa-strength-reduction.c gcc-7.3.0-msp430/gcc/gimple-ssa-strength-reduction.c
--- gcc-7.3.0/gcc/gimple-ssa-strength-reduction.c	2017-10-02 11:07:45.320595000 -0700
+++ gcc-7.3.0-msp430/gcc/gimple-ssa-strength-reduction.c	2019-06-25 02:27:21.145931103 -0700
@@ -55,6 +55,7 @@
 #include "params.h"
 #include "tree-ssa-address.h"
 #include "tree-affine.h"
+#include "tree-eh.h"
 #include "builtins.h"
 
 /* Information about a strength reduction candidate.  Each statement
@@ -265,6 +266,10 @@
      of a statement.  */
   cand_idx next_interp;
 
+  /* Index of the first candidate record in a chain for the same
+     statement.  */
+  cand_idx first_interp;
+
   /* Index of the basis statement S0, if any, in the candidate vector.  */
   cand_idx basis;
 
@@ -642,6 +647,7 @@
   c->kind = kind;
   c->cand_num = cand_vec.length () + 1;
   c->next_interp = 0;
+  c->first_interp = c->cand_num;
   c->dependent = 0;
   c->sibling = 0;
   c->def_phi = kind == CAND_MULT ? find_phi_def (base) : 0;
@@ -1212,6 +1218,7 @@
 	 is the stride and RHS2 is the base expression.  */
       c2 = create_mul_ssa_cand (gs, rhs2, rhs1, speed);
       c->next_interp = c2->cand_num;
+      c2->first_interp = c->cand_num;
     }
   else
     {
@@ -1449,7 +1456,10 @@
 	{
 	  c2 = create_add_ssa_cand (gs, rhs2, rhs1, false, speed);
 	  if (c)
-	    c->next_interp = c2->cand_num;
+	    {
+	      c->next_interp = c2->cand_num;
+	      c2->first_interp = c->cand_num;
+	    }
 	  else
 	    add_cand_for_stmt (gs, c2);
 	}
@@ -1572,6 +1582,8 @@
 
   if (base_cand && base_cand->kind != CAND_PHI)
     {
+      slsr_cand_t first_cand = NULL;
+
       while (base_cand)
 	{
 	  /* Propagate all data from the base candidate except the type,
@@ -1586,6 +1598,12 @@
 					 base_cand->index, base_cand->stride,
 					 ctype, base_cand->stride_type,
 					 savings);
+	  if (!first_cand)
+	    first_cand = c;
+
+	  if (first_cand != c)
+	    c->first_interp = first_cand->cand_num;
+
 	  if (base_cand->next_interp)
 	    base_cand = lookup_cand (base_cand->next_interp);
 	  else
@@ -1608,6 +1626,7 @@
       c2 = alloc_cand_and_find_basis (CAND_MULT, gs, rhs1, 0,
 				      integer_one_node, ctype, sizetype, 0);
       c->next_interp = c2->cand_num;
+      c2->first_interp = c->cand_num;
     }
 
   /* Add the first (or only) interpretation to the statement-candidate
@@ -1632,6 +1651,8 @@
 
   if (base_cand && base_cand->kind != CAND_PHI)
     {
+      slsr_cand_t first_cand = NULL;
+
       while (base_cand)
 	{
 	  /* Propagate all data from the base candidate.  */
@@ -1644,6 +1665,12 @@
 					 base_cand->index, base_cand->stride,
 					 base_cand->cand_type,
 					 base_cand->stride_type, savings);
+	  if (!first_cand)
+	    first_cand = c;
+
+	  if (first_cand != c)
+	    c->first_interp = first_cand->cand_num;
+
 	  if (base_cand->next_interp)
 	    base_cand = lookup_cand (base_cand->next_interp);
 	  else
@@ -1668,6 +1695,7 @@
 				      integer_one_node, TREE_TYPE (rhs1),
 				      sizetype, 0);
       c->next_interp = c2->cand_num;
+      c2->first_interp = c->cand_num;
     }
 
   /* Add the first (or only) interpretation to the statement-candidate
@@ -1699,6 +1727,9 @@
     {
       gimple *gs = gsi_stmt (gsi);
 
+      if (stmt_could_throw_p (gs))
+	continue;
+
       if (gimple_vuse (gs) && gimple_assign_single_p (gs))
 	slsr_process_ref (gs);
 
@@ -1835,8 +1866,9 @@
   print_generic_expr (dump_file, c->cand_type, 0);
   fprintf (dump_file, "\n     basis: %d  dependent: %d  sibling: %d\n",
 	   c->basis, c->dependent, c->sibling);
-  fprintf (dump_file, "     next-interp: %d  dead-savings: %d\n",
-	   c->next_interp, c->dead_savings);
+  fprintf (dump_file,
+	   "     next-interp: %d  first-interp: %d  dead-savings: %d\n",
+	   c->next_interp, c->first_interp, c->dead_savings);
   if (c->def_phi)
     fprintf (dump_file, "     phi:  %d\n", c->def_phi);
   fputs ("\n", dump_file);
@@ -2094,14 +2126,13 @@
       tree lhs = gimple_assign_lhs (c->cand_stmt);
       gassign *copy_stmt = gimple_build_assign (lhs, basis_name);
       gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-      slsr_cand_t cc = c;
+      slsr_cand_t cc = lookup_cand (c->first_interp);
       gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));
       gsi_replace (&gsi, copy_stmt, false);
-      c->cand_stmt = copy_stmt;
-      while (cc->next_interp)
+      while (cc)
 	{
-	  cc = lookup_cand (cc->next_interp);
 	  cc->cand_stmt = copy_stmt;
+	  cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	}
       if (dump_file && (dump_flags & TDF_DETAILS))
 	stmt_to_print = copy_stmt;
@@ -2128,15 +2159,14 @@
       else
 	{
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-	  slsr_cand_t cc = c;
+	  slsr_cand_t cc = lookup_cand (c->first_interp);
 	  gimple_assign_set_rhs_with_ops (&gsi, code,
 					  basis_name, bump_tree);
 	  update_stmt (gsi_stmt (gsi));
-	  c->cand_stmt = gsi_stmt (gsi);
-	  while (cc->next_interp)
+	  while (cc)
 	    {
-	      cc = lookup_cand (cc->next_interp);
 	      cc->cand_stmt = gsi_stmt (gsi);
+	      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	    }
 	  if (dump_file && (dump_flags & TDF_DETAILS))
 	    stmt_to_print = gsi_stmt (gsi);
@@ -3422,14 +3452,13 @@
 	      || !operand_equal_p (new_rhs2, old_rhs1, 0))))
     {
       gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-      slsr_cand_t cc = c;
+      slsr_cand_t cc = lookup_cand (c->first_interp);
       gimple_assign_set_rhs_with_ops (&gsi, new_code, new_rhs1, new_rhs2);
       update_stmt (gsi_stmt (gsi));
-      c->cand_stmt = gsi_stmt (gsi);
-      while (cc->next_interp)
+      while (cc)
 	{
-	  cc = lookup_cand (cc->next_interp);
 	  cc->cand_stmt = gsi_stmt (gsi);
+	  cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	}
 
       if (dump_file && (dump_flags & TDF_DETAILS))
@@ -3462,6 +3491,11 @@
   orig_rhs2 = gimple_assign_rhs2 (c->cand_stmt);
   cand_incr = cand_increment (c);
 
+  /* If orig_rhs2 is NULL, we have already replaced this in situ with
+     a copy statement under another interpretation.  */
+  if (!orig_rhs2)
+    return;
+
   if (dump_file && (dump_flags & TDF_DETAILS))
     {
       fputs ("Replacing: ", dump_file);
@@ -3534,14 +3568,13 @@
 	  || !operand_equal_p (rhs2, orig_rhs2, 0))
 	{
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-	  slsr_cand_t cc = c;
+	  slsr_cand_t cc = lookup_cand (c->first_interp);
 	  gimple_assign_set_rhs_with_ops (&gsi, MINUS_EXPR, basis_name, rhs2);
 	  update_stmt (gsi_stmt (gsi));
-          c->cand_stmt = gsi_stmt (gsi);
-	  while (cc->next_interp)
+	  while (cc)
 	    {
-	      cc = lookup_cand (cc->next_interp);
 	      cc->cand_stmt = gsi_stmt (gsi);
+	      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	    }
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -3561,14 +3594,13 @@
 	{
 	  gassign *copy_stmt = gimple_build_assign (lhs, basis_name);
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-	  slsr_cand_t cc = c;
+	  slsr_cand_t cc = lookup_cand (c->first_interp);
 	  gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));
 	  gsi_replace (&gsi, copy_stmt, false);
-	  c->cand_stmt = copy_stmt;
-	  while (cc->next_interp)
+	  while (cc)
 	    {
-	      cc = lookup_cand (cc->next_interp);
 	      cc->cand_stmt = copy_stmt;
+	      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	    }
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -3578,14 +3610,13 @@
 	{
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
 	  gassign *cast_stmt = gimple_build_assign (lhs, NOP_EXPR, basis_name);
-	  slsr_cand_t cc = c;
+	  slsr_cand_t cc = lookup_cand (c->first_interp);
 	  gimple_set_location (cast_stmt, gimple_location (c->cand_stmt));
 	  gsi_replace (&gsi, cast_stmt, false);
-	  c->cand_stmt = cast_stmt;
-	  while (cc->next_interp)
+	  while (cc)
 	    {
-	      cc = lookup_cand (cc->next_interp);
 	      cc->cand_stmt = cast_stmt;
+	      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	    }
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
diff -ruN gcc-7.3.0/gcc/gimplify.c gcc-7.3.0-msp430/gcc/gimplify.c
--- gcc-7.3.0/gcc/gimplify.c	2017-11-21 08:02:04.713777000 -0800
+++ gcc-7.3.0-msp430/gcc/gimplify.c	2019-06-25 02:27:21.145931103 -0700
@@ -1125,10 +1125,6 @@
 asan_poison_variable (tree decl, bool poison, gimple_stmt_iterator *it,
 		      bool before)
 {
-  /* When within an OMP context, do not emit ASAN_MARK internal fns.  */
-  if (gimplify_omp_ctxp)
-    return;
-
   tree unit_size = DECL_SIZE_UNIT (decl);
   tree base = build_fold_addr_expr (decl);
 
@@ -1640,7 +1636,8 @@
 	  && TREE_ADDRESSABLE (decl)
 	  && !TREE_STATIC (decl)
 	  && !DECL_HAS_VALUE_EXPR_P (decl)
-	  && dbg_cnt (asan_use_after_scope))
+	  && dbg_cnt (asan_use_after_scope)
+	  && !gimplify_omp_ctxp)
 	{
 	  asan_poisoned_variables->add (decl);
 	  asan_poison_variable (decl, false, seq_p);
@@ -4684,7 +4681,7 @@
 	     objects.  Initializers for such objects must explicitly set
 	     every field that needs to be set.  */
 	  cleared = false;
-	else if (!complete_p && !CONSTRUCTOR_NO_CLEARING (ctor))
+	else if (!complete_p)
 	  /* If the constructor isn't complete, clear the whole object
 	     beforehand, unless CONSTRUCTOR_NO_CLEARING is set on it.
 
@@ -4693,7 +4690,7 @@
 	     we'd need to *find* the elements that are not present, and that
 	     requires trickery to avoid quadratic compile-time behavior in
 	     large cases or excessive memory use in small cases.  */
-	  cleared = true;
+	  cleared = !CONSTRUCTOR_NO_CLEARING (ctor);
 	else if (num_ctor_elements - num_nonzero_elements
 		 > CLEAR_RATIO (optimize_function_for_speed_p (cfun))
 		 && num_nonzero_elements < num_ctor_elements / 4)
@@ -5776,8 +5773,11 @@
 	}
       else
 	/* The temporary may not be an SSA name as later abnormal and EH
-	   control flow may invalidate use/def domination.  */
-	val = get_initialized_tmp_var (val, pre_p, post_p, false);
+	   control flow may invalidate use/def domination.  When in SSA
+	   form then assume there are no such issues and SAVE_EXPRs only
+	   appear via GENERIC foldings.  */
+	val = get_initialized_tmp_var (val, pre_p, post_p,
+				       gimple_in_ssa_p (cfun));
 
       TREE_OPERAND (*expr_p, 0) = val;
       SAVE_EXPR_RESOLVED_P (*expr_p) = 1;
@@ -6458,7 +6458,8 @@
 	      clobber = build2 (MODIFY_EXPR, TREE_TYPE (temp), temp, clobber);
 	      gimple_push_cleanup (temp, clobber, false, pre_p, true);
 	    }
-	  if (asan_poisoned_variables && dbg_cnt (asan_use_after_scope))
+	  if (asan_poisoned_variables && dbg_cnt (asan_use_after_scope)
+	      && !gimplify_omp_ctxp)
 	    {
 	      tree asan_cleanup = build_asan_poison_call_expr (temp);
 	      if (asan_cleanup)
diff -ruN gcc-7.3.0/gcc/go/go-gcc.cc gcc-7.3.0-msp430/gcc/go/go-gcc.cc
--- gcc-7.3.0/gcc/go/go-gcc.cc	2017-05-11 16:53:13.232065000 -0700
+++ gcc-7.3.0-msp430/gcc/go/go-gcc.cc	2019-06-25 02:27:21.145931103 -0700
@@ -3032,7 +3032,7 @@
     DECL_UNINLINABLE(decl) = 1;
   if (disable_split_stack)
     {
-      tree attr = get_identifier("__no_split_stack__");
+      tree attr = get_identifier ("no_split_stack");
       DECL_ATTRIBUTES(decl) = tree_cons(attr, NULL_TREE, NULL_TREE);
     }
   if (in_unique_section)
diff -ruN gcc-7.3.0/gcc/graphite.h gcc-7.3.0-msp430/gcc/graphite.h
--- gcc-7.3.0/gcc/graphite.h	2017-02-15 23:53:53.972258000 -0800
+++ gcc-7.3.0-msp430/gcc/graphite.h	2019-06-25 02:27:21.149931075 -0700
@@ -37,6 +37,8 @@
 #include <isl/schedule.h>
 #include <isl/ast_build.h>
 #include <isl/schedule_node.h>
+#include <isl/id.h>
+#include <isl/space.h>
 
 typedef struct poly_dr *poly_dr_p;
 
diff -ruN gcc-7.3.0/gcc/hsa-gen.c gcc-7.3.0-msp430/gcc/hsa-gen.c
--- gcc-7.3.0/gcc/hsa-gen.c	2017-02-28 00:42:06.321121000 -0800
+++ gcc-7.3.0-msp430/gcc/hsa-gen.c	2019-06-25 02:27:21.149931075 -0700
@@ -917,9 +917,13 @@
 	  else if (lookup_attribute ("hsa_group_segment",
 				     DECL_ATTRIBUTES (decl)))
 	    segment = BRIG_SEGMENT_GROUP;
-	  else if (TREE_STATIC (decl)
-		   || lookup_attribute ("hsa_global_segment",
-					DECL_ATTRIBUTES (decl)))
+	  else if (TREE_STATIC (decl))
+	    {
+	      segment = BRIG_SEGMENT_GLOBAL;
+	      allocation = BRIG_ALLOCATION_PROGRAM;
+	    }
+	  else if (lookup_attribute ("hsa_global_segment",
+				     DECL_ATTRIBUTES (decl)))
 	    segment = BRIG_SEGMENT_GLOBAL;
 	  else
 	    segment = BRIG_SEGMENT_PRIVATE;
diff -ruN gcc-7.3.0/gcc/ipa-cp.c gcc-7.3.0-msp430/gcc/ipa-cp.c
--- gcc-7.3.0/gcc/ipa-cp.c	2017-11-29 14:13:34.210836000 -0800
+++ gcc-7.3.0-msp430/gcc/ipa-cp.c	2019-06-25 02:27:21.149931075 -0700
@@ -621,6 +621,24 @@
       reason = "calls comdat-local function";
     }
 
+  /* Functions calling BUILT_IN_VA_ARG_PACK and BUILT_IN_VA_ARG_PACK_LEN
+     works only when inlined.  Cloning them may still lead to better code
+     becuase ipa-cp will not give up on cloning further.  If the function is
+     external this however leads to wrong code becuase we may end up producing
+     offline copy of the function.  */
+  if (DECL_EXTERNAL (node->decl))
+    for (cgraph_edge *edge = node->callees; !reason && edge;
+	 edge = edge->next_callee)
+      if (DECL_BUILT_IN (edge->callee->decl)
+	  && DECL_BUILT_IN_CLASS (edge->callee->decl) == BUILT_IN_NORMAL)
+        {
+	  if (DECL_FUNCTION_CODE (edge->callee->decl) == BUILT_IN_VA_ARG_PACK)
+	    reason = "external function which calls va_arg_pack";
+	  if (DECL_FUNCTION_CODE (edge->callee->decl)
+	      == BUILT_IN_VA_ARG_PACK_LEN)
+	    reason = "external function which calls va_arg_pack_len";
+        }
+
   if (reason && dump_file && !node->alias && !node->thunk.thunk_p)
     fprintf (dump_file, "Function %s/%i is not versionable, reason: %s.\n",
 	     node->name (), node->order, reason);
@@ -4009,7 +4027,9 @@
 	  if (aglat->offset - offset == item->offset)
 	    {
 	      gcc_checking_assert (item->value);
-	      if (values_equal_for_ipcp_p (item->value, aglat->values->value))
+	      if (aglat->is_single_const ()
+		  && values_equal_for_ipcp_p (item->value,
+					      aglat->values->value))
 		found = true;
 	      break;
 	    }
diff -ruN gcc-7.3.0/gcc/ipa-devirt.c gcc-7.3.0-msp430/gcc/ipa-devirt.c
--- gcc-7.3.0/gcc/ipa-devirt.c	2017-06-22 04:39:26.186311000 -0700
+++ gcc-7.3.0-msp430/gcc/ipa-devirt.c	2019-06-25 02:27:21.149931075 -0700
@@ -1577,8 +1577,15 @@
 				 "in another translation unit"));
 		    return false;
 		  }
-		gcc_assert (DECL_NONADDRESSABLE_P (f1)
-			    == DECL_NONADDRESSABLE_P (f2));
+		if (DECL_BIT_FIELD (f1) != DECL_BIT_FIELD (f2))
+		  {
+		    warn_odr (t1, t2, f1, f2, warn, warned,
+			      G_("one field is bitfield while other is not"));
+		    return false;
+		  }
+		else
+		  gcc_assert (DECL_NONADDRESSABLE_P (f1)
+			      == DECL_NONADDRESSABLE_P (f2));
 	      }
 
 	    /* If one aggregate has more fields than the other, they
diff -ruN gcc-7.3.0/gcc/ipa-icf.c gcc-7.3.0-msp430/gcc/ipa-icf.c
--- gcc-7.3.0/gcc/ipa-icf.c	2018-01-17 03:46:31.433130000 -0800
+++ gcc-7.3.0-msp430/gcc/ipa-icf.c	2019-06-25 02:27:21.149931075 -0700
@@ -2132,23 +2132,6 @@
   return m_hash;
 }
 
-/* Set all points-to UIDs of aliases pointing to node N as UID.  */
-
-static void
-set_alias_uids (symtab_node *n, int uid)
-{
-  ipa_ref *ref;
-  FOR_EACH_ALIAS (n, ref)
-    {
-      if (dump_file)
-	fprintf (dump_file, "  Setting points-to UID of [%s] as %d\n",
-		 xstrdup_for_dump (ref->referring->asm_name ()), uid);
-
-      SET_DECL_PT_UID (ref->referring->decl, uid);
-      set_alias_uids (ref->referring, uid);
-    }
-}
-
 /* Merges instance with an ALIAS_ITEM, where alias, thunk or redirection can
    be applied.  */
 
@@ -2275,7 +2258,6 @@
       if (dump_file)
 	fprintf (dump_file, "Unified; Variable alias has been created.\n");
 
-      set_alias_uids (original, DECL_UID (original->decl));
       return true;
     }
 }
@@ -2295,7 +2277,7 @@
 
 sem_item_optimizer::sem_item_optimizer ()
 : worklist (0), m_classes (0), m_classes_count (0), m_cgraph_node_hooks (NULL),
-  m_varpool_node_hooks (NULL)
+  m_varpool_node_hooks (NULL), m_merged_variables ()
 {
   m_items.create (0);
   bitmap_obstack_initialize (&m_bmstack);
@@ -2320,6 +2302,7 @@
   m_items.release ();
 
   bitmap_obstack_release (&m_bmstack);
+  m_merged_variables.release ();
 }
 
 /* Write IPA ICF summary for symbols.  */
@@ -3571,13 +3554,103 @@
 	      }
 
 	    if (dbg_cnt (merged_ipa_icf))
-	      merged_p |= source->merge (alias);
+	      {
+		bool merged = source->merge (alias);
+		merged_p |= merged;
+
+		if (merged && alias->type == VAR)
+		  {
+		    symtab_pair p = symtab_pair (source->node, alias->node);
+		    m_merged_variables.safe_push (p);
+		  }
+	      }
 	  }
       }
 
+  if (!m_merged_variables.is_empty ())
+    fixup_points_to_sets ();
+
   return merged_p;
 }
 
+/* Fixup points to set PT.  */
+
+void
+sem_item_optimizer::fixup_pt_set (struct pt_solution *pt)
+{
+  if (pt->vars == NULL)
+    return;
+
+  unsigned i;
+  symtab_pair *item;
+  FOR_EACH_VEC_ELT (m_merged_variables, i, item)
+    if (bitmap_bit_p (pt->vars, DECL_UID (item->second->decl)))
+      bitmap_set_bit (pt->vars, DECL_UID (item->first->decl));
+}
+
+/* Set all points-to UIDs of aliases pointing to node N as UID.  */
+
+static void
+set_alias_uids (symtab_node *n, int uid)
+{
+  ipa_ref *ref;
+  FOR_EACH_ALIAS (n, ref)
+    {
+      if (dump_file)
+	fprintf (dump_file, "  Setting points-to UID of [%s] as %d\n",
+		 xstrdup_for_dump (ref->referring->asm_name ()), uid);
+
+      SET_DECL_PT_UID (ref->referring->decl, uid);
+      set_alias_uids (ref->referring, uid);
+    }
+}
+
+/* Fixup points to analysis info.  */
+
+void
+sem_item_optimizer::fixup_points_to_sets (void)
+{
+  /* TODO: remove in GCC 9 and trigger PTA re-creation after IPA passes.  */
+  cgraph_node *cnode;
+
+  FOR_EACH_DEFINED_FUNCTION (cnode)
+    {
+      tree name;
+      unsigned i;
+      function *fn = DECL_STRUCT_FUNCTION (cnode->decl);
+      if (!gimple_in_ssa_p (fn))
+	continue;
+
+      FOR_EACH_SSA_NAME (i, name, fn)
+	if (POINTER_TYPE_P (TREE_TYPE (name))
+	    && SSA_NAME_PTR_INFO (name))
+	  fixup_pt_set (&SSA_NAME_PTR_INFO (name)->pt);
+      fixup_pt_set (&fn->gimple_df->escaped);
+
+       /* The above get's us to 99% I guess, at least catching the
+	  address compares.  Below also gets us aliasing correct
+	  but as said we're giving leeway to the situation with
+	  readonly vars anyway, so ... */
+       basic_block bb;
+       FOR_EACH_BB_FN (bb, fn)
+	for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);
+	     gsi_next (&gsi))
+	  {
+	    gcall *call = dyn_cast<gcall *> (gsi_stmt (gsi));
+	    if (call)
+	      {
+		fixup_pt_set (gimple_call_use_set (call));
+		fixup_pt_set (gimple_call_clobber_set (call));
+	      }
+	  }
+    }
+
+  unsigned i;
+  symtab_pair *item;
+  FOR_EACH_VEC_ELT (m_merged_variables, i, item)
+    set_alias_uids (item->first, DECL_UID (item->first->decl));
+}
+
 /* Dump function prints all class members to a FILE with an INDENT.  */
 
 void
diff -ruN gcc-7.3.0/gcc/ipa-icf.h gcc-7.3.0-msp430/gcc/ipa-icf.h
--- gcc-7.3.0/gcc/ipa-icf.h	2017-01-10 06:37:55.952529000 -0800
+++ gcc-7.3.0-msp430/gcc/ipa-icf.h	2019-06-25 02:27:21.149931075 -0700
@@ -141,6 +141,8 @@
   unsigned int index;
 };
 
+typedef std::pair<symtab_node *, symtab_node *> symtab_pair;
+
 /* Semantic item is a base class that encapsulates all shared functionality
    for both semantic function and variable items.  */
 class sem_item
@@ -563,6 +565,12 @@
      processed.  */
   bool merge_classes (unsigned int prev_class_count);
 
+  /* Fixup points to analysis info.  */
+  void fixup_points_to_sets (void);
+
+  /* Fixup points to set PT.  */
+  void fixup_pt_set (struct pt_solution *pt);
+
   /* Adds a newly created congruence class CLS to worklist.  */
   void worklist_push (congruence_class *cls);
 
@@ -632,6 +640,10 @@
 
   /* Bitmap stack.  */
   bitmap_obstack m_bmstack;
+
+  /* Vector of merged variables.  Needed for fixup of points-to-analysis
+     info.  */
+  vec <symtab_pair> m_merged_variables;
 }; // class sem_item_optimizer
 
 } // ipa_icf namespace
diff -ruN gcc-7.3.0/gcc/ipa-inline.c gcc-7.3.0-msp430/gcc/ipa-inline.c
--- gcc-7.3.0/gcc/ipa-inline.c	2017-12-22 00:50:30.982989000 -0800
+++ gcc-7.3.0-msp430/gcc/ipa-inline.c	2019-06-25 02:27:21.149931075 -0700
@@ -1773,7 +1773,7 @@
 		struct cgraph_node *n2;
 		int id = dfs->scc_no + 1;
 		for (n2 = node; n2;
-		     n2 = ((struct ipa_dfs_info *) node->aux)->next_cycle)
+		     n2 = ((struct ipa_dfs_info *) n2->aux)->next_cycle)
 		  {
 		    struct inline_summary *info2 = inline_summaries->get (n2);
 		    if (info2->scc_no)
diff -ruN gcc-7.3.0/gcc/ipa-prop.c gcc-7.3.0-msp430/gcc/ipa-prop.c
--- gcc-7.3.0/gcc/ipa-prop.c	2017-06-29 01:53:27.821728000 -0700
+++ gcc-7.3.0-msp430/gcc/ipa-prop.c	2019-06-25 02:27:21.149931075 -0700
@@ -111,12 +111,13 @@
   typedef value_range *compare_type;
   static hashval_t
   hash (const value_range *p)
-  {
-    gcc_checking_assert (!p->equiv);
-    hashval_t t = (hashval_t) p->type;
-    t = iterative_hash_expr (p->min, t);
-    return iterative_hash_expr (p->max, t);
-  }
+    {
+      gcc_checking_assert (!p->equiv);
+      inchash::hash hstate (p->type);
+      hstate.add_ptr (p->min);
+      hstate.add_ptr (p->max);
+      return hstate.end ();
+    }
   static bool
   equal (const value_range *a, const value_range *b)
     {
@@ -4352,8 +4353,7 @@
 
 	  gcc_checking_assert (adj->offset % BITS_PER_UNIT == 0);
 	  base = gimple_call_arg (stmt, adj->base_index);
-	  loc = DECL_P (base) ? DECL_SOURCE_LOCATION (base)
-			      : EXPR_LOCATION (base);
+	  loc = gimple_location (stmt);
 
 	  if (TREE_CODE (base) != ADDR_EXPR
 	      && POINTER_TYPE_P (TREE_TYPE (base)))
@@ -4445,6 +4445,7 @@
 		  else
 		    expr = create_tmp_reg (TREE_TYPE (expr));
 		  gimple_assign_set_lhs (tem, expr);
+		  gimple_set_location (tem, loc);
 		  gsi_insert_before (&gsi, tem, GSI_SAME_STMT);
 		}
 	    }
diff -ruN gcc-7.3.0/gcc/ipa-utils.c gcc-7.3.0-msp430/gcc/ipa-utils.c
--- gcc-7.3.0/gcc/ipa-utils.c	2017-03-14 05:47:42.745690000 -0700
+++ gcc-7.3.0-msp430/gcc/ipa-utils.c	2019-06-25 02:27:21.149931075 -0700
@@ -404,6 +404,8 @@
 
   if (!dst->count)
     return;
+  if (!src->count || src->alias)
+    return;
   if (symtab->dump_file)
     {
       fprintf (symtab->dump_file, "Merging profiles of %s/%i to %s/%i\n",
diff -ruN gcc-7.3.0/gcc/loop-unroll.c gcc-7.3.0-msp430/gcc/loop-unroll.c
--- gcc-7.3.0/gcc/loop-unroll.c	2017-04-25 00:27:47.460843000 -0700
+++ gcc-7.3.0-msp430/gcc/loop-unroll.c	2019-06-25 02:27:21.149931075 -0700
@@ -477,7 +477,7 @@
 
   exit_mod = niter % (max_unroll + 1);
 
-  auto_sbitmap wont_exit (max_unroll + 1);
+  auto_sbitmap wont_exit (max_unroll + 2);
   bitmap_ones (wont_exit);
 
   auto_vec<edge> remove_edges;
diff -ruN gcc-7.3.0/gcc/lower-subreg.c gcc-7.3.0-msp430/gcc/lower-subreg.c
--- gcc-7.3.0/gcc/lower-subreg.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/lower-subreg.c	2019-06-25 02:27:21.149931075 -0700
@@ -490,7 +490,16 @@
 	     were the same number and size of pieces.  Hopefully this
 	     doesn't happen much.  */
 
-	  if (outer_words == 1 && inner_words > 1)
+	  if (outer_words == 1
+	      && inner_words > 1
+	      /* Don't allow to decompose floating point subregs of
+		 multi-word pseudos if the floating point mode does
+		 not have word size, because otherwise we'd generate
+		 a subreg with that floating mode from a different
+		 sized integral pseudo which is not allowed by
+		 validate_subreg.  */
+	      && (!FLOAT_MODE_P (GET_MODE (x))
+		  || outer_size == UNITS_PER_WORD))
 	    {
 	      bitmap_set_bit (decomposable_context, regno);
 	      iter.skip_subrtxes ();
diff -ruN gcc-7.3.0/gcc/lra.c gcc-7.3.0-msp430/gcc/lra.c
--- gcc-7.3.0/gcc/lra.c	2017-04-03 15:30:56.274463000 -0700
+++ gcc-7.3.0-msp430/gcc/lra.c	2019-06-25 02:27:21.153931047 -0700
@@ -946,7 +946,7 @@
   data = XNEW (struct lra_insn_recog_data);
   lra_insn_recog_data[uid] = data;
   data->insn = insn;
-  data->used_insn_alternative = -1;
+  data->used_insn_alternative = LRA_UNKNOWN_ALT;
   data->icode = icode;
   data->regs = NULL;
   if (DEBUG_INSN_P (insn))
@@ -1187,7 +1187,7 @@
       return data;
     }
   insn_static_data = data->insn_static_data;
-  data->used_insn_alternative = -1;
+  data->used_insn_alternative = LRA_UNKNOWN_ALT;
   if (DEBUG_INSN_P (insn))
     return data;
   if (data->icode < 0)
diff -ruN gcc-7.3.0/gcc/lra-constraints.c gcc-7.3.0-msp430/gcc/lra-constraints.c
--- gcc-7.3.0/gcc/lra-constraints.c	2017-11-06 23:44:58.581712000 -0800
+++ gcc-7.3.0-msp430/gcc/lra-constraints.c	2019-06-25 02:27:21.149931075 -0700
@@ -3724,7 +3724,13 @@
 
   curr_insn_set = single_set (curr_insn);
   if (curr_insn_set != NULL_RTX && simple_move_p ())
-    return false;
+    {
+      /* We assume that the corresponding insn alternative has no
+	 earlier clobbers.  If it is not the case, don't define move
+	 cost equal to 2 for the corresponding register classes.  */
+      lra_set_used_insn_alternative (curr_insn, LRA_NON_CLOBBERED_ALT);
+      return false;
+    }
 
   no_input_reloads_p = no_output_reloads_p = false;
   goal_alt_number = -1;
@@ -3832,7 +3838,7 @@
   if (change_p)
     /* If we've changed the instruction then any alternative that
        we chose previously may no longer be valid.  */
-    lra_set_used_insn_alternative (curr_insn, -1);
+    lra_set_used_insn_alternative (curr_insn, LRA_UNKNOWN_ALT);
 
   if (! check_only_p && curr_insn_set != NULL_RTX
       && check_and_process_move (&change_p, &sec_mem_p))
@@ -3840,7 +3846,7 @@
 
  try_swapped:
 
-  reused_alternative_num = check_only_p ? -1 : curr_id->used_insn_alternative;
+  reused_alternative_num = check_only_p ? LRA_UNKNOWN_ALT : curr_id->used_insn_alternative;
   if (lra_dump_file != NULL && reused_alternative_num >= 0)
     fprintf (lra_dump_file, "Reusing alternative %d for insn #%u\n",
 	     reused_alternative_num, INSN_UID (curr_insn));
@@ -6708,7 +6714,7 @@
 			}
 		      lra_push_insn_and_update_insn_regno_info (curr_insn);
 		      lra_set_used_insn_alternative_by_uid
-			(INSN_UID (curr_insn), -1);
+			(INSN_UID (curr_insn), LRA_UNKNOWN_ALT);
 		      done_p = true;
 		      if (lra_dump_file != NULL)
 			{
@@ -6747,7 +6753,7 @@
 		     constraints pass.  */
 		  lra_push_insn_and_update_insn_regno_info (curr_insn);
 		  lra_set_used_insn_alternative_by_uid
-		    (INSN_UID (curr_insn), -1);
+		    (INSN_UID (curr_insn), LRA_UNKNOWN_ALT);
 		}
 	      else if (restored_regs_p)
 		/* The instruction has been restored to the form that
diff -ruN gcc-7.3.0/gcc/lra-eliminations.c gcc-7.3.0-msp430/gcc/lra-eliminations.c
--- gcc-7.3.0/gcc/lra-eliminations.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/lra-eliminations.c	2019-06-25 02:27:21.149931075 -0700
@@ -1178,7 +1178,7 @@
     if (bitmap_bit_p (&to_process, INSN_UID (insn)))
       {
 	lra_push_insn (insn);
-	lra_set_used_insn_alternative (insn, -1);
+	lra_set_used_insn_alternative (insn, LRA_UNKNOWN_ALT);
       }
   bitmap_clear (&to_process);
 }
@@ -1409,7 +1409,7 @@
 	}
       lra_update_insn_regno_info (insn);
       lra_push_insn (insn);
-      lra_set_used_insn_alternative (insn, -1);
+      lra_set_used_insn_alternative (insn, LRA_UNKNOWN_ALT);
     }
 }
 
diff -ruN gcc-7.3.0/gcc/lra-int.h gcc-7.3.0-msp430/gcc/lra-int.h
--- gcc-7.3.0/gcc/lra-int.h	2017-02-14 14:17:19.917758000 -0800
+++ gcc-7.3.0-msp430/gcc/lra-int.h	2019-06-25 02:27:21.153931047 -0700
@@ -202,15 +202,20 @@
   const struct operand_alternative *operand_alternative;
 };
 
+/* Negative insn alternative numbers used for special cases.  */
+#define LRA_UNKNOWN_ALT -1
+#define LRA_NON_CLOBBERED_ALT -2
+
 /* LRA internal info about an insn (LRA internal insn
    representation).  */
 struct lra_insn_recog_data
 {
   /* The insn code.  */
   int icode;
-  /* The alternative should be used for the insn, -1 if invalid, or we
-     should try to use any alternative, or the insn is a debug
-     insn.  */
+  /* The alternative should be used for the insn, LRA_UNKNOWN_ALT if
+     unknown, or we should assume any alternative, or the insn is a
+     debug insn.  LRA_NON_CLOBBERED_ALT means ignoring any earlier
+     clobbers for the insn.  */
   int used_insn_alternative;
   /* SP offset before the insn relative to one at the func start.  */
   HOST_WIDE_INT sp_offset;
diff -ruN gcc-7.3.0/gcc/lra-lives.c gcc-7.3.0-msp430/gcc/lra-lives.c
--- gcc-7.3.0/gcc/lra-lives.c	2017-02-14 14:17:19.917758000 -0800
+++ gcc-7.3.0-msp430/gcc/lra-lives.c	2019-06-25 02:27:21.153931047 -0700
@@ -593,7 +593,9 @@
 reg_early_clobber_p (const struct lra_insn_reg *reg, int n_alt)
 {
   return (reg->early_clobber
-	  && (n_alt < 0 || TEST_BIT (reg->early_clobber_alts, n_alt)));
+	  && (n_alt == LRA_UNKNOWN_ALT
+	      || (n_alt != LRA_NON_CLOBBERED_ALT
+		  && TEST_BIT (reg->early_clobber_alts, n_alt))));
 }
 
 /* Process insns of the basic block BB to update pseudo live ranges,
diff -ruN gcc-7.3.0/gcc/lra-spills.c gcc-7.3.0-msp430/gcc/lra-spills.c
--- gcc-7.3.0/gcc/lra-spills.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/lra-spills.c	2019-06-25 02:27:21.153931047 -0700
@@ -503,7 +503,7 @@
 			 INSN_UID (insn));
 	      lra_push_insn (insn);
 	      if (lra_reg_spill_p || targetm.different_addr_displacement_p ())
-		lra_set_used_insn_alternative (insn, -1);
+		lra_set_used_insn_alternative (insn, LRA_UNKNOWN_ALT);
 	    }
 	  else if (CALL_P (insn)
 		   /* Presence of any pseudo in CALL_INSN_FUNCTION_USAGE
diff -ruN gcc-7.3.0/gcc/lto/ChangeLog gcc-7.3.0-msp430/gcc/lto/ChangeLog
--- gcc-7.3.0/gcc/lto/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/gcc/lto/ChangeLog	2019-06-25 02:27:21.153931047 -0700
@@ -1,3 +1,102 @@
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-19  Martin Liska  <mliska@suse.cz>
+
+	* lto-symtab.c (lto_symtab_resolve_symbols): Do not bail out
+	for multiple PREVAILING_DEF_IRONLY for common symbols.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-10  Martin Liska  <mliska@suse.cz>
+
+	PR lto/85248
+	* lto-symtab.c (lto_symtab_merge_p): Do not check for
+	TREE_VALUES of error attributes.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-10  Richard Biener  <rguenther@suse.de>
+		    Martin Liska  <mliska@suse.cz>
+
+	PR lto/85248
+	* lto-symtab.c (lto_symtab_merge_p): Handle noreturn attribute.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-23  Martin Liska  <mliska@suse.cz>
+
+	PR lto/81440
+	* lto-symtab.c (lto_symtab_merge): Handle and do not warn about
+	trailing arrays at the end of a struct.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Jan Hubicka  <hubicka@ucw.cz>
+
+	* lto-partition.c (lto_balanced_map): Watch overflow.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/81360
+	* lto.c (unify_scc): Register prevailing trees, not trees to be freed.
+	(read_cgraph_and_symbols): Use
+	symtab_node::output_to_lto_symbol_table_p.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	* lto.c (register_resolution): Remove forgotten sanity check.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/81004
+	* lto.c: Include builtins.h
+	(register_resolution): Merge resolutions in case trees was
+	merged across units.
+	(lto_maybe_register_decl): Break out from ...
+	(lto_read_decls): ... here.
+	(unify_scc): Also register decls here.
+	(read_cgraph_and_symbols): Sanity check that all resolutions was
+	read.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR lto/83954
+	* lto-symtab.c (warn_type_compatibility_p): Do not recurse into the
+	component type of array types with non-aliased component.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/83954
+	* lto-symtab.c (warn_type_compatibility_p): Silence false positive
+	for type match warning on arrays of pointers.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-10-13  Jan Hubicka  <hubicka@ucw.cz>
+
+	* lto-lang.c (lto_post_options): Clean shlib flag when not doing PIC.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/gcc/lto/lto.c gcc-7.3.0-msp430/gcc/lto/lto.c
--- gcc-7.3.0/gcc/lto/lto.c	2017-04-12 00:35:49.004848000 -0700
+++ gcc-7.3.0-msp430/gcc/lto/lto.c	2019-06-25 02:27:21.153931047 -0700
@@ -53,6 +53,7 @@
 #include "lto-symtab.h"
 #include "stringpool.h"
 #include "fold-const.h"
+#include "builtins.h"
 
 
 /* Number of parallel tasks to run, -1 if we want to use GNU Make jobserver.  */
@@ -829,12 +830,19 @@
 register_resolution (struct lto_file_decl_data *file_data, tree decl,
 		     enum ld_plugin_symbol_resolution resolution)
 {
+  bool existed;
   if (resolution == LDPR_UNKNOWN)
     return;
   if (!file_data->resolution_map)
     file_data->resolution_map
       = new hash_map<tree, ld_plugin_symbol_resolution>;
-  file_data->resolution_map->put (decl, resolution);
+  ld_plugin_symbol_resolution_t &res
+     = file_data->resolution_map->get_or_insert (decl, &existed);
+  if (!existed
+      || resolution == LDPR_PREVAILING_DEF_IRONLY
+      || resolution == LDPR_PREVAILING_DEF
+      || resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)
+    res = resolution;
 }
 
 /* Register DECL with the global symbol table and change its
@@ -877,6 +885,18 @@
 			 decl, get_resolution (data_in, ix));
 }
 
+/* Check if T is a decl and needs register its resolution info.  */
+
+static void
+lto_maybe_register_decl (struct data_in *data_in, tree t, unsigned ix)
+{
+  if (TREE_CODE (t) == VAR_DECL)
+    lto_register_var_decl_in_symtab (data_in, t, ix);
+  else if (TREE_CODE (t) == FUNCTION_DECL
+	   && !DECL_BUILT_IN (t))
+    lto_register_function_decl_in_symtab (data_in, t, ix);
+}
+
 
 /* For the type T re-materialize it in the type variant list and
    the pointer/reference-to chains.  */
@@ -1607,7 +1627,10 @@
 	  /* Fixup the streamer cache with the prevailing nodes according
 	     to the tree node mapping computed by compare_tree_sccs.  */
 	  if (len == 1)
-	    streamer_tree_cache_replace_tree (cache, pscc->entries[0], from);
+	    {
+	      lto_maybe_register_decl (data_in, pscc->entries[0], from);
+	      streamer_tree_cache_replace_tree (cache, pscc->entries[0], from);
+	    }
 	  else
 	    {
 	      tree *map2 = XALLOCAVEC (tree, 2 * len);
@@ -1619,8 +1642,12 @@
 	      qsort (map2, len, 2 * sizeof (tree), cmp_tree);
 	      qsort (map, len, 2 * sizeof (tree), cmp_tree);
 	      for (unsigned i = 0; i < len; ++i)
-		streamer_tree_cache_replace_tree (cache, map[2*i],
-						  (uintptr_t)map2[2*i]);
+		{
+		  lto_maybe_register_decl (data_in, map[2*i],
+					   (uintptr_t)map2[2*i]);
+		  streamer_tree_cache_replace_tree (cache, map[2*i],
+						    (uintptr_t)map2[2*i]);
+		}
 	    }
 
 	  /* Free the tree nodes from the read SCC.  */
@@ -1759,13 +1786,7 @@
 		}
 	      if (!flag_ltrans)
 		{
-		  /* Register variables and functions with the
-		     symbol table.  */
-		  if (TREE_CODE (t) == VAR_DECL)
-		    lto_register_var_decl_in_symtab (data_in, t, from + i);
-		  else if (TREE_CODE (t) == FUNCTION_DECL
-			   && !DECL_BUILT_IN (t))
-		    lto_register_function_decl_in_symtab (data_in, t, from + i);
+		  lto_maybe_register_decl (data_in, t, from + i);
 		  /* Scan the tree for references to global functions or
 		     variables and record those for later fixup.  */
 		  if (mentions_vars_p (t))
@@ -2858,13 +2879,25 @@
 
   /* Store resolutions into the symbol table.  */
 
-  ld_plugin_symbol_resolution_t *res;
   FOR_EACH_SYMBOL (snode)
-    if (snode->real_symbol_p ()
-	&& snode->lto_file_data
-	&& snode->lto_file_data->resolution_map
-	&& (res = snode->lto_file_data->resolution_map->get (snode->decl)))
-      snode->resolution = *res;
+    if (snode->externally_visible && snode->real_symbol_p ()
+	&& snode->lto_file_data && snode->lto_file_data->resolution_map
+	&& !is_builtin_fn (snode->decl)
+	&& !(VAR_P (snode->decl) && DECL_HARD_REGISTER (snode->decl)))
+      {
+	ld_plugin_symbol_resolution_t *res;
+
+	res = snode->lto_file_data->resolution_map->get (snode->decl);
+	if (!res || *res == LDPR_UNKNOWN)
+	  {
+	    if (snode->output_to_lto_symbol_table_p ())
+	      fatal_error (input_location, "missing resolution data for %s",
+		           IDENTIFIER_POINTER
+			     (DECL_ASSEMBLER_NAME (snode->decl)));
+	  }
+	else
+          snode->resolution = *res;
+      }
   for (i = 0; all_file_decl_data[i]; i++)
     if (all_file_decl_data[i]->resolution_map)
       {
diff -ruN gcc-7.3.0/gcc/lto/lto-lang.c gcc-7.3.0-msp430/gcc/lto/lto-lang.c
--- gcc-7.3.0/gcc/lto/lto-lang.c	2017-01-19 09:27:54.418217000 -0800
+++ gcc-7.3.0-msp430/gcc/lto/lto-lang.c	2019-06-25 02:27:21.153931047 -0700
@@ -840,11 +840,13 @@
          flag_pie is 2.  */
       flag_pie = MAX (flag_pie, flag_pic);
       flag_pic = flag_pie;
+      flag_shlib = 0;
       break;
 
     case LTO_LINKER_OUTPUT_EXEC: /* Normal executable */
       flag_pic = 0;
       flag_pie = 0;
+      flag_shlib = 0;
       break;
 
     case LTO_LINKER_OUTPUT_UNKNOWN:
diff -ruN gcc-7.3.0/gcc/lto/lto-partition.c gcc-7.3.0-msp430/gcc/lto/lto-partition.c
--- gcc-7.3.0/gcc/lto/lto-partition.c	2017-01-06 06:08:02.932231000 -0800
+++ gcc-7.3.0-msp430/gcc/lto/lto-partition.c	2019-06-25 02:27:21.153931047 -0700
@@ -756,7 +756,8 @@
 	  if (npartitions < n_lto_partitions)
 	    partition_size = total_size / (n_lto_partitions - npartitions);
 	  else
-	    partition_size = INT_MAX;
+	    /* Watch for overflow.  */
+	    partition_size = INT_MAX / 16;
 
 	  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))
 	    partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);
diff -ruN gcc-7.3.0/gcc/lto/lto-symtab.c gcc-7.3.0-msp430/gcc/lto/lto-symtab.c
--- gcc-7.3.0/gcc/lto/lto-symtab.c	2017-01-09 13:48:33.107036000 -0800
+++ gcc-7.3.0-msp430/gcc/lto/lto-symtab.c	2019-06-25 02:27:21.153931047 -0700
@@ -283,11 +283,25 @@
       alias_set_type set1 = get_alias_set (type);
       alias_set_type set2 = get_alias_set (prevailing_type);
 
-      if (set1 && set2 && set1 != set2 
-          && (!POINTER_TYPE_P (type) || !POINTER_TYPE_P (prevailing_type)
+      if (set1 && set2 && set1 != set2)
+	{
+          tree t1 = type, t2 = prevailing_type;
+
+	  /* Alias sets of arrays with aliased components are the same as alias
+	     sets of the inner types.  */
+	  while (TREE_CODE (t1) == ARRAY_TYPE
+		 && !TYPE_NONALIASED_COMPONENT (t1)
+		 && TREE_CODE (t2) == ARRAY_TYPE
+		 && !TYPE_NONALIASED_COMPONENT (t2))
+	    {
+	      t1 = TREE_TYPE (t1);
+	      t2 = TREE_TYPE (t2);
+	    }
+          if ((!POINTER_TYPE_P (t1) || !POINTER_TYPE_P (t2))
 	      || (set1 != TYPE_ALIAS_SET (ptr_type_node)
-		  && set2 != TYPE_ALIAS_SET (ptr_type_node))))
-        lev |= 5;
+		  && set2 != TYPE_ALIAS_SET (ptr_type_node)))
+             lev |= 5;
+	}
     }
 
   return lev;
@@ -351,18 +365,31 @@
     return false;
 
   if (DECL_SIZE (decl) && DECL_SIZE (prevailing_decl)
-      && !tree_int_cst_equal (DECL_SIZE (decl), DECL_SIZE (prevailing_decl))
+      && !tree_int_cst_equal (DECL_SIZE (decl), DECL_SIZE (prevailing_decl)))
+      {
+	if (!DECL_COMMON (decl) && !DECL_EXTERNAL (decl))
+	  return false;
+
+	tree type = TREE_TYPE (decl);
+
+	/* For record type, check for array at the end of the structure.  */
+	if (TREE_CODE (type) == RECORD_TYPE)
+	  {
+	    tree field = TYPE_FIELDS (type);
+	    while (DECL_CHAIN (field) != NULL_TREE)
+	      field = DECL_CHAIN (field);
+
+	    return TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE;
+	  }
       /* As a special case do not warn about merging
 	 int a[];
 	 and
 	 int a[]={1,2,3};
 	 here the first declaration is COMMON
 	 and sizeof(a) == sizeof (int).  */
-      && ((!DECL_COMMON (decl) && !DECL_EXTERNAL (decl))
-	  || TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE
-	  || TYPE_SIZE (TREE_TYPE (decl))
-	     != TYPE_SIZE (TREE_TYPE (TREE_TYPE (decl)))))
-    return false;
+	else if (TREE_CODE (type) == ARRAY_TYPE)
+	  return (TYPE_SIZE (decl) == TYPE_SIZE (TREE_TYPE (type)));
+      }
 
   return true;
 }
@@ -438,9 +465,14 @@
   /* If the chain is already resolved there is nothing else to do.  */
   if (prevailing)
     {
-      /* Assert it's the only one.  */
+      /* Assert it's the only one.
+	 GCC should silence multiple PREVAILING_DEF_IRONLY defs error
+	 on COMMON symbols since it isn't error.
+	 See: https://sourceware.org/bugzilla/show_bug.cgi?id=23079.  */
       for (e = prevailing->next_sharing_asm_name; e; e = e->next_sharing_asm_name)
 	if (lto_symtab_symbol_p (e)
+	    && !DECL_COMMON (prevailing->decl)
+	    && !DECL_COMMON (e->decl)
 	    && (e->resolution == LDPR_PREVAILING_DEF_IRONLY
 		|| e->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP
 		|| e->resolution == LDPR_PREVAILING_DEF))
@@ -544,6 +576,9 @@
 	  return false;
 	}
     }
+
+  /* FIXME: after MPX is removed, use flags_from_decl_or_type
+     function instead.  PR lto/85248.  */
   if (DECL_ATTRIBUTES (prevailing) != DECL_ATTRIBUTES (decl))
     {
       tree prev_attr = lookup_attribute ("error", DECL_ATTRIBUTES (prevailing));
@@ -571,6 +606,16 @@
 		     "warning attribute mismatch\n");
 	  return false;
 	}
+
+      prev_attr = lookup_attribute ("noreturn", DECL_ATTRIBUTES (prevailing));
+      attr = lookup_attribute ("noreturn", DECL_ATTRIBUTES (decl));
+      if ((prev_attr == NULL) != (attr == NULL))
+	{
+          if (symtab->dump_file)
+	    fprintf (symtab->dump_file, "Not merging decls; "
+		     "noreturn attribute mismatch\n");
+	  return false;
+	}
     }
   return true;
 }
diff -ruN gcc-7.3.0/gcc/lto-streamer-out.c gcc-7.3.0-msp430/gcc/lto-streamer-out.c
--- gcc-7.3.0/gcc/lto-streamer-out.c	2017-04-12 00:35:49.004848000 -0700
+++ gcc-7.3.0-msp430/gcc/lto-streamer-out.c	2019-06-25 02:27:21.153931047 -0700
@@ -2524,13 +2524,10 @@
   const char *comdat;
   unsigned char c;
 
-  /* None of the following kinds of symbols are needed in the
-     symbol table.  */
-  if (!TREE_PUBLIC (t)
-      || is_builtin_fn (t)
-      || DECL_ABSTRACT_P (t)
-      || (VAR_P (t) && DECL_HARD_REGISTER (t)))
-    return;
+  gcc_checking_assert (TREE_PUBLIC (t)
+		       && !is_builtin_fn (t)
+		       && !DECL_ABSTRACT_P (t)
+		       && (!VAR_P (t) || !DECL_HARD_REGISTER (t)));
 
   gcc_assert (VAR_OR_FUNCTION_DECL_P (t));
 
@@ -2618,45 +2615,6 @@
   lto_write_data (&slot_num, 4);
 }
 
-/* Return true if NODE should appear in the plugin symbol table.  */
-
-bool
-output_symbol_p (symtab_node *node)
-{
-  struct cgraph_node *cnode;
-  if (!node->real_symbol_p ())
-    return false;
-  /* We keep external functions in symtab for sake of inlining
-     and devirtualization.  We do not want to see them in symbol table as
-     references unless they are really used.  */
-  cnode = dyn_cast <cgraph_node *> (node);
-  if (cnode && (!node->definition || DECL_EXTERNAL (cnode->decl))
-      && cnode->callers)
-    return true;
-
- /* Ignore all references from external vars initializers - they are not really
-    part of the compilation unit until they are used by folding.  Some symbols,
-    like references to external construction vtables can not be referred to at all.
-    We decide this at can_refer_decl_in_current_unit_p.  */
- if (!node->definition || DECL_EXTERNAL (node->decl))
-    {
-      int i;
-      struct ipa_ref *ref;
-      for (i = 0; node->iterate_referring (i, ref); i++)
-	{
-	  if (ref->use == IPA_REF_ALIAS)
-	    continue;
-          if (is_a <cgraph_node *> (ref->referring))
-	    return true;
-	  if (!DECL_EXTERNAL (ref->referring->decl))
-	    return true;
-	}
-      return false;
-    }
-  return true;
-}
-
-
 /* Write an IL symbol table to OB.
    SET and VSET are cgraph/varpool node sets we are outputting.  */
 
@@ -2681,7 +2639,7 @@
     {
       symtab_node *node = lsei_node (lsei);
 
-      if (!output_symbol_p (node) || DECL_EXTERNAL (node->decl))
+      if (DECL_EXTERNAL (node->decl) || !node->output_to_lto_symbol_table_p ())
 	continue;
       write_symbol (cache, node->decl, &seen, false);
     }
@@ -2690,7 +2648,7 @@
     {
       symtab_node *node = lsei_node (lsei);
 
-      if (!output_symbol_p (node) || !DECL_EXTERNAL (node->decl))
+      if (!DECL_EXTERNAL (node->decl) || !node->output_to_lto_symbol_table_p ())
 	continue;
       write_symbol (cache, node->decl, &seen, false);
     }
diff -ruN gcc-7.3.0/gcc/machmode.def gcc-7.3.0-msp430/gcc/machmode.def
--- gcc-7.3.0/gcc/machmode.def	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/machmode.def	2019-06-25 02:27:21.153931047 -0700
@@ -243,6 +243,7 @@
 
 /* Complex modes.  */
 COMPLEX_MODES (INT);
+COMPLEX_MODES (PARTIAL_INT);
 COMPLEX_MODES (FLOAT);
 
 /* Decimal floating point modes.  */
diff -ruN gcc-7.3.0/gcc/Makefile.in gcc-7.3.0-msp430/gcc/Makefile.in
--- gcc-7.3.0/gcc/Makefile.in	2017-05-02 09:12:40.965506000 -0700
+++ gcc-7.3.0-msp430/gcc/Makefile.in	2019-06-25 02:27:21.057931733 -0700
@@ -862,6 +862,7 @@
 PATCHLEVEL_c := \
   $(shell echo $(BASEVER_c) | sed -e 's/^[0-9]*\.[0-9]*\.\([0-9]*\)$$/\1/')
 
+PATCHLEVEL_c :=
 
 # For use in version.c - double quoted strings, with appropriate
 # surrounding punctuation and spaces, and with the datestamp and
diff -ruN gcc-7.3.0/gcc/match.pd gcc-7.3.0-msp430/gcc/match.pd
--- gcc-7.3.0/gcc/match.pd	2017-07-17 12:45:59.727832000 -0700
+++ gcc-7.3.0-msp430/gcc/match.pd	2019-06-25 02:27:21.153931047 -0700
@@ -2789,15 +2789,17 @@
 (simplify
  (cond
   (ne (bit_and @0 integer_pow2p@1) integer_zerop)
-  integer_pow2p@2 integer_zerop)
- (with {
-    int shift = wi::exact_log2 (@2) - wi::exact_log2 (@1);
-  }
-  (if (shift > 0)
-   (bit_and
-    (lshift (convert @0) { build_int_cst (integer_type_node, shift); }) @2)
-   (bit_and
-    (convert (rshift @0 { build_int_cst (integer_type_node, -shift); })) @2))))
+  INTEGER_CST@2 integer_zerop)
+ (if (integer_pow2p (@2))
+  (with {
+     int shift = wi::exact_log2 (@2) - wi::exact_log2 (@1);
+   }
+   (if (shift > 0)
+    (bit_and
+     (lshift (convert @0) { build_int_cst (integer_type_node, shift); }) @2)
+    (bit_and
+     (convert (rshift @0 { build_int_cst (integer_type_node, -shift); }))
+     @2)))))
 
 /* If we have (A & C) != 0 where C is the sign bit of A, convert
    this into A < 0.  Similarly for (A & C) == 0 into A >= 0.  */
@@ -2818,8 +2820,9 @@
 (simplify
  (cond
   (lt @0 integer_zerop)
-  integer_pow2p@1 integer_zerop)
- (if (!TYPE_UNSIGNED (TREE_TYPE (@0)))
+  INTEGER_CST@1 integer_zerop)
+ (if (integer_pow2p (@1)
+      && !TYPE_UNSIGNED (TREE_TYPE (@0)))
   (with {
     int shift = element_precision (@0) - wi::exact_log2 (@1) - 1;
    }
@@ -2926,10 +2929,13 @@
 (for cmp (ne eq)
  (simplify
   (cmp (convert @0) INTEGER_CST@1)
-  (if ((POINTER_TYPE_P (TREE_TYPE (@0)) && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@0)))
-	&& INTEGRAL_TYPE_P (TREE_TYPE (@1)))
-      || (INTEGRAL_TYPE_P (TREE_TYPE (@0)) && POINTER_TYPE_P (TREE_TYPE (@1))
-	  && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@1)))))
+  (if (((POINTER_TYPE_P (TREE_TYPE (@0))
+	 && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@0)))
+	 && INTEGRAL_TYPE_P (TREE_TYPE (@1)))
+	|| (INTEGRAL_TYPE_P (TREE_TYPE (@0))
+	    && POINTER_TYPE_P (TREE_TYPE (@1))
+	    && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@1)))))
+       && TYPE_PRECISION (TREE_TYPE (@0)) == TYPE_PRECISION (TREE_TYPE (@1)))
    (cmp @0 (convert @1)))))
 
 /* Non-equality compare simplifications from fold_binary  */
diff -ruN gcc-7.3.0/gcc/omp-expand.c gcc-7.3.0-msp430/gcc/omp-expand.c
--- gcc-7.3.0/gcc/omp-expand.c	2017-09-07 13:40:06.556044000 -0700
+++ gcc-7.3.0-msp430/gcc/omp-expand.c	2019-06-25 02:27:21.153931047 -0700
@@ -5628,6 +5628,14 @@
 
 	  split->flags ^= EDGE_FALLTHRU | EDGE_TRUE_VALUE;
 
+	  /* Add a dummy exit for the tiled block when cont_bb is missing.  */
+	  if (cont_bb == NULL)
+	    {
+	      edge e = make_edge (body_bb, exit_bb, EDGE_FALSE_VALUE);
+	      e->probability = PROB_EVEN;
+	      split->probability = PROB_EVEN;
+	    }
+
 	  /* Initialize the user's loop vars.  */
 	  gsi = gsi_start_bb (elem_body_bb);
 	  expand_oacc_collapse_vars (fd, true, &gsi, counts, e_offset);
diff -ruN gcc-7.3.0/gcc/omp-low.c gcc-7.3.0-msp430/gcc/omp-low.c
--- gcc-7.3.0/gcc/omp-low.c	2017-09-07 13:41:42.148347000 -0700
+++ gcc-7.3.0-msp430/gcc/omp-low.c	2019-06-25 02:27:21.153931047 -0700
@@ -3261,6 +3261,43 @@
 
 /* Re-gimplification and code generation routines.  */
 
+/* Remove omp_member_access_dummy_var variables from gimple_bind_vars
+   of BIND if in a method.  */
+
+static void
+maybe_remove_omp_member_access_dummy_vars (gbind *bind)
+{
+  if (DECL_ARGUMENTS (current_function_decl)
+      && DECL_ARTIFICIAL (DECL_ARGUMENTS (current_function_decl))
+      && (TREE_CODE (TREE_TYPE (DECL_ARGUMENTS (current_function_decl)))
+	  == POINTER_TYPE))
+    {
+      tree vars = gimple_bind_vars (bind);
+      for (tree *pvar = &vars; *pvar; )
+	if (omp_member_access_dummy_var (*pvar))
+	  *pvar = DECL_CHAIN (*pvar);
+	else
+	  pvar = &DECL_CHAIN (*pvar);
+      gimple_bind_set_vars (bind, vars);
+    }
+}
+
+/* Remove omp_member_access_dummy_var variables from BLOCK_VARS of
+   block and its subblocks.  */
+
+static void
+remove_member_access_dummy_vars (tree block)
+{
+  for (tree *pvar = &BLOCK_VARS (block); *pvar; )
+    if (omp_member_access_dummy_var (*pvar))
+      *pvar = DECL_CHAIN (*pvar);
+    else
+      pvar = &DECL_CHAIN (*pvar);
+
+  for (block = BLOCK_SUBBLOCKS (block); block; block = BLOCK_CHAIN (block))
+    remove_member_access_dummy_vars (block);
+}
+
 /* If a context was created for STMT when it was scanned, return it.  */
 
 static omp_context *
@@ -7002,6 +7039,7 @@
   pop_gimplify_context (new_stmt);
 
   gimple_bind_append_vars (new_stmt, ctx->block_vars);
+  maybe_remove_omp_member_access_dummy_vars (new_stmt);
   BLOCK_VARS (block) = gimple_bind_vars (new_stmt);
   if (BLOCK_VARS (block))
     TREE_USED (block) = 1;
@@ -7452,6 +7490,7 @@
   /* Declare all the variables created by mapping and the variables
      declared in the scope of the parallel body.  */
   record_vars_into (ctx->block_vars, child_fn);
+  maybe_remove_omp_member_access_dummy_vars (par_bind);
   record_vars_into (gimple_bind_vars (par_bind), child_fn);
 
   if (ctx->record_type)
@@ -7820,6 +7859,7 @@
       /* Declare all the variables created by mapping and the variables
 	 declared in the scope of the target body.  */
       record_vars_into (ctx->block_vars, child_fn);
+      maybe_remove_omp_member_access_dummy_vars (tgt_bind);
       record_vars_into (gimple_bind_vars (tgt_bind), child_fn);
     }
 
@@ -8811,6 +8851,7 @@
       break;
     case GIMPLE_BIND:
       lower_omp (gimple_bind_body_ptr (as_a <gbind *> (stmt)), ctx);
+      maybe_remove_omp_member_access_dummy_vars (as_a <gbind *> (stmt));
       break;
     case GIMPLE_OMP_PARALLEL:
     case GIMPLE_OMP_TASK:
@@ -9015,6 +9056,16 @@
       all_contexts = NULL;
     }
   BITMAP_FREE (task_shared_vars);
+
+  /* If current function is a method, remove artificial dummy VAR_DECL created
+     for non-static data member privatization, they aren't needed for
+     debuginfo nor anything else, have been already replaced everywhere in the
+     IL and cause problems with LTO.  */
+  if (DECL_ARGUMENTS (current_function_decl)
+      && DECL_ARTIFICIAL (DECL_ARGUMENTS (current_function_decl))
+      && (TREE_CODE (TREE_TYPE (DECL_ARGUMENTS (current_function_decl)))
+	  == POINTER_TYPE))
+    remove_member_access_dummy_vars (DECL_INITIAL (current_function_decl));
   return 0;
 }
 
diff -ruN gcc-7.3.0/gcc/optabs.c gcc-7.3.0-msp430/gcc/optabs.c
--- gcc-7.3.0/gcc/optabs.c	2017-07-16 15:07:15.836437000 -0700
+++ gcc-7.3.0-msp430/gcc/optabs.c	2019-06-25 02:27:21.157931017 -0700
@@ -4294,9 +4294,10 @@
 	  save_pending_stack_adjust (&save);
 	  last = get_last_insn ();
 	  do_pending_stack_adjust ();
+	  machine_mode cmpmode = cmode;
 	  prepare_cmp_insn (XEXP (comparison, 0), XEXP (comparison, 1),
 			    GET_CODE (comparison), NULL_RTX, unsignedp,
-			    OPTAB_WIDEN, &comparison, &cmode);
+			    OPTAB_WIDEN, &comparison, &cmpmode);
 	  if (comparison)
 	    {
 	      struct expand_operand ops[4];
diff -ruN gcc-7.3.0/gcc/opts.c gcc-7.3.0-msp430/gcc/opts.c
--- gcc-7.3.0/gcc/opts.c	2017-09-15 01:18:34.015147000 -0700
+++ gcc-7.3.0-msp430/gcc/opts.c	2019-06-25 02:27:21.157931017 -0700
@@ -1014,6 +1014,26 @@
   if ((opts->x_flag_sanitize & SANITIZE_KERNEL_ADDRESS) && opts->x_flag_tm)
     sorry ("transactional memory is not supported with "
 	   "%<-fsanitize=kernel-address%>");
+
+  /* Comes from final.c -- no real reason to change it.  */
+#define MAX_CODE_ALIGN 16
+#define MAX_CODE_ALIGN_VALUE (1 << MAX_CODE_ALIGN)
+
+  if (opts->x_align_loops > MAX_CODE_ALIGN_VALUE)
+    error_at (loc, "-falign-loops=%d is not between 0 and %d",
+	      opts->x_align_loops, MAX_CODE_ALIGN_VALUE);
+
+  if (opts->x_align_jumps > MAX_CODE_ALIGN_VALUE)
+    error_at (loc, "-falign-jumps=%d is not between 0 and %d",
+	      opts->x_align_jumps, MAX_CODE_ALIGN_VALUE);
+
+  if (opts->x_align_functions > MAX_CODE_ALIGN_VALUE)
+    error_at (loc, "-falign-functions=%d is not between 0 and %d",
+	      opts->x_align_functions, MAX_CODE_ALIGN_VALUE);
+
+  if (opts->x_align_labels > MAX_CODE_ALIGN_VALUE)
+    error_at (loc, "-falign-labels=%d is not between 0 and %d",
+	      opts->x_align_labels, MAX_CODE_ALIGN_VALUE);
 }
 
 #define LEFT_COLUMN	27
diff -ruN gcc-7.3.0/gcc/params.def gcc-7.3.0-msp430/gcc/params.def
--- gcc-7.3.0/gcc/params.def	2017-06-22 04:40:00.086369000 -0700
+++ gcc-7.3.0-msp430/gcc/params.def	2019-06-25 02:27:21.157931017 -0700
@@ -344,11 +344,11 @@
 	"The maximum number of unswitchings in a single loop.",
 	3, 0, 0)
 
-/* The maximum number of insns in loop header duplicated by he copy loop
+/* The maximum number of insns in loop header duplicated by the copy loop
    headers pass.  */
 DEFPARAM(PARAM_MAX_LOOP_HEADER_INSNS,
 	"max-loop-header-insns",
-	"The maximum number of insns in loop header duplicated by he copy loop headers pass.",
+	"The maximum number of insns in loop header duplicated by the copy loop headers pass.",
 	20, 0, 0)
 
 /* The maximum number of iterations of a loop the brute force algorithm
diff -ruN gcc-7.3.0/gcc/postreload.c gcc-7.3.0-msp430/gcc/postreload.c
--- gcc-7.3.0/gcc/postreload.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/postreload.c	2019-06-25 02:27:21.157931017 -0700
@@ -1160,11 +1160,13 @@
 	     value in PREV, the constant loading instruction.  */
 	  validate_change (prev, &SET_DEST (prev_set), index_reg, 1);
 	  if (reg_state[regno].offset != const0_rtx)
-	    validate_change (prev,
-			     &SET_SRC (prev_set),
-			     GEN_INT (INTVAL (SET_SRC (prev_set))
-				      + INTVAL (reg_state[regno].offset)),
-			     1);
+	    {
+	      HOST_WIDE_INT c
+		= trunc_int_for_mode (UINTVAL (SET_SRC (prev_set))
+				      + UINTVAL (reg_state[regno].offset),
+				      GET_MODE (index_reg));
+	      validate_change (prev, &SET_SRC (prev_set), GEN_INT (c), 1);
+	    }
 
 	  /* Now for every use of REG that we have recorded, replace REG
 	     with REG_SUM.  */
diff -ruN gcc-7.3.0/gcc/regcprop.c gcc-7.3.0-msp430/gcc/regcprop.c
--- gcc-7.3.0/gcc/regcprop.c	2017-04-18 08:00:43.628540000 -0700
+++ gcc-7.3.0-msp430/gcc/regcprop.c	2019-06-25 02:27:21.157931017 -0700
@@ -854,6 +854,12 @@
 		  && reg_overlap_mentioned_p (XEXP (link, 0), SET_SRC (set)))
 		set = NULL;
 	    }
+
+	  /* We need to keep CFI info correct, and the same on all paths,
+	     so we cannot normally replace the registers REG_CFA_REGISTER
+	     refers to.  Bail.  */
+	  if (REG_NOTE_KIND (link) == REG_CFA_REGISTER)
+	    goto did_replacement;
 	}
 
       /* Special-case plain move instructions, since we may well
diff -ruN gcc-7.3.0/gcc/regrename.c gcc-7.3.0-msp430/gcc/regrename.c
--- gcc-7.3.0/gcc/regrename.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/regrename.c	2019-06-25 02:27:21.157931017 -0700
@@ -1656,7 +1656,8 @@
 	     (6) For any non-earlyclobber write we find in an operand, make
 	         a new chain or mark the hard register as live.
 	     (7) For any REG_UNUSED, close any chains we just opened.
-	     (8) For any REG_CFA_RESTORE, kill any chain containing it.
+	     (8) For any REG_CFA_RESTORE or REG_CFA_REGISTER, kill any chain
+	         containing its dest.
 
 	     We cannot deal with situations where we track a reg in one mode
 	     and see a reference in another mode; these will cause the chain
@@ -1871,10 +1872,20 @@
 	      }
 
 	  /* Step 8: Kill the chains involving register restores.  Those
-	     should restore _that_ register.  */
+	     should restore _that_ register.  Similar for REG_CFA_REGISTER.  */
 	  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))
-	    if (REG_NOTE_KIND (note) == REG_CFA_RESTORE)
-	      scan_rtx (insn, &XEXP (note, 0), NO_REGS, mark_all_read, OP_IN);
+	    if (REG_NOTE_KIND (note) == REG_CFA_RESTORE
+		|| REG_NOTE_KIND (note) == REG_CFA_REGISTER)
+	      {
+		rtx *x = &XEXP (note, 0);
+		if (!*x)
+		  x = &PATTERN (insn);
+		if (GET_CODE (*x) == PARALLEL)
+		  x = &XVECEXP (*x, 0, 0);
+		if (GET_CODE (*x) == SET)
+		  x = &SET_DEST (*x);
+		scan_rtx (insn, x, NO_REGS, mark_all_read, OP_IN);
+	      }
 	}
       else if (DEBUG_INSN_P (insn)
 	       && !VAR_LOC_UNKNOWN_P (INSN_VAR_LOCATION_LOC (insn)))
diff -ruN gcc-7.3.0/gcc/reorg.c gcc-7.3.0-msp430/gcc/reorg.c
--- gcc-7.3.0/gcc/reorg.c	2017-06-15 06:25:33.108663000 -0700
+++ gcc-7.3.0-msp430/gcc/reorg.c	2019-06-25 02:27:21.157931017 -0700
@@ -1035,7 +1035,8 @@
 
 static void
 steal_delay_list_from_target (rtx_insn *insn, rtx condition, rtx_sequence *seq,
-			      vec<rtx_insn *> *delay_list, resources *sets,
+			      vec<rtx_insn *> *delay_list,
+			      struct resources *sets,
 			      struct resources *needed,
 			      struct resources *other_needed,
 			      int slots_to_fill, int *pslots_filled,
@@ -1048,7 +1049,7 @@
   int used_annul = 0;
   int i;
   struct resources cc_set;
-  bool *redundant;
+  rtx_insn **redundant;
 
   /* We can't do anything if there are more delay slots in SEQ than we
      can handle, or if we don't know that it will be a taken branch.
@@ -1087,7 +1088,7 @@
   if (! targetm.can_follow_jump (insn, seq->insn (0)))
     return;
 
-  redundant = XALLOCAVEC (bool, XVECLEN (seq, 0));
+  redundant = XALLOCAVEC (rtx_insn *, XVECLEN (seq, 0));
   for (i = 1; i < seq->len (); i++)
     {
       rtx_insn *trial = seq->insn (i);
@@ -1151,7 +1152,10 @@
      we therefore decided not to copy.  */
   for (i = 1; i < seq->len (); i++)
     if (redundant[i])
-      update_block (seq->insn (i), insn);
+      {
+	fix_reg_dead_note (redundant[i], insn);
+	update_block (seq->insn (i), insn);
+      }
 
   /* Show the place to which we will be branching.  */
   *pnew_thread = first_active_target_insn (JUMP_LABEL (seq->insn (0)));
@@ -1198,6 +1202,7 @@
   for (i = 1; i < seq->len (); i++)
     {
       rtx_insn *trial = seq->insn (i);
+      rtx_insn *prior_insn;
 
       /* If TRIAL sets CC0, stealing it will move it too far from the use
 	 of CC0.  */
@@ -1209,8 +1214,9 @@
 	break;
 
       /* If this insn was already done, we don't need it.  */
-      if (redundant_insn (trial, insn, *delay_list))
+      if ((prior_insn = redundant_insn (trial, insn, *delay_list)))
 	{
+	  fix_reg_dead_note (prior_insn, insn);
 	  update_block (trial, insn);
 	  delete_from_delay_slot (trial);
 	  continue;
@@ -1790,15 +1796,14 @@
       }
 }
 
-/* Delete any REG_UNUSED notes that exist on INSN but not on REDUNDANT_INSN.
+/* Delete any REG_UNUSED notes that exist on INSN but not on OTHER_INSN.
 
    This handles the case of udivmodXi4 instructions which optimize their
-   output depending on whether any REG_UNUSED notes are present.
-   we must make sure that INSN calculates as many results as REDUNDANT_INSN
-   does.  */
+   output depending on whether any REG_UNUSED notes are present.  We must
+   make sure that INSN calculates as many results as OTHER_INSN does.  */
 
 static void
-update_reg_unused_notes (rtx_insn *insn, rtx redundant_insn)
+update_reg_unused_notes (rtx_insn *insn, rtx other_insn)
 {
   rtx link, next;
 
@@ -1810,8 +1815,7 @@
 	  || !REG_P (XEXP (link, 0)))
 	continue;
 
-      if (! find_regno_note (redundant_insn, REG_UNUSED,
-			     REGNO (XEXP (link, 0))))
+      if (!find_regno_note (other_insn, REG_UNUSED, REGNO (XEXP (link, 0))))
 	remove_note (insn, link);
     }
 }
@@ -2324,9 +2328,8 @@
    taken and THREAD_IF_TRUE is set.  This is used for the branch at the
    end of a loop back up to the top.
 
-   OWN_THREAD and OWN_OPPOSITE_THREAD are true if we are the only user of the
-   thread.  I.e., it is the fallthrough code of our jump or the target of the
-   jump when we are the only jump going there.
+   OWN_THREAD is true if we are the only user of the thread, i.e. it is
+   the target of the jump when we are the only jump going there.
 
    If OWN_THREAD is false, it must be the "true" thread of a jump.  In that
    case, we can only take insns from the head of the thread for our delay
@@ -3117,7 +3120,7 @@
   /* Look at every JUMP_INSN and see if we can improve it.  */
   for (insn = first; insn; insn = next)
     {
-      rtx_insn *other;
+      rtx_insn *other, *prior_insn;
       bool crossing;
 
       next = next_active_insn (insn);
@@ -3223,8 +3226,9 @@
       /* See if the first insn in the delay slot is redundant with some
 	 previous insn.  Remove it from the delay slot if so; then set up
 	 to reprocess this insn.  */
-      if (redundant_insn (pat->insn (1), delay_insn, vNULL))
+      if ((prior_insn = redundant_insn (pat->insn (1), delay_insn, vNULL)))
 	{
+	  fix_reg_dead_note (prior_insn, insn);
 	  update_block (pat->insn (1), insn);
 	  delete_from_delay_slot (pat->insn (1));
 	  next = prev_active_insn (next);
diff -ruN gcc-7.3.0/gcc/sched-deps.c gcc-7.3.0-msp430/gcc/sched-deps.c
--- gcc-7.3.0/gcc/sched-deps.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/sched-deps.c	2019-06-25 02:27:21.157931017 -0700
@@ -2851,9 +2851,11 @@
     {
       rtx insn_set = single_set (insn);
 
+      if (!insn_set)
+	return;
+
       prev = prev_nonnote_nondebug_insn (insn);
       if (!prev
-          || !insn_set
           || !single_set (prev))
         return;
 
@@ -2920,6 +2922,8 @@
 	= alloc_INSN_LIST (insn, deps->sched_before_next_jump);
 
       /* Make sure epilogue insn is scheduled after preceding jumps.  */
+      add_dependence_list (insn, deps->last_pending_memory_flush, 1,
+			   REG_DEP_ANTI, true);
       add_dependence_list (insn, deps->pending_jump_insns, 1, REG_DEP_ANTI,
 			   true);
     }
diff -ruN gcc-7.3.0/gcc/shrink-wrap.c gcc-7.3.0-msp430/gcc/shrink-wrap.c
--- gcc-7.3.0/gcc/shrink-wrap.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/shrink-wrap.c	2019-06-25 02:27:21.157931017 -0700
@@ -157,7 +157,7 @@
 			   struct dead_debug_local *debug)
 {
   rtx set, src, dest;
-  bitmap live_out, live_in, bb_uses, bb_defs;
+  bitmap live_out, live_in, bb_uses = NULL, bb_defs = NULL;
   unsigned int i, dregno, end_dregno;
   unsigned int sregno = FIRST_PSEUDO_REGISTER;
   unsigned int end_sregno = FIRST_PSEUDO_REGISTER;
@@ -330,8 +330,11 @@
       /* Check whether BB uses DEST or clobbers DEST.  We need to add
 	 INSN to BB if so.  Either way, DEST is no longer live on entry,
 	 except for any part that overlaps SRC (next loop).  */
-      bb_uses = &DF_LR_BB_INFO (bb)->use;
-      bb_defs = &DF_LR_BB_INFO (bb)->def;
+      if (!*split_p)
+	{
+	  bb_uses = &DF_LR_BB_INFO (bb)->use;
+	  bb_defs = &DF_LR_BB_INFO (bb)->def;
+	}
       if (df_live)
 	{
 	  for (i = dregno; i < end_dregno; i++)
@@ -1374,6 +1377,8 @@
       bitmap_clear_bit (seen, bb->index);
     }
 
+  todo.release ();
+
   /* Finally, mark everything not not needed both forwards and backwards.  */
 
   FOR_EACH_BB_FN (bb, cfun)
diff -ruN gcc-7.3.0/gcc/simplify-rtx.c gcc-7.3.0-msp430/gcc/simplify-rtx.c
--- gcc-7.3.0/gcc/simplify-rtx.c	2017-07-25 04:39:23.866903000 -0700
+++ gcc-7.3.0-msp430/gcc/simplify-rtx.c	2019-06-25 02:27:21.157931017 -0700
@@ -3299,7 +3299,8 @@
       if (CONST_INT_P (trueop1)
 	  && exact_log2 (UINTVAL (trueop1)) > 0)
 	return simplify_gen_binary (AND, mode, op0,
-				    gen_int_mode (INTVAL (op1) - 1, mode));
+				    gen_int_mode (UINTVAL (trueop1) - 1,
+						  mode));
       break;
 
     case MOD:
diff -ruN gcc-7.3.0/gcc/stor-layout.c gcc-7.3.0-msp430/gcc/stor-layout.c
--- gcc-7.3.0/gcc/stor-layout.c	2017-04-12 00:35:49.004848000 -0700
+++ gcc-7.3.0-msp430/gcc/stor-layout.c	2019-06-25 02:27:21.157931017 -0700
@@ -305,13 +305,23 @@
   if (limit && size > MAX_FIXED_MODE_SIZE)
     return BLKmode;
 
+  if (mclass == MODE_PARTIAL_INT)
+    for (i = 0; i < NUM_INT_N_ENTS; i ++)
+      if (int_n_enabled_p[i]
+	  /* If the class is MODE_PARTIAL_INT, the size passed could be the
+	     in-memory size of the mode, which might be different from its
+	     bitsize, so check for both.  */
+	  && (GET_MODE_BITSIZE (int_n_data[i].m) == size
+	      || int_n_data[i].bitsize == size))
+	return int_n_data[i].m;
+
   /* Get the first mode which has this size, in the specified class.  */
   for (mode = GET_CLASS_NARROWEST_MODE (mclass); mode != VOIDmode;
        mode = GET_MODE_WIDER_MODE (mode))
     if (GET_MODE_PRECISION (mode) == size)
       return mode;
 
-  if (mclass == MODE_INT || mclass == MODE_PARTIAL_INT)
+  if (mclass == MODE_INT)
     for (i = 0; i < NUM_INT_N_ENTS; i ++)
       if (int_n_data[i].bitsize == size
 	  && int_n_enabled_p[i])
@@ -1526,6 +1536,30 @@
 	= size_binop (PLUS_EXPR, rli->offset, DECL_SIZE_UNIT (field));
       rli->bitpos = bitsize_zero_node;
       rli->offset_align = MIN (rli->offset_align, desired_align);
+
+      if (!multiple_of_p (bitsizetype, DECL_SIZE (field),
+			  bitsize_int (rli->offset_align)))
+	{
+	  tree type = strip_array_types (TREE_TYPE (field));
+	  /* The above adjusts offset_align just based on the start of the
+	     field.  The field might not have a size that is a multiple of
+	     that offset_align though.  If the field is an array of fixed
+	     sized elements, assume there can be any multiple of those
+	     sizes.  If it is a variable length aggregate or array of
+	     variable length aggregates, assume worst that the end is
+	     just BITS_PER_UNIT aligned.  */
+	  if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)
+	    {
+	      if (TREE_INT_CST_LOW (TYPE_SIZE (type)))
+		{
+		  unsigned HOST_WIDE_INT sz
+		    = least_bit_hwi (TREE_INT_CST_LOW (TYPE_SIZE (type)));
+		  rli->offset_align = MIN (rli->offset_align, sz);
+		}
+	    }
+	  else
+	    rli->offset_align = MIN (rli->offset_align, BITS_PER_UNIT);
+	}
     }
   else if (targetm.ms_bitfield_layout_p (rli->t))
     {
@@ -1672,7 +1706,12 @@
       /* If this field is the whole struct, remember its mode so
 	 that, say, we can put a double in a class into a DF
 	 register instead of forcing it to live in the stack.  */
-      if (simple_cst_equal (TYPE_SIZE (type), DECL_SIZE (field)))
+      if (simple_cst_equal (TYPE_SIZE (type), DECL_SIZE (field))
+	  /* Partial int types (e.g. __int20) may have TYPE_SIZE equal to
+	     wider types (e.g. int32), despite precision being less. Ensure
+	     that the TYPE_MODE of the struct does not get set to the partial
+	     int mode if there is a wider type also in the struct.  */
+	  && GET_MODE_PRECISION (DECL_MODE (field)) > GET_MODE_PRECISION (mode))
 	mode = DECL_MODE (field);
 
       /* With some targets, it is sub-optimal to access an aligned
@@ -1689,7 +1728,10 @@
       && GET_MODE_BITSIZE (mode) == tree_to_uhwi (TYPE_SIZE (type)))
     SET_TYPE_MODE (type, mode);
   else
-    SET_TYPE_MODE (type, mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1));
+    mode = mode_for_size_tree (TYPE_SIZE (type),
+			       (GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)
+			       ? MODE_PARTIAL_INT : MODE_INT, 1);
+    SET_TYPE_MODE (type, mode);
 
   /* If structure's known alignment is less than what the scalar
      mode would need, and it matters, then stick with BLKmode.  */
diff -ruN gcc-7.3.0/gcc/symtab.c gcc-7.3.0-msp430/gcc/symtab.c
--- gcc-7.3.0/gcc/symtab.c	2017-04-28 04:42:14.556427000 -0700
+++ gcc-7.3.0-msp430/gcc/symtab.c	2019-06-25 02:27:21.157931017 -0700
@@ -35,6 +35,7 @@
 #include "output.h"
 #include "ipa-utils.h"
 #include "calls.h"
+#include "builtins.h"
 
 static const char *ipa_ref_use_name[] = {"read","write","addr","alias","chkp"};
 
@@ -2279,3 +2280,58 @@
 
   return false;
 }
+
+/* Return true if symbol should be output to the symbol table.  */
+
+bool
+symtab_node::output_to_lto_symbol_table_p (void)
+{
+  /* Only externally visible symbols matter.  */
+  if (!TREE_PUBLIC (decl))
+    return false;
+  if (!real_symbol_p ())
+    return false;
+  /* FIXME: variables probably should not be considered as real symbols at
+     first place.  */
+  if (VAR_P (decl) && DECL_HARD_REGISTER (decl))
+    return false;
+  /* FIXME: Builtins corresponding to real functions probably should have
+     symbol table entries.  */
+  if (is_builtin_fn (decl))
+    return false;
+
+  /* We have real symbol that should be in symbol table.  However try to trim
+     down the refernces to libraries bit more because linker will otherwise
+     bring unnecesary object files into the final link.
+     FIXME: The following checks can easily be confused i.e. by self recursive
+     function or self-referring variable.  */
+
+  /* We keep external functions in symtab for sake of inlining
+     and devirtualization.  We do not want to see them in symbol table as
+     references unless they are really used.  */
+  cgraph_node *cnode = dyn_cast <cgraph_node *> (this);
+  if (cnode && (!definition || DECL_EXTERNAL (decl))
+      && cnode->callers)
+    return true;
+
+ /* Ignore all references from external vars initializers - they are not really
+    part of the compilation unit until they are used by folding.  Some symbols,
+    like references to external construction vtables can not be referred to at
+    all.  We decide this at can_refer_decl_in_current_unit_p.  */
+ if (!definition || DECL_EXTERNAL (decl))
+    {
+      int i;
+      struct ipa_ref *ref;
+      for (i = 0; iterate_referring (i, ref); i++)
+	{
+	  if (ref->use == IPA_REF_ALIAS)
+	    continue;
+          if (is_a <cgraph_node *> (ref->referring))
+	    return true;
+	  if (!DECL_EXTERNAL (ref->referring->decl))
+	    return true;
+	}
+      return false;
+    }
+  return true;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/gomp/pr83977-1.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/gomp/pr83977-1.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/gomp/pr83977-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/gomp/pr83977-1.c	2019-06-25 02:27:21.157931017 -0700
@@ -0,0 +1,19 @@
+/* PR middle-end/83977 */
+/* { dg-do compile } */
+/* { dg-additional-options "-O2" } */
+
+struct S { int a, b, c; };
+
+#pragma omp declare simd uniform(z) linear(v:1)
+__attribute__((noinline)) static int
+foo (int x, int y, struct S z, int u, int v)
+{
+  return x + y + z.a;
+}
+
+int
+bar (int x, int y, int z)
+{
+  struct S s = { z, 1, 1 };
+  return foo (x, y, s, 0, 0);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/gomp/pr83977-2.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/gomp/pr83977-2.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/gomp/pr83977-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/gomp/pr83977-2.c	2019-06-25 02:27:21.157931017 -0700
@@ -0,0 +1,18 @@
+/* PR middle-end/83977 */
+/* { dg-do compile } */
+
+void bar (void);
+
+#pragma omp declare simd uniform (b) linear(a:b)
+int
+foo (int a, int b)
+{
+  a = a + 1;
+/* This function can't be called from simd loops,
+   because it violates declare simd restrictions.
+   We shouldn't ICE on it though, nor attempt to generate
+   simd clones for the *omp_fn* functions.  */
+  #pragma omp parallel
+  bar ();  
+  return a;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/gomp/pr83977-3.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/gomp/pr83977-3.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/gomp/pr83977-3.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/gomp/pr83977-3.c	2019-06-25 02:27:21.157931017 -0700
@@ -0,0 +1,21 @@
+/* PR middle-end/83977 */
+/* { dg-do compile } */
+
+void bar (void);
+int foo (int, int) __attribute__((used));
+
+#pragma omp declare simd uniform (b) linear(a:b)
+int
+foo (int a, int b)
+{
+  a = a + 1;
+/* This function can't be called from simd loops,
+   because it violates declare simd restrictions.
+   We shouldn't ICE on it though, nor attempt to generate
+   simd clones for the *omp_fn* functions.  */
+  #pragma omp parallel
+  bar ();  
+  return a;
+}
+
+int foo (int, int)  __attribute__((unused));
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/gomp/pr84341.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/gomp/pr84341.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/gomp/pr84341.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/gomp/pr84341.c	2019-06-25 02:27:21.157931017 -0700
@@ -0,0 +1,10 @@
+/* PR c++/84341 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp" } */
+
+void
+foo (int i)
+{
+  #pragma omp atomic
+    i = &i + 1;		/* { dg-error "invalid form of" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/gomp/pr85696.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/gomp/pr85696.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/gomp/pr85696.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/gomp/pr85696.c	2019-06-25 02:27:21.157931017 -0700
@@ -0,0 +1,20 @@
+/* PR c/85696 */
+
+#ifndef __cplusplus
+void
+foo (int n, int a[][n])
+{
+  #pragma omp parallel shared(a) default(none)
+  #pragma omp master
+    a[23][0] = 42;
+}
+#endif
+
+void
+bar (int n, void *p)
+{
+  int (*a)[n] = (int (*)[n]) p;
+  #pragma omp parallel shared(a) default(none)
+  #pragma omp master
+    a[23][0] = 42;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/gomp/pr86025.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/gomp/pr86025.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/gomp/pr86025.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/gomp/pr86025.c	2019-06-25 02:27:21.157931017 -0700
@@ -0,0 +1,20 @@
+/* PR c++/86025 */
+/* { dg-do compile } */
+/* { dg-additional-options "-Wduplicated-branches" } */
+
+int i;
+
+void
+foo (int x)
+{
+  if (x)
+    {
+      #pragma omp critical (foo)
+      i++;
+    }
+  else
+    {
+      #pragma omp critical
+      i++;
+    }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/pr41779.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/pr41779.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/pr41779.c	2013-07-22 10:18:54.439312000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/pr41779.c	2019-06-25 02:27:21.157931017 -0700
@@ -1,6 +1,7 @@
 /* PR41779: Wconversion cannot see through real*integer promotions. */
 /* { dg-do compile } */
 /* { dg-skip-if "doubles are floats" { "avr-*-*" } { "*" } { "" } } */
+/* { dg-skip-if "int is smaller than float" { "msp430-*-*" } { "*" } { "" } } */
 /* { dg-options "-std=c99 -Wconversion" { target c } } */
 /* { dg-options "-Wconversion" { target c++ } } */
 /* { dg-require-effective-target large_double } */
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/pr43690.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/pr43690.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/pr43690.c	2010-11-05 04:11:50.293939000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/pr43690.c	2019-06-25 02:27:21.157931017 -0700
@@ -6,8 +6,8 @@
 foo (char *x)
 {
   asm ("" : : "m" (x++));	/* { dg-error "is not directly addressable" } */
-  asm ("" : : "m" (++x));	/* { dg-error "is not directly addressable" } */
+  asm ("" : : "m" (++x));	/* { dg-error "is not directly addressable" "" { target c } } */
   asm ("" : : "m" (x--));	/* { dg-error "is not directly addressable" } */
-  asm ("" : : "m" (--x));	/* { dg-error "is not directly addressable" } */
+  asm ("" : : "m" (--x));	/* { dg-error "is not directly addressable" "" { target c } } */
   asm ("" : : "m" (x + 1));	/* { dg-error "is not directly addressable" } */
 }
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/pr84873.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/pr84873.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/pr84873.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/pr84873.c	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-frounding-math" } */
+
+int
+i1 (int w3, int n9)
+{
+  return w3 >> ((long int)(1 + 0.1) + -!n9);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/pr84999.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/pr84999.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/pr84999.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/pr84999.c	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,12 @@
+/* PR c/84999 */
+/* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */
+/* { dg-options "" } */
+
+typedef __float128 V __attribute__ ((__vector_size__ (2 * sizeof (__float128))));
+V a;
+typeof (a != 0) b;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a == 0) c;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a < 0) d;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a <= 0) e;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a > 0) f;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a >= 0) g;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-10.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-10.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-10.c	2014-11-12 04:28:06.506786000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-10.c	2019-06-25 02:27:21.161930989 -0700
@@ -1,6 +1,7 @@
 /* Test __builtin_{add,sub}_overflow on {,un}signed long int.  */
 /* { dg-do run } */
 /* { dg-skip-if "" { ! run_expensive_tests }  { "*" } { "-O0" "-O2" } } */
+/* { dg-timeout 120 { target msp430-*-* } } */
 
 typedef signed long int S;
 typedef unsigned long int U;
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-p-10.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-p-10.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-p-10.c	2016-06-24 04:03:27.056842000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/torture/builtin-arith-overflow-p-10.c	2019-06-25 02:27:21.161930989 -0700
@@ -1,6 +1,7 @@
 /* Test __builtin_{add,sub}_overflow_p on {,un}signed long int.  */
 /* { dg-do run } */
 /* { dg-skip-if "" { ! run_expensive_tests }  { "*" } { "-O0" "-O2" } } */
+/* { dg-timeout 120 { target msp430-*-* } } */
 
 typedef signed long int S;
 typedef unsigned long int U;
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/torture/pr85022.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/torture/pr85022.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/torture/pr85022.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/torture/pr85022.c	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,9 @@
+/* PR inline-asm/85022 */
+
+extern struct B b;
+
+void
+foo ()
+{
+  __asm ("" : "+m" (b));
+}
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c	2015-01-08 14:17:49.923425000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c	2019-06-25 02:27:21.161930989 -0700
@@ -37,9 +37,10 @@
 }
 
 /* { dg-output "WARNING: ThreadSanitizer: data race.*(\n|\r\n|\r)" } */
-/* { dg-output "  Atomic read of size 1 at .* by thread T2:(\n|\r\n|\r)" } */
+/* { dg-output "  Atomic read of size \[0-9]\+ at .* by thread T2:(\n|\r\n|\r)" } */
 /* { dg-output "    #0 pthread_mutex_lock.*" } */
 /* { dg-output "    #1 Thread2.* .*(race_on_mutex.c:22|\\?{2}:0) (.*)" } */
-/* { dg-output "  Previous write of size 1 at .* by thread T1:(\n|\r\n|\r)" } */
-/* { dg-output "    #0 pthread_mutex_init .* (.)*" } */
-/* { dg-output "    #1 Thread1.* .*(race_on_mutex.c:12|\\?{2}:0) .*" } */
+/* { dg-output "  Previous write of size \[0-9]\+ at .* by thread T1:(\n|\r\n|\r)" } */
+/* { dg-output "(    #0 \[^\n\r\]*(\n|\r\n|\r))?" } */
+/* { dg-output "    #\[01\] ((__GI_)?__)?pthread_mutex_init \[^\n\r\]* (.)*" } */
+/* { dg-output "    #\[12\] Thread1.* .*(race_on_mutex.c:12|\\?{2}:0) .*" } */
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/ubsan/pr71512-1.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/ubsan/pr71512-1.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/ubsan/pr71512-1.c	2016-08-12 12:56:26.105797000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/ubsan/pr71512-1.c	2019-06-25 02:27:21.161930989 -0700
@@ -1,5 +1,6 @@
 /* PR c/71512 */
 /* { dg-do compile } */
 /* { dg-options "-O2 -fnon-call-exceptions -ftrapv -fexceptions -fsanitize=undefined" } */
+/* { dg-require-effective-target trapping } */
 
 #include "../../gcc.dg/pr44545.c"
diff -ruN gcc-7.3.0/gcc/testsuite/c-c++-common/ubsan/pr71512-2.c gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/ubsan/pr71512-2.c
--- gcc-7.3.0/gcc/testsuite/c-c++-common/ubsan/pr71512-2.c	2016-08-12 12:56:26.105797000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/c-c++-common/ubsan/pr71512-2.c	2019-06-25 02:27:21.161930989 -0700
@@ -1,5 +1,6 @@
 /* PR c/71512 */
 /* { dg-do compile } */
 /* { dg-options "-O -fexceptions -fnon-call-exceptions -ftrapv -fsanitize=undefined" } */
+/* { dg-require-effective-target trapping } */
 
 #include "../../gcc.dg/pr47086.c"
diff -ruN gcc-7.3.0/gcc/testsuite/ChangeLog gcc-7.3.0-msp430/gcc/testsuite/ChangeLog
--- gcc-7.3.0/gcc/testsuite/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/ChangeLog	2019-06-25 02:27:21.157931017 -0700
@@ -1,3 +1,1703 @@
+2018-08-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-08-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/87014
+	* g++.dg/torture/pr87014.C: New file.
+
+2018-08-21  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	Backport from mainline
+	2018-08-21  Szabolcs Nagy  <szabolcs.nagy@arm.com>
+
+	* g++.dg/torture/pr86763.C: Restrict to *-*-linux*.
+
+2018-08-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-08-02  Richard Biener  <rguenther@suse.de>
+
+	PR c++/86763
+	* g++.dg/torture/pr86763.C: New testcase.
+
+2018-07-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/discr55.adb: New test.
+
+2018-07-16  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/83184
+	Backport from trunk.
+	* gfortran.dg/assumed_rank_14.f90: New testcase.
+	* gfortran.dg/assumed_rank_15.f90: New testcase.
+	* gfortran.dg/dec_structure_8.f90: Update error messages.
+	* gfortran.dg/dec_structure_23.f90: Update error messages.
+
+2018-07-16  Fritz Reese  <fritzoreese@gmail.com>
+
+	Backport from trunk:
+
+	PR fortran/83183
+	PR fortran/86325
+	* gfortran.dg/init_flag_18.f90: New testcase.
+	* gfortran.dg/init_flag_19.f03: New testcase.
+
+2018-07-12  Richard Biener  <rguenther@suse.de>
+
+	PR target/84829
+	* gcc.target/i386/pr84829.c: New testcase.
+
+2018-07-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82969
+	PR fortran/86242
+	* gfortran.dg/proc_ptr_50.f90: New test.
+
+2018-06-26  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backported from mainline
+	2018-06-20  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* gcc.target/powerpc/builtins-1.c: Add dg directives to scan
+	for vpkudus.
+
+2018-06-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/86314
+	* gcc.dg/pr86314.c: New test.
+
+2018-06-25  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/82972
+	PR fortran/83088
+	PR fortran/85851
+	Backport from trunk.
+	* gfortran.dg/init_flag_17.f90: New testcase.
+
+2018-06-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84786
+	* gcc.target/i386/avx512f-pr84786-3.c: New test.
+
+2018-06-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83118
+	Back port from trunk
+	* gfortran.dg/unlimited_polymorphic_30.f03: New test.
+
+2018-06-23  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR tree-optimization/85989
+	* gcc.dg/torture/pr85989.c: New test.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* g++.dg/ext/offsetof3.C: New test.
+
+	2018-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86210
+	* g++.dg/warn/Wnonnull4.C: New test.
+
+	PR tree-optimization/86231
+	* gcc.dg/tree-ssa/vrp119.c: New test.
+	* gcc.c-torture/execute/pr86231.c: New test.
+
+	2018-06-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/85878
+	* gfortran.fortran-torture/compile/pr85878.f90: New test.
+
+	2018-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85945
+	* gcc.c-torture/compile/pr85945.c: New test.
+
+	2018-06-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86025
+	* c-c++-common/gomp/pr86025.c: New test.
+
+	2018-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85952
+	* g++.dg/warn/Wunused-var-33.C: New test.
+
+	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/85696
+	* c-c++-common/gomp/pr85696.c: New test.
+
+	2018-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* g++.dg/ext/offsetof2.C: New test.
+
+	2018-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85659
+	* g++.dg/ext/asm14.C: New test.
+	* g++.dg/ext/asm15.C: New test.
+	* g++.dg/ext/asm16.C: New test.
+
+	2018-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85529
+	* gcc.c-torture/execute/pr85529-1.c: New test.
+	* gcc.c-torture/execute/pr85529-2.c: New test.
+	* gcc.dg/pr85529.c: New test.
+
+	2018-04-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84463
+	* g++.dg/cpp0x/constexpr-nullptr-1.C: Add -O1 to dg-options.
+	* g++.dg/cpp0x/constexpr-nullptr-2.C: Expect different diagnostics
+	in two cases.  Uncomment two other tests and add expected dg-error for
+	them.
+	* g++.dg/init/struct2.C: Cast to int rather than long to avoid
+	-Wnarrowing diagnostics on some targets for c++11.
+	* g++.dg/parse/array-size2.C: Remove xfail.
+	* g++.dg/cpp0x/constexpr-84463.C: New test.
+
+	2018-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85430
+	* gcc.dg/pr85430.c: New test.
+
+	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85300
+	* gcc.dg/pr85300.c: New test.
+
+	PR fortran/85313
+	* gfortran.dg/gomp/pr85313.f90: New test.
+
+	2018-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85257
+	* gcc.dg/pr85257.c: New test.
+
+	2018-04-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/85252
+	* gcc.dg/debug/pr85252.c: New test.
+
+	PR c++/85210
+	* g++.dg/cpp1z/decomp42.C: New test.
+
+	2018-04-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85208
+	* g++.dg/cpp1z/decomp41.C: New test.
+
+	2018-04-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/85172
+	* g++.dg/ext/builtin13.C: New test.
+	* g++.dg/ext/atomic-4.C: New test.
+
+	2018-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85167
+	* gcc.dg/pr85167.c: New test.
+
+	PR c++/85147
+	* g++.dg/cpp0x/pr85147.C: New test.
+
+	PR c++/85140
+	* g++.dg/cpp0x/gen-attrs-64.C: New test.
+
+	2018-03-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84791
+	* g++.dg/gomp/pr84791.C: New test.
+
+	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85095
+	* gcc.target/i386/pr85095-1.c: New test.
+	* gcc.target/i386/pr85095-2.c: New test.
+	* gcc.c-torture/execute/pr85095.c: New test.
+
+	2018-03-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85076
+	* g++.dg/cpp1y/pr85076.C: New test.
+
+	PR c++/85068
+	* g++.dg/inherit/covariant22.C: New test.
+
+	2018-03-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/85034
+	* gcc.target/i386/pr85034.c: New test.
+
+	PR inline-asm/85022
+	* c-c++-common/torture/pr85022.c: New test.
+
+	2018-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/84941
+	* gcc.dg/pr84941.c: New test.
+
+	2018-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/84999
+	* c-c++-common/pr84999.c: New test.
+
+	PR c++/84961
+	* c-c++-common/pr43690.c: Don't expect errors on "m" (--x) and
+	"m" (++x) in C++.
+	* g++.dg/torture/pr84961-1.C: New test.
+	* g++.dg/torture/pr84961-2.C: New test.
+
+	2018-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/84875
+	* gcc.dg/pr84875.c: New test.
+
+	PR c/84953
+	* gcc.dg/pr84953.c: New test.
+
+	2018-03-19  Maxim Ostapenko  <m.ostapenko@samsung.com>
+
+	PR sanitizer/78651
+	* g++.dg/asan/pr78651.C: New test.
+
+	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84899
+	* gcc.dg/pr84899.c: New test.
+
+	PR c++/84874
+	* g++.dg/cpp1z/desig8.C: New test.
+
+	PR tree-optimization/84841
+	* gcc.dg/pr84841.c: New test.
+
+	PR c++/84874
+	* g++.dg/cpp1z/desig7.C: New test.
+
+	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/79085
+	* g++.dg/opt/pr79085.C: New test.
+
+	PR c++/84222
+	* g++.dg/warn/deprecated.C (T::member3): Change dg-warning to dg-bogus.
+	* g++.dg/warn/deprecated-6.C (T::member3): Likewise.
+	* g++.dg/warn/deprecated-13.C: New test.
+
+	PR target/84860
+	* gcc.c-torture/compile/pr84860.c: New test.
+
+	PR c/84853
+	* gcc.dg/pr84853.c: New test.
+
+	2018-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/84834
+	* gcc.dg/pr84834.c: New test.
+
+	PR target/84827
+	* gcc.target/i386/pr84827.c: New test.
+
+	PR target/84786
+	* gcc.target/i386/avx512f-pr84786-1.c: New test.
+	* gcc.target/i386/avx512f-pr84786-2.c: New test.
+
+	2018-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84772
+	* gcc.dg/pr84772.c: New test.
+
+	2018-03-09  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84076
+	* g++.dg/warn/Wformat-2.C: New test.
+
+	2018-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84767
+	* g++.dg/ext/vla18.C: New test.
+
+	2018-03-08  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/80598
+	* g++.dg/warn/Wunused-function4.C: New test.
+
+	2018-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/84739
+	* gcc.dg/pr84739.c: New test.
+
+	2018-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84700
+	* gcc.target/powerpc/pr84700.c: New test.
+
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84662
+	* g++.dg/cpp1y/pr84662.C: New test.
+
+2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2018-06-05  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* gcc.target/arm/cmse/cmse-1c99.c: New test.
+
+2018-06-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/aggr24.adb: New test.
+	* gnat.dg/aggr24_pkg.ad[sb]: New helper.
+
+2018-06-18  Martin Sebor  <msebor@redhat.com>
+
+        PR middle-end/82063
+        * gcc.dg/Walloc-size-larger-than-1.c: New test.
+        * gcc.dg/Walloc-size-larger-than-10.c: New test.
+        * gcc.dg/Walloc-size-larger-than-11.c: New test.
+        * gcc.dg/Walloc-size-larger-than-12.c: New test.
+        * gcc.dg/Walloc-size-larger-than-13.c: New test.
+        * gcc.dg/Walloc-size-larger-than-14.c: New test.
+        * gcc.dg/Walloc-size-larger-than-15.c: New test.
+        * gcc.dg/Walloc-size-larger-than-16.c: New test.
+        * gcc.dg/Walloc-size-larger-than-2.c: New test.
+        * gcc.dg/Walloc-size-larger-than-3.c: New test.
+        * gcc.dg/Walloc-size-larger-than-4.c: New test.
+        * gcc.dg/Walloc-size-larger-than-5.c: New test.
+        * gcc.dg/Walloc-size-larger-than-6.c: New test.
+        * gcc.dg/Walloc-size-larger-than-7.c: New test.
+        * gcc.dg/Walloc-size-larger-than-8.c: New test.
+        * gcc.dg/Walloc-size-larger-than-9.c: New test.
+        * gcc.dg/Walloc-size-larger-than.c: New test.
+
+2018-06-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86110
+	* gfortran.dg/pr86110.f90: New test.
+
+2018-06-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/44491
+	* gfortran.dg/pr44491.f90: New testcase
+
+2018-06-11  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-06-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/85755
+	* gcc.target/powerpc/pr85755.c: New test.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/38351
+	* gfortran.dg/pr38351.f90: New test.
+	* gfortran.dg/typebound_operator_4.f03: Adjust for new error message.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/63514
+	* gfortran.dg/pr63514.f90: New test.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78278
+	* gfortran.dg/data_bounds_1.f90: Add -std=gnu option.
+	* gfortran.dg/data_char_1.f90: Ditto.
+	* gfortran.dg/pr78571.f90: Ditto.
+	* gfortran.dg/pr78278.f90: New test.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86059
+	* gfortran.dg/associate_30.f90: Remove code tested ...
+	* gfortran.dg/pr67803.f90: Ditto.
+	* gfortran.dg/pr67805.f90: Ditto.
+	* gfortran.dg/pr86059.f90: ... here.  New test.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85138
+	PR fortran/85996
+	PR fortran/86051
+	* gfortran.dg/pr85138_1.f90: New test.
+	* gfortran.dg/pr85138_2.f90: Ditto.
+	* gfortran.dg/pr85996.f90: Ditto.
+
+2018-06-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86045
+	Backport from trunk.
+	* gfortran.dg/pr86045.f90: New test.
+
+2018-06-07  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/85641
+	Backport from trunk.
+	* gfortran.dg/realloc_on_assign_30.f90: New test.
+
+2018-06-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-05-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85588
+	* gcc.dg/torture/pr85588.c: New testcase.
+	* gcc.dg/torture/pr57656.c: Use dg-additional-options.
+
+	2018-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85567
+	* gcc.dg/torture/pr85567.c: New testcase.
+
+	2018-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85597
+	* gcc.dg/vect/pr85597.c: New testcase.
+
+2018-06-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-06-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/htm-builtins-compile-4.c: New test.
+
+2018-06-04  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85981
+	* gfortran.dg/allocate_alloc_opt_14.f90: New test.
+	* gfortran.dg/allocate_alloc_opt_1.f90: Update error string.
+	* gfortran.dg/allocate_stat_2.f90: Ditto.
+	* gfortran.dg/deallocate_alloc_opt_1.f90: Ditto.
+
+2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/specs/opt3.ads: New test.
+	* gnat.dg/specs/opt3_pkg.ads: New helper.
+
+2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/discr53.ad[sb]: New test.
+	* gnat.dg/discr53_pkg.ads: New helper.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85543
+	Backport from trunk
+	* gfortran.dg/pr85543.f90: New test.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85779
+	Backport from trunk
+	* gfortran.dg/pr85779_1.f90: New test.
+	* gfortran.dg/pr85779_2.f90: Ditto.
+	* gfortran.dg/pr85779_3.f90: Ditto.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85780
+	Backport from trunk
+	* gfortran.dg/pr85780.f90: New test.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85895
+	Backport from trunk
+	* gfortran.dg/coarray_3.f90: Fix invalid testcase.
+	* gfortran.dg/pr85895.f90: New test.
+
+2018-05-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/avx512f-vcvtusi2sd64-1.c: Update scan string.
+	* gcc.target/i386/avx512f-vcvtusi2ss64-1.c: Ditto.
+
+2018-05-21  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline:
+	2018-05-17  Pat Haugen  <pthaugen@us.ibm.com>
+
+	PR target/85698
+	* gcc.target/powerpc/pr85698.c: New test.
+
+2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/80657
+	Backport from trunk
+	* gfortran.dg/char_result_18.f90: New test.
+
+2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82275
+	Backport from trunk
+	* gfortran.dg/select_type_42.f90: New test.
+
+2018-05-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82923
+	Backport from trunk
+	* gfortran.dg/allocate_assumed_charlen_4.f90: New test. Note
+	that the patch fixes PR66694 & PR82617, although the testcases
+	are not explicitly included.
+
+2017-05-17  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82814
+	Backport from trunk
+	* gfortran.dg/submodule_31.f08: New test.
+
+2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83149
+	Backport from trunk
+	* gfortran.dg/pr83149_1.f90: New test.
+	* gfortran.dg/pr83149.f90: Additional source for previous.
+	* gfortran.dg/pr83149_b.f90: New test.
+	* gfortran.dg/pr83149_a.f90: Additional source for previous.
+
+2018-16-05  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83898
+	Backport from trunk
+	* gfortran.dg/associate_33.f03 : New test.
+
+2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/84546
+	Backport from trunk
+	* gfortran.dg/unlimited_polymorphic_29.f90 : New test.
+
+2018-05-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85542
+	Backport from trunk
+	* gfortran.dg/pr85542.f90: New test.
+
+2018-05-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/68846
+	Backport from trunk
+	* gfortran.dg/temporary_3.f90 : New test.
+
+	PR fortran/70864
+	Backport from trunk
+	* gfortran.dg/temporary_2.f90 : New test.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/70870
+	Backport from trunk
+	* gfortran.dg/pr70870_1.f90: New test.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85521
+	Backport from trunk
+	* gfortran.dg/pr85521_1.f90: New test.
+	* gfortran.dg/pr85521_2.f90: New test.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85687
+	Backport from trunk
+	* gfortran.dg/pr85687.f90: new test.
+
+2018-05-06  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/85507
+	Backport from trunk.
+	* gfortran.dg/coarray_dependency_1.f90: New test.
+	* gfortran.dg/coarray_lib_comm_1.f90: Fix counting caf-expressions.
+
+2018-05-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from trunk
+	2018-04-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/82518
+	* lib/target-supports.exp (check_effective_target_vect_load_lanes):
+	Use check_effective_target_arm_little_endian.
+
+2018-04-28  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/81773
+	PR fortran/83606
+	Backport from trunk.
+	* gfortran.dg/coarray/get_to_indexed_array_1.f90: New test.
+	* gfortran.dg/coarray/get_to_indirect_array.f90: New test.
+
+2018-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-04-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85284
+	* gcc.dg/torture/pr85284.c: New testcase.
+
+	2018-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85244
+	* gcc.dg/torture/pr85244-1.c: New testcase.
+	* gcc.dg/torture/pr85244-2.c: Likewise.
+
+	2018-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85168
+	* gcc.dg/torture/pr85168.c: New testcase.
+
+	2018-03-15  Richard Biener  <rguenther@suse.de>
+
+	PR c/84873
+	* c-c++-common/pr84873.c: New testcase.
+
+2018-04-24  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85520
+	* gfortran.dg/pr85520.f90: New test.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR lto/85248
+	* gcc.dg/lto/pr85248_0.c: New test.
+	* gcc.dg/lto/pr85248_1.c: New test.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
+		    Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/85081
+	* g++.dg/asan/pr85081.C: New test.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-21  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/84963
+	* gfortran.dg/goacc/pr84963.f90: New test.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-13  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/84658.
+	* g++.dg/ipa/pr84658.C: New test.
+
+2018-04-23  Aaron Sawdey  <acsawdey@linux.ibm.com>
+
+	Backport from mainline
+	2018-04-16  Aaron Sawdey  <acsawdey@linux.ibm.com>
+
+	PR target/83660
+	* gcc.target/powerpc/pr83660.C: New test.
+
+2018-04-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/torture/pr85496.C: New test.
+
+2018-04-20  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/85436
+	* go.dg/pr85436.go: New test.
+
+	Backport from mainline
+	2018-03-09  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83969
+	* gcc.target/powerpc/pr83969.c: New test.
+
+2018-04-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/85464 - missing location for -Wignored-qualifiers diagnostic
+	* g++.dg/diagnostic/pr85464.C: New.
+
+2018-04-18  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2018-04-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/85261
+	* gcc.target/arm/fpscr.c: Add call to __builtin_arm_set_fpscr with
+	literal value.  Expect 2 MCR instruction.  Fix function prototype.
+	Remove volatile keyword.
+
+2018-04-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-04-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/nobp-no-dwarf2-cfi.c: New test.
+
+2018-04-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2018-04-04  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/85203
+	* gcc.target/arm/cmse/cmse-1.c: Tighten cmse_nonsecure_caller RTL scan
+	to match a single insn of the baz function.  Move scan directives at
+	the end of the file below the functions they are trying to test for
+	better readability.
+	* gcc.target/arm/cmse/cmse-16.c: New testcase.
+
+2018-04-10  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR target/85056
+	* gcc.target/nvptx/pr85056.c (main): Initialize "sum".
+
+2018-04-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/84748
+	* gcc.c-torture/execute/pr84748.c: New test.
+
+2018-04-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/opt/pr85196.C: New test.
+
+2018-04-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/85193
+	* gcc.target/i386/pr85193.c: New test.
+
+2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR rtl-optimization/84878
+	* gcc.target/powerpc/pr84878.c: New test.
+
+2018-04-03  Cesar Philippidis  <cesar@codesourcery.com>
+
+	Backport from mainline
+	2018-03-27  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR target/85056
+	* testsuite/gcc.target/nvptx/pr85056.c: New test.
+	* testsuite/gcc.target/nvptx/pr85056a.c: New test.
+
+2018-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84912
+	* gcc.target/powerpc/extend-divide-1.c (div_weo): Remove test for
+	deleted builtin function.
+	(div_weuo): Likewise.
+	* gcc.target/powerpc/extend-divide-2.c (div_deo): Likewise.
+	(div_deuo): Likewise.
+
+2018-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/81143
+	* gcc.target/powerpc/pr79799-2.c: Use __LITTLE_ENDIAN__.
+
+2018-03-29  Sebastian Peryt  <sebastian.peryt@intel.com>
+
+	PR c++/84783
+	* gcc.target/i386/avx512vl-vpermd-1.c (_mm256_permutexvar_epi32):
+	Test new intrinsic.
+	* gcc.target/i386/avx512vl-vpermq-imm-1.c (_mm256_permutex_epi64):
+	Ditto.
+	* gcc.target/i386/avx512vl-vpermq-var-1.c (_mm256_permutexvar_epi64):
+	Ditto.
+	* gcc.target/i386/avx512f-vpermd-2.c: Do not check for AVX512F_LEN.
+	* gcc.target/i386/avx512f-vpermq-imm-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermq-var-2.c: Ditto.
+
+2018-03-29  Sudakshina Das  <sudi.das@arm.com>
+
+	* gcc.target/arm/pr84826.c: Change dg-option to -fstack-check.
+
+	Backport from mainline
+	2018-03-23  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/84826
+	* gcc.target/arm/pr84826.c: Add dg directive.
+
+	Backport from mainline
+	2018-03-22  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/84826
+	* gcc.target/arm/pr84826.c: New test.
+
+2018-03-28  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/crypto-builtin-1-runnable:  Add
+	p8vector_hw to dg-do run.
+
+2018-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/85084
+	Backport from trunk.
+	* gfortran.dg/matmul_rank_1.f90: New test.
+
+2018-03-28  Sudakshina Das  <sudi.das@arm.com>
+	    Christophe Lyon  <christophe.lyon@linaro.org>
+
+	2018-03-20  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	PR target/81647
+	* gcc.target/aarch64/pr81647.c: Require fenv_exceptions.
+
+	2018-03-19  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/81647
+	* gcc.target/aarch64/pr81647.c: New.
+
+2018-03-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/85026
+	* g++.dg/pr85026.C: New test.
+
+2018-03-28  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2018-03-08  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/82411
+	* gcc.target/powerpc/ppc-sdata-2.c: Skip if -mno-readonly-in-sdata.
+
+2018-03-27  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from mainline:
+	2018-03-20  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82989
+	* gcc.target/arm/pr82989.c: New test.
+
+	Backport from mainline:
+	2018-03-21  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82989
+	* gcc.target/arm/pr82989.c: Change dg scan-assembly directives.
+
+2018-03-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/82518
+	* lib/target-supports.exp (check_effective_target_vect_load_lanes):
+	Disable for armeb targets.
+	* gcc.target/arm/pr82518.c: New test.
+
+2018-03-23  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/crypto-builtin-1-runnable.c: New test file.
+
+2018-03-22  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2018-03-22  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/84956
+	* gcc.dg/pr84956.c: New test.
+
+2018-03-20  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85001
+	* gfortran.dg/interface_41.f90: New test.
+
+2018-03-19  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84931
+	Backport from trunk
+	* gfortran.dg/array_constructor_52.f90: New test.
+
+2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/77414
+	* gfortran.dg/pr77414.f90: New test.
+	* gfortran.dg/internal_references_1.f90: Adjust error message.
+
+2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/65453
+	* gfortran.dg/pr65453.f90: New test.
+
+2018-03-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-03-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84574
+	* gcc.target/i386/ret-thunk-9.c: Expect __x86_return_thunk
+	label instead of __x86_indirect_thunk label.
+
+2018-03-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78741
+	* gfortran.dg/pr78741.f90: New test.
+
+2018-03-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/83939
+	* gfortran.dg/pr83939.f90
+
+2018-03-12  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR tree-optimization/84485
+	* gcc.dg/vect/pr84485.c: New test.
+
+2018-03-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84734
+	* gfortran.dg/pr84734.f90: New test.
+
+2018-03-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/prot3.adb: New test.
+	* gnat.dg/prot3_pkg.ad[sb]: New helper.
+
+2018-03-09  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	Backport from mainline
+	2017-09-13  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	* gcc.target/aarch64/pr63304_1.c: Remove-mno-fix-cortex-a53-843419.
+
+2018-03-08  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/64124
+	PR fortran/70409
+	* gfortran.dg/pr64124.f90: New tests.
+	* gfortran.dg/pr70409.f90: New tests.
+
+2018-03-06  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline
+	2/16/18  commit 257748  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/p9-vinsert4b-1.c: Remove test file for non-ABI
+	tests.
+	* gcc.target/powerpc/p9-vinsert4b-2.c: Remove test file for non-ABI
+	tests.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-23  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR testsuite/80551
+	* c-c++-common/tsan/race_on_mutex.c: Change regexp to allow
+	__GI___pthread_mutex_init as well.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-20  Martin Liska  <mliska@suse.cz>
+
+	PR c/84310
+	PR target/79747
+	* gcc.target/i386/pr84310.c: New test.
+	* gcc.target/i386/pr84310-2.c: Likewise.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-23  Martin Liska  <mliska@suse.cz>
+
+	PR lto/81440
+	* gcc.dg/lto/pr81440.h: New test.
+	* gcc.dg/lto/pr81440_0.c: New test.
+	* gcc.dg/lto/pr81440_1.c: New test.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-04-27  Martin Liska  <mliska@suse.cz>
+
+	PR testsuite/79455
+	* c-c++-common/tsan/race_on_mutex.c: Make the scanned pattern
+	more generic.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/83954
+	* gcc.dg/lto/pr83954.h: New testcase.
+	* gcc.dg/lto/pr83954_0.c: New testcase.
+	* gcc.dg/lto/pr83954_1.c: New testcase.
+
+2018-03-06  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/56667
+	* gfortran.dg/implied_do_2.f90: New test.
+	* gfortran.dg/coarray_8.f90: Update for new error message.
+
+2018-03-06  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-22  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR target/81572
+	* gcc.target/powerpc/pr81572.c: New.
+
+2018-03-06  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-02-28  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/84607
+	* gcc.dg/pr84607.c: New testcase.
+
+2018-03-05  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	Backport from trunk.
+
+	2018-02-16  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	PR target/84371
+	* gcc.target/powerpc/builtins-3.c: Update dg-options and dg-skip-if
+	stanzas.
+	* gcc.target/powerpc/builtins-3.p8.c: Add dg-skip-if stanza.
+	* gcc.target/powerpc/builtins-3.p9.c: Add dg-skip-if stanza.
+
+2018-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84524
+	* gcc.c-torture/execute/pr84524.c: New test.
+	* gcc.target/i386/avx512bw-pr84524.c: New test.
+
+2018-03-04  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83076
+	* gfortran.dg/coarray_45.f90: New test.
+
+	PR fortran/83319
+	* gfortran.dg/coarray_46.f90: New test.
+
+2018-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/71085
+	* gfortran.dg/pr71085.f90: New test.
+
+2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/51434
+	* gfortran.dg/pr51434.f90: New test.
+
+2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/80965
+	* gfortran.dg/select_type_41.f90: New test.
+
+2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from trunk.
+	PR fortran/78990
+	* gfortran.dg/class_67.f90: New test.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/84628
+	* gcc.dg/pr84628.c: New test.
+
+	PR inline-asm/84625
+	* gcc.target/i386/pr84625.c: New test.
+
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/70875
+	* gcc.dg/ubsan/bounds-3.c: Add -fno-sanitize-recover=bounds to
+	dg-options and dg-shouldfail "ubsan" directive.
+
+	2018-02-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84558
+	* g++.dg/cpp1y/pr84558.C: New test.
+
+	PR c++/84557
+	* g++.dg/gomp/pr84557.C: New test.
+
+	PR c++/84556
+	* g++.dg/gomp/pr84556.C: New test.
+	* g++.dg/vect/pr84556.cc: New test.
+
+	2018-02-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/84503
+	* gcc.dg/pr84503-1.c: New test.
+	* gcc.dg/pr84503-2.c: New test.
+
+	2017-11-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/82916
+	* gcc.dg/pr82916.c: New test.
+
+	2018-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84445
+	* g++.dg/cpp1z/launder7.C: New test.
+
+	PR c++/84449
+	* g++.dg/cpp0x/constexpr-84449.C: New test.
+
+	2018-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84444
+	* g++.dg/cpp1z/launder8.C: New test.
+
+	PR c++/84448
+	* g++.dg/gomp/pr84448.C: New test.
+
+	PR c++/84430
+	* g++.dg/gomp/pr84430.C: New test.
+
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/84425
+	* gcc.c-torture/compile/pr84425.c: New test.
+
+	2018-02-16  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84192
+	* g++.dg/cpp1y/constexpr-84192.C: New test.
+
+	2018-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/82210
+	* gcc.c-torture/execute/pr82210.c: New test.
+
+	2018-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84341
+	* c-c++-common/gomp/pr84341.c: New test.
+
+	2018-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* g++.dg/ubsan/pr83987-2.C: New test.
+
+	2018-02-09  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83659
+	* g++.dg/torture/pr83659.C: New test.
+
+	2018-02-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84082
+	* g++.dg/template/incomplete11.C: New test.
+	* g++.dg/parse/crash67.C: Expect an incomplete type diagnostics too.
+
+	2018-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/81661
+	PR tree-optimization/84117
+	* gcc.dg/pr81661.c: New test.
+	* gfortran.dg/pr84117.f90: New test.
+
+	2018-01-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/84116
+	* gfortran.dg/gomp/pr84116.f90: New test.
+
+	PR c++/83993
+	* g++.dg/init/pr83993-2.C: New test.
+
+	PR preprocessor/69869
+	* gcc.dg/cpp/trad/pr69869.c: New test.
+
+	2018-01-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/83986
+	* gcc.dg/pr83986.c: New test.
+
+	2018-01-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84031
+	* g++.dg/cpp1z/decomp36.C: New test.
+
+	2018-01-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/83977
+	* c-c++-common/gomp/pr83977-1.c: New test.
+	* c-c++-common/gomp/pr83977-2.c: New test.
+	* c-c++-common/gomp/pr83977-3.c: New test.
+	* gfortran.dg/gomp/pr83977.f90: New test.
+
+	2018-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* g++.dg/ubsan/pr83987.C: New test.
+
+	PR c++/83958
+	* g++.dg/cpp1z/decomp35.C: New test.
+
+	2018-01-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/83945
+	* gcc.dg/tls/pr83945.c: New test.
+
+	PR target/83930
+	* gcc.dg/pr83930.c: New test.
+
+	2018-01-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83824
+	* g++.dg/cpp0x/pr83824.C: New test.
+
+	2018-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83817
+	* g++.dg/cpp1y/pr83817.C: New test.
+
+	2018-01-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/83605
+	* gcc.dg/pr83605.c: New test.
+
+2018-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84039
+	* gcc.target/i386/indirect-thunk-1.c: Updated.
+	* gcc.target/i386/indirect-thunk-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-bnd-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-bnd-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-bnd-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-bnd-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-7.c: Likewise.
+	* gcc.target/i386/ret-thunk-9.c: Likewise.
+	* gcc.target/i386/ret-thunk-10.c: Likewise.
+	* gcc.target/i386/ret-thunk-11.c: Likewise.
+	* gcc.target/i386/ret-thunk-12.c: Likewise.
+	* gcc.target/i386/ret-thunk-13.c: Likewise.
+	* gcc.target/i386/ret-thunk-14.c: Likewise.
+	* gcc.target/i386/ret-thunk-15.c: Likewise.
+
+2018-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84530
+	* gcc.target/i386/ret-thunk-22.c: New test.
+	* gcc.target/i386/ret-thunk-23.c: Likewise.
+	* gcc.target/i386/ret-thunk-24.c: Likewise.
+	* gcc.target/i386/ret-thunk-25.c: Likewise.
+	* gcc.target/i386/ret-thunk-26.c: Likewise.
+
+2017-03-02  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport from trunk r256891:
+	2018-01-19  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR target/83790
+	* gcc.target/nvptx/indirect_call.c: New test.
+
+2017-03-01  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2017-12-05  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+	with follow-up r255433 commit.
+
+	* gcc.c-torture/unsorted/dump-noaddr.x: Generate dump files in
+	tmpdir.
+
+2018-02-28  Alan Modra  <amodra@gmail.com>
+
+	* lib/prune.exp (prune_gcc_output): Match lower case "in function"
+	GNU ld message.
+	* g++.dg/other/anon5.C: Match lower case "bad value" GNU ld message.
+
+2018-02-26  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline: commit 257747 on 2018-02-16.
+
+	* gcc.target/powerpc/builtins-7-p9-runnable.c: New runnable test file
+	for the ABI definitions for vec_extract4b and vec_insert4b.
+
+2018-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20180226-1.c: New test.
+
+2018-02-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	ChangeLog for r257972
+	PR fortran/83633
+	* gfortran.dg/explicit_shape_1.f90: New test.
+	* gfortran.dg/automatic_module_variable.f90: Update regex.
+	* gfortran.dg/bad_automatic_objects_1.f90: Ditto.
+
+2018-02-25  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/78238
+	Backport from trunk
+	* gfortran.dg/select_type_40.f90: New test.
+
+2018-02-24  Steven G. Kargl <kargl@gcc.gnu.org>
+
+	PR fortran/30792
+	* gfortran.dg/data_substring.f90: New test.
+
+2018-02-23  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84346
+	* gfortran.dg/statement_function_1.f90: Update test.
+
+2018-02-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84506
+	* gfortran.dg/inquire_19.f90: New test.
+
+2018-02-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/81116
+	PR fortran/84495
+	* gfortran.dg/realloc_on_assignment_29.f90:  New test.
+
+2017-02-22  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from mainline:
+	2017-12-14  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/81228
+	* gcc.dg/pr81228.c: New.
+
+2018-02-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-01-02  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/81860
+	* g++.dg/cpp0x/inh-ctor30.C: New test.
+
+2018-02-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR libgfortran/84412
+	* gfortran.dg/inquire_18.f90: New test.
+
+2018-02-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84270
+	* gfortran.dg/inline_matmul_22.f90: New test.
+
+2018-02-16  Jozef Lawrynowicz <jozefl.gcc@gmail.com>
+
+	PR target/79242
+	gcc.target/msp430/pr79242.c: New test.
+
+2018-02-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/84277
+	* gnat.dg/array11.adb (Array11): Tweak index and remove warning.
+	* gnat.dg/dispatch1.adb: Rename into...
+	* gnat.dg/disp1.adb: ...this.
+	* gnat.dg/dispatch1_p.ads: Rename into...
+	* gnat.dg/disp1_pkg.ads: ...this.
+	* gnat.dg/disp2.adb: Rename into...
+	* gnat.dg/dispatch2.adb: ...this.
+	* gnat.dg/dispatch2_p.ads: Rename into...
+	* gnat.dg/disp2_pkg.ads: ...this.
+	* gnat.dg/dispatch2_p.adb: Rename into...
+	* gnat.dg/disp2_pkg.adb: this.
+	* gnat.dg/generic_dispatch.adb: Rename into...
+	* gnat.dg/generic_disp.adb: this.
+	* gnat.dg/generic_dispatch_p.ads: Rename into...
+	* gnat.dg/generic_disp_pkg.ads: ...this.
+	* gnat.dg/generic_dispatch_p.adb: Rename into...
+	* gnat.dg/generic_disp_pkg.adb: ...this.
+	* gnat.dg/null_pointer_deref1.adb (Null_Pointer_Deref1): Robustify.
+	* gnat.dg/null_pointer_deref2.adb (Null_Pointer_Deref2): Likewise.
+	* gnat.dg/object_overflow1.adb: Tweak index.
+	* gnat.dg/object_overflow2.adb: Likewise.
+	* gnat.dg/object_overflow3.adb: Likewise.
+	* gnat.dg/object_overflow4.adb: Likewise.
+	* gnat.dg/object_overflow5.adb: Likewise.
+
+2018-02-16  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from trunk
+	2018-01-12  Sudakshina Das  <sudi.das@arm.com>
+
+	* gcc.c-torture/compile/pr82096.c: Add dg-skip-if
+	directive.
+
+	Backport from trunk
+	2018-01-10  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82096
+	* gcc.c-torture/compile/pr82096.c: New test.
+
+2018-02-16  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84190
+	* g++.dg/torture/pr84190.C: New testcase.
+
+2018-02-15  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-02-07  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/84154
+	* gcc.target/powerpc/pr84154-1.c: New tests.
+	* gcc.target/powerpc/pr84154-2.c: Likewise.
+	* gcc.target/powerpc/pr84154-3.c: Likewise.
+
+2018-02-15  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	PR target/84388
+	* gcc.target/powerpc/fold-vec-mult-int128-p8.c: Update dg-options
+	and scan-assembler stanzas.
+	* gcc.target/powerpc/fold-vec-mult-int128-p9.c: Same.
+
+2018-02-14  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84390
+	* gcc.target/powerpc/vsxcopy.c: Also match lxv when compiling
+	with -mcpu=power9.
+
+2018-02-14  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-02-13  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84279
+	* g++.dg/pr84279.C: New test.
+
+2018-02-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/68560
+	* gfortran.dg/shape_9.f90: New test.
+
+2018-02-12  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	PR fortran/35299
+	ChangeLog for r257566
+	* gfortran.dg/statement_function_3.f: New test.
+
+2018-02-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/54223
+	PR fortran/84276
+	* gfortran.dg/statement_function_1.f90: New test.
+	* gfortran.dg/statement_function_2.f90: New test.
+
+2018-02-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	PR target/PR84295
+	* gcc.target/s390/pr84295.c: New test.
+
+2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/nobp-function-pointer-attr.c: New test.
+	* gcc.target/s390/nobp-function-pointer-nothunk.c: New test.
+	* gcc.target/s390/nobp-function-pointer-z10.c: New test.
+	* gcc.target/s390/nobp-function-pointer-z900.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-attr.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-inline-attr.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-inline-z10.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-inline-z900.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-nothunk.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-z10.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-z900.c: New test.
+	* gcc.target/s390/nobp-return-attr-all.c: New test.
+	* gcc.target/s390/nobp-return-attr-neg.c: New test.
+	* gcc.target/s390/nobp-return-mem-attr.c: New test.
+	* gcc.target/s390/nobp-return-mem-nothunk.c: New test.
+	* gcc.target/s390/nobp-return-mem-z10.c: New test.
+	* gcc.target/s390/nobp-return-mem-z900.c: New test.
+	* gcc.target/s390/nobp-return-reg-attr.c: New test.
+	* gcc.target/s390/nobp-return-reg-mixed.c: New test.
+	* gcc.target/s390/nobp-return-reg-nothunk.c: New test.
+	* gcc.target/s390/nobp-return-reg-z10.c: New test.
+	* gcc.target/s390/nobp-return-reg-z900.c: New test.
+	* gcc.target/s390/nobp-table-jump-inline-z10.c: New test.
+	* gcc.target/s390/nobp-table-jump-inline-z900.c: New test.
+	* gcc.target/s390/nobp-table-jump-z10.c: New test.
+	* gcc.target/s390/nobp-table-jump-z900.c: New test.
+
+2018-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84233
+	* g++.dg/torture/pr84233.C: New testcase.
+
+2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82994
+	* gfortran.dg/deallocate_error_3.f90: New test.
+	* gfortran.dg/deallocate_error_4.f90: New test.
+
+2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82049
+	* gfortran.dg/assumed_charlen_parameter.f90: New test.
+
+2018-02-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-06  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/safe-indirect-jump-1.c: Detect deprecation
+	warning for -mno-speculate-indirect-jumps.
+	* gcc.target/powerpc/safe-indirect-jump-2.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-3.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-4.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-5.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-6.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-7.c: Likewise.
+
+2018-02-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR target/79975
+	* gcc.dg/rtl/x86_64/final.c: Add -fdwarf2-cfi-asm to dg-options.
+
+2017-02-02  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gfortran.dg/dec_parameter_1.f (sub1): Remove statement with no effect.
+	* gfortran.dg/dec_parameter_2.f90 (sub1): Ditto.
+
+2018-02-01  Renlin Li  <renlin.li@arm.com>
+
+	Backport from mainline
+	2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR target/83370
+	* gcc.target/aarch64/pr83370.c: New.
+
+2018-02-01  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2017-11-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/82795
+	* gcc.target/i386/pr82795.c: New testcase.
+
+2018-02-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline
+	2018-01-12  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* lib/target-supports.exp (check_effective_target_avx512f): Also
+	check for __builtin_ia32_addsd_round,
+	__builtin_ia32_getmantsd_round.
+	* gcc.target/i386/i386.exp (check_effective_target_avx512f):
+	Remove.
+
+2018-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20180131-1.c: New test.
+
+2018-01-29  Alan Modra  <amodra@gmail.com>
+
+	PR target/84033
+	* gcc.target/powerpc/swaps-p8-46.c: New.
+
+2018-01-26  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-01-26  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* gcc.target/powerpc/safe-indirect-jump-1.c: Build on all targets.
+	Make expected output depend on whether we expect sibcalls or not.
+	* gcc.target/powerpc/safe-indirect-jump-8.c: Delete (merged into
+	safe-indirect-jump-1.c).
+
+	Backport from trunk
+	2018-01-21  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/83946
+	* gcc.target/powerpc/safe-indirect-jump-8.c: Skip for AIX.
+
+2018-01-26  Nathan Sidwell  <nathan@acm.org>
+
+	PR c++/82878
+	* g++.dg/cpp0x/pr82878.C: New.
+	* g++.dg/cpp1z/inh-ctor38.C: Check moves too.
+
+2018-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/83985
+	* gcc.dg/pr83985.c: New test.
+
+2018-01-25  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-01-22  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/83862
+	* gcc.target/powerpc/pr83862.c: New test.
+
+2018-01-25  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-01-10  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83399
+	* gcc.target/powerpc/pr83399.c: New test.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
@@ -920,7 +2620,7 @@
 
 	Backported from trunk
 	PR fortran/80850
-	* gfortran.dg/class_64_f90 : New test.
+	* gfortran.dg/class_64_f90: New test.
 
 2017-10-30  Paolo Carlini  <paolo.carlini@oracle.com>
 
@@ -971,7 +2671,7 @@
 
 	Backport from trunk
 	PR fortran/82312
-	* gfortran.dg/typebound_proc_36.f90 : New test.
+	* gfortran.dg/typebound_proc_36.f90: New test.
 
 2017-10-20  Thomas Koenig  <tkoenig@gcc.gnu.org>
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/compile/20151204.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/compile/20151204.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/compile/20151204.c	2016-03-16 11:09:51.328187000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/compile/20151204.c	2019-06-25 02:27:21.165930961 -0700
@@ -1,4 +1,4 @@
-/* { dg-skip-if "Array too big" { "avr-*-*" } } */
+/* { dg-skip-if "Array too big" { "avr-*-*" msp430-*-* } } */
 
 typedef __SIZE_TYPE__ size_t;
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/compile/pr65595.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/compile/pr65595.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/compile/pr65595.c	2015-03-27 03:33:17.604171000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/compile/pr65595.c	2019-06-25 02:27:21.165930961 -0700
@@ -1,4 +1,4 @@
-extern void *memcpy(void *, const void *, unsigned long);
+extern void *memcpy(void *, const void *, __SIZE_TYPE__);
 struct in6_addr {
   struct {
     int u6_addr32[4];
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/compile/pr82096.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/compile/pr82096.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/compile/pr82096.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/compile/pr82096.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,11 @@
+/* { dg-require-effective-target arm_arch_v5t_ok { target arm*-*-* } } */
+/* { dg-skip-if "Do not combine float-abi values" { arm*-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=soft" } } */
+/* { dg-additional-options "-march=armv5t -mthumb -mfloat-abi=soft" { target arm*-*-* } } */
+
+static long long AL[24];
+
+int
+check_ok (void)
+{
+  return (__sync_bool_compare_and_swap (AL+1, 0x200000003ll, 0x1234567890ll));
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/compile/pr84425.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/compile/pr84425.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/compile/pr84425.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/compile/pr84425.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,17 @@
+/* PR ipa/84425 */
+
+void bar (int);
+
+void
+foo (int x)
+{
+  if (x < 5)
+    bar (x);
+}
+
+__attribute__((optimize(0))) void
+bar (int x)
+{
+  if (x > 10)
+    foo (x);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/compile/pr84860.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/compile/pr84860.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/compile/pr84860.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/compile/pr84860.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,11 @@
+/* PR target/84860 */
+
+void
+foo (int x, int y)
+{
+  while (x < 1)
+    {
+      x = y;
+      y = ((float)1 / 0) ? 2 : 0;
+    }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/compile/pr85945.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/compile/pr85945.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/compile/pr85945.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/compile/pr85945.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,16 @@
+/* PR target/85945 */
+
+typedef float V __attribute__((vector_size(16)));
+union U { V v; float f[4]; };
+int f;
+float g[4];
+
+void
+foo (void)
+{
+  V d;
+  union U i;
+  i.v = d;
+  for (f = 0; f < 4; f++)
+    g[f] = i.f[f];
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/20180112-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/20180112-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/20180112-1.c	2018-01-12 02:20:42.007402000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/20180112-1.c	2019-06-25 02:27:21.165930961 -0700
@@ -3,7 +3,7 @@
 
 extern void abort (void);
 
-typedef unsigned int u32;
+typedef __UINT32_TYPE__ u32;
 
 u32 bug (u32 * result) __attribute__((noinline));
 u32 bug (u32 * result)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/20180131-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/20180131-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/20180131-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/20180131-1.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,28 @@
+/* PR rtl-optimization/84071 */
+/* Reported by Wilco <wilco@gcc.gnu.org> */
+
+extern void abort (void);
+
+typedef union 
+{
+  signed short ss;
+  unsigned short us;
+  int x;
+} U;
+
+int f(int x, int y, int z, int a, U u) __attribute__((noclone, noinline));
+
+int f(int x, int y, int z, int a, U u)
+{
+  return (u.ss <= 0) + u.us;
+}
+
+int main (void)
+{
+  U u = { .ss = -1 };
+
+  if (f (0, 0, 0, 0, u) != (1 << sizeof (short) * 8))
+    abort ();
+
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/20180226-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/20180226-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/20180226-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/20180226-1.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,31 @@
+/* PR rtl-optimization/83496 */
+/* Reported by Hauke Mehrtens <gcc@hauke-m.de> */
+
+extern void abort (void);
+
+typedef unsigned long mp_digit;
+
+typedef struct { int used, alloc, sign; mp_digit *dp; } mp_int;
+
+int mytest(mp_int *a, mp_digit b) __attribute__((noclone, noinline));
+
+int mytest(mp_int *a, mp_digit b)
+{
+  if (a->sign == 1)
+    return -1;
+  if (a->used > 1)
+    return 1;
+  if (a->dp[0] > b)
+    return 1;
+  if (a->dp[0] < b)
+    return -1;
+  return 0;
+}
+
+int main (void)
+{
+  mp_int i = { 2, 0, -1 };
+  if (mytest (&i, 0) != 1)
+    abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/920501-8.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/920501-8.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/920501-8.c	1998-12-16 14:24:51.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/920501-8.c	2019-06-25 02:27:21.165930961 -0700
@@ -1,3 +1,5 @@
+/* { dg-additional-options "-Wl,-u,_printf_float" { target newlib_nano_io } } */
+
 #include <stdio.h>
 #include <stdarg.h>
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/930513-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/930513-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/930513-1.c	1998-12-16 14:24:51.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/930513-1.c	2019-06-25 02:27:21.165930961 -0700
@@ -1,3 +1,5 @@
+/* { dg-additional-options "-Wl,-u,_printf_float" { target newlib_nano_io } } */
+
 #include <stdio.h>
 char buf[2];
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/991014-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/991014-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/991014-1.c	2010-02-22 13:15:41.340127000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/991014-1.c	2019-06-25 02:27:21.165930961 -0700
@@ -1,11 +1,16 @@
-
 typedef __SIZE_TYPE__ Size_t;
 
+/* size_t is __int20, so 20 bits, for __MSP430X_LARGE__, but __SIZEOF_POINTER__
+   returns the bytesize which is 4.  */
+#ifdef __MSP430X_LARGE__
+#define bufsize ((1L << (20 - 2))-256)
+#else  /* !__MSP430X_LARGE__ */
 #if __SIZEOF_LONG__ < __SIZEOF_POINTER__
 #define bufsize ((1LL << (8 * sizeof(Size_t) - 2))-256)
 #else
 #define bufsize ((1L << (8 * sizeof(Size_t) - 2))-256)
 #endif
+#endif
 
 struct huge_struct
 {
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/arith-rand-ll.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/arith-rand-ll.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/arith-rand-ll.c	2006-11-03 06:52:19.866811000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/arith-rand-ll.c	2019-06-25 02:27:21.165930961 -0700
@@ -1,3 +1,5 @@
+/* { dg-timeout 120 { target msp430-*-* } } */
+
 long long
 simple_rand ()
 {
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp	2019-06-25 02:27:21.165930961 -0700
@@ -33,6 +33,7 @@
 
 load_lib torture-options.exp
 load_lib c-torture.exp
+load_lib gcc-dg.exp
 
 torture-init
 set-torture-options $C_TORTURE_OPTIONS {{}} $LTO_TORTURE_OPTIONS
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/ieee/920810-1.x gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/ieee/920810-1.x
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/ieee/920810-1.x	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/ieee/920810-1.x	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,4 @@
+if { [check_effective_target_newlib_nano_io] } {
+    lappend additional_flags "-Wl,-u,_printf_float"
+}
+return 0
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr81503.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr81503.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr81503.c	2017-09-05 14:49:01.761674000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr81503.c	2019-06-25 02:27:21.165930961 -0700
@@ -1,11 +1,20 @@
 unsigned short a = 41461;
 unsigned short b = 3419;
+#if __SIZEOF_INT__ >= 4
 int c = 0;
 
 void foo() {
   if (a + b * ~(0 != 5))
     c = -~(b * ~(0 != 5)) + 2147483647;
 }
+#else
+__INT32_TYPE__ c = 0;
+
+void foo() {
+  if (a + b * ~((__INT32_TYPE__)(0 != 5)))
+    c = -~(b * ~((__INT32_TYPE__)(0 != 5))) + 2147483647;
+}
+#endif
 
 int main() {
   foo();
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr82210.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr82210.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr82210.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr82210.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,26 @@
+/* PR c/82210 */
+
+void
+foo (int size)
+{
+  int i;
+  struct S {
+    __attribute__((aligned (16))) struct T { short c; } a[size];
+    int b[size];
+  } s;
+
+  for (i = 0; i < size; i++)
+    s.a[i].c = 0x1234;
+  for (i = 0; i < size; i++)
+    s.b[i] = 0;
+  for (i = 0; i < size; i++)
+    if (s.a[i].c != 0x1234 || s.b[i] != 0)
+      __builtin_abort ();
+}
+
+int
+main ()
+{
+  foo (15);
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr84524.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr84524.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr84524.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr84524.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,41 @@
+/* PR target/84524 */
+
+__attribute__((noinline,noclone)) void
+foo (unsigned short *x)
+{
+  unsigned short i, v;
+  unsigned char j;
+  for (i = 0; i < 256; i++)
+    {
+      v = i << 8;
+      for (j = 0; j < 8; j++)
+	if (v & 0x8000)
+	  v = (v << 1) ^ 0x1021;
+	else
+	  v = v << 1;
+      x[i] = v;
+    }
+}
+
+int
+main ()
+{
+  unsigned short a[256];
+
+  foo (a);
+  for (int i = 0; i < 256; i++)
+    {
+      unsigned short v = i << 8;
+      for (int j = 0; j < 8; j++)
+	{
+	  asm volatile ("" : "+r" (v));
+	  if (v & 0x8000)
+	    v = (v << 1) ^ 0x1021;
+	  else
+	    v = v << 1;
+	}
+      if (a[i] != v)
+	__builtin_abort ();
+    }
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr84748.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr84748.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr84748.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr84748.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,34 @@
+/* { dg-require-effective-target int128 } */
+
+typedef unsigned __int128 u128;
+
+int a, c, d;
+u128 b;
+
+unsigned long long g0, g1;
+
+void
+store (unsigned long long a0, unsigned long long a1)
+{
+  g0 = a0;
+  g1 = a1;
+}
+
+void
+foo (void)
+{
+  b += a;
+  c = d != 84347;
+  b /= c;
+  u128 x = b;
+  store (x >> 0, x >> 64);
+}
+
+int
+main (void)
+{
+  foo ();
+  if (g0 != 0 || g1 != 0)
+    __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr85095.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr85095.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr85095.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr85095.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,52 @@
+/* PR target/85095 */
+
+__attribute__((noinline, noclone)) unsigned long
+f1 (unsigned long a, unsigned long b)
+{
+  unsigned long i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+__attribute__((noinline, noclone)) unsigned long
+f2 (unsigned long a, unsigned long b)
+{
+  unsigned long i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+
+__attribute__((noinline, noclone)) unsigned long
+f3 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+__attribute__((noinline, noclone)) unsigned long
+f4 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+
+int
+main ()
+{
+  if (f1 (16UL, -18UL) != -2UL
+      || f1 (16UL, -17UL) != -1UL
+      || f1 (16UL, -16UL) != 1UL
+      || f1 (16UL, -15UL) != 2UL
+      || f2 (24UL, -26UL) != -2UL
+      || f2 (24UL, -25UL) != -1UL
+      || f2 (24UL, -24UL) != -1UL
+      || f2 (24UL, -23UL) != 0UL
+      || f3 (32U, -34U) != -2U
+      || f3 (32U, -33U) != -1U
+      || f3 (32U, -32U) != 1U
+      || f3 (32U, -31U) != 2U
+      || f4 (35U, -37U) != -2U
+      || f4 (35U, -36U) != -1U
+      || f4 (35U, -35U) != -1U
+      || f4 (35U, -34U) != 0U)
+    __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr85529-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr85529-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr85529-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr85529-1.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,28 @@
+/* PR tree-optimization/85529 */
+
+struct S { int a; };
+
+int b, c = 1, d, e, f;
+static int g;
+volatile struct S s;
+
+signed char
+foo (signed char i, int j)
+{
+  return i < 0 ? i : i << j;
+}
+
+int
+main ()
+{
+  signed char k = -83;
+  if (!d)
+    goto L;
+  k = e || f;
+L:
+  for (; b < 1; b++)
+    s.a != (k < foo (k, 2) && (c = k = g));
+  if (c != 1)
+    __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr85529-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr85529-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr85529-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr85529-2.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,25 @@
+/* PR tree-optimization/85529 */
+
+__attribute__((noinline, noclone)) int
+foo (int x)
+{
+  x &= 63;
+  x -= 50;
+  x |= 1;
+  if (x < 0)
+    return 1;
+  int y = x >> 2;
+  if (x >= y)
+    return 1;
+  return 0;
+}
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 63; i++)
+    if (foo (i) != 1)
+      __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr86231.c gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr86231.c
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/execute/pr86231.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/execute/pr86231.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,30 @@
+/* PR tree-optimization/86231 */
+
+#define ONE ((void *) 1)
+#define TWO ((void *) 2)
+
+__attribute__((noinline, noclone)) int
+foo (void *p, int x)
+{
+  if (p == ONE) return 0;
+  if (!p)
+    p = x ? TWO : ONE;
+  return p == ONE ? 0 : 1;
+}
+
+int v[8];
+
+int
+main ()
+{
+  if (foo ((void *) 0, 0) != 0
+      || foo ((void *) 0, 1) != 1
+      || foo (ONE, 0) != 0
+      || foo (ONE, 1) != 0
+      || foo (TWO, 0) != 1
+      || foo (TWO, 1) != 1
+      || foo (&v[7], 0) != 1
+      || foo (&v[7], 1) != 1)
+    __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x
--- gcc-7.3.0/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x	2016-09-21 08:16:41.995758000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x	2019-06-25 02:27:21.165930961 -0700
@@ -9,14 +9,14 @@
 
     # loop through all the options
     foreach option $option_list {
-	file delete -force dump1
-	file mkdir dump1
+	file delete -force $tmpdir/dump1
+	file mkdir $tmpdir/dump1
 	c-torture-compile $src "$option $options -dumpbase dump1/$dumpbase -DMASK=1 -x c --param ggc-min-heapsize=1 -fdump-ipa-all -fdump-rtl-all -fdump-tree-all -fdump-noaddr"
-	file delete -force dump2
-	file mkdir dump2
+	file delete -force $tmpdir/dump2
+	file mkdir $tmpdir/dump2
 	c-torture-compile $src "$option $options -dumpbase dump2/$dumpbase -DMASK=2 -x c -fdump-ipa-all -fdump-rtl-all -fdump-tree-all -fdump-noaddr"
-	foreach dump1 [lsort [glob -nocomplain dump1/*]] {
-	    regsub dump1/ $dump1 dump2/ dump2
+	foreach dump1 [lsort [glob -nocomplain $tmpdir/dump1/*]] {
+	    set dump2 "$tmpdir/dump2/[file tail $dump1]"
 	    set dumptail "gcc.c-torture/unsorted/[file tail $dump1]"
 	    regsub {\.\d+((t|r|i)\.[^.]+)$} $dumptail {.*\1} dumptail
 	    set tmp [ diff "$dump1" "$dump2" ]
@@ -29,8 +29,8 @@
 	    }
 	}
     }
-    file delete -force dump1
-    file delete -force dump2
+    file delete -force $tmpdir/dump1
+    file delete -force $tmpdir/dump2
 }
 
 dump_compare $src $options
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/addr_builtin-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/addr_builtin-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/addr_builtin-1.c	2015-11-25 15:29:57.940119000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/addr_builtin-1.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,5 +1,6 @@
-/* PR66516 - missing diagnostic on taking the address of a builtin function
-   { dg-do compile }  */
+/* PR66516 - missing diagnostic on taking the address of a builtin function.  */
+/* { dg-do compile } */
+/* { dg-options "" { target { ! ptr_t_ansi_compatible } } } */
 
 typedef void (F)(void);
 typedef __UINTPTR_TYPE__ uintptr_t;
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/attr-alloc_size-10.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/attr-alloc_size-10.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/attr-alloc_size-10.c	2017-01-10 13:02:07.076010000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/attr-alloc_size-10.c	2019-06-25 02:27:21.169930931 -0700
@@ -12,7 +12,7 @@
 
 #define SHRT_MAX  __SHRT_MAX__
 #define SHRT_MIN  (-SHRT_MAX - 1)
-#define USHRT_MAX (SHRT_MAX * 2 + 1)
+#define USHRT_MAX (SHRT_MAX * 2U + 1)
 
 #define INT_MAX   __INT_MAX__
 #define INT_MIN   (-INT_MAX - 1)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/attr-alloc_size-11.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/attr-alloc_size-11.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/attr-alloc_size-11.c	2017-10-17 13:34:43.617161000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/attr-alloc_size-11.c	2019-06-25 02:27:21.169930931 -0700
@@ -11,7 +11,7 @@
 
 #define SHRT_MAX  __SHRT_MAX__
 #define SHRT_MIN  (-SHRT_MAX - 1)
-#define USHRT_MAX (SHRT_MAX * 2 + 1)
+#define USHRT_MAX (SHRT_MAX * 2U + 1)
 
 #define INT_MAX   __INT_MAX__
 #define INT_MIN   (-INT_MAX - 1)
@@ -47,8 +47,8 @@
 
 /* The following tests fail because of missing range information.  The xfail
    exclusions are PR79356.  */
-TEST (signed char, SCHAR_MIN + 2, ALLOC_MAX);   /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" "missing range info for signed char" { xfail { ! { aarch64*-*-* arm*-*-* alpha*-*-* ia64-*-* mips*-*-* powerpc*-*-* sparc*-*-* s390*-*-* visium-*-* } } } } */
-TEST (short, SHRT_MIN + 2, ALLOC_MAX); /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" "missing range info for short" { xfail { ! { aarch64*-*-* arm*-*-* alpha*-*-* ia64-*-* mips*-*-* powerpc*-*-* sparc*-*-* s390x-*-* visium-*-* } } } } */
+TEST (signed char, SCHAR_MIN + 2, ALLOC_MAX);   /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" "missing range info for signed char" { xfail { ! { aarch64*-*-* arm*-*-* avr-*-* alpha*-*-* ia64-*-* mips*-*-* msp430-*-* powerpc*-*-* sparc*-*-* s390*-*-* visium-*-* } } } } */
+TEST (short, SHRT_MIN + 2, ALLOC_MAX); /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" "missing range info for short" { xfail { ! { aarch64*-*-* arm*-*-* alpha*-*-* avr-*-* ia64-*-* mips*-*-* msp430-*-* powerpc*-*-* sparc*-*-* s390x-*-* visium-*-* } } } } */
 TEST (int, INT_MIN + 2, ALLOC_MAX);    /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" } */
 TEST (int, -3, ALLOC_MAX);             /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" } */
 TEST (int, -2, ALLOC_MAX);             /* { dg-warning "argument 1 range \\\[13, \[0-9\]+\\\] exceeds maximum object size 12" } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/attr-alloc_size-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/attr-alloc_size-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/attr-alloc_size-3.c	2017-01-07 11:45:33.824234000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/attr-alloc_size-3.c	2019-06-25 02:27:21.169930931 -0700
@@ -5,7 +5,7 @@
    functions decorated with attribute alloc_size that either overflow or
    exceed the default maximum object size (with -Walloc-size-larger-than
    not explicitly specified).  */
-/* { dg-do compile } */
+/* { dg-do compile { target size32plus } } */
 /* { dg-options "-O2 -Wall" } */
 
 #define SCHAR_MAX  __SCHAR_MAX__
@@ -14,7 +14,7 @@
 
 #define SHRT_MAX   __SHRT_MAX__
 #define SHRT_MIN   (-SHRT_MAX - 1)
-#define USHRT_MAX  (SHRT_MAX * 2 + 1)
+#define USHRT_MAX  (SHRT_MAX * 2U + 1)
 
 #define INT_MAX    __INT_MAX__
 #define INT_MIN    (-INT_MAX - 1)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/attr-alloc_size-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/attr-alloc_size-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/attr-alloc_size-4.c	2017-01-19 09:42:50.451817000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/attr-alloc_size-4.c	2019-06-25 02:27:21.169930931 -0700
@@ -162,7 +162,7 @@
   sink (f_size_2 (   0, 1234));
   sink (f_size_2 (   1, 1234));
   sink (f_size_2 (   2, 1234));  /* { dg-warning "product .2 \\* 1234. of arguments 1 and 2 exceeds maximum object size \[0-9\]+" } */
-  sink (f_size_2 (1234, 1234));  /* { dg-warning "product .1234 \\* 1234. of arguments 1 and 2 exceeds maximum object size 1234" } */
+  sink (f_size_2 (1234, 1234));  /* { dg-warning "product .1234 \\* 1234. of arguments 1 and 2 exceeds (.SIZE_MAX.|maximum object size 1234)" } */
   sink (f_size_2 (1235, 1234));  /* { dg-warning "argument 1 value .1235. exceeds maximum object size 1234" } */
   sink (f_size_2 (1234, 1235));  /* { dg-warning "argument 2 value .1235. exceeds maximum object size 1234" } */
   sink (f_size_2 (1234, max));  /* { dg-warning "argument 2 value .\[0-9\]+. exceeds maximum object size 1234" } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/attr-alloc_size-5.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/attr-alloc_size-5.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/attr-alloc_size-5.c	2016-12-08 15:50:40.479286000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/attr-alloc_size-5.c	2019-06-25 02:27:21.169930931 -0700
@@ -12,7 +12,7 @@
 
 #define SHRT_MAX   __SHRT_MAX__
 #define SHRT_MIN   (-SHRT_MAX - 1)
-#define USHRT_MAX  (SHRT_MAX * 2 + 1)
+#define USHRT_MAX  (SHRT_MAX * 2U + 1)
 
 #define INT_MAX    __INT_MAX__
 #define INT_MIN    (-INT_MAX - 1)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/builtin-apply2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/builtin-apply2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/builtin-apply2.c	2017-02-06 13:39:03.759220000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/builtin-apply2.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,7 +1,7 @@
 /* { dg-do run } */
 /* { dg-require-effective-target untyped_assembly } */
 /* { dg-skip-if "Variadic funcs have all args on stack. Normal funcs have args in registers." { "avr-*-* nds32*-*-*" } { "*" } { "" } } */
-/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs." { "riscv*-*-*" } { "*" } { "" } } */
+/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs." { "riscv*-*-*" msp430-*-* } { "*" } { "" } } */
 /* { dg-skip-if "Variadic funcs use Base AAPCS.  Normal funcs use VFP variant." { arm*-*-* && arm_hf_eabi } { "*" } { "" } } */
 
 /* PR target/12503 */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/builtin-stringop-chk-7.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/builtin-stringop-chk-7.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/builtin-stringop-chk-7.c	2017-01-10 13:02:07.076010000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/builtin-stringop-chk-7.c	2019-06-25 02:27:21.169930931 -0700
@@ -9,7 +9,7 @@
 #define UCHAR_MAX (SCHAR_MAX * 2 + 1)
 
 #define SHRT_MAX  __SHRT_MAX__
-#define USHRT_MAX (SHRT_MAX * 2 + 1)
+#define USHRT_MAX (SHRT_MAX * 2U + 1)
 
 #define INT_MAX   __INT_MAX__
 #define UINT_MAX  (INT_MAX * 2U + 1)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/c11-static-assert-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c11-static-assert-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/c11-static-assert-3.c	2017-04-18 23:55:33.851493000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c11-static-assert-3.c	2019-06-25 02:27:21.169930931 -0700
@@ -6,6 +6,8 @@
 /* { dg-error "overflow in constant expression" "error" { target *-*-* } .-1 } */
 
 _Static_assert ((void *)(__SIZE_TYPE__)16, "non-integer"); /* { dg-error "not an integer" } */
+	/* { dg-error "ISO C does not support" "" { target { ! size_t_ansi_compatible } } .-1 } */
+                      
 
 _Static_assert (1.0, "non-integer"); /* { dg-error "not an integer" } */
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/c11-uni-string-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c11-uni-string-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/c11-uni-string-1.c	2013-10-22 09:56:06.594356000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c11-uni-string-1.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,6 +1,7 @@
 /* Test Unicode strings in C11.  Test valid code.  */
 /* { dg-do run } */
-/* { dg-options "-std=c11 -pedantic-errors" } */
+/* { dg-options "-std=c11" } */
+/* { dg-additional-options "-pedantic-errors" { target { size_t_ansi_compatible } } } */
 
 /* More thorough tests are in c-c++-common/raw-string-*.c; this test
    verifies the particular subset (Unicode but not raw strings) that
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/c90-const-expr-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c90-const-expr-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/c90-const-expr-2.c	2009-09-08 12:16:18.155168000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c90-const-expr-2.c	2019-06-25 02:27:21.169930931 -0700
@@ -18,6 +18,8 @@
 #define ZERO 0L
 #elif defined(_WIN64)
 #define ZERO 0LL
+#elif defined(__MSP430X_LARGE__)
+#define ZERO (__int20)0
 #else
 #define ZERO 0
 #endif
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/c99-const-expr-10.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-const-expr-10.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/c99-const-expr-10.c	2010-06-07 20:56:40.233305000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-const-expr-10.c	2019-06-25 02:27:21.169930931 -0700
@@ -4,6 +4,7 @@
 /* Origin: Joseph Myers <joseph@codesourcery.com> */
 /* { dg-do compile } */
 /* { dg-options "-std=iso9899:1999 -pedantic-errors" } */
+/* { dg-excess-errors "ISO C does not support" { target { ! size_t_ansi_compatible } } } */
 
 void *p = (__SIZE_TYPE__)(void *)0; /* { dg-error "without a cast" } */
 struct s { void *a; } q = { (__SIZE_TYPE__)(void *)0 }; /* { dg-error "without a cast|near initialization" } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/c99-const-expr-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-const-expr-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/c99-const-expr-2.c	2009-09-08 12:16:18.155168000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-const-expr-2.c	2019-06-25 02:27:21.169930931 -0700
@@ -18,6 +18,8 @@
 #define ZERO 0L
 #elif defined(_WIN64)
 #define ZERO 0LL
+#elif defined(__MSP430X_LARGE__)
+#define ZERO (__int20)0
 #else
 #define ZERO 0
 #endif
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/c99-const-expr-6.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-const-expr-6.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/c99-const-expr-6.c	2012-04-11 10:58:01.946737000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-const-expr-6.c	2019-06-25 02:27:21.169930931 -0700
@@ -3,6 +3,7 @@
 /* Origin: Joseph Myers <joseph@codesourcery.com> */
 /* { dg-do compile } */
 /* { dg-options "-std=iso9899:1999 -pedantic-errors" } */
+/* { dg-excess-errors "ISO C does not support" { target { ! ptr_t_ansi_compatible } } } */
 
 /* PR 29116.  */
 int n = 0, p[n * 0 + 1]; /* { dg-error "variabl" } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/c99-const-expr-9.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-const-expr-9.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/c99-const-expr-9.c	2012-04-30 04:43:29.980065000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-const-expr-9.c	2019-06-25 02:27:21.169930931 -0700
@@ -4,6 +4,7 @@
 /* Origin: Joseph Myers <joseph@codesourcery.com> */
 /* { dg-do compile } */
 /* { dg-options "-std=iso9899:1999 -pedantic-errors -ftrack-macro-expansion=0" } */
+/* { dg-excess-errors "ISO C does not support" { target { ! size_t_ansi_compatible } } } */
 
 struct s {
   int a;
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/c99-init-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-init-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/c99-init-1.c	2001-01-12 15:18:05.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-init-1.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,7 +1,8 @@
 /* Test for C99 designated initializers */
 /* Origin: Jakub Jelinek <jakub@redhat.com> */
 /* { dg-do run } */
-/* { dg-options "-std=iso9899:1999 -pedantic-errors" } */
+/* { dg-options "-std=iso9899:1999" } */
+/* { dg-additional-options "-pedantic-errors" { target { size_t_ansi_compatible } } } */
 
 typedef __SIZE_TYPE__ size_t;
 typedef __WCHAR_TYPE__ wchar_t;
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/c99-stdint-5.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-stdint-5.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/c99-stdint-5.c	2009-11-20 17:34:51.442867000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-stdint-5.c	2019-06-25 02:27:21.169930931 -0700
@@ -2,7 +2,8 @@
    with any system header (which GCC will use by default for hosted
    compilations).  */
 /* { dg-do compile } */
-/* { dg-options "-std=iso9899:1999 -pedantic-errors" } */
+/* { dg-options "-std=iso9899:1999" } */
+/* { dg-additional-options "-pedantic-errors" { target { ptr_t_ansi_compatible } } } */
 
 #include <stdint.h>
 #ifndef SIGNAL_SUPPRESS
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/c99-stdint-6.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-stdint-6.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/c99-stdint-6.c	2014-04-22 05:30:59.344095000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/c99-stdint-6.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,7 +1,8 @@
 /* Verify that GCC's internal notions of types in <stdint.h> agree
    with any system <inttypes.h> header.  */
 /* { dg-do compile { target inttypes_types } } */
-/* { dg-options "-std=iso9899:1999 -pedantic-errors" } */
+/* { dg-options "-std=iso9899:1999" } */
+/* { dg-additional-options "-pedantic-errors" { target { ptr_t_ansi_compatible } } } */
 
 #include <inttypes.h>
 #ifndef SIGNAL_SUPPRESS
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/compat/struct-by-value-16a_x.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/compat/struct-by-value-16a_x.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/compat/struct-by-value-16a_x.c	2008-09-08 20:17:22.762171000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/compat/struct-by-value-16a_x.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,3 +1,5 @@
+/* { dg-options "-O1" { target msp430-*-* } } */
+
 #include "compat-common.h"
 
 #include "fp-struct-defs.h"
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/cpp/trad/pr69869.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/cpp/trad/pr69869.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/cpp/trad/pr69869.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/cpp/trad/pr69869.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,8 @@
+/* PR preprocessor/69869 */
+/* { dg-do preprocess } */
+/* { dg-options "-traditional-cpp" } */
+
+#define C(a,b)a/**/b
+C (foo/,**/)
+C (foo/,*)
+/* { dg-error "unterminated comment" "" {target "*-*-*"} .-1 } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c	2016-11-02 05:42:19.272080000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c	2019-06-25 02:27:21.169930931 -0700
@@ -3,9 +3,8 @@
    the build not reproducible.  Other skipped options could be tested here
    as well.  */
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf -dA -fdebug-prefix-map=a=b" } */
-/* { dg-final { scan-assembler "DW_AT_producer: \"GNU C" { target { { { ! *-*-solaris2* } || gas } && { { ! hppa*64*-*-* } && { ! powerpc-ibm-aix* } } } } } } */
-/* { dg-final { scan-assembler "\"GNU C\[^\\n\\r\]+ DW_AT_producer" { target { { *-*-solaris2* && { ! gas } } || { hppa*64*-*-* } } } } } */
+/* { dg-options "-O2 -gdwarf -dA -fno-merge-debug-strings -fdebug-prefix-map=a=b" } */
+/* { dg-final { scan-assembler "\"GNU C\[^\\n\\r\]+ DW_AT_producer" } } */
 /* { dg-final { scan-assembler-not "debug-prefix-map" } } */
 
 void func (void)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/debug/pr85252.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/debug/pr85252.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/debug/pr85252.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/debug/pr85252.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,11 @@
+/* PR debug/85252 */
+/* { dg-do compile } */
+
+void
+foo (void)
+{
+  static char a[0] = "";
+  static char b[0] = "b";	/* { dg-warning "initializer-string for array of chars is too long" } */
+  static char c[1] = "c";
+  static char d[1] = "de";	/* { dg-warning "initializer-string for array of chars is too long" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/fold-convmaxconv-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/fold-convmaxconv-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/fold-convmaxconv-1.c	2016-10-27 01:31:01.917676000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/fold-convmaxconv-1.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,9 +1,15 @@
 /* { dg-do compile } */
 /* { dg-options "-O -fdump-tree-optimized" } */
 
-int foo (short a[], int x)
+#if __SIZEOF_INT__ == __SIZEOF_SHORT__
+#define T long 
+#else
+#define T int
+#endif
+
+T foo (short a[], T x)
 {
-  unsigned int i;
+  unsigned T i;
   for (i = 0; i < 1000; i++)
     {
       x = a[i];
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/fold-convminconv-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/fold-convminconv-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/fold-convminconv-1.c	2016-10-27 01:31:01.917676000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/fold-convminconv-1.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,9 +1,15 @@
 /* { dg-do compile } */
 /* { dg-options "-O -fdump-tree-optimized" } */
 
-int foo (unsigned short a[], unsigned int x)
+#if __SIZEOF_INT__ == __SIZEOF_SHORT__
+#define T long 
+#else
+#define T int
+#endif
+
+T foo (unsigned short a[], unsigned T x)
 {
-  unsigned int i;
+  unsigned T i;
   for (i = 0; i < 1000; i++)
     {
       x = a[i];
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/format/format.h gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/format/format.h
--- gcc-7.3.0/gcc/testsuite/gcc.dg/format/format.h	2008-03-20 01:24:42.744961000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/format/format.h	2019-06-25 02:27:21.169930931 -0700
@@ -56,6 +56,7 @@
 __extension__ typedef int llong  __attribute__ ((mode (DI)));
 __extension__ typedef unsigned int ullong  __attribute__ ((mode (DI)));
 #else
+#ifndef __MSP430X_LARGE__
 /* Kludges to get types corresponding to size_t and ptrdiff_t.  */
 #define unsigned signed
 typedef __SIZE_TYPE__ signed_size_t;
@@ -65,6 +66,18 @@
 #define signed /* Type might or might not have explicit 'signed'.  */
 typedef unsigned __PTRDIFF_TYPE__ unsigned_ptrdiff_t;
 #undef signed
+#else /* __MSP430X_LARGE__ */
+/* msp430x large data model uses __int20 for __{SIZE,PTRDIFF}_TYPE__ which
+   is not ISO C compatible. Define these types as GNU C extensions to prevent
+   ISO C errors when using the types.  */
+#define unsigned signed
+__extension__ typedef __SIZE_TYPE__ signed_size_t;
+__extension__ typedef __SIZE_TYPE__ ssize_t;
+#undef unsigned
+#define signed /* Type might or might not have explicit 'signed'.  */
+__extension__ typedef unsigned __PTRDIFF_TYPE__ unsigned_ptrdiff_t;
+#undef signed
+#endif /* __MSP430X_LARGE__ */
 
 __extension__ typedef long long int llong;
 __extension__ typedef unsigned long long int ullong;
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/ftrapv-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ftrapv-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/ftrapv-3.c	2011-07-07 07:21:21.907286000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ftrapv-3.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-options "-ftrapv" } */
+/* { dg-require-effective-target trapping } */
 
 extern void abort (void);
 unsigned long
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/ifcvt-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ifcvt-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/ifcvt-4.c	2017-04-04 10:52:27.193766000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ifcvt-4.c	2019-06-25 02:27:21.169930931 -0700
@@ -2,7 +2,7 @@
 /* { dg-additional-options "-misel" { target { powerpc*-*-* } } } */
 /* { dg-additional-options "-march=z196" { target { s390x-*-* } } } */
 /* { dg-additional-options "-mtune-ctrl=^one_if_conv_insn" { target { i?86-*-* x86_64-*-* } } } */
-/* { dg-skip-if "Multiple set if-conversion not guaranteed on all subtargets" { "arm*-*-* hppa*64*-*-* s390-*-* visium-*-*" riscv*-*-* } }  */
+/* { dg-skip-if "Multiple set if-conversion not guaranteed on all subtargets" { "arm*-*-* hppa*64*-*-* msp430-*-* s390-*-* visium-*-*" riscv*-*-* } }  */
 /* { dg-skip-if "" { "s390x-*-*" } { "-m31" } }  */
 
 typedef int word __attribute__((mode(word)));
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/ipa/iinline-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ipa/iinline-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/ipa/iinline-4.c	2015-05-29 01:20:29.810091000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ipa/iinline-4.c	2019-06-25 02:27:21.169930931 -0700
@@ -214,7 +214,7 @@
 /* { dg-final { scan-ipa-dump "hooray1\[^\\n\]*inline copy in test1"  "inline"  } } */
 /* { dg-final { scan-ipa-dump "hooray2\[^\\n\]*inline copy in test2"  "inline"  } } */
 /* { dg-final { scan-ipa-dump "hooray3\[^\\n\]*inline copy in test3"  "inline"  } } */
-/* { dg-final { scan-ipa-dump "hooray4\[^\\n\]*inline copy in test4"  "inline"  { xfail { { hppa*-*-* } && { ! lp64 } } } } } */
+/* { dg-final { scan-ipa-dump "hooray4\[^\\n\]*inline copy in test4"  "inline"  { xfail { msp430-*-* } || { { hppa*-*-* } && { ! lp64 } } } } } */
 /* { dg-final { scan-ipa-dump "hooray5\[^\\n\]*inline copy in test5"  "inline"  } } */
 /* { dg-final { scan-ipa-dump "hooray6\[^\\n\]*inline copy in test6"  "inline"  } } */
 /* { dg-final { scan-ipa-dump "hooray7\[^\\n\]*inline copy in test7"  "inline"  } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/ipa/inline-5.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ipa/inline-5.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/ipa/inline-5.c	2015-05-29 01:20:29.810091000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ipa/inline-5.c	2019-06-25 02:27:21.169930931 -0700
@@ -34,5 +34,5 @@
     /* Will be eliminated by inlining */
 }
 
-/* { dg-final { scan-ipa-dump-times "Will be eliminated" 4 "inline" { xfail { { hppa*-*-* } && { ! lp64 } } } } } */
+/* { dg-final { scan-ipa-dump-times "Will be eliminated" 4 "inline" { xfail { msp430-*-* } || { { hppa*-*-* } && { ! lp64 } } } } } */
 /* { dg-final { scan-ipa-dump-times "50. will be eliminated" 1 "inline"  } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/ipa/propalign-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ipa/propalign-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/ipa/propalign-1.c	2016-10-08 21:48:50.672831000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ipa/propalign-1.c	2019-06-25 02:27:21.169930931 -0700
@@ -12,8 +12,7 @@
 foo (void *p)
 {
   uintptr_t a = (uintptr_t) p;
-
-  if (a % 4)
+  if (a % 2)
     return fail_the_test (p);
   else
     return pass_the_test (p);
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/ipa/propalign-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ipa/propalign-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/ipa/propalign-2.c	2016-10-08 21:48:50.672831000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ipa/propalign-2.c	2019-06-25 02:27:21.169930931 -0700
@@ -25,7 +25,7 @@
 {
   uintptr_t a = (uintptr_t) p;
 
-  if (a % 4)
+  if (a % 2)
     return fail_the_test (p);
   else
     return pass_the_test (p);
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/ipa/propalign-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ipa/propalign-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/ipa/propalign-4.c	2016-10-08 21:48:50.672831000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ipa/propalign-4.c	2019-06-25 02:27:21.169930931 -0700
@@ -20,4 +20,4 @@
   test (&aa[3]);
   return 0;
 }
-/* { dg-final { scan-ipa-dump "align: 8, misalign: 4"  "cp"  } } */
+/* { dg-final { scan-ipa-dump "align: 8, misalign: 4"  "cp" { xfail msp430-*-* } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/loop-9.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/loop-9.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/loop-9.c	2015-05-29 01:20:29.810091000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/loop-9.c	2019-06-25 02:27:21.169930931 -0700
@@ -10,6 +10,7 @@
 }
 
 /* Load of x is moved out of the loop.  */
-/* { dg-final { scan-rtl-dump "Decided" "loop2_invariant" } } */
-/* { dg-final { scan-rtl-dump "without introducing a new temporary register" "loop2_invariant" } } */
+/* MSP430 FIXME load 18.4242 into reg before loop.  */
+/* { dg-final { scan-rtl-dump "Decided" "loop2_invariant" { target { !msp430-*-* } } } } */
+/* { dg-final { scan-rtl-dump "without introducing a new temporary register" "loop2_invariant" { target { !msp430-*-* } } } } */
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/lto/20081210-1_0.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/20081210-1_0.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/lto/20081210-1_0.c	2014-10-06 01:38:03.222857000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/20081210-1_0.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,10 +1,4 @@
-#if defined(_LP64)
-typedef unsigned long int uintptr_t;
-#elif defined (_WIN64)
-typedef unsigned long long int uintptr_t;
-#else
-typedef unsigned int uintptr_t;
-#endif
+__extension__ typedef __UINTPTR_TYPE__ uintptr_t;
 
 extern void srand (uintptr_t);
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/lto/20091013-1_1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/20091013-1_1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/lto/20091013-1_1.c	2014-10-06 01:38:03.222857000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/20091013-1_1.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,4 +1,4 @@
-/* { dg-xfail-if "cast to pointer of different size" { "avr-*-*" x86_64-*-mingw* } { "*" } { "" } } */
+/* { dg-xfail-if "cast to pointer of different size" { "avr-*-*" x86_64-*-mingw* msp430-*-* } { "*" } { "" } } */
 typedef struct HDC__ { int unused; } *HDC;
 typedef struct HFONT__ { int unused; } *HFONT;
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/lto/20091013-1_2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/20091013-1_2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/lto/20091013-1_2.c	2014-10-06 01:38:03.222857000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/20091013-1_2.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,4 +1,4 @@
-/* { dg-xfail-if "cast to pointer of different size" { "avr-*-*" x86_64-*-mingw* } { "*" } { "" } } */
+/* { dg-xfail-if "cast to pointer of different size" { "avr-*-*" x86_64-*-mingw* msp430-*-* } { "*" } { "" } } */
 typedef struct HDC__ { int unused; } *HDC;
 typedef struct HFONT__ { int unused; } *HFONT;
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr81440_0.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr81440_0.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr81440_0.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr81440_0.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,9 @@
+/* { dg-lto-do link } */
+
+#include "pr81440.h"
+
+extern struct_t my_struct;
+
+int main() {
+ return my_struct.ints[0];
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr81440_1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr81440_1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr81440_1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr81440_1.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,6 @@
+#include "pr81440.h"
+
+struct_t my_struct = {
+ 20,
+ { 1, 2 }
+};
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr81440.h gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr81440.h
--- gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr81440.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr81440.h	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,4 @@
+typedef struct {
+  int i;
+  int ints[];
+} struct_t;
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr83954_0.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr83954_0.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr83954_0.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr83954_0.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,8 @@
+/* { dg-lto-do link } */
+#include "pr83954.h"
+
+int main() {
+  // just to prevent symbol removal
+  FOO_PTR_ARR[1] = 0;
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr83954_1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr83954_1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr83954_1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr83954_1.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,7 @@
+#include "pr83954.h"
+
+struct foo {
+ int x;
+};
+struct foo *FOO_PTR_ARR[1] = { 0 };
+
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr83954.h gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr83954.h
--- gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr83954.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr83954.h	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,3 @@
+struct foo;
+extern struct foo *FOO_PTR_ARR[1];
+
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr85248_0.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr85248_0.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr85248_0.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr85248_0.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,45 @@
+/* PR lto/85248 */
+/* { dg-lto-do run } */
+/* { dg-lto-options { { -flto -O2 } } } */
+
+extern void test_alias (int s, int e) __asm__ (__USER_LABEL_PREFIX__ "test");
+extern void test_noreturn (int s, int e) __asm__ (__USER_LABEL_PREFIX__ "test")
+  __attribute__ ((__noreturn__));
+
+extern inline __attribute__ ((__always_inline__, __gnu_inline__)) void
+test (int s, int e)
+{
+  if (__builtin_constant_p (s) && s != 0)
+    test_noreturn (s, e);
+  else
+    test_alias (s, e);
+}
+
+int
+foo (void)
+{
+  static volatile int a;
+  return a;
+}
+
+static void
+bar (void)
+{
+  test (0, 1);
+  __builtin_exit (0);
+}
+
+static void
+baz ()
+{
+  test (1, 0);
+}
+
+int
+main ()
+{
+  if (foo ())
+    baz ();
+  bar ();
+  __builtin_abort ();
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr85248_1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr85248_1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/lto/pr85248_1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/lto/pr85248_1.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,9 @@
+/* { dg-options "-fno-lto" } */
+
+void
+test (int s, int e)
+{
+  asm volatile ("" : "+g" (s), "+g" (e) : : "memory");
+  if (s)
+    __builtin_abort ();
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/parm-impl-decl-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/parm-impl-decl-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/parm-impl-decl-1.c	2014-10-06 04:46:21.636023000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/parm-impl-decl-1.c	2019-06-25 02:27:21.169930931 -0700
@@ -7,7 +7,7 @@
 /* Implicit function declaration in attribute in definition (testcase
    from bug).  */
 int
-foo (int __attribute__ ((__mode__ (vector_size(8)))) i) /* { dg-warning "'__mode__' attribute ignored" } */
+foo (int __attribute__ ((__mode__ (vector_size(8)))) i) /* { dg-warning "'mode' attribute ignored" } */
 {
   return (long long) i;
 }
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/parm-impl-decl-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/parm-impl-decl-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/parm-impl-decl-3.c	2014-10-06 04:46:21.636023000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/parm-impl-decl-3.c	2019-06-25 02:27:21.169930931 -0700
@@ -4,7 +4,7 @@
 /* { dg-options "-g -std=gnu89" } */
 
 int
-foo (int __attribute__ ((__mode__ (vector_size(8)))) i) /* { dg-warning "'__mode__' attribute ignored" } */
+foo (int __attribute__ ((__mode__ (vector_size(8)))) i) /* { dg-warning "'mode' attribute ignored" } */
 {
   return (long long) i;
 }
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr33644.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr33644.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr33644.c	2007-10-22 12:28:23.277454000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr33644.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,6 +1,7 @@
 /* PR rtl-optimization/33644 */
 /* { dg-do compile } */
 /* { dg-options "-O2 -ftrapv" } */
+/* { dg-require-effective-target trapping } */
 
 extern char *bar (const char *);
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr34225.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr34225.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr34225.c	2007-11-27 07:28:07.114458000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr34225.c	2019-06-25 02:27:21.169930931 -0700
@@ -2,6 +2,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fno-strict-aliasing -fstack-protector" } */
 /* { dg-require-effective-target fstack_protector } */
+/* { dg-skip-if "Array too big" { msp430-*-* } { "*" } { "-mlarge" } } */
 
 typedef __SIZE_TYPE__ size_t;
 extern int sscanf (const char *, const char *, ...);
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr34856.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr34856.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr34856.c	2012-04-11 10:58:01.946737000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr34856.c	2019-06-25 02:27:21.169930931 -0700
@@ -2,6 +2,7 @@
 /* { dg-options "-O2" } */
 /* { dg-options "-O2 -msse2" { target { i?86-*-* x86_64-*-* } } } */
 /* { dg-options "-O2 -maltivec" { target { powerpc*-*-linux* && powerpc_altivec_ok } } } */
+/* { dg-skip-if "can't divide a power of 2 into int20 sized chunks" { msp430-*-* } { "-mlarge" } { "" } } */
 
 typedef __UINTPTR_TYPE__ uintptr_t;
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr36227.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr36227.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr36227.c	2008-07-02 15:24:18.409275000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr36227.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,14 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -Wstrict-overflow=3" } */
-#if (__SIZEOF_LONG_LONG__ == __SIZEOF_POINTER__)
-typedef unsigned long long ptrcast;
-#elif (__SIZEOF_LONG__ == __SIZEOF_POINTER__)
-typedef unsigned long ptrcast;
-#elif (__SIZEOF_INT__ == __SIZEOF_POINTER__)
-typedef unsigned int ptrcast;
-#else
-#error Add target support here
-#endif
+typedef __UINTPTR_TYPE__ ptrcast;
 
 volatile unsigned long *
 sat_add(volatile unsigned long *ptr, unsigned long i, volatile unsigned long *end)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr40971.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr40971.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr40971.c	2009-08-18 04:42:07.864078000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr40971.c	2019-06-25 02:27:21.169930931 -0700
@@ -2,6 +2,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O -fstack-protector -fno-strict-aliasing" } */
 /* { dg-require-effective-target fstack_protector } */
+/* { dg-skip-if "Array too big" { msp430-*-* } { "*" } { "-mlarge" } } */
 
 extern void bar (char *);
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr42611.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr42611.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr42611.c	2013-07-18 03:17:44.447956000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr42611.c	2019-06-25 02:27:21.169930931 -0700
@@ -3,7 +3,8 @@
 /* { dg-options "" } */
 
 #define L \
-  (sizeof (__SIZE_TYPE__) == 1 ? __SCHAR_MAX__				\
+  (sizeof (__SIZE_TYPE__) == sizeof (void *) ? __INTPTR_MAX__ \
+  : sizeof (__SIZE_TYPE__) == 1 ? __SCHAR_MAX__				\
   : sizeof (__SIZE_TYPE__) == sizeof (short) ? __SHRT_MAX__		\
   : sizeof (__SIZE_TYPE__) == sizeof (int) ? __INT_MAX__		\
   : sizeof (__SIZE_TYPE__) == sizeof (long) ? __LONG_MAX__		\
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr44545.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr44545.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr44545.c	2010-11-16 06:15:55.445860000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr44545.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,5 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fnon-call-exceptions -ftrapv -fexceptions" } */
+/* { dg-require-effective-target trapping } */
+
 int
 DrawChunk(int *tabSize, int x) 
 {
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr47086.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr47086.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr47086.c	2011-01-11 06:10:54.997849000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr47086.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O -fexceptions -fnon-call-exceptions -ftrapv" } */
+/* { dg-require-effective-target trapping } */
 
 void
 foo ()
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr52549.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr52549.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr52549.c	2014-08-29 16:16:29.826323000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr52549.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,4 +1,7 @@
 /* { dg-do compile } */
+/* "-pedantic-errors" is likely to be a default flag, override the options for
+   this test if passing it would cause the usage of __SIZE_TYPE__to error.  */
+/* { dg-options "-ansi" { target { ! size_t_ansi_compatible } } } */
 
 #ifdef __SIZE_TYPE__
 _mark (__SIZE_TYPE__ obj, int i, char *a)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr69071.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr69071.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr69071.c	2016-05-25 12:51:49.510501000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr69071.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,7 +1,7 @@
 /* PR target/69071 */
 /* { dg-do compile } */
 /* { dg-options "-O2 -g" } */
-/* { dg-skip-if "Array too big" { "avr-*-*" } } */
+/* { dg-skip-if "Array too big" { "avr-*-*" msp430-*-* } { "*" } { "-mlarge" } } */
 
 void *bar (void *);
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr71558.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr71558.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr71558.c	2016-06-20 23:59:33.417150000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr71558.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,4 +1,7 @@
 /* PR tree-optimization/71588 */
+/* "-pedantic-errors" is likely to be a default flag, override the options for
+   this test if passing it would cause the usage of __SIZE_TYPE__to error.  */
+/* { dg-options "-ansi" { target { ! size_t_ansi_compatible } } } */
 
 /* strcpy must not be pure, but make sure we don't ICE even when
    it is declared incorrectly.  */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr77587.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr77587.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr77587.c	2017-02-03 17:28:56.270166000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr77587.c	2019-06-25 02:27:21.169930931 -0700
@@ -3,6 +3,9 @@
 /* { dg-require-alias "" } */
 /* { dg-require-weak-override "" } */
 /* { dg-additional-sources "pr77587a.c" } */
+/* "-pedantic-errors" is likely to be a default flag, override the options for
+   this test if passing it would cause the usage of __UINTPTR_TYPE__to error.  */
+/* { dg-options "-ansi" { target { ! ptr_t_ansi_compatible } } } */
 
 void
 bar (long x, long y, long z)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr78138.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr78138.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr78138.c	2017-01-12 13:54:41.345413000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr78138.c	2019-06-25 02:27:21.169930931 -0700
@@ -5,7 +5,7 @@
 
 char d [5];
 
-void* memcpy (void*, const void*, unsigned long);
+void* memcpy (void*, const void*, __SIZE_TYPE__);
 extern char* strcpy (char*, const char*);
 
 void f (int i, int j)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr78973.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr78973.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr78973.c	2017-01-12 09:43:16.985417000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr78973.c	2019-06-25 02:27:21.169930931 -0700
@@ -9,7 +9,7 @@
 void f (void *p, int n)
 {
   if (n <= 4)
-    __builtin_memset (p, 0, n);   /* { dg-warning "exceeds maximum object size" "pr79073" { xfail ilp32 } } */
+    __builtin_memset (p, 0, n);   /* { dg-warning "exceeds maximum object size" "pr79073" { xfail { ilp32 || { int16 && { ! msp430_large_memory_model } } } } } */
 }
 
 void g (void *d, unsigned n)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr79788-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr79788-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr79788-2.c	2017-04-18 06:15:46.328721000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr79788-2.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,6 +1,7 @@
 /* PR middle-end/79788 */
 /* { dg-do compile } */
 /* { dg-options "-ftrapv" } */
+/* { dg-require-effective-target trapping } */
 
 void bar (void);
 void
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr81192.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr81192.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr81192.c	2017-07-03 01:32:20.444245000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr81192.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,5 +1,10 @@
 /* { dg-options "-Os -fdump-tree-pre-details" } */
 
+#if __SIZEOF_INT__ == 2
+#define unsigned __UINT32_TYPE__
+#define int __INT32_TYPE__
+#endif
+
 unsigned a;
 int b, c;
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr81228.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr81228.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr81228.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr81228.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,21 @@
+/* PR target/81228.  */
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-tree-ssa" } */
+
+void *a;
+
+void b ()
+{
+  char c;
+  long d;
+  char *e = a;
+  for (; d; d++)
+  {
+    double f, g;
+    c = g < f || g > f;
+    e[d] = c;
+  }
+}
+
+/* Let's make sure we do have a LTGT.  */
+/* { dg-final { scan-tree-dump "<>" "ssa" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr81661.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr81661.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr81661.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr81661.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,13 @@
+/* PR tree-optimization/81661 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -ftrapv" } */
+/* { dg-require-effective-target trapping } */
+
+int a, b, c;
+
+void
+foo (void)
+{
+  while (a + c > b)
+    a--;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr82274-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr82274-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr82274-1.c	2017-10-13 10:26:28.677791000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr82274-1.c	2019-06-25 02:27:21.169930931 -0700
@@ -2,6 +2,7 @@
 /* { dg-do run } */
 /* { dg-shouldfail "trapv" } */
 /* { dg-options "-ftrapv" } */
+/* { dg-require-effective-target trapping } */
 
 int
 main ()
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr82916.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr82916.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr82916.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr82916.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,47 @@
+/* PR bootstrap/82916 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-dse" } */
+
+struct A { struct A *next; };
+struct C
+{
+  int *of;
+  struct C *parent, *prev, *next;
+  int depth;
+  int min;
+  struct C *min_occ;
+};
+
+__attribute__((noinline, noclone)) struct C *
+foo (int *node)
+{
+  struct A *p = __builtin_malloc (sizeof (struct C));
+  if (!p)
+    return 0;
+  p->next = 0;
+  /* Originally placement new.  */
+  struct C *nw = (struct C *)(void *)p;
+  nw->of = node;
+  nw->parent = 0;
+  nw->prev = 0;
+  nw->next = 0;
+  nw->depth = 0;
+  nw->min_occ = nw;
+  nw->min = 0;
+  return nw;
+}
+
+int
+main ()
+{
+  int o;
+  struct C *p = foo (&o);
+  if (p)
+    {
+      if (p->of != &o || p->parent || p->prev || p->next || p->depth
+	  || p->min || p->min_occ != p)
+	__builtin_abort ();
+    }
+  __builtin_free (p);
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr83605.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr83605.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr83605.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr83605.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,21 @@
+/* PR tree-optimization/83605 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -ftrapv -fexceptions -fnon-call-exceptions" } */
+/* { dg-require-effective-target trapping } */
+
+int a;
+
+int
+foo (int x)
+{
+  int b = a;
+  {
+    int c;
+    int *d = (x == 0) ? &c : &b;
+
+    for (a = 0; a < 2; ++a)
+      c = (x + b) < a;
+
+    return *d;
+  }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr83930.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr83930.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr83930.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr83930.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,17 @@
+/* PR target/83930 */
+/* { dg-do compile } */
+/* { dg-options "-Og -fno-tree-ccp -w" } */
+
+unsigned __attribute__ ((__vector_size__ (16))) v;
+
+static inline void
+bar (unsigned char d)
+{
+  v /= d;
+}
+
+__attribute__ ((always_inline)) void
+foo (void)
+{
+  bar (4);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr83985.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr83985.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr83985.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr83985.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,25 @@
+/* PR rtl-optimization/83985 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-mcpu=e300c3 -mtune=e300c3" { target { powerpc*-*-* && ilp32 } } } */
+
+long long int v;
+
+void
+foo (int x)
+{
+  if (x == 0)
+    return;
+
+  while (v < 2)
+    {
+      signed char *a;
+      v /= x;
+      a = v == 0 ? (signed char *) &x : (signed char *) &v;
+      ++*a;
+      ++v;
+    }
+
+  while (1)
+    ;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr83986.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr83986.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr83986.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr83986.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,14 @@
+/* PR rtl-optimization/83986 */
+/* { dg-do compile } */
+/* { dg-options "-g -O2 -fsched2-use-superblocks -funwind-tables --param max-pending-list-length=1" } */
+
+int v;
+
+int
+foo (int x)
+{
+  v &= !!v && !!x;
+  if (v != 0)
+    foo (0);
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84503-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84503-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84503-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84503-1.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,68 @@
+/* PR tree-optimization/84503 */
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+
+typedef __SIZE_TYPE__ size_t;
+typedef __UINTPTR_TYPE__ uintptr_t;
+
+struct S { int a; unsigned short b; int c, d, e; long f, g, h; int i, j; };
+static struct S *k;
+static size_t l = 0;
+int m;
+
+static int
+bar (void)
+{
+  unsigned i;
+  int j;
+  if (k[0].c == 0)
+    {
+      ++m;
+      size_t n = l * 2;
+      struct S *o;
+      o = (struct S *) __builtin_realloc (k, sizeof (struct S) * n);
+      if (!o)
+	__builtin_exit (0);
+      k = o;
+      for (i = l; i < n; i++)
+	{
+	  void *p = (void *) &k[i];
+	  int q = 0;
+	  size_t r = sizeof (struct S);
+	  if ((((uintptr_t) p) % __alignof__ (long)) == 0
+	      && r % sizeof (long) == 0)
+	    {
+	      long __attribute__ ((may_alias)) *s = (long *) p;
+	      long *t = (long *) ((char *) s + r);
+	      while (s < t)
+		*s++ = 0;
+	    }
+	  else
+	    __builtin_memset (p, q, r);
+	  k[i].c = i + 1;
+	  k[i].a = -1;
+	}
+      k[n - 1].c = 0;
+      k[0].c = l;
+      l = n;
+    }
+  j = k[0].c;
+  k[0].c = k[j].c;
+  return j;
+}
+
+int
+main ()
+{
+  k = (struct S *) __builtin_malloc (sizeof (struct S));
+  if (!k)
+    __builtin_exit (0);
+  __builtin_memset (k, '\0', sizeof (struct S));
+  k->a = -1;
+  l = 1;
+  for (int i = 0; i < 15; ++i)
+    bar ();
+  if (m != 4)
+    __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84503-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84503-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84503-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84503-2.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,5 @@
+/* PR tree-optimization/84503 */
+/* { dg-do run } */
+/* { dg-options "-O3 -fno-tree-vectorize -fno-ivopts" } */
+
+#include "pr84503-1.c"
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84607.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84607.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84607.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84607.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,16 @@
+/* { dg-do run } */
+
+extern void exit(int);
+extern void abort(void);
+int a[10];
+int foo()
+{
+  exit (0);
+  return 0;
+}
+int main()
+{
+  if (&a[foo()])
+    abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84628.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84628.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84628.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84628.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,8 @@
+/* PR ipa/84628 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int f0 (void);
+__attribute__((error ("err"))) void f1 (void) { f0 (); f0 (); }
+__attribute__((error ("err"))) void f2 (void) { f0 (); f0 (); }
+/* { dg-bogus "declared with attribute error" "" { target *-*-* } 0 } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84739.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84739.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84739.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84739.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,26 @@
+/* PR tree-optimization/84739 */
+/* { dg-do compile } */
+/* { dg-require-weak "" } */
+/* { dg-options "-O2 -w" } */
+
+static void baz (void) __attribute__((weakref("bar")));
+
+int
+foo (int x, int y)
+{
+  if (x)
+    y = 0;
+  if (y)
+    goto lab;
+  y = 0;
+lab:
+  return y;
+}
+
+void
+bar (int x, int y)
+{
+  y = foo (x, y);
+  if (y != 0)
+    baz ();
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84772.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84772.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84772.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84772.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,13 @@
+/* PR target/84772 */
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+#include <stdarg.h>
+
+void
+foo (int *x, int y, va_list ap)
+{
+  __builtin_memset (x, 0, sizeof (int));
+  for (int i = 0; i < y; i++)
+    va_arg (ap, long double);			/* { dg-bogus "uninitialized" } */  
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84834.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84834.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84834.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84834.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,15 @@
+/* PR middle-end/84834 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+_Complex int
+foo (int a)
+{
+  return a < 0;
+}
+
+_Complex int
+bar (int a)
+{
+  return (a & 8) ? (_Complex int) 16 : (_Complex int) 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84841.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84841.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84841.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84841.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,9 @@
+/* PR tree-optimization/84841 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fassociative-math -frounding-math -fno-signed-zeros -fno-trapping-math -fno-tree-forwprop" } */
+
+double
+foo (double x)
+{
+  return -x * 0.1 * 0.1;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84853.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84853.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84853.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84853.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,19 @@
+/* PR c/84853 */
+/* { dg-do compile } */
+
+typedef float V __attribute__((__vector_size__ (16)));
+typedef int W __attribute__((__vector_size__ (16)));
+
+void
+foo (int x, V *y, V *z, W *w)
+{
+  *y = *y << x;		/* { dg-error "invalid operands to binary <<" } */
+  *z = *z << *w;	/* { dg-error "invalid operands to binary <<" } */
+}
+
+void
+bar (int x, V *y, V *z, W *w)
+{
+  *y = *y >> x;		/* { dg-error "invalid operands to binary >>" } */
+  *z = *z >> *w;	/* { dg-error "invalid operands to binary >>" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84875.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84875.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84875.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84875.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,28 @@
+/* PR debug/84875 */
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-additional-options "-fpie" { target pie } } */
+/* { dg-additional-options "-march=z196" { target s390*-*-* } } */
+
+static long *a[100];
+static int b[100];
+long *c;
+int d;
+void foo (long *);
+
+void
+bar ()
+{
+  long *g = c;
+  g--;
+  d = *g;
+  if (d)
+    if (b[d] < 8)
+      {
+	*(void **)g = a[d];
+	a[d] = g;
+	b[d]++;
+	return;
+      }
+  foo (g);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84899.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84899.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84899.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84899.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,12 @@
+/* PR target/84899 */
+/* { dg-do compile } */
+/* { dg-options "-O -funroll-all-loops -fno-move-loop-invariants" } */
+
+void
+foo (int x)
+{
+  int a = 1 / x, b = 0;
+
+  while ((a + b + 1) < x)
+    b = __INT_MAX__;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84941.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84941.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84941.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84941.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,10 @@
+/* PR inline-asm/84941 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo (void)
+{
+  short *b[1] = { 0 };
+  asm volatile ("" : "=m,m" (b), "=r,r" (b) : "1,p" (b));
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84953.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84953.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84953.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84953.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,11 @@
+/* PR c/84953 */
+/* { dg-do compile } */
+
+char *strpbrk (const char *, const char *);
+
+char *
+test (char *p)
+{
+  p = strpbrk (p, "");	/* { dg-bogus "assignment discards 'const' qualifier from pointer target type" } */
+  return p;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr84956.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84956.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr84956.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr84956.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,27 @@
+/* { dg-options "-O2 -ftree-tail-merge" } */
+
+char a;
+int c;
+unsigned b ();
+
+unsigned
+setjmp ()
+{
+}
+
+static void
+d ()
+{
+  if (b ())
+    c = 3;
+}
+
+void
+e ()
+{
+  d ();
+  a && ({ setjmp (); });
+  a && ({ setjmp (); });
+  a && ({ setjmp (); });
+}
+
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr85167.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr85167.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr85167.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr85167.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,16 @@
+/* PR rtl-optimization/85167 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -w" } */
+
+struct A { long b; };
+int c, d, e;
+int bar (void);
+
+int
+foo (void)
+{
+  long g;
+  for (; g == c ? 0 : (e = 1); g = ((struct A *)g)->b)
+    if (bar ())
+      return d;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr85257.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr85257.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr85257.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr85257.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,20 @@
+/* PR tree-optimization/85257 */
+/* { dg-do run { target int128 } } */
+/* { dg-options "-O2 -fno-tree-ccp" } */
+
+typedef __int128 V __attribute__ ((__vector_size__ (16 * sizeof (__int128))));
+
+__int128 __attribute__ ((noinline, noclone))
+foo (void)
+{
+  V v = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
+  return v[5];
+}
+
+int
+main ()
+{
+  if (foo () != 6)
+    __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr85300.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr85300.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr85300.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr85300.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,16 @@
+/* PR rtl-optimization/85300 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -g -funroll-all-loops -fno-tree-ter -fno-web" } */
+
+void
+foo (double x, unsigned char y)
+{
+  while ((int) x < 1)
+    {
+      float a;
+
+      a = y | 0x100;
+      y = 0;
+      x = a;
+    }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr85430.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr85430.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr85430.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr85430.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,12 @@
+/* PR target/85430 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-tree-ccp -fno-tree-fre" } */
+
+typedef char V __attribute__((vector_size (4)));
+
+V
+foo (V v)
+{
+  v[(V){}[0]] <<= 1;
+  return v;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr85529.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr85529.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr85529.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr85529.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,27 @@
+/* PR tree-optimization/85529 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-ssa-phiopt" } */
+
+__attribute__((noinline, noclone)) int
+foo (int x)
+{
+  x &= 31;
+  x -= 25;
+  x *= 2;
+  if (x < 0)
+    return 1;
+  int y = x >> 2;
+  if (x >= y)
+    return 1;
+  return 0;
+}
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 63; i++)
+    if (foo (i) != 1)
+      __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/pr86314.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr86314.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/pr86314.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/pr86314.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,20 @@
+// PR target/86314
+// { dg-do run { target sync_int_long } }
+// { dg-options "-O2" }
+
+__attribute__((noinline, noclone)) unsigned long
+foo (unsigned long *p)
+{
+  unsigned long m = 1UL << ((*p & 1) ? 1 : 0);
+  unsigned long n = __atomic_fetch_or (p, m, __ATOMIC_SEQ_CST);
+  return (n & m) == 0;
+}
+
+int
+main ()
+{
+  unsigned long v = 1;
+  if (foo (&v) != 1)
+    __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/rtl/x86_64/final.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/rtl/x86_64/final.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/rtl/x86_64/final.c	2017-03-02 11:32:32.039357000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/rtl/x86_64/final.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { { i?86-*-* x86_64-*-* } && lp64 } } } */
-/* { dg-options "-fdump-rtl-final" } */
+/* { dg-options "-fdwarf2-cfi-asm -fdump-rtl-final" } */
 
 /* Lightly-modified dump of test.c.304r.dwarf2 for x86_64 target,
    with various NOTE_INSN_CFI deleted by hand for now.  */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/sibcall-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/sibcall-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/sibcall-3.c	2014-05-12 15:12:31.456514000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/sibcall-3.c	2019-06-25 02:27:21.173930904 -0700
@@ -5,7 +5,7 @@
    Copyright (C) 2002 Free Software Foundation Inc.
    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */
 
-/* { dg-do run { xfail { { cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* mcore-*-* mn10300-*-* msp430*-*-* nds32*-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */
+/* { dg-do run { xfail { { cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* mcore-*-* mn10300-*-* nds32*-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */
 /* -mlongcall disables sibcall patterns.  */
 /* { dg-skip-if "" { powerpc*-*-* } { "-mlongcall" } { "" } } */
 /* { dg-options "-O2 -foptimize-sibling-calls" } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/sibcall-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/sibcall-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/sibcall-4.c	2014-05-12 15:12:31.456514000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/sibcall-4.c	2019-06-25 02:27:21.173930904 -0700
@@ -5,7 +5,7 @@
    Copyright (C) 2002 Free Software Foundation Inc.
    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */
 
-/* { dg-do run { xfail { { cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* mcore-*-* mn10300-*-* msp430*-*-* nds32*-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */
+/* { dg-do run { xfail { { cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* mcore-*-* mn10300-*-* nds32*-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */
 /* -mlongcall disables sibcall patterns.  */
 /* { dg-skip-if "" { powerpc*-*-* } { "-mlongcall" } { "" } } */
 /* { dg-options "-O2 -foptimize-sibling-calls" } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tls/pr83945.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tls/pr83945.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tls/pr83945.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tls/pr83945.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,21 @@
+/* PR middle-end/83945 */
+/* { dg-do compile { target tls } } */
+/* { dg-options "-O2" } */
+
+struct S { int a[1]; };
+__thread struct T { int c; } e;
+int f;
+void bar (int);
+
+void
+foo (int f, int x)
+{
+  struct S *h = (struct S *) &e.c;
+  for (;;)
+    {
+      int *a = h->a, i;
+      for (i = x; i; i--)
+	bar (a[f]);
+      bar (a[f]);
+    }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr57656.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr57656.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr57656.c	2013-09-03 03:00:06.816688000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr57656.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,5 +1,5 @@
 /* { dg-do run } */
-/* { dg-options "-fstrict-overflow" } */
+/* { dg-additional-options "-fstrict-overflow" } */
 
 int main (void)
 {
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85168.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85168.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85168.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85168.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target indirect_jumps } */
+
+typedef struct {
+    struct {
+	char a;
+    } b;
+} c;
+
+int d, f;
+c *e;
+
+extern void i(void);
+extern void sejtmp () __attribute__((returns_twice));
+
+void g(void)
+{
+  c *h = e;
+  if (f)
+    {
+      i();
+      h--;
+      if (d)
+	if (h->b.a)
+	  i();
+    }
+  if (h->b.a)
+    sejtmp();
+  e = h;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85244-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85244-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85244-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85244-1.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-additional-sources "pr85244-2.c" } */
+
+struct s {
+ long a;
+ int b;
+ int tab[];
+};
+
+extern const struct s val;
+extern int idx;
+extern void abort (void);
+
+int main()
+{
+  if (val.tab[0] != 42 || val.tab[1] != 1337 || val.tab[idx] != 1337)
+    abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85244-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85244-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85244-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85244-2.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,8 @@
+struct s {
+    long a;
+    int b;
+    int tab[];
+};
+
+int idx = 1;
+const struct s val = { 0, 0, { 42, 1337 } };
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85284.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85284.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85284.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85284.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+
+static int p[48], v;
+
+int
+main ()
+{
+  p[32] = 1;
+  for (int i = 48; i--;)
+    {
+      if (!p[i])
+	continue;
+      if ((i & 7) > 2)
+	break;
+      v = i & 1;
+    }
+  if (v != 0)
+    __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85567.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85567.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85567.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85567.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+
+extern void sincos(double x, double *sinx, double *cosx);
+
+void apply(void (*f)(double, double *, double *),
+	   double x, double *sinx, double *cosx)
+{
+  f(x, sinx, cosx);
+  return;
+}
+
+void apply_sincos(double x, double *sinx, double *cosx)
+{
+  apply(sincos, x, sinx, cosx);
+  return;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85588.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85588.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85588.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85588.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,4 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fwrapv" } */
+
+#include "pr57656.c"
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85989.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85989.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/torture/pr85989.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/pr85989.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+
+#define N 9
+
+void __attribute__((noinline, noclone))
+f (double x, double y, double *res)
+{
+  y = -y;
+  for (int i = 0; i < N; ++i)
+    {
+      double tmp = y;
+      y = x;
+      x = tmp;
+      res[i] = i;
+    }
+  res[N] = y * y;
+  res[N + 1] = x;
+}
+
+int
+main (void)
+{
+  double res[N + 2];
+  f (10, 20, res);
+  for (int i = 0; i < N; ++i)
+    if (res[i] != i)
+      __builtin_abort ();
+  if (res[N] != 100 || res[N + 1] != -20)
+    __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c	2017-02-06 18:26:48.979730000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c	2019-06-25 02:27:21.173930904 -0700
@@ -9,7 +9,7 @@
 /* arm_hf_eabi: Variadic funcs use Base AAPCS.  Normal funcs use VFP variant.
    avr: Variadic funcs don't pass arguments in registers, while normal funcs
         do.  */
-/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs" { arm_hf_eabi || { avr-*-* riscv*-*-* } } "*" "" } */
+/* { dg-skip-if "Variadic funcs use different argument passing from normal funcs" { arm_hf_eabi || { avr-*-* riscv*-*-* msp430-*-* } } "*" "" } */
 /* { dg-skip-if "Variadic funcs have all args on stack. Normal funcs have args in registers." { nds32*-*-* } "*" "" } */
 /* { dg-require-effective-target untyped_assembly } */
    
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c	2017-02-06 13:39:03.759220000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c	2019-06-25 02:27:21.173930904 -0700
@@ -33,4 +33,4 @@
    that the && should be emitted (based on BRANCH_COST).  Fix this
    by teaching dom to look through && and register all components
    as true.  */
-/* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" { xfail { ! "alpha*-*-* arm*-*-* aarch64*-*-* powerpc*-*-* cris-*-* crisv32-*-* hppa*-*-* i?86-*-* mmix-*-* mips*-*-* m68k*-*-* moxie-*-* nds32*-*-* s390*-*-* sh*-*-* sparc*-*-* spu-*-* visium-*-* x86_64-*-* riscv*-*-*" } } } } */
+/* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" { xfail { ! "alpha*-*-* arm*-*-* aarch64*-*-* powerpc*-*-* cris-*-* crisv32-*-* hppa*-*-* i?86-*-* mmix-*-* mips*-*-* m68k*-*-* moxie-*-* msp430-*-* nds32*-*-* s390*-*-* sh*-*-* sparc*-*-* spu-*-* visium-*-* x86_64-*-* riscv*-*-*" } } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/alias-32.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/alias-32.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/alias-32.c	2015-05-29 01:20:29.810091000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/alias-32.c	2019-06-25 02:27:21.173930904 -0700
@@ -3,10 +3,14 @@
 
 int bar (short *p)
 {
-  int res = *p;
+  int res;
   struct { int *q1; int *q2; } q;
   q.q1 = __builtin_aligned_alloc (128, 128 * sizeof (int));
   q.q2 = __builtin_aligned_alloc (128, 128 * sizeof (int));
+  /* Register pressure (? maybe) causes the var *p is in to get messed up by
+     the above calls, so moving the assignment here fixes the testcase. 
+     Alternatively could change the analysed pass to fre3.  */
+  res = *p;
   *q.q1 = 1;
   *q.q2 = 2;
   return res + *p + *q.q1 + *q.q2;
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/asm-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/asm-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/asm-3.c	2015-05-29 01:20:29.810091000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/asm-3.c	2019-06-25 02:27:21.173930904 -0700
@@ -8,9 +8,13 @@
 #ifdef __moxie__
 #define REGISTER "8"
 #else
+#ifdef __MSP430__
+#define REGISTER "4"
+#else
 #define REGISTER "0"
 #endif
 #endif
+#endif
 
 void foo (int);
 void bar (int);
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-warn-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-warn-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-warn-3.c	2017-02-14 08:51:24.610231000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-warn-3.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,6 +1,7 @@
 /* PR middle-end/79448 - unhelpful -Wformat-truncation=2 warning
    { dg-do compile }
-   { dg-options "-O2 -Wformat -Wformat-truncation=2 -ftrack-macro-expansion=0" } */
+   { dg-options "-O2 -Wformat -Wformat-truncation=2 -ftrack-macro-expansion=0" } 
+   { dg-require-effective-target ptr32plus } */
 
 typedef __SIZE_TYPE__  size_t;
 typedef __WCHAR_TYPE__ wchar_t;
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-2.c	2017-03-01 15:39:59.190849000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-2.c	2019-06-25 02:27:21.173930904 -0700
@@ -78,7 +78,10 @@
 EQL (1, 1, "%c",  'x');
 EQL (1, 1, "%-s", "x");
 
+/* Size of character constant must be larger than 2 for this to overflow.  */
+#if __SIZEOF_INT__ > 2
 EQL (1, 2, "%c",  'x');
+#endif
 
 EQL (4, 4, "%4c", 'x');
 
@@ -168,7 +171,11 @@
 RNG (0,  5,  6, "%i", i)
 RNG (0,  6,  6, "%i", i)
 
+/* If int is 16bit then it will always fit in 7 char characters with this
+   formatting.  */
+#if __SIZEOF_INT__ > 2
 RNG (0,  0,  7, "%i", i)
+#endif
 RNG (0,  1,  7, "%i", i)
 RNG (0,  2,  7, "%i", i)
 RNG (0,  3,  7, "%i", i)
@@ -291,6 +298,6 @@
 /*  Only conditional calls to must_not_eliminate must be made (with
     any probability):
     { dg-final { scan-tree-dump-times "> \\\[\[0-9.\]+%\\\]:\n *must_not_eliminate" 127 "optimized" { target { ilp32 || lp64 } } } }
-    { dg-final { scan-tree-dump-times "> \\\[\[0-9.\]+%\\\]:\n *must_not_eliminate" 96 "optimized" { target { { ! ilp32 } && { ! lp64 } } } } }
+    { dg-final { scan-tree-dump-times "> \\\[\[0-9.\]+%\\\]:\n *must_not_eliminate" 94 "optimized" { target { { ! ilp32 } && { ! lp64 } } } } }
     No unconditional calls to abort should be made:
     { dg-final { scan-tree-dump-not ";\n *must_not_eliminate" "optimized" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf.c	2017-01-30 13:59:37.935601000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf.c	2019-06-25 02:27:21.173930904 -0700
@@ -5,6 +5,7 @@
    aborts at runtime if any of the assertions fails.  */
 /* { dg-do run } */
 /* { dg-additional-options "-O2 -Wall -Wno-pedantic -fprintf-return-value" } */
+/* { dg-require-effective-target not_newlib_nano_io } */
 
 #ifndef LINE
 #  define LINE   0
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-10.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-10.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-10.c	2017-04-10 22:09:41.624898000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-10.c	2019-06-25 02:27:21.173930904 -0700
@@ -38,17 +38,26 @@
   T1 ("%*.a", 6);     /* { dg-warning "between 6 and 10 bytes" } */
   T1 ("%*.a", 7);     /* { dg-warning "between 7 and 10 bytes" } */
 
-  T1 ("%*.a", w);     /* { dg-warning "writing between 6 and 2147483648 bytes" } */
-  T1 ("%*.0a", w);    /* { dg-warning "writing between 6 and 2147483648 bytes" } */
-  T1 ("%*.1a", w);    /* { dg-warning "writing between 8 and 2147483648 bytes" } */
-  T1 ("%*.2a", w);    /* { dg-warning "writing between 9 and 2147483648 bytes" } */
-
-  T1 ("%.*a",  p);    /* { dg-warning "writing between 6 and 2147483658 bytes" } */
-  T1 ("%1.*a", p);    /* { dg-warning "writing between 6 and 2147483658 bytes" } */
-  T1 ("%2.*a", p);    /* { dg-warning "writing between 6 and 2147483658 bytes" } */
-  T1 ("%3.*a", p);    /* { dg-warning "writing between 6 and 2147483658 bytes" } */
+  T1 ("%*.a", w);     /* { dg-warning "writing between 6 and 2147483648 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 6 and 32768 bytes" "" { target int16 } .-1 } */
+  T1 ("%*.0a", w);    /* { dg-warning "writing between 6 and 2147483648 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 6 and 32768 bytes" "" { target int16 } .-1 } */
+  T1 ("%*.1a", w);    /* { dg-warning "writing between 8 and 2147483648 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 8 and 32768 bytes" "" { target int16 } .-1 } */
+  T1 ("%*.2a", w);    /* { dg-warning "writing between 9 and 2147483648 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 9 and 32768 bytes" "" { target int16 } .-1 } */
+
+  T1 ("%.*a",  p);    /* { dg-warning "writing between 6 and 2147483658 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 6 and 32778 bytes" "" { target int16 } .-1 } */
+  T1 ("%1.*a", p);    /* { dg-warning "writing between 6 and 2147483658 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 6 and 32778 bytes" "" { target int16 } .-1 } */
+  T1 ("%2.*a", p);    /* { dg-warning "writing between 6 and 2147483658 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 6 and 32778 bytes" "" { target int16 } .-1 } */
+  T1 ("%3.*a", p);    /* { dg-warning "writing between 6 and 2147483658 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 6 and 32778 bytes" "" { target int16 } .-1 } */
 
-  T2 ("%*.*a", w, p); /* { dg-warning "writing between 6 and 2147483658 bytes" } */
+  T2 ("%*.*a", w, p); /* { dg-warning "writing between 6 and 2147483658 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 6 and 32778 bytes" "" { target int16 } .-1 } */
 }
 
 /* Exercise %e.  */
@@ -68,17 +77,26 @@
   T1 ("%*.e", 6);     /* { dg-warning "between 6 and 7 bytes" } */
   T1 ("%*.e", 7);     /* { dg-warning "writing 7 bytes" } */
 
-  T1 ("%*.e", w);     /* { dg-warning "writing between 5 and 2147483648 bytes" } */
-  T1 ("%*.0e", w);    /* { dg-warning "writing between 5 and 2147483648 bytes" } */
-  T1 ("%*.1e", w);    /* { dg-warning "writing between 7 and 2147483648 bytes" } */
-  T1 ("%*.2e", w);    /* { dg-warning "writing between 8 and 2147483648 bytes" } */
-
-  T1 ("%.*e",  p);    /* { dg-warning "writing between 5 and 2147483655 bytes" } */
-  T1 ("%1.*e", p);    /* { dg-warning "writing between 5 and 2147483655 bytes" } */
-  T1 ("%2.*e", p);    /* { dg-warning "writing between 5 and 2147483655 bytes" } */
-  T1 ("%3.*e", p);    /* { dg-warning "writing between 5 and 2147483655 bytes" } */
+  T1 ("%*.e", w);     /* { dg-warning "writing between 5 and 2147483648 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 5 and 32768 bytes" "" { target int16 } .-1 } */
+  T1 ("%*.0e", w);    /* { dg-warning "writing between 5 and 2147483648 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 5 and 32768 bytes" "" { target int16 } .-1 } */
+  T1 ("%*.1e", w);    /* { dg-warning "writing between 7 and 2147483648 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 7 and 32768 bytes" "" { target int16 } .-1 } */
+  T1 ("%*.2e", w);    /* { dg-warning "writing between 8 and 2147483648 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 8 and 32768 bytes" "" { target int16 } .-1 } */
+
+  T1 ("%.*e",  p);    /* { dg-warning "writing between 5 and 2147483655 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 5 and 32775 bytes" "" { target int16 } .-1 } */
+  T1 ("%1.*e", p);    /* { dg-warning "writing between 5 and 2147483655 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 5 and 32775 bytes" "" { target int16 } .-1 } */
+  T1 ("%2.*e", p);    /* { dg-warning "writing between 5 and 2147483655 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 5 and 32775 bytes" "" { target int16 } .-1 } */
+  T1 ("%3.*e", p);    /* { dg-warning "writing between 5 and 2147483655 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 5 and 32775 bytes" "" { target int16 } .-1 } */
 
-  T2 ("%*.*e", w, p); /* { dg-warning "writing between 5 and 2147483655 bytes" } */
+  T2 ("%*.*e", w, p); /* { dg-warning "writing between 5 and 2147483655 bytes" "" { target int32 } } */
+		      /* { dg-warning "writing between 5 and 32775 bytes" "" { target int16 } .-1 } */
 }
 
 /* Exercise %f.  */
@@ -100,17 +118,26 @@
   T2 ("%*.*f", 312, 312);   /* { dg-warning "between 314 and 623 bytes" } */
   T2 ("%*.*f", 312, 313);   /* { dg-warning "between 315 and 624 bytes" } */
 
-  T1 ("%*.f", w);           /* { dg-warning "writing between 1 and 2147483648 bytes" } */
-  T1 ("%*.0f", w);          /* { dg-warning "writing between 1 and 2147483648 bytes" } */
-  T1 ("%*.1f", w);          /* { dg-warning "writing between 3 and 2147483648 bytes" } */
-  T1 ("%*.2f", w);          /* { dg-warning "writing between 4 and 2147483648 bytes" } */
-
-  T1 ("%.*f",  p);          /* { dg-warning "writing between 1 and 2147483958 bytes" } */
-  T1 ("%1.*f", p);          /* { dg-warning "writing between 1 and 2147483958 bytes" } */
-  T1 ("%2.*f", p);          /* { dg-warning "writing between 2 and 2147483958 bytes" } */
-  T1 ("%3.*f", p);          /* { dg-warning "writing between 3 and 2147483958 bytes" } */
+  T1 ("%*.f", w);           /* { dg-warning "writing between 1 and 2147483648 bytes" "" { target int32 } } */
+			    /* { dg-warning "writing between 1 and 32768 bytes" "" { target int16 } .-1 } */
+  T1 ("%*.0f", w);          /* { dg-warning "writing between 1 and 2147483648 bytes" "" { target int32 } } */
+			    /* { dg-warning "writing between 1 and 32768 bytes" "" { target int16 } .-1 } */
+  T1 ("%*.1f", w);          /* { dg-warning "writing between 3 and 2147483648 bytes" "" { target int32 } } */
+			    /* { dg-warning "writing between 3 and 32768 bytes" "" { target int16 } .-1 } */
+  T1 ("%*.2f", w);          /* { dg-warning "writing between 4 and 2147483648 bytes" "" { target int32 } } */
+			    /* { dg-warning "writing between 4 and 32768 bytes" "" { target int16 } .-1 } */
+
+  T1 ("%.*f",  p);          /* { dg-warning "writing between 1 and 2147483958 bytes" "" { target int32 } } */
+			    /* { dg-warning "writing between 1 and 33078 bytes" "" { target int16 } .-1 } */
+  T1 ("%1.*f", p);          /* { dg-warning "writing between 1 and 2147483958 bytes" "" { target int32 } } */
+			    /* { dg-warning "writing between 1 and 33078 bytes" "" { target int16 } .-1 } */
+  T1 ("%2.*f", p);          /* { dg-warning "writing between 2 and 2147483958 bytes" "" { target int32 } } */
+			    /* { dg-warning "writing between 2 and 33078 bytes" "" { target int16 } .-1 } */
+  T1 ("%3.*f", p);          /* { dg-warning "writing between 3 and 2147483958 bytes" "" { target int32 } } */
+			    /* { dg-warning "writing between 3 and 33078 bytes" "" { target int16 } .-1 } */
 
-  T2 ("%*.*f", w, p);       /* { dg-warning "writing between 1 and 2147483958 bytes" } */
+  T2 ("%*.*f", w, p);       /* { dg-warning "writing between 1 and 2147483958 bytes" "" { target int32 } } */
+			    /* { dg-warning "writing between 1 and 33078 bytes" "" { target int16 } .-1 } */
 }
 
 /* Exercise %g.  The expected output is the lesser of %e and %f.  */
@@ -151,18 +178,28 @@
   T ("%6.a");       /* { dg-warning "between 6 and 10 bytes" } */
   T ("%7.a");       /* { dg-warning "between 7 and 10 bytes" } */
 
-  T ("%*.a");       /* { dg-warning "writing between 6 and 2147483648 bytes" } */
-  T ("%*.0a");      /* { dg-warning "writing between 6 and 2147483648 bytes" } */
-  T ("%*.1a");      /* { dg-warning "writing between 8 and 2147483648 bytes" } */
-  T ("%*.2a");      /* { dg-warning "writing between 9 and 2147483648 bytes" } */
-
-  T ("%.*a");       /* { dg-warning "writing between 6 and 2147483658 bytes" } */
-  T ("%1.*a");      /* { dg-warning "writing between 6 and 2147483658 bytes" } */
-  T ("%2.*a");      /* { dg-warning "writing between 6 and 2147483658 bytes" } */
-  T ("%6.*a");      /* { dg-warning "writing between 6 and 2147483658 bytes" } */
-  T ("%9.*a");      /* { dg-warning "writing between 9 and 2147483658 bytes" } */
+  T ("%*.a");       /* { dg-warning "writing between 6 and 2147483648 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 6 and 32768 bytes" "" { target int16 } .-1 } */
+  T ("%*.0a");      /* { dg-warning "writing between 6 and 2147483648 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 6 and 32768 bytes" "" { target int16 } .-1 } */
+  T ("%*.1a");      /* { dg-warning "writing between 8 and 2147483648 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 8 and 32768 bytes" "" { target int16 } .-1 } */
+  T ("%*.2a");      /* { dg-warning "writing between 9 and 2147483648 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 9 and 32768 bytes" "" { target int16 } .-1 } */
+
+  T ("%.*a");       /* { dg-warning "writing between 6 and 2147483658 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 6 and 32778 bytes" "" { target int16 } .-1 } */
+  T ("%1.*a");      /* { dg-warning "writing between 6 and 2147483658 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 6 and 32778 bytes" "" { target int16 } .-1 } */
+  T ("%2.*a");      /* { dg-warning "writing between 6 and 2147483658 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 6 and 32778 bytes" "" { target int16 } .-1 } */
+  T ("%6.*a");      /* { dg-warning "writing between 6 and 2147483658 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 6 and 32778 bytes" "" { target int16 } .-1 } */
+  T ("%9.*a");      /* { dg-warning "writing between 9 and 2147483658 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 9 and 32778 bytes" "" { target int16 } .-1 } */
 
-  T ("%*.*a");      /* { dg-warning "writing between 6 and 2147483658 bytes" } */
+  T ("%*.*a");      /* { dg-warning "writing between 6 and 2147483658 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 6 and 32778 bytes" "" { target int16 } .-1 } */
 }
 
 /* Exercise %e.  */
@@ -190,12 +227,17 @@
   T ("%6.e");       /* { dg-warning "between 6 and 7 bytes" } */
   T ("%7.e");       /* { dg-warning "writing 7 bytes" } */
 
-  T ("%.*e");       /* { dg-warning "writing between 5 and 2147483655 bytes" } */
-  T ("%1.*e");      /* { dg-warning "writing between 5 and 2147483655 bytes" } */
-  T ("%6.*e");      /* { dg-warning "writing between 6 and 2147483655 bytes" } */
-  T ("%9.*e");      /* { dg-warning "writing between 9 and 2147483655 bytes" } */
+  T ("%.*e");       /* { dg-warning "writing between 5 and 2147483655 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 5 and 32775 bytes" "" { target int16 } .-1 } */
+  T ("%1.*e");      /* { dg-warning "writing between 5 and 2147483655 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 5 and 32775 bytes" "" { target int16 } .-1 } */
+  T ("%6.*e");      /* { dg-warning "writing between 6 and 2147483655 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 6 and 32775 bytes" "" { target int16 } .-1 } */
+  T ("%9.*e");      /* { dg-warning "writing between 9 and 2147483655 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 9 and 32775 bytes" "" { target int16 } .-1 } */
 
-  T ("%*.*e");      /* { dg-warning "writing between 5 and 2147483655 bytes" } */
+  T ("%*.*e");      /* { dg-warning "writing between 5 and 2147483655 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 5 and 32775 bytes" "" { target int16 } .-1 } */
 }
 
 /* Exercise %f.  */
@@ -227,11 +269,15 @@
   T ("%312.312f");  /* { dg-warning "between 314 and 623 bytes" } */
   T ("%312.313f");  /* { dg-warning "between 315 and 624 bytes" } */
 
-  T ("%.*f");       /* { dg-warning "writing between 1 and 2147483958 bytes" } */
-  T ("%1.*f");      /* { dg-warning "writing between 1 and 2147483958 bytes" } */
-  T ("%3.*f");      /* { dg-warning "writing between 3 and 2147483958 bytes" } */
+  T ("%.*f");       /* { dg-warning "writing between 1 and 2147483958 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 1 and 33078 bytes" "" { target int16 } .-1 } */
+  T ("%1.*f");      /* { dg-warning "writing between 1 and 2147483958 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 1 and 33078 bytes" "" { target int16 } .-1 } */
+  T ("%3.*f");      /* { dg-warning "writing between 3 and 2147483958 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 3 and 33078 bytes" "" { target int16 } .-1 } */
 
-  T ("%*.*f");      /* { dg-warning "writing between 1 and 2147483958 bytes" } */
+  T ("%*.*f");      /* { dg-warning "writing between 1 and 2147483958 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 1 and 33078 bytes" "" { target int16 } .-1 } */
 }
 
 /* Exercise %g.  The expected output is the lesser of %e and %f.  */
@@ -269,5 +315,6 @@
   T ("%1.*g");      /* { dg-warning "writing between 1 and 310 bytes" } */
   T ("%4.*g");      /* { dg-warning "writing between 4 and 310 bytes" } */
 
-  T ("%*.*g");      /* { dg-warning "writing between 1 and 2147483648 bytes" } */
+  T ("%*.*g");      /* { dg-warning "writing between 1 and 2147483648 bytes" "" { target int32 } } */
+		    /* { dg-warning "writing between 1 and 32768 bytes" "" { target int16 } .-1 } */
 }
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-3.c	2017-04-10 22:09:41.624898000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-3.c	2019-06-25 02:27:21.173930904 -0700
@@ -357,35 +357,35 @@
   const size_t imax_p1 = imax + 1;
 
   __builtin_snprintf (d, imax,    "%c", x);
-  __builtin_snprintf (d, imax_p1, "%c", x);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "INT_MAX + 1" { target lp64 } } */
-  /* { dg-warning "specified bound \[0-9\]+ exceeds maximum object size" "INT_MAX + 1" { target { { avr-*-* } || ilp32 } } .-1 } */
+  __builtin_snprintf (d, imax_p1, "%c", x);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "INT_MAX + 1" { target { lp64 || msp430_large_memory_model } } } */
+  /* { dg-warning "specified bound \[0-9\]+ exceeds maximum object size" "INT_MAX + 1" { target { { avr-*-* } || { { ilp32 } || { int16 && { ! msp430_large_memory_model } } } } } .-1 } */
 
   __builtin_vsnprintf (d, imax,    "%c", va);
-  __builtin_vsnprintf (d, imax_p1, "%c", va);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "INT_MAX + 1" { target lp64 } } */
-  /* { dg-warning "specified bound \[0-9\]+ exceeds maximum object size" "INT_MAX + 1" { target { { avr-*-* } || ilp32 } } .-1 } */
+  __builtin_vsnprintf (d, imax_p1, "%c", va);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "INT_MAX + 1" { target { lp64 || msp430_large_memory_model } } } */
+  /* { dg-warning "specified bound \[0-9\]+ exceeds maximum object size" "INT_MAX + 1" { target { { avr-*-* } || { { ilp32 } || { int16 && { ! msp430_large_memory_model } } } } } .-1 } */
 
   __builtin___snprintf_chk (d, imax,    0, imax,    "%c", x);
-  __builtin___snprintf_chk (d, imax_p1, 0, imax_p1, "%c", x);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "INT_MAX + 1" { target lp64 } } */
-  /* { dg-warning "specified bound \[0-9\]+ exceeds maximum object size" "INT_MAX + 1" { target { { avr-*-* } || ilp32 } } .-1 } */
+  __builtin___snprintf_chk (d, imax_p1, 0, imax_p1, "%c", x);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "INT_MAX + 1" { target { lp64 || msp430_large_memory_model } } } */
+  /* { dg-warning "specified bound \[0-9\]+ exceeds maximum object size" "INT_MAX + 1" { target { { avr-*-* } || { { ilp32 } || { int16 && { ! msp430_large_memory_model } } } } } .-1 } */
 
   __builtin___vsnprintf_chk (d, imax,    0, imax,    "%c", va);
-  __builtin___vsnprintf_chk (d, imax_p1, 0, imax_p1, "%c", va);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "INT_MAX + 1" { target lp64 } } */
-  /* { dg-warning "specified bound \[0-9\]+ exceeds maximum object size" "INT_MAX + 1" { target { { avr-*-* } || ilp32 } } .-1 } */
+  __builtin___vsnprintf_chk (d, imax_p1, 0, imax_p1, "%c", va);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "INT_MAX + 1" { target { lp64 || msp430_large_memory_model } } } */
+  /* { dg-warning "specified bound \[0-9\]+ exceeds maximum object size" "INT_MAX + 1" { target { { avr-*-* } || { { ilp32 } || { int16 && { ! msp430_large_memory_model } } } } } .-1 } */
 
   const size_t ptrmax = __PTRDIFF_MAX__;
   const size_t ptrmax_m1 = ptrmax - 1;
 
-  __builtin_snprintf (d, ptrmax_m1, "%c", x);  /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX - 1" { target lp64 } } */
-  __builtin_snprintf (d, ptrmax, "  %c", x);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX" { target lp64 } } */
+  __builtin_snprintf (d, ptrmax_m1, "%c", x);  /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX - 1" { target { lp64 || msp430_large_memory_model } } } */
+  __builtin_snprintf (d, ptrmax, "  %c", x);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX" { target { lp64 || msp430_large_memory_model } } } */
 
-  __builtin_vsnprintf (d, ptrmax_m1, "%c", va);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX - 1" { target lp64 } } */
-  __builtin_vsnprintf (d, ptrmax,    "%c", va);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX" { target lp64 } } */
+  __builtin_vsnprintf (d, ptrmax_m1, "%c", va);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX - 1" { target { lp64 || msp430_large_memory_model } } } */
+  __builtin_vsnprintf (d, ptrmax,    "%c", va);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX" { target { lp64 || msp430_large_memory_model } } } */
 
-  __builtin___snprintf_chk (d, ptrmax_m1, 0, ptrmax_m1, "%c", x);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX - 1" { target lp64 } } */
-  __builtin___snprintf_chk (d, ptrmax,    0, ptrmax,    "%c", x);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX" { target lp64 } } */
+  __builtin___snprintf_chk (d, ptrmax_m1, 0, ptrmax_m1, "%c", x);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX - 1" { target { lp64 || msp430_large_memory_model } } } */
+  __builtin___snprintf_chk (d, ptrmax,    0, ptrmax,    "%c", x);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX" { target { lp64 || msp430_large_memory_model } } } */
 
-  __builtin___vsnprintf_chk (d, ptrmax_m1, 0, ptrmax_m1, "%c", va);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX - 1" { target lp64 } } */
-  __builtin___vsnprintf_chk (d, ptrmax,    0, ptrmax,    "%c", va);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX" { target lp64 } } */
+  __builtin___vsnprintf_chk (d, ptrmax_m1, 0, ptrmax_m1, "%c", va);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX - 1" { target { lp64 || msp430_large_memory_model } } } */
+  __builtin___vsnprintf_chk (d, ptrmax,    0, ptrmax,    "%c", va);   /* { dg-warning "specified bound \[0-9\]+ exceeds .INT_MAX." "PTRDIFF_MAX" { target { lp64 || msp430_large_memory_model } } } */
 }
 
 /* Exercise ordinary sprintf with malloc.  */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-6.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-6.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-6.c	2017-01-26 13:14:18.253883000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-6.c	2019-06-25 02:27:21.173930904 -0700
@@ -3,6 +3,8 @@
    -Wformat-lenght check to prevent warnings.  */
 /* { dg-do compile } */
 /* { dg-options "-O2 -Wformat -Wformat-overflow -fdump-tree-optimized" } */
+/* FIXME should add C99 string "require-support" directive instead probably.  */
+/* { dg-require-effective-target not_newlib_nano_io } */
 
 void abort (void);
 int snprintf (char*, __SIZE_TYPE__, const char*, ...);
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/cunroll-13.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/cunroll-13.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/cunroll-13.c	2016-10-24 04:22:42.785163000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/cunroll-13.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,10 +1,17 @@
 /* { dg-do compile } */
 /* { dg-options "-O3 -fdisable-tree-evrp -fdisable-tree-cunrolli -fdisable-tree-vrp1 -fdump-tree-cunroll-blocks-details" } */
+
+#if __SIZEOF_INT__ < 4
+__extension__ typedef __INT32_TYPE__ i32;
+#else
+typedef int i32;
+#endif
+
 struct a {int a[8];int b;};
 void
 t(struct a *a)
 {
-  for (int i=0;i<123456 && a->a[i];i++)
+  for (i32 i=0;i<123456 && a->a[i];i++)
     a->a[i]++;
 }
 /* This pass relies on the fact that we do not eliminate the redundant test for i early.
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11.c	2015-05-29 01:20:29.810091000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11.c	2019-06-25 02:27:21.173930904 -0700
@@ -30,4 +30,4 @@
 }
 
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target { ! avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { target !avr-*-* !msp430-*-* } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-25.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-25.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-25.c	2015-05-29 01:20:29.810091000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/gen-vect-25.c	2019-06-25 02:27:21.173930904 -0700
@@ -54,5 +54,5 @@
   return main_1 (n + 2, (int *) &n);
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { target { ! avr-*-* } } } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { ! avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect" { target { { ! avr-*-* } && { ! msp430-*-* } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" { target { { ! avr-*-* } && { ! msp430-*-* } } } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/integer-addr.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/integer-addr.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/integer-addr.c	2015-05-29 01:20:29.810091000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/integer-addr.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,7 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fdump-tree-optimized -fno-strict-aliasing" } */
 /* Test with fixed address */
-static int *foo =  (int *) (unsigned long) 0x7800000;
+static int *foo =  (int *) (unsigned long) __INTPTR_MAX__;
 
 int func(void) __attribute__ ((noinline));
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/ldist-25.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/ldist-25.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/ldist-25.c	2017-01-27 05:56:59.846836000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/ldist-25.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,4 +1,4 @@
-/* { dg-do compile } */
+/* { dg-do compile { target size32plus } } */
 /* { dg-options "-O3 -ftree-loop-distribute-patterns -fdump-tree-ldist-details" } */
 
 #define k 1335
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/loop-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/loop-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/loop-1.c	2015-11-05 00:43:46.893709000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/loop-1.c	2019-06-25 02:27:21.173930904 -0700
@@ -43,10 +43,10 @@
 /* The SH targets always use separate instructions to load the address
    and to do the actual call - bsr is only generated by link time
    relaxation.  */
-/* CRIS keeps the address in a register.  */
+/* CRIS and MSP430 keep the address in a register.  */
 /* m68k sometimes puts the address in a register, depending on CPU and PIC.  */
 
-/* { dg-final { scan-assembler-times "foo" 5 { xfail hppa*-*-* ia64*-*-* sh*-*-* cris-*-* crisv32-*-* fido-*-* m68k-*-* i?86-*-mingw* i?86-*-cygwin* x86_64-*-mingw* visium-*-* } } } */
+/* { dg-final { scan-assembler-times "foo" 5 { xfail hppa*-*-* ia64*-*-* sh*-*-* cris-*-* crisv32-*-* fido-*-* m68k-*-* msp430-*-* i?86-*-mingw* i?86-*-cygwin* x86_64-*-mingw* visium-*-* } } } */
 /* { dg-final { scan-assembler-times "foo,%r" 5 { target hppa*-*-* } } } */
 /* { dg-final { scan-assembler-times "= foo"  5 { target ia64*-*-* } } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*_foo" 5 { target i?86-*-mingw* i?86-*-cygwin* } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/loop-35.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/loop-35.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/loop-35.c	2015-11-25 13:26:37.311791000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/loop-35.c	2019-06-25 02:27:21.173930904 -0700
@@ -67,5 +67,5 @@
     }
 }
 /* long index not hoisted for avr target PR 36561 */
-/* { dg-final { scan-tree-dump-times "Executing store motion of" 8 "lim2" { xfail { "avr-*-*" } } } } */
-/* { dg-final { scan-tree-dump-times "Executing store motion of" 6 "lim2" { target { "avr-*-*" } } } } */
+/* { dg-final { scan-tree-dump-times "Executing store motion of" 8 "lim2" { xfail { "avr-*-*" msp430-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "Executing store motion of" 6 "lim2" { target { "avr-*-*" msp430-*-* } } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/pr23455.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/pr23455.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/pr23455.c	2015-05-29 01:20:29.810091000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/pr23455.c	2019-06-25 02:27:21.173930904 -0700
@@ -25,5 +25,5 @@
 /* We should eliminate one load of outcnt, which will in turn let us eliminate
    one multiply of outcnt which will in turn let us eliminate
    one add involving outcnt and outbuf.  */
-/* { dg-final { scan-tree-dump-times "Eliminated: 3" 1 "pre" {target { ! avr-*-* } } } } */
-/* { dg-final { scan-tree-dump-times "Eliminated: 4" 1 "pre" {target {   avr-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "Eliminated: 3" 1 "pre" {target { !avr-*-* !msp430-*-* } } } } */
+/* { dg-final { scan-tree-dump-times "Eliminated: 4" 1 "pre" {target {   avr-*-* msp430-*-* } } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/pr66449.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/pr66449.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/pr66449.c	2016-12-22 04:42:35.303528000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/pr66449.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,9 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O3" } */
 
-#if __SIZEOF_POINTER__ != __SIZEOF_LONG__
 #define long __INTPTR_TYPE__
-#endif
 
 void *fn1(void *p1, void *p2, long p3)
 {
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/pr78886.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/pr78886.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/pr78886.c	2016-12-22 05:09:11.279677000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/pr78886.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,6 +1,8 @@
 /* { dg-do compile } */
 /* { dg-options "-O2" } */
-void *malloc(unsigned long x);
+
+__extension__ typedef __SIZE_TYPE__ size_t;
+void *malloc(size_t x);
 
 void foo(void)
 {
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/pr79327-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/pr79327-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/pr79327-2.c	2017-04-15 13:07:47.485888000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/pr79327-2.c	2019-06-25 02:27:21.173930904 -0700
@@ -76,6 +76,7 @@
   ASSERT_MAYBE (5 == n);
   ASSERT_MAYBE (6 == n);
   ASSERT_MAYBE (7 == n);
+  /* Below will be optimized out for 16-bit int.  */
   ASSERT_MAYBE (8 == n);
   ASSERT_MAYBE (9 == n);
   ASSERT_MAYBE (10 == n);
@@ -147,6 +148,7 @@
   ASSERT_MAYBE (4 == n);
   ASSERT_MAYBE (5 == n);
   ASSERT_MAYBE (6 == n);
+  /* Below will be optimized out for 16-bit int.  */
   ASSERT_MAYBE (7 == n);
   ASSERT_MAYBE (8 == n);
   ASSERT_MAYBE (9 == n);
@@ -156,4 +158,5 @@
 }
 
 /* { dg-final { scan-tree-dump-not "failure_on_line" "optimized"} }
-   { dg-final { scan-tree-dump-times "keep_call_on_line" 43 "optimized"} } */
+   { dg-final { scan-tree-dump-times "keep_call_on_line" 43 "optimized" { target { ! int16 } } } }
+   { dg-final { scan-tree-dump-times "keep_call_on_line" 34 "optimized" { target int16 } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/scev-8.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/scev-8.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/scev-8.c	2016-07-15 07:21:55.449404000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/scev-8.c	2019-06-25 02:27:21.173930904 -0700
@@ -3,6 +3,12 @@
 
 int *a;
 
+#if __SIZEOF_INT__ == __SIZEOF_SHORT__
+#define T char
+#else
+#define T short
+#endif
+
 int
 foo1 (long long s, long long l)
 {
@@ -10,7 +16,7 @@
 
   for (i = s; i < l; i++)
     {
-      a[(short)i] = 0;
+      a[(T)i] = 0;
     }
   return 0;
 }
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-8.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-8.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-8.c	2016-12-22 04:42:35.303528000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-8.c	2019-06-25 02:27:21.173930904 -0700
@@ -300,9 +300,9 @@
 	  else
 	    {
 	      o = f2 (x);
-#if __SIZEOF_POINTER__ == __SIZEOF_LONG__
+#if __SIZEOF_POINTER__ == __SIZEOF_LONG__ && !__MSP430X_LARGE__
 	      if (((unsigned long) o > (unsigned long) -4000L))
-#elif __SIZEOF_POINTER__ == __SIZEOF_INT__
+#else
 	  if (((__UINTPTR_TYPE__) o > (__UINTPTR_TYPE__) -4000U))
 #endif
 		{
@@ -388,9 +388,9 @@
 	  break;
 	case 19:
 	  o = f2 (x);
-#if __SIZEOF_POINTER__ == __SIZEOF_LONG__
+#if __SIZEOF_POINTER__ == __SIZEOF_LONG__ && !__MSP430X_LARGE__
 	  if (((unsigned long) o > (unsigned long) -4000L))
-#elif __SIZEOF_POINTER__ == __SIZEOF_INT__
+#else
 	  if (((__UINTPTR_TYPE__) o > (__UINTPTR_TYPE__) -4000U))
 #endif
 	    {
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/ssa-hoist-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/ssa-hoist-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/ssa-hoist-4.c	2016-07-12 06:32:04.487485000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/ssa-hoist-4.c	2019-06-25 02:27:21.173930904 -0700
@@ -19,6 +19,13 @@
        tem1 = MAX (array[k+1], tem1)
      return tem1;  */
 
-/* { dg-final { scan-tree-dump-times "= \\*" 2 "optimized" } } */
-/* { dg-final { scan-tree-dump-times "MAX_EXPR" 1 "optimized" } } */
+/* These two fail if long > sizetype. k has to keep getting cast to sizetype,
+   which requires an extra temporary variable and GCC isnt smart enough to
+   recognize these can be merged. Or maybe it is being correctly cautious.
+   Of course, an index with a max value > max size type would get wrapped (?)
+   anyway.
+   Passes if k is made unsigned int and the "L" is removed from the literal
+   in the array index. */
+/* { dg-final { scan-tree-dump-times "= \\*" 2 "optimized" { xfail msp430-*-* } } } */
+/* { dg-final { scan-tree-dump-times "MAX_EXPR" 1 "optimized" { xfail msp430-*-* } } } */
 /* { dg-final { scan-tree-dump-times "= PHI" 1 "optimized" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-11.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-11.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-11.c	2015-05-29 01:20:29.810091000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-11.c	2019-06-25 02:27:21.173930904 -0700
@@ -13,4 +13,5 @@
   return r;
 }
 
-/* { dg-final { scan-tree-dump "MEM\\\[.* \\+ 252B\\\]" "optimized"} } */
+/* { dg-final { scan-tree-dump "MEM\\\[.* \\+ 252B\\\]" "optimized" { target int32plus } } } */
+/* { dg-final { scan-tree-dump "MEM\\\[.* \\+ 126B\\\]" "optimized" { target int16 } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-12.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-12.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-12.c	2015-05-29 01:20:29.810091000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/ssa-sink-12.c	2019-06-25 02:27:21.173930904 -0700
@@ -14,4 +14,5 @@
   return r;
 }
 
-/* { dg-final { scan-tree-dump "MEM\\\[.* \\+ 252B\\\]" "optimized"} } */
+/* { dg-final { scan-tree-dump "MEM\\\[.* \\+ 252B\\\]" "optimized" { target int32plus } } } */
+/* { dg-final { scan-tree-dump "MEM\\\[.* \\+ 126B\\\]" "optimized" { target int16 } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/vrp119.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/vrp119.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/tree-ssa/vrp119.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/tree-ssa/vrp119.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,20 @@
+/* PR tree-optimization/86231 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-vrp1" } */
+/* { dg-final { scan-tree-dump-not "link_error" "vrp1" } } */
+
+int bar (int);
+void link_error (void);
+
+int
+foo (int x, int y, int z)
+{
+  if (x < 4 || x > 8) __builtin_unreachable ();
+  if (y >= 2 && y <= 6) __builtin_unreachable ();
+  /* x is [4, 8], y is ~[2, 6], resulting range of e should be ~[2, 3].  */
+  int e = (z ? x : y);
+  bar (bar (bar (bar (bar (bar (bar (bar (bar (bar (bar (bar (e))))))))))));
+  if (e == 2 || e == 3)
+    link_error ();
+  return e;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/ubsan/bounds-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ubsan/bounds-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/ubsan/bounds-3.c	2016-05-06 02:47:25.392289000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/ubsan/bounds-3.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,6 +1,7 @@
 /* PR sanitizer/70875 */
 /* { dg-do run } */
-/* { dg-options "-fsanitize=bounds" } */
+/* { dg-options "-fsanitize=bounds -fno-sanitize-recover=bounds" } */
+/* { dg-shouldfail "ubsan" } */
 
 int
 foo (int n, int k)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/vect/pr84485.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/vect/pr84485.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/vect/pr84485.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/vect/pr84485.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+#define N 256
+
+void __attribute__ ((noinline, noclone))
+f (unsigned long incx, unsigned long incy,
+   float *restrict dx, float *restrict dy)
+{
+  unsigned long ix = 0, iy = 0;
+  for (unsigned long i = 0; i < N; ++i)
+    {
+      dy[iy] += dx[ix];
+      ix += incx;
+      iy += incy;
+    }
+}
+
+float a = 0.0;
+float b[N];
+
+int
+main (void)
+{
+  check_vect ();
+
+  for (int i = 0; i < N; ++i)
+    b[i] = i;
+  f (1, 0, b, &a);
+  if (a != N * (N - 1) / 2)
+    __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/vect/pr85597.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/vect/pr85597.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/vect/pr85597.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/vect/pr85597.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+/* { dg-additional-options "-mfma" { target { x86_64-*-* i?86-*-* } } } */
+
+extern double fma (double, double, double);
+
+static inline void
+bar (int i, double *D, double *S)
+{
+  while (i-- > 0)
+    {
+      D[0] = fma (1, S[0], D[0]);
+      D[1] = fma (1, S[1], D[1]);
+      D[2] = fma (1, S[2], D[2]);
+      D[3] = fma (1, S[3], D[3]);
+      D += 4;
+      S += 4;
+    }
+}
+
+void
+foo (double *d, double *s)
+{
+  bar (10, d, s);
+}
+
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/vla-11.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/vla-11.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/vla-11.c	2017-04-18 23:55:33.851493000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/vla-11.c	2019-06-25 02:27:21.173930904 -0700
@@ -5,6 +5,7 @@
 /* Origin: Joseph Myers <joseph@codesourcery.com> */
 /* { dg-do compile } */
 /* { dg-options "-std=c99 -pedantic-errors" } */
+/* { dg-excess-errors "ISO C does not support" { target { { ! size_t_ansi_compatible } || { ! ptr_t_ansi_compatible } } } } */
 
 void foo11a(int x[sizeof(int *(*)[*])]);	/* { dg-warning "not in a declaration" } */
 void foo11b(__SIZE_TYPE__ x, int y[(__UINTPTR_TYPE__)(int (*)[*])x]);	/* { dg-warning "not in a declaration" } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/vla-9.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/vla-9.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/vla-9.c	2010-04-07 13:27:37.009686000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/vla-9.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile  } */
-/* { dg-options "-std=c99 -pedantic-errors -W -Wall" } */
+/* { dg-options "-std=c99 -W -Wall" } */
+/* { dg-additional-options "-pedantic-errors" { target { size_t_ansi_compatible } } } */
 /* PR c/28280 */
 
 void f(__SIZE_TYPE__ d)
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloca-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloca-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloca-1.c	2017-04-18 23:55:33.851493000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloca-1.c	2019-06-25 02:27:21.169930931 -0700
@@ -24,8 +24,8 @@
   char *s = alloca (123);
   useit (s);			// OK, constant argument to alloca
 
-  s = alloca (num);		// { dg-warning "large due to conversion" "" { target lp64 } }
-  // { dg-warning "unbounded use of 'alloca'" "" { target { ! lp64 } } .-1 }
+  s = alloca (num);		// { dg-warning "large due to conversion" "" { target { { lp64 } || { msp430_large_memory_model } } } }
+  // { dg-warning "unbounded use of 'alloca'" "" { target { { ! lp64 } && { ! msp430_large_memory_model } } } .-1 }
   useit (s);
 
   s = alloca (30000);		/* { dg-warning "is too large" } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloca-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloca-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloca-2.c	2017-04-18 23:55:33.851493000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloca-2.c	2019-06-25 02:27:21.169930931 -0700
@@ -13,7 +13,7 @@
     // 32-bit targets because VRP is not giving us any range info for
     // the argument to __builtin_alloca.  This should be fixed by the
     // upcoming range work.
-    p = __builtin_alloca (n); // { dg-bogus "unbounded use of 'alloca'" "" { xfail { ! lp64 } } }
+    p = __builtin_alloca (n); // { dg-bogus "unbounded use of 'alloca'" "" { xfail { { ! lp64 } && { ! msp430_large_memory_model } } } }
   else
     p = __builtin_malloc (n);
   f (p);
@@ -36,9 +36,9 @@
   void *p;
   if (n > 0 && n < 3000)
     {
-      p = __builtin_alloca (n); // { dg-warning "'alloca' may be too large" "" { target lp64} }
-      // { dg-message "note:.*argument may be as large as 2999" "note" { target lp64 } .-1 }
-      // { dg-warning "unbounded use of 'alloca'" "" { target { ! lp64 } } .-2 }
+      p = __builtin_alloca (n); // { dg-warning "'alloca' may be too large" "" { target { lp64 || msp430_large_memory_model } } }
+      // { dg-message "note:.*argument may be as large as 2999" "note" { target { lp64 || msp430_large_memory_model } } .-1 }
+      // { dg-warning "unbounded use of 'alloca'" "" { target { { ! lp64 } && { ! msp430_large_memory_model } } } .-2 }
     }
   else
     p = __builtin_malloc (n);
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-10.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-10.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-10.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-10.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1PiB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1024 * 1024 * 1024 * 1024 * 1024;   /* 1 pebibyte (PiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1125899906842625. exceeds maximum object size 1125899906842624" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-11.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-11.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-11.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-11.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1PB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1000 * 1000 * 1000 * 1000 * 1000;   /* 1 petabyte (PB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000000000000001. exceeds maximum object size 1000000000000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-12.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-12.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-12.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-12.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1EiB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1024 * 1024 * 1024 * 1024 * 1024 * 1024;   /* 1 exbibyte (EiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1152921504606846977. exceeds maximum object size 1152921504606846976" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-13.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-13.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-13.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-13.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1EB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1000 * 1000 * 1000 * 1000 * 1000 * 1000;   /* 1 exabyte (EB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000000000000000001. exceeds maximum object size 1000000000000000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-14.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-14.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-14.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-14.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,30 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=123456789123456789123456789123456789 -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+/* Verify that an exceedingly large -Walloc-size-larger-than argument
+   with no suffix is accepted and treated as infinite.  */
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));
+
+  n = __SIZE_MAX__ - 1;
+  T (__builtin_malloc (n));
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-15.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-15.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-15.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-15.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,30 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=123456789123456789123456789123456789gb -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+/* Verify that an exceeingly large -Walloc-size-larger-than argument
+   with a valid suffic is accepted and treated as infinite.  */
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));
+
+  n = __SIZE_MAX__ - 1;
+  T (__builtin_malloc (n));
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-16.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-16.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-16.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-16.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,32 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1zb -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+/* Verify that an invalid -Walloc-size-larger-than argument is diagnosed
+   and rejected without changing the default setting of PTRDIFF_MAX.  */
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__ - 1;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
+
+/* { dg-warning "invalid argument .1zb. to .-Walloc-size-larger-than=." "" { target *-*-* } 0 } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-1.c	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,19 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1KB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  unsigned n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1024;   /* 1 kibibyte (KB or KiB) */
+  T (__builtin_malloc (n));
+
+  n = 1025;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1025. exceeds maximum object size 1024" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-2.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,20 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1KiB -ftrack-macro-expansion=0" }
+*/
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  unsigned n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1024;   /* 1 kibibyte (KB or KiB) */
+  T (__builtin_malloc (n));
+
+  n = 1025;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1025. exceeds maximum object size 1024" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-3.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-3.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,19 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1kB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  unsigned n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1000;   /* 1 kilobyte (kB, not to be confused with KB or KiB) */
+  T (__builtin_malloc (n));
+
+  n = 1001;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1001. exceeds maximum object size 1000" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-4.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-4.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,20 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-require-effective-target size32plus }
+   { dg-options "-O -Walloc-size-larger-than=1MiB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  unsigned n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1024 * 1024;   /* 1 mebibyte (MiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1048577. exceeds maximum object size 1048576" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-5.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-5.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-5.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-5.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,26 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-require-effective-target size32plus }
+   { dg-options "-O -Walloc-size-larger-than=1MB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  __SIZE_TYPE__ n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1000 * 1000;   /* 1 megabyte (MB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000001. exceeds maximum object size 1000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size 1000000" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size 1000000" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-6.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-6.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-6.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-6.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,26 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-require-effective-target size32plus }
+   { dg-options "-O -Walloc-size-larger-than=1GiB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  __SIZE_TYPE__ n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1024 * 1024 * 1024;   /* 1 gigibyte (GiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1073741825. exceeds maximum object size 1073741824" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-7.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-7.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-7.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-7.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,26 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-require-effective-target size32plus }
+   { dg-options "-O -Walloc-size-larger-than=1GB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  __SIZE_TYPE__ n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1000 * 1000 * 1000;   /* 1 gigabyte (GB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000000001. exceeds maximum object size 1000000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-8.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-8.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-8.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-8.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1TiB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1024 * 1024 * 1024 * 1024;   /* 1 tebibyte (TiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1099511627777. exceeds maximum object size 1099511627776" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-9.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-9.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than-9.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than-9.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1TB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1000 * 1000 * 1000 * 1000;   /* 1 terabyte (TB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000000000001. exceeds maximum object size 1000000000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Walloc-size-larger-than.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Walloc-size-larger-than.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,13 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-Walloc-size-larger-than=0 -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  T (__builtin_malloc (0));
+  T (__builtin_malloc (1));   /* { dg-warning "argument 1 value .1. exceeds maximum object size 0" } */
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Wattributes-5.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Wattributes-5.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Wattributes-5.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Wattributes-5.c	2019-06-25 02:27:21.169930931 -0700
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options -Wattributes } */
+
+void __attribute__((_foobar)) foo() { }		/* { dg-warning "attribute directive ignored" } */
+void __attribute__((_xformat__)) foo2() { }	/* { dg-warning "attribute directive ignored" } */
+void __attribute__((xformat__)) foo3() { }	/* { dg-warning "attribute directive ignored" } */
+void __attribute__((__xformat)) foo4() { }	/* { dg-warning "attribute directive ignored" } */
+void __attribute__((_)) foo5() { }	/* { dg-warning "attribute directive ignored" } */
+void __attribute__((_)) foo6() { }	/* { dg-warning "attribute directive ignored" } */
+void __attribute__((__)) foo7() { }	/* { dg-warning "attribute directive ignored" } */
+void __attribute__((___)) foo8() { }	/* { dg-warning "attribute directive ignored" } */
+void __attribute__((____)) foo9() { }	/* { dg-warning "attribute directive ignored" } */
+void __attribute__((_____)) foo10() { }	/* { dg-warning "attribute directive ignored" } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/weak/typeof-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/weak/typeof-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/weak/typeof-2.c	2015-01-06 00:50:12.605355000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/weak/typeof-2.c	2019-06-25 02:27:21.173930904 -0700
@@ -48,6 +48,8 @@
 // { dg-final { if [string match m68k-*-* $target_triplet ] {return} } }
 // Likewise for moxie targets.
 // { dg-final { if [string match moxie-*-* $target_triplet ] {return} } }
+// Likewise for msp430 targets.
+// { dg-final { if [string match msp430-*-* $target_triplet ] {return} } }
 // Likewise for Visium targets.
 // { dg-final { if [string match visium-*-* $target_triplet ] {return} } }
 // { dg-final { scan-assembler "baz3.*baz3.*baz3.*baz3.*baz3.*baz3" } }
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.dg/Wno-frame-address.c gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Wno-frame-address.c
--- gcc-7.3.0/gcc/testsuite/gcc.dg/Wno-frame-address.c	2016-09-06 05:02:23.805451000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.dg/Wno-frame-address.c	2019-06-25 02:27:21.169930931 -0700
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-skip-if "Cannot access arbitrary stack frames" { arm*-*-* avr-*-* hppa*-*-* ia64-*-* visium-*-* } } */
+/* { dg-skip-if "Cannot access arbitrary stack frames" { arm*-*-* avr-*-* hppa*-*-* ia64-*-* msp430-*-* visium-*-* } } */
 /* { dg-options "-Werror" } */
 /* { dg-additional-options "-mbackchain" { target { s390*-*-* } } } */
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/aarch64/pr63304_1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/aarch64/pr63304_1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/aarch64/pr63304_1.c	2016-03-18 06:58:32.199587000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/aarch64/pr63304_1.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,5 +1,5 @@
 /* { dg-do assemble } */
-/* { dg-options "-O1 --save-temps -mno-fix-cortex-a53-843419" } */
+/* { dg-options "-O1 --save-temps" } */
 #pragma GCC push_options
 #pragma GCC target ("+nothing+simd, cmodel=small")
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/aarch64/pr81647.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/aarch64/pr81647.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/aarch64/pr81647.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/aarch64/pr81647.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,45 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -fdump-tree-ssa" } */
+/* { dg-require-effective-target fenv_exceptions } */
+
+#include <fenv.h>
+
+double x[28], y[28];
+int res[28];
+
+int
+main (void)
+{
+  int i;
+  for (i = 0; i < 28; ++i)
+    {
+      x[i] = __builtin_nan ("");
+      y[i] = i;
+    }
+  __asm__ volatile ("" ::: "memory");
+  feclearexcept (FE_ALL_EXCEPT);
+  for (i = 0; i < 4; ++i)
+    res[i] = __builtin_isgreater (x[i], y[i]);
+  for (i = 4; i < 8; ++i)
+    res[i] = __builtin_isgreaterequal (x[i], y[i]);
+  for (i = 8; i < 12; ++i)
+    res[i] = __builtin_isless (x[i], y[i]);
+  for (i = 12; i < 16; ++i)
+    res[i] = __builtin_islessequal (x[i], y[i]);
+  for (i = 16; i < 20; ++i)
+    res[i] = __builtin_islessgreater (x[i], y[i]);
+  for (i = 20; i < 24; ++i)
+    res[i] = __builtin_isunordered (x[i], y[i]);
+  for (i = 24; i < 28; ++i)
+    res[i] = !(__builtin_isunordered (x[i], y[i]));
+  __asm__ volatile ("" ::: "memory");
+  return fetestexcept (FE_ALL_EXCEPT) != 0;
+}
+
+/* { dg-final { scan-tree-dump " u> " "ssa" } } */
+/* { dg-final { scan-tree-dump " u>= " "ssa" } } */
+/* { dg-final { scan-tree-dump " u< " "ssa" } } */
+/* { dg-final { scan-tree-dump " u<= " "ssa" } } */
+/* { dg-final { scan-tree-dump " u== " "ssa" } } */
+/* { dg-final { scan-tree-dump " unord " "ssa" } } */
+/* { dg-final { scan-tree-dump " ord " "ssa" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/aarch64/pr83370.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/aarch64/pr83370.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/aarch64/pr83370.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/aarch64/pr83370.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+typedef void (*fun) (void);
+
+void
+f (fun x1)
+{
+  register fun x2 asm ("x16");
+  int arr[5000];
+  int *volatile ptr = arr;
+  asm ("mov %0, %1" : "=r" (x2) : "r" (x1));
+  x2 ();
+}
+
+void g (void) {}
+
+int
+main (void)
+{
+  f (g);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/arm/cmse/cmse-16.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/cmse/cmse-16.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/arm/cmse/cmse-16.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/cmse/cmse-16.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-options "-Os -mcmse" }  */
+
+#include <arm_cmse.h>
+
+int
+foo (void)
+{
+  return cmse_nonsecure_caller ();
+}
+
+int
+main (void)
+{
+  /* Return success (0) if main is secure, ie if cmse_nonsecure_caller/foo
+     returns false (0).  */
+  return foo ();
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/arm/cmse/cmse-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/cmse/cmse-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/arm/cmse/cmse-1.c	2016-12-02 07:34:36.577750000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/cmse/cmse-1.c	2019-06-25 02:27:21.173930904 -0700
@@ -71,6 +71,20 @@
 {
   return cmse_nonsecure_caller ();
 }
+/* { dg-final { scan-assembler "baz:" } } */
+/* { dg-final { scan-assembler "__acle_se_baz:" } } */
+/* { dg-final { scan-assembler-not "\tcmse_nonsecure_caller" } } */
+/* Look for an andsi of 1 with a register in function baz, ie.
+
+;; Function baz<anything>
+<any line without '('>
+(insn <anything but '('> (set (reg<any register modifier>:SI <anything but ')'>)
+     (and:SI (reg<any register modifier>:SI <anything but ')'>)
+	     (const_int 1 <anything but ')'>)<anything but '('>
+   <optional: (nil)<anything but '('>>
+(insn
+*/
+/* { dg-final { scan-rtl-dump "\n;; Function baz\[^\n\]*\[^(\]+\[^;\]*\n\\(insn \[^(\]+ \\(set \\(reg\[^:\]*:SI \[^)\]+\\)\[^(\]*\\(and:SI \\(reg\[^:\]*:SI \[^)\]+\\)\[^(\]*\\((const_int 1|reg\[^:\]*:SI) \[^)\]+\\)\[^(\]+(\\(nil\\)\[^(\]+)?\\(insn" expand } } */
 
 typedef int __attribute__ ((cmse_nonsecure_call)) (int_nsfunc_t) (void);
 
@@ -86,6 +100,11 @@
 {
   fp = cmse_nsfptr_create (callback);
 }
+/* { dg-final { scan-assembler "qux:" } } */
+/* { dg-final { scan-assembler "__acle_se_qux:" } } */
+/* { dg-final { scan-assembler "bic" } } */
+/* { dg-final { scan-assembler "push\t\{r4, r5, r6" } } */
+/* { dg-final { scan-assembler "msr\tAPSR_nzcvq" } } */
 
 int call_callback (void)
 {
@@ -94,13 +113,4 @@
   else
     return default_callback ();
 }
-/* { dg-final { scan-assembler "baz:" } } */
-/* { dg-final { scan-assembler "__acle_se_baz:" } } */
-/* { dg-final { scan-assembler "qux:" } } */
-/* { dg-final { scan-assembler "__acle_se_qux:" } } */
-/* { dg-final { scan-assembler-not "\tcmse_nonsecure_caller" } } */
-/* { dg-final { scan-rtl-dump "and.*reg.*const_int 1" expand } } */
-/* { dg-final { scan-assembler "bic" } } */
-/* { dg-final { scan-assembler "push\t\{r4, r5, r6" } } */
-/* { dg-final { scan-assembler "msr\tAPSR_nzcvq" } } */
 /* { dg-final { scan-assembler-times "bl\\s+__gnu_cmse_nonsecure_call" 1 } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/arm/cmse/cmse-1c99.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/cmse/cmse-1c99.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/arm/cmse/cmse-1c99.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/cmse/cmse-1c99.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -mcmse -std=c99" }  */
+/* This is a copy of cmse-1.c to test arm_mve.h ISO C compatibility.  */
+#include "cmse-1.c"
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/arm/fpscr.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/fpscr.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/arm/fpscr.c	2017-06-23 09:08:40.529482000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/fpscr.c	2019-06-25 02:27:21.173930904 -0700
@@ -6,11 +6,14 @@
 /* { dg-add-options arm_fp } */
 
 void
-test_fpscr ()
+test_fpscr (void)
 {
-  volatile unsigned int status = __builtin_arm_get_fpscr ();
+  unsigned status;
+
+  __builtin_arm_set_fpscr (0);
+  status = __builtin_arm_get_fpscr ();
   __builtin_arm_set_fpscr (status);
 }
 
 /* { dg-final { scan-assembler "mrc\tp10, 7, r\[0-9\]+, cr1, cr0, 0" } } */
-/* { dg-final { scan-assembler "mcr\tp10, 7, r\[0-9\]+, cr1, cr0, 0" } } */
+/* { dg-final { scan-assembler-times "mcr\tp10, 7, r\[0-9\]+, cr1, cr0, 0" 2 } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/arm/pr82518.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/pr82518.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/arm/pr82518.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/pr82518.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,29 @@
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-additional-options "-O3 -fno-inline -std=gnu99" } */
+/* { dg-add-options arm_neon } */
+
+typedef struct { int x, y; } X;
+
+void f4(X *p, int n)
+{
+  for (int i = 0; i < n; i++)
+  { p[i].x = i;
+    p[i].y = i + 1;
+  }
+}
+
+__attribute ((aligned (16))) X arr[100];
+
+int main(void)
+{
+  volatile int fail = 0;
+  f4 (arr, 100);
+  for (int i = 0; i < 100; i++)
+    if (arr[i].y != i+1 || arr[i].x != i)
+      fail = 1;
+  if (fail)
+     __builtin_abort ();
+
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/arm/pr82989.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/pr82989.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/arm/pr82989.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/pr82989.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,33 @@
+/* PR target/82989.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-skip-if "avoid conflicts with multilib options" { *-*-* } { "-mcpu=*" } { "-mcpu=cortex-a8" } } */
+/* { dg-skip-if "avoid conflicts with multilib options" { *-*-* } { "-mfpu=*" } { "-mfpu=neon" } } */
+/* { dg-skip-if "avoid conflicts with multilib options" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=hard" } } */
+/* { dg-options "-O2 -mcpu=cortex-a8 -mfpu=neon -mfloat-abi=hard" } */
+/* { dg-add-options arm_neon } */
+
+typedef unsigned long long uint64_t;
+
+void f_shr_imm (uint64_t *a)
+{
+  *a += *a >> 32;
+}
+
+void f_shr_reg (uint64_t *a, uint64_t b)
+{
+  *a += *a >> b;
+}
+
+void f_shl_imm (uint64_t *a)
+{
+  *a += *a << 32;
+}
+
+void f_shl_reg (uint64_t *a, uint64_t b)
+{
+  *a += *a << b;
+}
+/* { dg-final { scan-assembler-not "vshl*" } } */
+/* { dg-final { scan-assembler-not "vshr*" } } */
+/* { dg-final { scan-assembler-not "vmov*" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/arm/pr84826.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/pr84826.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/arm/pr84826.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/arm/pr84826.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-options "-Ofast -fstack-check" } */
+
+void d (void *);
+
+void a ()
+{
+  int b;
+  void bar (int c)
+  {
+    if (__builtin_expect (c, 0))
+      ++b;
+  }
+  d (bar);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512bw-pr84524.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512bw-pr84524.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512bw-pr84524.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512bw-pr84524.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,14 @@
+/* PR target/84524 */
+/* { dg-do run { target avx512bw } } */
+/* { dg-options "-O3 -mavx512bw" } */
+
+#include "avx512bw-check.h"
+
+#define main() do_main()
+#include "../../gcc.c-torture/execute/pr84524.c"
+
+static void
+avx512bw_test (void)
+{
+  do_main ();
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-pr84786-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-pr84786-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-pr84786-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-pr84786-1.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,25 @@
+/* PR target/84786 */
+/* { dg-do run { target { ! ia32 } } } */
+/* { dg-options "-mavx512f -mno-avx512vl -O2" } */
+/* { dg-require-effective-target avx512f } */
+
+#include "avx512f-check.h"
+
+typedef double V __attribute__((vector_size (16)));
+
+__attribute__((noinline, noclone)) V
+foo (V x, double y)
+{
+  register double z __asm ("xmm18");
+  asm volatile ("" : "=v" (z) : "0" (y));
+  x[1] = z;
+  return x;
+}
+
+static void
+avx512f_test (void)
+{
+  V a = foo ((V) { 1.0, 2.0 }, 3.0);
+  if (a[0] != 1.0 || a[1] != 3.0)
+    abort ();
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-pr84786-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-pr84786-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-pr84786-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-pr84786-2.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,16 @@
+/* PR target/84786 */
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-mavx512f -mno-avx512vl -O2" } */
+
+typedef double V __attribute__((vector_size (16)));
+
+__attribute__((noinline, noclone)) V
+foo (V x, double y)
+{
+  register double z __asm ("xmm18");
+  asm volatile ("" : "=v" (z) : "0" (y));
+  x[1] = z;
+  return x;
+}
+
+/* { dg-final { scan-assembler-not "vunpcklpd\[\^\n\r]*xmm(1\[6-9]|\[23]\[0-9])" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-pr84786-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-pr84786-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-pr84786-3.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-pr84786-3.c	2019-06-25 02:27:21.173930904 -0700
@@ -0,0 +1,50 @@
+/* PR target/84786 */
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-mavx512f -mno-avx512vl -O2" } */
+
+#include <x86intrin.h>
+
+__m512i v;
+__m128i w;
+
+__m128i
+foo (__m128i x, int y)
+{
+  __m128i z;
+#define A(n) register __m512i zmm##n __asm ("zmm" #n);
+#define B A(1) A(2) A(3) A(4) A(5) A(6) A(7) \
+	  A(8) A(9) A(10) A(11) A(12) A(13) A(14)
+  B
+#undef A
+#define A(n) asm volatile ("" : "=v" (zmm##n) : "0" (v));
+  B
+  asm volatile ("" : "=x" (z) : "0" (w));
+  x = _mm_srli_epi16 (x, y);
+  asm volatile ("" : : "x" (z));
+#undef A
+#define A(n) asm volatile ("" : : "v" (zmm##n));
+  B
+  return x;
+}
+
+__m256i
+bar (__m256i x, int y)
+{
+  __m128i z;
+#undef A
+#define A(n) register __m512i zmm##n __asm ("zmm" #n);
+  B
+#undef A
+#define A(n) asm volatile ("" : "=v" (zmm##n) : "0" (v));
+  B
+  asm volatile ("" : "=x" (z) : "0" (w));
+  x = _mm256_slli_epi16 (x, y);
+  asm volatile ("" : : "x" (z));
+#undef A
+#define A(n) asm volatile ("" : : "v" (zmm##n));
+  B
+  return x;
+}
+
+/* { dg-final { scan-assembler-not "vpsrlw\[\^\n\r]*xmm(1\[6-9]|\[23]\[0-9])" } } */
+/* { dg-final { scan-assembler-not "vpsllw\[\^\n\r]*xmm(1\[6-9]|\[23]\[0-9])" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c	2015-12-29 02:32:21.184118000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-options "-mavx512f -O2" } */
-/* { dg-final { scan-assembler-times "vcvtusi2sd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vcvtusi2sd\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{ru-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2sdq\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2sdq\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{ru-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c	2015-12-29 02:32:21.184118000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-options "-mavx512f -O2" } */
-/* { dg-final { scan-assembler-times "vcvtusi2ss\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vcvtusi2ss\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{rz-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2ssq\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2ssq\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{rz-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c	2014-10-29 00:09:46.016350000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c	2019-06-25 02:27:21.173930904 -0700
@@ -41,18 +41,14 @@
       res3.a[i] = DEFAULT_VALUE;
     }
 
-#if AVX512F_LEN == 512
   res1.x = INTRINSIC (_permutexvar_epi32) (src1.x, src2.x);
-#endif
   res2.x = INTRINSIC (_maskz_permutexvar_epi32) (mask, src1.x, src2.x);
   res3.x = INTRINSIC (_mask_permutexvar_epi32) (res3.x, mask, src1.x, src2.x);
 
   CALC (src1.a, src2.a, res_ref);
 
-#if AVX512F_LEN == 512
   if (UNION_CHECK (AVX512F_LEN, i_d) (res1, res_ref))
     abort ();
-#endif
 
   MASK_ZERO (i_d) (res_ref, mask, SIZE);
   if (UNION_CHECK (AVX512F_LEN, i_d) (res2, res_ref))
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c	2014-10-29 00:09:46.016350000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c	2019-06-25 02:27:21.173930904 -0700
@@ -40,18 +40,14 @@
       res3.a[i] = DEFAULT_VALUE;
     }
 
-#if AVX512F_LEN == 512
   res1.x = INTRINSIC (_permutex_epi64) (src1.x, IMM_MASK);
-#endif
   res2.x = INTRINSIC (_maskz_permutex_epi64) (mask, src1.x, IMM_MASK);
   res3.x = INTRINSIC (_mask_permutex_epi64) (res3.x, mask, src1.x, IMM_MASK);
 
   CALC (src1.a, IMM_MASK, res_ref);
 
-#if AVX512F_LEN == 512
   if (UNION_CHECK (AVX512F_LEN, i_q) (res1, res_ref))
     abort ();
-#endif
 
   MASK_ZERO (i_q) (res_ref, mask, SIZE);
   if (UNION_CHECK (AVX512F_LEN, i_q) (res2, res_ref))
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c	2014-10-29 00:09:46.016350000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c	2019-06-25 02:27:21.173930904 -0700
@@ -41,18 +41,14 @@
       res3.a[i] = DEFAULT_VALUE;
     }
 
-#if AVX512F_LEN == 512
   res1.x = INTRINSIC (_permutexvar_epi64) (src1.x, src2.x);
-#endif
   res2.x = INTRINSIC (_maskz_permutexvar_epi64) (mask, src1.x, src2.x);
   res3.x = INTRINSIC (_mask_permutexvar_epi64) (res3.x, mask, src1.x, src2.x);
 
   CALC (src1.a, src2.a, res_ref);
 
-#if AVX512F_LEN == 512
   if (UNION_CHECK (AVX512F_LEN, i_q) (res1, res_ref))
     abort ();
-#endif
 
   MASK_ZERO (i_q) (res_ref, mask, SIZE);
   if (UNION_CHECK (AVX512F_LEN, i_q) (res2, res_ref))
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c	2014-12-03 05:39:51.493038000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512vl -O2" } */
+/* { dg-final { scan-assembler-times "vpermd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 
@@ -11,6 +12,7 @@
 void extern
 avx512vl_test (void)
 {
+  x = _mm256_permutexvar_epi32 (x, x);
   x = _mm256_maskz_permutexvar_epi32 (m, x, x);
   x = _mm256_mask_permutexvar_epi32 (x, m, x, x);
 }
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c	2014-12-03 05:39:51.493038000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512vl -O2" } */
+/* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 
@@ -11,6 +12,7 @@
 void extern
 avx512vl_test (void)
 {
+  x = _mm256_permutex_epi64 (x, 13);
   x = _mm256_mask_permutex_epi64 (x, m, x, 13);
   x = _mm256_maskz_permutex_epi64 (m, x, 13);
 }
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c	2014-12-03 05:39:51.493038000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c	2019-06-25 02:27:21.173930904 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512vl -O2" } */
+/* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 
@@ -11,6 +12,7 @@
 void extern
 avx512vl_test (void)
 {
+  x = _mm256_permutexvar_epi64 (x, x);
   x = _mm256_maskz_permutexvar_epi64 (m, x, x);
   x = _mm256_mask_permutexvar_epi64 (x, m, x, x);
 }
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/i386.exp gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/i386.exp
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/i386.exp	2017-03-03 08:55:31.667106000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/i386.exp	2019-06-25 02:27:21.177930874 -0700
@@ -241,18 +241,6 @@
     } "-mrtm" ]
 }
 
-# Return 1 if avx512f instructions can be compiled.
-proc check_effective_target_avx512f { } {
-    return [check_no_compiler_messages avx512f object {
-	typedef long long __v8di __attribute__ ((__vector_size__ (64)));
-	__v8di
-	mm512_and_epi64  (__v8di __X, __v8di __Y)
-	{
-            return __builtin_ia32_pandq512_mask (__X, __Y, __X, -1);
-	}
-    } "-mavx512f" ]
-}
-
 # Return 1 if avx512vl instructions can be compiled.
 proc check_effective_target_avx512vl { } {
     return [check_no_compiler_messages avx512vl object {
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c	2019-06-25 02:27:21.177930874 -0700
@@ -11,9 +11,8 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c	2019-06-25 02:27:21.177930874 -0700
@@ -11,9 +11,8 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c	2019-06-25 02:27:21.177930874 -0700
@@ -12,9 +12,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c	2019-06-25 02:27:21.177930874 -0700
@@ -12,9 +12,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-5.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-5.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-5.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-5.c	2019-06-25 02:27:21.177930874 -0700
@@ -9,8 +9,10 @@
   bar ();
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-6.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-6.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-6.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-6.c	2019-06-25 02:27:21.177930874 -0700
@@ -10,9 +10,13 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target x32 } } } */
+/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 { target x32 } } } */
+/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
+/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c	2019-06-25 02:27:21.177930874 -0700
@@ -35,9 +35,8 @@
     }
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c	2019-06-25 02:27:21.177930874 -0700
@@ -14,9 +14,8 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c	2019-06-25 02:27:21.177930874 -0700
@@ -12,9 +12,8 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c	2019-06-25 02:27:21.177930874 -0700
@@ -14,10 +14,9 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
 /* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c	2019-06-25 02:27:21.177930874 -0700
@@ -13,10 +13,9 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
 /* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c	2019-06-25 02:27:21.177930874 -0700
@@ -14,9 +14,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c	2019-06-25 02:27:21.177930874 -0700
@@ -13,9 +13,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c	2019-06-25 02:27:21.177930874 -0700
@@ -36,9 +36,8 @@
     }
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c	2019-06-25 02:27:21.177930874 -0700
@@ -10,9 +10,9 @@
   dispatch (buf);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "pushq\[ \t\]%rax" { target x32 } } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd_rax" { target lp64 } } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_eax" { target ia32 } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c	2019-06-25 02:27:21.177930874 -0700
@@ -11,10 +11,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "pushq\[ \t\]%rax" { target x32 } } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd" } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_(r|e)ax" } } */
 /* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c	2019-06-25 02:27:21.177930874 -0700
@@ -10,8 +10,9 @@
   bar (buf);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" } } */
+/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd_rax" { target lp64 } } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_eax" { target ia32 } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c	2019-06-25 02:27:21.177930874 -0700
@@ -11,10 +11,9 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-times "bnd call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_(r|e)ax" } } */
+/* { dg-final { scan-assembler-times "bnd call\[ \t\]*\.LIND" 1 } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c	2019-06-25 02:27:21.177930874 -0700
@@ -11,9 +11,8 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c	2019-06-25 02:27:21.177930874 -0700
@@ -11,9 +11,8 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c	2019-06-25 02:27:21.177930874 -0700
@@ -12,9 +12,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c	2019-06-25 02:27:21.177930874 -0700
@@ -12,9 +12,7 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
 /* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c	2019-06-25 02:27:21.177930874 -0700
@@ -9,8 +9,10 @@
   bar ();
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c	2019-06-25 02:27:21.177930874 -0700
@@ -10,8 +10,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c	2019-06-25 02:27:21.177930874 -0700
@@ -35,9 +35,8 @@
     }
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c	2019-06-25 02:27:21.177930874 -0700
@@ -11,7 +11,7 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c	2019-06-25 02:27:21.177930874 -0700
@@ -11,7 +11,7 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c	2019-06-25 02:27:21.177930874 -0700
@@ -12,7 +12,7 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c	2019-06-25 02:27:21.177930874 -0700
@@ -12,7 +12,7 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c	2019-06-25 02:27:21.177930874 -0700
@@ -9,7 +9,8 @@
   bar ();
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c	2019-06-25 02:27:21.177930874 -0700
@@ -10,7 +10,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c	2019-06-25 02:27:21.177930874 -0700
@@ -35,8 +35,8 @@
     }
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr82795.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr82795.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr82795.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr82795.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mavx2" } */
+
+void
+sj (int qh, int rn, int *by)
+{
+  for (;;)
+    if (qh != 0)
+      {
+	int dc;
+
+	for (dc = 0; dc < 17; ++dc)
+	  {
+	    int nn;
+
+	    nn = (rn != 0) ? qh : dc;
+	    if (nn != 0)
+	      qh = nn;
+	    else
+	      qh = (qh != 0) ? *by : dc;
+	  }
+      }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr84310-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr84310-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr84310-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr84310-2.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -malign-loops=16" } */
+/* { dg-warning "is obsolete" "" { target *-*-* } 0 } */
+
+void
+c (void)
+{
+  for (;;)
+    ;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr84310.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr84310.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr84310.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr84310.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -falign-functions=100000" } */
+/* { dg-error "is not between 0 and 65536" "" { target *-*-* } 0 } */
+
+void
+test_func (void)
+{
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr84625.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr84625.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr84625.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr84625.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,12 @@
+/* PR inline-asm/84625 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -msse2" } */
+
+typedef int V __attribute__((vector_size (16)));
+
+void
+foo (void)
+{
+  asm volatile ("# %0" : : "X" ((V) { 1, 2, 3, 4 }));	// { dg-error "invalid vector immediate" }
+  asm volatile ("# %0" : : "" ((V) { 2, 3, 4, 5 }));	// { dg-error "invalid vector immediate" }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr84827.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr84827.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr84827.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr84827.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,21 @@
+/* PR target/84827 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -fno-fp-int-builtin-inexact -ftrapping-math -fno-associative-math -mfpmath=387" } */
+
+double
+f1 (double a)
+{
+  return __builtin_round (a);
+}
+
+float
+f2 (float a)
+{
+  return __builtin_roundf (a);
+}
+
+long double
+f3 (long double a)
+{
+  return __builtin_roundl (a);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr84829.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr84829.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr84829.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr84829.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,7 @@
+/* { dg-do link } */
+/* { dg-options "-mieee-fp" } */
+
+int main()
+{
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr85034.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr85034.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr85034.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr85034.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,11 @@
+/* PR inline-asm/85034 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo (void)
+{
+  volatile float a;
+  struct S { char a; } b = { 0 };
+  asm volatile ("" : "=r" (a) : "0ir" (b));
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr85095-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr85095-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr85095-1.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr85095-1.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,33 @@
+/* PR target/85095 *
+/* { dg-do compile } */
+/* { dg-options "-O2 -masm=att" } */
+
+unsigned int
+foo (unsigned int a, unsigned int b)
+{
+  a += b;
+  if (a < b) a++;
+  return a;
+}
+
+#ifdef __x86_64__
+unsigned long long
+bar (unsigned long long a, unsigned long long b)
+{
+  a += b;
+  if (a < b) a++;
+  return a;
+}
+
+unsigned long long
+baz (unsigned int a, unsigned int b)
+{
+  a += b;
+  if (a < b) a++;
+  return a;
+}
+#endif
+
+/* { dg-final { scan-assembler-times "adcl\t\\\$0," 1 { target ia32 } } } */
+/* { dg-final { scan-assembler-times "adcl\t\\\$0," 2 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-times "adcq\t\\\$0," 1 { target { ! ia32 } } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr85095-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr85095-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr85095-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr85095-2.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,54 @@
+/* PR target/85095 *
+/* { dg-do compile } */
+/* { dg-options "-O2 -masm=att" } */
+
+unsigned int
+f1 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+unsigned int
+f2 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+
+#ifdef __x86_64__
+unsigned long long
+f3 (unsigned long long a, unsigned long long b)
+{
+  unsigned long long i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+unsigned long long
+f4 (unsigned long long a, unsigned long long b)
+{
+  unsigned long long i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+
+unsigned long long
+f5 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+unsigned long long
+f6 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+#endif
+
+/* { dg-final { scan-assembler-times "adcl\t\\\$0," 1 { target ia32 } } } */
+/* { dg-final { scan-assembler-times "sbbl\t\\\$0," 1 { target ia32 } } } */
+/* { dg-final { scan-assembler-times "adcl\t\\\$0," 2 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-times "sbbl\t\\\$0," 2 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-times "adcq\t\\\$0," 1 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-times "sbbq\t\\\$0," 1 { target { ! ia32 } } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr85193.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr85193.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/pr85193.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/pr85193.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-Wno-psabi -O2 -fno-tree-ccp -fno-tree-fre -mno-sse" } */
+
+typedef unsigned char U __attribute__((vector_size(16)));
+typedef unsigned int V __attribute__((vector_size(16)));
+typedef unsigned long long W __attribute__((vector_size(16)));
+
+extern void bar(U, U);
+
+V v;
+
+void
+foo(U f)
+{
+  f[0] = f[0] << (unsigned char)~v[0] | f[~((W)(U){0, 0, 0, 0, 0, 0, 0, 0, 5})[1] & 5] >> (-(unsigned char)~v[0] & 7);
+  bar(f, (U){});
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-10.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-10.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-10.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-10.c	2019-06-25 02:27:21.177930874 -0700
@@ -15,9 +15,6 @@
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } }  } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk:" { target { ! x32 } }  } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-11.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-11.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-11.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-11.c	2019-06-25 02:27:21.177930874 -0700
@@ -15,9 +15,6 @@
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk:" { target { ! x32 } }  } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-12.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-12.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-12.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-12.c	2019-06-25 02:27:21.177930874 -0700
@@ -15,8 +15,6 @@
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk:" { target { ! x32 } }  } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-13.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-13.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-13.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-13.c	2019-06-25 02:27:21.177930874 -0700
@@ -14,9 +14,8 @@
 /* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 3 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 3 } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-14.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-14.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-14.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-14.c	2019-06-25 02:27:21.177930874 -0700
@@ -16,7 +16,6 @@
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-15.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-15.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-15.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-15.c	2019-06-25 02:27:21.177930874 -0700
@@ -16,7 +16,6 @@
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-22.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-22.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-22.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-22.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,15 @@
+/* PR target/r84530 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mfunction-return=thunk" } */
+
+struct s { _Complex unsigned short x; };
+struct s gs = { 100 + 200i };
+struct s __attribute__((noinline)) foo (void) { return gs; }
+
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {\tpause} } } */
+/* { dg-final { scan-assembler {\tlfence} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-23.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-23.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-23.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-23.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,15 @@
+/* PR target/r84530 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mfunction-return=thunk-extern" } */
+
+struct s { _Complex unsigned short x; };
+struct s gs = { 100 + 200i };
+struct s __attribute__((noinline)) foo (void) { return gs; }
+
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {\tpause} } } */
+/* { dg-final { scan-assembler-not {\tlfence} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-24.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-24.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-24.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-24.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,15 @@
+/* PR target/r84530 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mfunction-return=thunk-inline" } */
+
+struct s { _Complex unsigned short x; };
+struct s gs = { 100 + 200i };
+struct s __attribute__((noinline)) foo (void) { return gs; }
+
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {\tpause} } } */
+/* { dg-final { scan-assembler {\tlfence} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-25.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-25.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-25.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-25.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,15 @@
+/* PR target/r84530 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mfunction-return=thunk -fcheck-pointer-bounds -mmpx -fno-pic" } */
+
+struct s { _Complex unsigned short x; };
+struct s gs = { 100 + 200i };
+struct s __attribute__((noinline)) foo (void) { return gs; }
+
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_bnd_ecx" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {\tpause} } } */
+/* { dg-final { scan-assembler {\tlfence} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-26.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-26.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-26.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-26.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,40 @@
+/* PR target/r84530 */
+/* { dg-do run } */
+/* { dg-options "-Os -mfunction-return=thunk" } */
+
+struct S { int i; };
+__attribute__((const, noinline, noclone))
+struct S foo (int x)
+{
+  struct S s;
+  s.i = x;
+  return s;
+}
+
+int a[2048], b[2048], c[2048], d[2048];
+struct S e[2048];
+
+__attribute__((noinline, noclone)) void
+bar (void)
+{
+  int i;
+  for (i = 0; i < 1024; i++)
+    {
+      e[i] = foo (i);
+      a[i+2] = a[i] + a[i+1];
+      b[10] = b[10] + i;
+      c[i] = c[2047 - i];
+      d[i] = d[i + 1];
+    }
+}
+
+int
+main ()
+{
+  int i;
+  bar ();
+  for (i = 0; i < 1024; i++)
+    if (e[i].i != i)
+      __builtin_abort ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-9.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-9.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/i386/ret-thunk-9.c	2018-01-16 03:17:49.509247000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/i386/ret-thunk-9.c	2019-06-25 02:27:21.177930874 -0700
@@ -13,12 +13,9 @@
 /* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk:" } } */
-/* { dg-final { scan-assembler-times {\tpause} 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times {\tlfence} 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times {\tpause} 2 { target { x32 } } } } */
-/* { dg-final { scan-assembler-times {\tlfence} 2 { target { x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } } } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "__x86_return_thunk:" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler-times {\tpause} 2 } } */
+/* { dg-final { scan-assembler-times {\tlfence} 2 } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/msp430/attr-critical.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/attr-critical.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/msp430/attr-critical.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/attr-critical.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-final { scan-assembler-times "start of prologue.*PUSH\\s+SR.*DINT.*end of prologue" 1 } } */
+/* { dg-final { scan-assembler-times "start of epilogue.*POP\\s+SR.*RET" 1 } } */
+
+extern int a;
+
+void __attribute__((critical))
+critical_fn(void)
+{
+  while(a);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/msp430/attr-naked.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/attr-naked.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/msp430/attr-naked.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/attr-naked.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-final { scan-assembler-not "prologue" } } */
+/* { dg-final { scan-assembler-not "epilogue" } } */
+
+extern int a;
+
+void __attribute__((naked))
+naked_fn(void)
+{
+  while(a);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/msp430/attr-reentrant.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/attr-reentrant.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/msp430/attr-reentrant.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/attr-reentrant.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-final { scan-assembler-times "start of prologue.*DINT.*end of prologue" 1 } } */
+/* { dg-final { scan-assembler-times "start of epilogue.*EINT.*RET" 1 } } */
+
+extern int a;
+
+void __attribute__((reentrant))
+reentrant_fn(void)
+{
+  while(a);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/msp430/attr-wakeup.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/attr-wakeup.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/msp430/attr-wakeup.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/attr-wakeup.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-final { scan-assembler-times "BIC.W\\s+#240, \\S+SP" 1 } } */
+
+extern int a;
+
+/* The SR is TOS on entry to an interrupt function. Clear bits 0xF0 (240) in
+   the SR to exit out of low power mode.  */
+void __attribute__((wakeup,interrupt))
+wake_interrupt_fn(void)
+{
+  while(a);
+}
+
+/* wakeup attribute is silently ignored for non-interrupt functions.  */
+void __attribute__((wakeup))
+wake_fn(void)
+{
+  while(a);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/msp430/data-attributes-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/data-attributes-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/msp430/data-attributes-2.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/data-attributes-2.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+
+int __attribute__((persistent,noinit)) a = 22; /* { dg-warning "variable 'a' cannot have both noinit and persistent attributes" } */
+int __attribute__((noinit,persistent)) b; /* { dg-warning "variable 'b' cannot have both noinit and persistent attributes" } */
+int __attribute__((noinit,section(".foo"))) c; /* { dg-error "section of 'c' conflicts with" } */
+int __attribute__((persistent,section(".foo"))) d = 10; /* { dg-error "section of 'd' conflicts with" } */
+int __attribute__((section(".foo"),noinit)) e; /* { dg-warning "section of 'e' conflicts with" } */
+int __attribute__((section(".foo"),persistent)) f = 10; /* { dg-warning "section of 'f' conflicts with" } */
+int __attribute__((section(".noinit"),noinit)) g;
+int __attribute__((section(".persistent"),persistent)) h = 10;
+
+int main (void)
+{
+  int __attribute__((noinit)) la; /* { dg-warning "'noinit' attribute has no effect on automatic variables" } */
+  int __attribute__((persistent)) lb; /* { dg-warning "'persistent' attribute has no effect on automatic variables" } */
+  return la;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/msp430/data-attributes-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/data-attributes-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/msp430/data-attributes-3.c	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/data-attributes-3.c	2019-06-25 02:27:21.177930874 -0700
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+
+int __attribute__((noinit)) a = 5; /* { dg-error "only zero initializers are allowed in section '.noinit'" } */
+int __attribute__((persistent)) b; /* { dg-warning "variable 'b' was declared persistent and should be explicitly initialized" } */
+
+int main (void)
+{
+  static int __attribute__((noinit)) c;
+  return c;
+}
+
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/msp430/data-attributes.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/data-attributes.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/msp430/data-attributes.c	2015-10-06 09:26:22.186379000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/data-attributes.c	2019-06-25 02:27:21.177930874 -0700
@@ -10,12 +10,17 @@
 int a;
 int b = 0;
 int c = 1;
-int __attribute__((noinit)) d;
-int __attribute__((persistent)) e = 2;
+int __attribute__((noinit)) gd;
+int __attribute__((persistent)) ge = 2;
 
 int
 main (void)
 {
+  /* Persistent/noinit static local variables should behave the same as their
+     global counterparts.  */
+  static int __attribute__((noinit)) ld;
+  static int __attribute__((persistent)) le = 2;
+
   /* Make sure that the C startup code has correctly initialised the ordinary variables.  */
   if (a != 0)
     abort ();
@@ -25,26 +30,31 @@
      This does not support FLASH, and as a side effect it does not support
      reinitialising initialised data.  Hence we only test b and c if this
      is the first time through this test, or large support has been enabled.  */
-  if (e == 2)
+  if (ge == 2)
 #endif
   if (b != 0 || c != 1)
     abort ();
-  
-  switch (e)
+
+  /* The local and global persistent variables should always have the same
+     value.  */
+  if (ge != le)
+    abort();
+  switch (ge)
     {
     case 2:
       /* First time through - change all the values.  */
-      a = b = c = d = e = 3;
+      a = b = c = gd = ge = ld = le = 3;
       break;
 
     case 3:
-      /* Second time through - make sure that d has not been reset.  */
-      if (d != 3)
+      /* Second time through - make sure that gd and ld have not been reset,
+	 and that they have the same value.  */
+      if (gd != 3 || gd != ld)
 	abort ();
       exit (0);
 
     default:
-      /* Any other value for e is an error.  */
+      /* Any other value for ge is an error.  */
       abort ();
     }
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/msp430/msp430.exp gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/msp430.exp
--- gcc-7.3.0/gcc/testsuite/gcc.target/msp430/msp430.exp	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/msp430/msp430.exp	2019-06-25 02:27:21.177930874 -0700
@@ -24,10 +24,16 @@
 # Load support procs.
 load_lib gcc-dg.exp
 
-# If a testcase doesn't have special options, use these.
+# The '-pedantic-errors' option in the global variable DEFAULT_CFLAGS that is
+# set by other drivers causes an error when the __int20 type is used, so remove
+# this option from DEFAULT_CFLAGS for the msp430 tests.
 global DEFAULT_CFLAGS
-if ![info exists DEFAULT_CFLAGS] then {
-    set DEFAULT_CFLAGS ""
+
+if [info exists DEFAULT_CFLAGS] then {
+    set MSP430_DEFAULT_CFLAGS \
+      [ string map { "-pedantic-errors" "" } $DEFAULT_CFLAGS ]
+} else {
+   set MSP430_DEFAULT_CFLAGS ""
 }
 
 # Initialize `dg'.
@@ -35,7 +41,10 @@
 
 # Main loop.
 dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cCS\]]] \
-	"" $DEFAULT_CFLAGS
+	"" $MSP430_DEFAULT_CFLAGS
+
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/devices/*.\[cCS\]]] \
+	"" "-I$srcdir/$subdir/devices $MSP430_DEFAULT_CFLAGS"
 
 # All done.
 dg-finish
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/builtins-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/builtins-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/builtins-1.c	2014-11-04 04:09:50.858929000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/builtins-1.c	2019-06-25 02:27:21.181930845 -0700
@@ -165,3 +165,6 @@
 
   return 0;
 }
+
+/* Translation of vec_packsu (unsigned long long, unsigned long long) */
+/* { dg-final { scan-assembler-times {\mvpkudus\M} 1 } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/builtins-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/builtins-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/builtins-3.c	2017-01-16 09:18:05.187869000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/builtins-3.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_vsx_ok } */
-/* { dg-options "-maltivec -mvsx" } */
+/* { dg-options "-O2 -mvsx -mcpu=power6" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power6" } } */
 
 #include <altivec.h>
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c	2017-01-25 08:23:48.644141000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
 /* { dg-options "-mcpu=power8" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
 
 #include <altivec.h>
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c	2017-01-16 09:03:14.553089000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_p9vector_ok } */
 /* { dg-options "-mcpu=power9" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
 
 #include <altivec.h>
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/extend-divide-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/extend-divide-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/extend-divide-1.c	2014-11-04 04:09:50.858929000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/extend-divide-1.c	2019-06-25 02:27:21.181930845 -0700
@@ -5,9 +5,7 @@
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
 /* { dg-options "-mcpu=power7 -O2" } */
 /* { dg-final { scan-assembler-times "divwe "   1 } } */
-/* { dg-final { scan-assembler-times "divweo "  1 } } */
 /* { dg-final { scan-assembler-times "divweu "  1 } } */
-/* { dg-final { scan-assembler-times "divweuo " 1 } } */
 /* { dg-final { scan-assembler-not    "bl __builtin" } } */
 
 int
@@ -16,20 +14,8 @@
   return __builtin_divwe (a, b);
 }
 
-int
-div_weo (int a, int b)
-{
-  return __builtin_divweo (a, b);
-}
-
 unsigned int
 div_weu (unsigned int a, unsigned int b)
 {
   return __builtin_divweu (a, b);
 }
-
-unsigned int
-div_weuo (unsigned int a, unsigned int b)
-{
-  return __builtin_divweuo (a, b);
-}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/extend-divide-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/extend-divide-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/extend-divide-2.c	2014-11-04 04:09:50.858929000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/extend-divide-2.c	2019-06-25 02:27:21.181930845 -0700
@@ -5,9 +5,7 @@
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
 /* { dg-options "-mcpu=power7 -O2" } */
 /* { dg-final { scan-assembler-times "divde "   1 } } */
-/* { dg-final { scan-assembler-times "divdeo "  1 } } */
 /* { dg-final { scan-assembler-times "divdeu "  1 } } */
-/* { dg-final { scan-assembler-times "divdeuo " 1 } } */
 /* { dg-final { scan-assembler-not    "bl __builtin" } } */
 
 long
@@ -16,20 +14,8 @@
   return __builtin_divde (a, b);
 }
 
-long
-div_deo (long a, long b)
-{
-  return __builtin_divdeo (a, b);
-}
-
 unsigned long
 div_deu (unsigned long a, unsigned long b)
 {
   return __builtin_divdeu (a, b);
 }
-
-unsigned long
-div_deuo (unsigned long a, unsigned long b)
-{
-  return __builtin_divdeuo (a, b);
-}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c	2016-12-19 11:03:48.312388000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c	2019-06-25 02:27:21.181930845 -0700
@@ -4,7 +4,9 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
 /* { dg-require-effective-target int128 } */
-/* { dg-options "-maltivec -mvsx -mpower8-vector" } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mpower8-vector -mcpu=power8 -O2" } */
 /* { dg-additional-options "-maix64" { target powerpc-ibm-aix* } } */
 
 #include "altivec.h"
@@ -21,5 +23,5 @@
   return vec_mul (x, y);
 }
 
-/* { dg-final { scan-assembler-times "\[ \t\]mulld " 6 } } */
-/* { dg-final { scan-assembler-times "\[ \t\]mulhdu" 2 } } */
+/* { dg-final { scan-assembler-times {\mmulld\M} 6 } } */
+/* { dg-final { scan-assembler-times {\mmulhdu\M} 2 } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c	2016-12-19 11:03:48.312388000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c	2019-06-25 02:27:21.181930845 -0700
@@ -2,10 +2,10 @@
    inputs produce the right results.  */
 
 /* { dg-do compile } */
-/* { dg-require-effective-target powerpc_float128_hw_ok } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
 /* { dg-require-effective-target int128 } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
-/* { dg-options "-maltivec -mvsx -mcpu=power9 -O2" } */
+/* { dg-options "-mpower9-vector -mcpu=power9 -O2" } */
 /* { dg-additional-options "-maix64" { target powerpc-ibm-aix* } } */
 
 #include "altivec.h"
@@ -22,4 +22,5 @@
   return vec_mul (x, y);
 }
 
-/* { dg-final { scan-assembler-times "\[ \t\]xsmulqp" 2 } } */
+/* { dg-final { scan-assembler-times {\mmulld\M} 4 } } */
+/* { dg-final { scan-assembler-times {\mmulhdu\M} 2 } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c	2014-10-03 15:38:39.305959000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c	2019-06-25 02:27:21.181930845 -0700
@@ -6,7 +6,7 @@
 /* { dg-options "-O0 -Wno-deprecated" } */
 /* { dg-final { scan-assembler-times "lvsl" 2 } } */
 /* { dg-final { scan-assembler-times "lvsr" 2 } } */
-/* { dg-final { scan-assembler-times "lxvd2x" 2 } } */
+/* { dg-final { scan-assembler-times {\mlxvd2x\M|\mlxv\M} 2 } } */
 /* { dg-final { scan-assembler-times "vperm" 2 } } */
 
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-1.c	2016-12-14 08:08:07.811486000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-1.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,39 +0,0 @@
-/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
-/* { dg-require-effective-target powerpc_p9vector_ok } */
-/* { dg-options "-mcpu=power9 -O2" } */
-
-#include <altivec.h>
-
-vector signed char
-vins_v4si (vector int *vi, vector signed char *vc)
-{
-  return vec_vinsert4b (*vi, *vc, 1);
-}
-
-vector unsigned char
-vins_di (long di, vector unsigned char *vc)
-{
-  return vec_vinsert4b (di, *vc, 2);
-}
-
-vector char
-vins_di2 (long *p_di, vector char *vc)
-{
-  return vec_vinsert4b (*p_di, *vc, 3);
-}
-
-vector unsigned char
-vins_di0 (vector unsigned char *vc)
-{
-  return vec_vinsert4b (0, *vc, 4);
-}
-
-long
-vext (vector signed char *vc)
-{
-  return vec_vextract4b (*vc, 5);
-}
-
-/* { dg-final { scan-assembler "xxextractuw\|vextuw\[lr\]x" } } */
-/* { dg-final { scan-assembler "xxinsertw" } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-2.c	2016-12-27 15:19:15.373566000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-2.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,30 +0,0 @@
-/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
-/* { dg-require-effective-target powerpc_p9vector_ok } */
-/* { dg-options "-mcpu=power9 -O2" } */
-
-#include <altivec.h>
-
-vector signed char
-ins_v4si (vector int vi, vector signed char vc)
-{
-  return vec_vinsert4b (vi, vc, 13);	/* { dg-error "vec_vinsert4b" } */
-}
-
-vector unsigned char
-ins_di (long di, vector unsigned char vc, long n)
-{
-  return vec_vinsert4b (di, vc, n);	/* { dg-error "vec_vinsert4b" } */
-}
-
-long
-vext1 (vector signed char vc)
-{
-  return vec_vextract4b (vc, 13);	/* { dg-error "vec_vextract4b" } */
-}
-
-long
-vextn (vector unsigned char vc, long n)
-{
-  return vec_vextract4b (vc, n);	/* { dg-error "vec_vextract4b" } */
-}
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c	2013-02-11 15:11:12.058023000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c	2019-06-25 02:27:21.181930845 -0700
@@ -5,6 +5,7 @@
 /* { dg-final { scan-assembler-not "\\.section\[ \t\]\\.sdata2," } } */
 /* { dg-final { scan-assembler "sdat@sdarel\\(13\\)" } } */
 /* { dg-final { scan-assembler "sdat2@sdarel\\(13\\)" } } */
+/* { dg-skip-if "" { *-*-* } { "-mno-readonly-in-sdata" } { "" } } */
 
 
 int sdat = 2;
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/pr79799-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/pr79799-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/pr79799-2.c	2017-06-29 15:19:29.243766000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/pr79799-2.c	2019-06-25 02:27:21.181930845 -0700
@@ -8,7 +8,7 @@
 /* Optimize x = vec_insert (vec_extract (v2, N), v1, M) for SFmode if N is the default
    scalar position.  */
 
-#if __ORDER_LITTLE_ENDIAN__
+#if __LITTLE_ENDIAN__
 #define ELE 2
 #else
 #define ELE 1
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c	2018-01-21 05:32:58.843504000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,5 +1,6 @@
-/* { dg-do compile { target { lp64 } } } */
+/* { dg-do compile } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of indirect calls.  */
 
@@ -11,4 +12,10 @@
 }
 
 /* { dg-final { scan-assembler "crset 2" } } */
-/* { dg-final { scan-assembler "beqctrl-" } } */
+
+/* The AIX and ELFv2 ABIs don't allow a sibcall here.  */
+/* { dg-final { scan-assembler "beqctrl-" { target { lp64 || { powerpc*-*-aix* } } } } } */
+
+/* The other ABIs do allow a sibcall.  */
+/* { dg-final { scan-assembler "beqctr-" { target { ilp32 && !powerpc*-*-aix* } } } } */
+/* { dg-final { scan-assembler {b \$} { target { ilp32 && !powerpc*-*-aix* } } } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c	2018-01-21 05:32:58.843504000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of computed goto.  */
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c	2018-01-21 05:32:58.843504000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of jump tables.  */
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c	2018-01-17 17:34:10.497108000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of indirect calls for ELFv2.  */
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c	2018-01-17 17:34:10.497108000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps -Wno-pedantic" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of computed goto.  */
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c	2018-01-17 17:34:10.497108000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of jump tables.  */
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c	2018-01-21 05:32:58.843504000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of indirect calls.  */
 
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-8.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-8.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-8.c	2018-01-21 05:32:58.843504000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-8.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,15 +0,0 @@
-/* { dg-do compile { target { ilp32 } } } */
-/* { dg-additional-options "-O2 -mno-speculate-indirect-jumps" } */
-
-/* Test for deliberate misprediction of -m32 sibcalls.  */
-
-extern int (*f)();
-
-int bar ()
-{
-  return (*f) ();
-}
-
-/* { dg-final { scan-assembler "crset 2" } } */
-/* { dg-final { scan-assembler "beqctr-" } } */
-/* { dg-final { scan-assembler {b \$} } } */
diff -ruN gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/vsxcopy.c gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/vsxcopy.c
--- gcc-7.3.0/gcc/testsuite/gcc.target/powerpc/vsxcopy.c	2014-06-02 15:38:30.360391000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gcc.target/powerpc/vsxcopy.c	2019-06-25 02:27:21.181930845 -0700
@@ -1,8 +1,8 @@
 /* { dg-do compile { target { powerpc64*-*-* } } } */
 /* { dg-require-effective-target powerpc_vsx_ok } */
 /* { dg-options "-O1 -mvsx" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "stxvd2x" } } */
+/* { dg-final { scan-assembler {\mlxvd2x\M|\mlxv\M} } } */
+/* { dg-final { scan-assembler {\mstxvd2x\M|\mstxv\M} } } */
 /* { dg-final { scan-assembler-not "xxpermdi" } } */
 
 typedef float vecf __attribute__ ((vector_size (16)));
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/asan/pr78651.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/asan/pr78651.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/asan/pr78651.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/asan/pr78651.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,26 @@
+// PR sanitizer/78651
+// { dg-do run }
+// { dg-additional-options "-fpic" { target fpic } }
+
+struct A { };
+
+namespace {
+
+void thisThrows () {
+  throw A();
+}
+
+struct SomeRandomType {};
+}
+
+int main() {
+  try {
+    thisThrows();
+  }
+  catch (SomeRandomType) {
+    throw;
+  }
+  catch (A) {
+  }
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/asan/pr85081.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/asan/pr85081.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/asan/pr85081.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/asan/pr85081.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,20 @@
+/* PR sanitizer/85081 */
+/* { dg-do run } */
+/* { dg-options "-fopenmp-simd" } */
+/* { dg-require-effective-target fopenmp } */
+
+inline const int& max(const int& a, const int& b)
+{
+  return a < b ? b : a;
+}
+
+int main()
+{
+  #pragma omp simd
+  for ( int i = 0; i < 20; ++i )
+  {
+    const int j = max(i, 1);
+  }
+
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/concepts/auto4.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/concepts/auto4.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/concepts/auto4.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/concepts/auto4.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,11 @@
+// PR c++/85006
+// { dg-additional-options "-std=c++17 -fconcepts" }
+
+template<typename... Ts> struct A {};
+
+template<typename... Us> A<auto...> foo() { return A{}; }
+
+void bar()
+{
+  foo();
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/auto51.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/auto51.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/auto51.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/auto51.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,9 @@
+// PR c++/84798
+// { dg-do compile { target c++11 } }
+
+template<typename T>
+struct S {
+    static constexpr T value = 0;
+};
+
+constexpr auto x = S<void(*)(auto)>::value; // { dg-error "auto" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/auto-60626.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/auto-60626.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/auto-60626.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/auto-60626.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,6 @@
+// PR c++/60626
+// { dg-do compile { target c++14 } }
+
+struct A {};
+
+void (*A::p)(auto) = 0;  // { dg-error "auto|static data member|template" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/constexpr-84449.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/constexpr-84449.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/constexpr-84449.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/constexpr-84449.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,14 @@
+// PR c++/84449
+// { dg-do compile { target c++11 } }
+
+struct A
+{
+  constexpr A (int) {}
+  ~A () = delete;
+};
+
+struct B
+{
+  A a;
+  constexpr B () : a (0) {}	// { dg-error "use of deleted function" }
+};
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/constexpr-84463.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/constexpr-84463.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/constexpr-84463.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/constexpr-84463.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,22 @@
+// PR c++/84463
+// { dg-do compile { target c++11 } }
+
+struct S { int r; const unsigned char s[5]; };
+static constexpr S a[] = { { 0, "abcd" } };
+struct T { const unsigned char s[5]; };
+static constexpr T b[] = { { "abcd" } };
+
+constexpr int
+foo (const unsigned char *x)
+{
+  return x[0];
+}
+
+constexpr static const S *j = &a[0];
+constexpr static const int k = j->s[0];
+constexpr static int l = foo (a[0].s);
+constexpr static int m = foo (j->s);
+constexpr static const T *n = &b[0];
+constexpr static const int o = n->s[0];
+constexpr static int p = foo (b[0].s);
+constexpr static int q = foo (n->s);
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/constexpr-ctor21.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/constexpr-ctor21.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/constexpr-ctor21.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/constexpr-ctor21.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,15 @@
+// PR c++/83835
+// { dg-do compile { target c++11 } }
+
+struct Z
+{
+  void const * p_;
+  constexpr Z( void const * p ): p_( p ) {}
+  ~Z();
+};
+
+struct Y
+{
+  Z z_;
+  constexpr Y() noexcept: z_( this ) {}
+};
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/constexpr-list2.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/constexpr-list2.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/constexpr-list2.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/constexpr-list2.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,20 @@
+// PR c++/82461
+// { dg-do compile { target c++11 } }
+
+class A {
+private:
+public:
+  constexpr A() {}
+  ~A() {}
+};
+
+class B {
+private:
+  A  a;
+public:
+  constexpr B() : a{} {}
+// works
+// constexpr B() : a() {}
+
+  ~B() {}
+};
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C	2016-09-29 19:15:51.308116000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C	2019-06-25 02:27:21.161930989 -0700
@@ -6,7 +6,7 @@
 // c++/67376 on gcc-patches for additional background.
 
 // { dg-do compile { target c++11 } }
-// { dg-options "-fdelete-null-pointer-checks -fdump-tree-optimized" }
+// { dg-options "-O1 -fdelete-null-pointer-checks -fdump-tree-optimized" }
 
 // Runtime assert.  Used for potentially invalid expressions.
 #define RA(e)  ((e) ? (void)0 : __builtin_abort ())
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C	2016-07-30 15:36:56.043489000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C	2019-06-25 02:27:21.161930989 -0700
@@ -192,12 +192,11 @@
 constexpr S* ps1 = ps;
 constexpr S* ps2 = ps1;
 
-// The following aren't diagnosed due to a bug.
-// constexpr int* pi0 = &((S*)0)->i;
-// constexpr int* pi1 = &((S*)nullptr)->i;
+constexpr int* pi0 = &((S*)0)->i;	// { dg-error "null pointer|not a constant" }
+constexpr int* pi1 = &((S*)nullptr)->i;	// { dg-error "null pointer|not a constant" }
 
-constexpr int* pj0 = &((S*)0)->j;	// { dg-error "not a constant expression" }
-constexpr int* pj1 = &((S*)nullptr)->j;  // { dg-error "not a constant expression" }
+constexpr int* pj0 = &((S*)0)->j;	// { dg-error "null pointer|not a constant" }
+constexpr int* pj1 = &((S*)nullptr)->j;	// { dg-error "null pointer|not a constant" }
 
 constexpr int* psi = &ps->i;	    // { dg-error "null pointer|not a constant" }
 constexpr int* psj = &ps->j;	    // { dg-error "null pointer|not a constant" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/decltype-33837.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/decltype-33837.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/decltype-33837.C	2014-03-07 12:01:12.577361000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/decltype-33837.C	2019-06-25 02:27:21.161930989 -0700
@@ -2,6 +2,6 @@
 // PR c++/33837
 void foo()
 {
-  __decltype (A::foo()); // { dg-error "was not declared|expected" }
-  __decltype (B); // { dg-error "was not declared" }
+  __decltype (A::foo()); // { dg-error "A" }
+  __decltype (B); // { dg-error "B" }
 }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/decltype43.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/decltype43.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/decltype43.C	2012-10-09 09:09:32.324210000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/decltype43.C	2019-06-25 02:27:21.161930989 -0700
@@ -22,6 +22,6 @@
 int main()
 {
   int x = B<decltype(A<int>::a(1))>::b(A<int>::a(1));
-  int y = B<decltype(A     ::a(2))>::b(A<int>::a(2)); // { dg-error "template argument" }
+  int y = B<decltype(A     ::a(2))>::b(A<int>::a(2)); // { dg-error "template" }
   return x + y;
 }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/decltype67.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/decltype67.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/decltype67.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/decltype67.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,7 @@
+// PR c++/85279
+// { dg-do compile { target c++11 } }
+
+template<typename T> struct A
+{
+  void foo(decltype(T())::Y);	// { dg-error {decltype\(T\(\)\)::Y} }
+};
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/elision3.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/elision3.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/elision3.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/elision3.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,21 @@
+// PR c++/84441
+// { dg-do compile { target c++11 } }
+
+struct B {
+  int *b;
+};
+struct A {
+  B b;
+  A (A &&);
+};
+struct C {
+  A c;
+  int d;
+};
+C bar ();
+struct D : C {
+  D ()
+    : C (0 ? bar () : bar ())
+  {}
+};
+D d;
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/extern_template-4.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/extern_template-4.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/extern_template-4.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/extern_template-4.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,23 @@
+// PR c++/85470
+// { dg-do compile { target c++11 } }
+
+template <class T>
+struct StaticObject
+{
+    static T& create()
+    {
+      static T t;
+      return t;
+    }
+
+    static T & instance;
+};
+
+template <class T> T & StaticObject<T>::instance = StaticObject<T>::create();
+
+extern template class StaticObject<int>;
+
+void test()
+{
+    StaticObject<int>::instance;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg8.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg8.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg8.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg8.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,10 @@
+// PR c++/80227
+// { dg-do compile { target c++11 } }
+
+template <class T>
+int foo (T);
+
+template <class T, class U = T [sizeof (T) - 5]>
+int foo (T, U* = 0);
+
+int i = foo (123);
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/gen-attrs-64.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/gen-attrs-64.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/gen-attrs-64.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/gen-attrs-64.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,4 @@
+// PR c++/85140
+// { dg-do compile { target c++11 } }
+
+namespace N alignas() {}	// { dg-error "expected" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/inh-ctor30.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/inh-ctor30.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/inh-ctor30.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/inh-ctor30.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,27 @@
+// PR c++/81860
+// { dg-do compile { target c++11 } }
+// { dg-final { scan-assembler "_ZN1AIjEC\[12\]Ev" } }
+
+template <typename T>
+struct A
+{
+  A() {}
+};
+
+struct B
+{
+  template <typename D>
+  B(D, const A<unsigned>& a = A<unsigned>()) : a(a) {}
+
+  A<unsigned> a;
+};
+
+struct C : B
+{
+  using B::B;
+};
+
+int main()
+{
+  C c(0);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/initlist98.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/initlist98.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/initlist98.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/initlist98.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,17 @@
+// PR c++/83227
+// { dg-do compile { target c++11 } }
+
+#include <initializer_list>
+
+template <typename d> struct f {
+  f(std::initializer_list<d>) {}
+};
+
+struct h {};
+struct i : h {
+  i();
+};
+void foo(f<h>);
+int main() {
+  foo({i{}});
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/initlist-defarg2.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/initlist-defarg2.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/initlist-defarg2.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/initlist-defarg2.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,8 @@
+// PR c++/82336
+// { dg-do link { target c++11 } }
+
+struct foo { int x = 5; };
+struct bar : foo { bar() = default; };
+struct baz { bar x; };
+void qux(baz = {}){}
+int main() { qux(); }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-dependent1.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-dependent1.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-dependent1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-dependent1.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,19 @@
+// PR c++/85815
+// { dg-do compile { target c++11 } }
+
+template<class T>
+class A {
+    static A* INSTANCE;
+    void foobar();
+    void moo() {}
+};
+
+template<class T>
+A<T>* A<T>::INSTANCE = nullptr;
+
+template<class T>
+void A<T>::foobar() {
+    auto x = []() {
+        INSTANCE->moo();
+    };
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle5.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle5.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle5.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle5.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,15 @@
+// { dg-do compile { target c++11 } }
+// { dg-final { scan-assembler "_ZZN1AIiEC4IiEET_S2_Ed_NKUlvE_clEv" } }
+
+template <class T> struct A
+{
+  template <class U>
+  A(U, U = []{ return 42; }());
+};
+
+struct B: A<int>
+{
+  using A::A;
+};
+
+B b(24);
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/noexcept32.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/noexcept32.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/noexcept32.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/noexcept32.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,14 @@
+// PR c++/84045
+// { dg-do compile { target c++11 } }
+
+template <typename T> struct K {
+  static const bool d = true;
+};
+template <typename T, typename> struct B {
+  typedef K<T> D;
+  void foo () noexcept (D::d);
+};
+template <typename T> struct P {
+  P () noexcept (K<T>::d);
+};
+P<int> p;
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/noexcept33.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/noexcept33.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/noexcept33.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/noexcept33.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,28 @@
+// PR c++/86378
+// { dg-do compile { target c++11 } }
+
+struct Pepper {};
+struct Apple { Apple(int) {} };
+
+struct Combination : Apple, Pepper
+{
+  Combination(Pepper p, Apple a)
+    : Apple(a), Pepper(p)
+  {}
+};
+
+struct MyCombination
+{
+  using Spice = Pepper;
+  using Fruit = Apple;
+
+  Combination combination;
+
+  template<typename T>
+  constexpr MyCombination(T&& t)
+  noexcept(noexcept(Combination(Spice(), Fruit(t))))
+    : combination(Spice(), Fruit(t))
+  {}
+};
+
+MyCombination obj(Apple(4));
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/nsdmi14.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/nsdmi14.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/nsdmi14.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/nsdmi14.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,19 @@
+// PR c++/71638
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wall" }
+
+struct A {
+  struct {
+    int i;
+    int &j = i;
+  } b;
+  int a = b.j;
+};
+
+void bar (A);
+
+void
+foo ()
+{
+  bar (A{});
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/nsdmi-empty1.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/nsdmi-empty1.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/nsdmi-empty1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/nsdmi-empty1.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,18 @@
+// PR c++/82764
+// { dg-do compile { target c++11 } }
+
+struct Empty {};
+struct Empty2 : Empty {};
+
+struct A : Empty2
+{
+  int x {1};
+  int y {2};
+};
+
+struct B
+{
+  A a {};
+};
+
+B b;
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/pr65558.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/pr65558.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/pr65558.C	2015-03-25 13:08:05.753884000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/pr65558.C	2019-06-25 02:27:21.161930989 -0700
@@ -2,5 +2,5 @@
 // { dg-do compile { target c++11 } }
 
 inline namespace __attribute__((__abi_tag__))
-{ // { dg-warning "ignoring .__abi_tag__. attribute on anonymous namespace" }
+{ // { dg-warning "ignoring .abi_tag. attribute on anonymous namespace" }
 }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/pr82878.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/pr82878.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/pr82878.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/pr82878.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,20 @@
+// { dg-do compile { target c++11 } }
+// { dg-additional-options "-O" }
+// pr 82878 erroneously unwrapped a reference parm in the lambda::_FUN
+// thunk.
+
+struct A {
+  ~A();
+  operator int ();
+};
+
+void baz ();
+
+void
+bar (A b)
+{
+  void (*lam) (A) = [](A) { baz (); };
+
+  if (auto c = b)
+    lam (c);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/pr83824.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/pr83824.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/pr83824.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/pr83824.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,9 @@
+// PR c++/83824
+// { dg-do compile { target c++11 } }
+
+void
+foo ()
+{
+  if (alignas(1 alignas(1)))	// { dg-error "expected" }
+    ;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/pr85147.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/pr85147.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/pr85147.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/pr85147.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,9 @@
+// PR c++/85147
+// { dg-do compile { target c++11 } }
+
+template<typename T> struct A
+{
+  template<template<...T> class...> struct B {};	// { dg-error "expected|mismatch" }
+};
+
+A<int>::B<> b;						// { dg-error "does not name a template type" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/range-for13.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/range-for13.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/range-for13.C	2015-04-15 10:18:27.600150000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/range-for13.C	2019-06-25 02:27:21.161930989 -0700
@@ -3,16 +3,6 @@
 
 // { dg-do compile { target c++11 } }
 
-//These should not be used
-template<typename T> int *begin(T &t)
-{
-    T::fail;
-}
-template<typename T> int *end(T &t)
-{
-    T::fail;
-}
-
 struct container1
 {
     int *begin();
@@ -87,10 +77,37 @@
     static function end;
 };
 
+namespace N
+{
+template<typename T> int *begin(T &t)
+{
+    return 0;
+}
+template<typename T> int *end(T &t)
+{
+    return 0;
+}
+struct container11
+{
+    int *begin();
+    //no end
+};
+
+struct container12
+{
+    int *end();
+    //no begin
+};
+
+struct container13
+{
+};
+}
+
 void test1()
 {
-  for (int x : container1()); // { dg-error "member but not" }
-  for (int x : container2()); // { dg-error "member but not" }
+  for (int x : container1()); // { dg-error "'begin' was not declared|'end' was not declared" }
+  for (int x : container2()); // { dg-error "'begin' was not declared|'end' was not declared" }
   for (int x : container3()); // { dg-error "within this context" }
   for (int x : container4()); // { dg-error "cannot be used as a function" }
   for (int x : container5()); // { dg-error "invalid use of" }
@@ -99,4 +116,7 @@
   for (int x : container8());
   for (int x : container9()); // { dg-error "within this context" }
   for (int x : container10());
+  for (int x : N::container11());
+  for (int x : N::container12());
+  for (int x : N::container13());
 }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/range-for35.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/range-for35.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/range-for35.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/range-for35.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,8 @@
+// PR c++/86060
+// { dg-options -Wpedantic }
+
+template <typename T> void foo(T (&a)[8]) {
+  for (int i : a)		// { dg-warning "range-based" "" { target c++98_only } }
+    i;
+}
+void fn1() { foo<int>; }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/range-for9.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/range-for9.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/range-for9.C	2014-06-26 11:15:42.916121000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/range-for9.C	2019-06-25 02:27:21.161930989 -0700
@@ -5,6 +5,6 @@
 void test()
 {
     int a[] = {0,1,2};
-    for (int x : a)  // { dg-error "range-based 'for'" }
+    for (int x : a)  // { dg-error "range-based 'for'|forming reference" }
         ;
 }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/ref-qual18.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/ref-qual18.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/ref-qual18.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/ref-qual18.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,18 @@
+// PR c++/71784
+// { dg-do compile { target c++11 } }
+
+template<typename T> struct A {
+  template<typename U> void f(U const&) & { }
+  template<typename U> void f(U const&) && { }
+};
+
+template void A<int>::f<int>(int const&) &;
+template void A<float>::f<int>(int const&) &&;
+
+template<typename T> struct B {
+  void f(int const&) & { }
+  void f(int const&) && { }
+};
+
+template void B<int>::f(int const&) &;
+template void B<float>::f(int const&) &&;
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/sfinae60.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/sfinae60.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/sfinae60.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/sfinae60.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,25 @@
+// PR c++/78489
+// { dg-do compile { target c++11 } }
+
+template <bool P, class T = void> struct enable_if { using type = T; };
+template <class T> struct enable_if<false, T> {};
+
+template <class Dummy> struct use_type { using type = int; };
+
+template <bool Pred>
+struct get_type {
+    static_assert(Pred, "");
+    using type = int;
+};
+
+template <bool Val,
+              class      = typename enable_if<Val>::type, // Evaluation/Substitution should end here
+              class ValT = typename get_type<Val>::type,  // This should not be instantiated
+              typename use_type<ValT>::type = 0           // This NTTP causes ValT to be required
+            >
+constexpr bool test(int) { return false; }
+
+template <bool>
+constexpr bool test(long) { return true; }
+
+static_assert(test<false>(0), ""); // should call test(long)
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/variadic-nested2.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/variadic-nested2.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/variadic-nested2.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/variadic-nested2.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,9 @@
+// PR c++/84839
+// { dg-do compile { target c++11 } }
+
+template<typename... T>
+struct S {
+    using fptr = void(*)(T... x, decltype(x)... y);
+};
+
+using F = S<int>::fptr;
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/variadic-nested3.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/variadic-nested3.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp0x/variadic-nested3.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp0x/variadic-nested3.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,10 @@
+// PR c++/71834
+// { dg-do compile { target c++11 } }
+
+template < typename ... Ts > struct A 
+{
+  template < Ts ..., typename U > struct B {};
+};
+
+// should be, e.g.: A < int >::B < 0, int > e; 
+A < int >::B < 0 > e;	   // { dg-error "wrong number of template arguments" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/constexpr-84192.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/constexpr-84192.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/constexpr-84192.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/constexpr-84192.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,41 @@
+// PR c++/84192
+// { dg-do compile { target c++14 } }
+// { dg-options "" }
+
+bool
+f1 ()
+{ 
+  return ({ return true; }) && false;	// { dg-error "could not convert" }
+}
+
+void
+f2 ()
+{ 
+  for (;;)
+    constexpr bool b = ({ break; false; }) && false;	// { dg-error "statement is not a constant expression" }
+}
+
+constexpr bool
+f3 (int n)
+{
+  bool b = false;
+  for (int i = 0; i < n; i++)
+    b = ({ break; });	// { dg-error "void value not ignored as it ought to be" }
+  return b;
+}
+
+constexpr bool b = f3 (4);
+
+bool
+f4 ()
+{
+  constexpr bool b = ({ return true; }) && false;	// { dg-error "could not convert" }
+  return false;
+}
+
+constexpr bool
+f5 (int x)
+{
+  constexpr bool b = ({ switch (x) case 0: true; }) && false;	// { dg-error "could not convert" }
+  return false;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-nsdmi1.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/lambda-generic-nsdmi1.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-nsdmi1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/lambda-generic-nsdmi1.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,8 @@
+// PR c++/84520
+// { dg-do compile { target c++14 } }
+
+struct A
+{
+  static void foo(int);
+  void (*f)(int) = [](auto i) { foo(i); };
+};
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic16.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic16.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic16.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic16.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,8 @@
+// PR c++/64095
+// { dg-do compile { target c++14 } }
+
+void f()
+{
+  [](auto...){}();
+  [](auto&&...){}();
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic17.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic17.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic17.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic17.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,125 @@
+// PR c++/85118
+// { dg-do compile { target c++14 } }
+
+namespace std
+{
+  template<typename _Tp>
+    struct remove_const
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_const<_Tp const>
+    { typedef _Tp type; };
+
+
+  template<typename _Tp>
+    struct remove_volatile
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_volatile<_Tp volatile>
+    { typedef _Tp type; };
+
+
+  template<typename _Tp>
+    struct remove_cv
+    {
+      typedef typename
+      remove_const<typename remove_volatile<_Tp>::type>::type type;
+    };
+
+  template<typename _Tp>
+    struct remove_reference
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_reference<_Tp&>
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_reference<_Tp&&>
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct decay
+    {
+      using type = typename remove_reference<typename remove_const<_Tp>::type>::type;
+    };
+
+  template<typename _Tp>
+    _Tp&&
+    declval() noexcept;
+
+  template<typename _Tp>
+    constexpr _Tp&&
+    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
+    { return static_cast<_Tp&&>(__t); }
+
+
+  template<typename _Arg>
+    struct _Mu
+    {
+      template<typename _CVArg, typename _Tuple>
+         _CVArg&&
+         operator()(_CVArg&& __arg, _Tuple&) const volatile
+         { return std::forward<_CVArg>(__arg); }
+    };
+
+   template<typename _Functor, typename _Bound_args>
+    struct _Bind
+    {
+      _Functor _M_f;
+      _Bound_args _M_bound_args;
+
+      template<typename _Args, typename _Result
+         = decltype( std::declval<_Functor&>()(
+               _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
+              std::declval<_Args&>() ) ) )>
+         _Result
+      operator()(_Args&& __args) { return {}; }
+
+      template<typename _Args, typename _Result
+         = decltype( std::declval<volatile _Functor&>()(
+               _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
+              std::declval<_Args&>() ) ) )>
+         _Result
+         operator()(_Args&& __args) volatile;
+
+    };
+
+  template<typename _Func, typename _BoundArgs>
+    _Bind<typename decay<_Func>::type, typename decay<_BoundArgs>::type>
+    bind(_Func&& __f, _BoundArgs&& __args)
+    {
+      return {
+        std::forward<_Func>(__f),
+          std::forward<_BoundArgs>(__args)
+      };
+    }
+
+} // namespace std
+
+
+template <typename T>
+bool isOneOf(const T& )
+{
+    return false;
+}
+
+template <typename T, typename FirstType, typename... Tail>
+bool isOneOf(const T& t, const FirstType& firstValue, const Tail&... tail)
+{
+    return t == firstValue || isOneOf(t, tail...);
+}
+
+int main()
+{
+    const auto isOneOfHelper = [](auto&&... params)
+    {
+      return isOneOf(std::forward<decltype(params)>(params)...);
+    };
+
+    auto isO = std::bind(isOneOfHelper, 'o');
+
+    isO('o');
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic19.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic19.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic19.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic19.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,4 @@
+// PR c++/86728
+// { dg-do compile { target c++14 } }
+
+auto c = [](auto x ...) { };
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C	2016-12-12 09:00:37.751966000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C	2019-06-25 02:27:21.161930989 -0700
@@ -85,4 +85,4 @@
 // { dg-final { scan-assembler "_Z3eatIZ3FoovEUlPT_PT0_E4_Z3FoovEUlS1_S3_E5_EvRS0_RS2_:" } }
 // { dg-final { scan-assembler "_Z3eatIPiZ3BarIsEvvEUlPsPfS3_E_EvRT_RT0_:" } }
 // { dg-final { scan-assembler "_Z3eatIPiZ3BarIsEvvEUlPsPT_PT0_E0_EvRS3_RS5_:" } }
-// { dg-final { scan-assembler "_Z3eatIPiZ3BarIsEvvEUlPsPT_zE1_EvRS3_RT0_:" } }
+// { dg-final { scan-assembler "_Z3eatIPiZ3BarIsEvvEUlPsDpPT_E1_EvRT_RT0_:" } }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr10.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr10.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr10.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr10.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,7 @@
+// PR c++/71638
+// { dg-do compile { target c++14 } }
+
+struct {
+  int &&a;
+  int b{a};
+} c[] { { 2 } };
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr11.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr11.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr11.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr11.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,12 @@
+// PR c++/85148
+// { dg-do compile { target c++14 } }
+
+template<typename T> struct A
+{
+  T x[1]{(__PTRDIFF_TYPE__)this};
+};
+
+void foo()
+{
+  A<A<__PTRDIFF_TYPE__>> a{};
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr9.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr9.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr9.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr9.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,14 @@
+// PR c++/84927 - ICE with NSDMI and reference
+// { dg-do compile { target c++14 } }
+
+struct A
+{
+  int& r;
+  int i = r;
+};
+
+void foo()
+{
+  int j;
+  A a = A{j};
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr60393.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr60393.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr60393.C	2014-08-23 09:50:22.136130000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr60393.C	2019-06-25 02:27:21.161930989 -0700
@@ -1,8 +1,7 @@
 // PR c++/60393
 // { dg-do compile { target c++14 } }
-// { dg-options "" }
 
-void (*f)(auto) + 0; // { dg-error "expected" }
+void (*f)(auto) + 0; // { dg-error "auto|expected" }
 
 struct A
 {
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr60626.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr60626.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr60626.C	2014-08-25 05:48:22.249785000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr60626.C	2019-06-25 02:27:21.161930989 -0700
@@ -1,7 +0,0 @@
-// PR c++/60626
-// { dg-do compile { target c++14 } }
-// { dg-options "" }
-
-struct A {};
-
-void (*A::p)(auto) = 0;  // { dg-error "static data member|template" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr83817.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr83817.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr83817.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr83817.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,17 @@
+// PR c++/83817
+// { dg-do compile { target c++14 } }
+
+struct A;
+struct B { template <typename> using C = A; };
+struct D : B { struct F { typedef C<char> E; }; };
+struct G {
+  struct I { I (D, A &); } h;
+  D::F::E &k ();
+  D j;
+  G (G &&) : h (j, k ()) {}
+};
+struct N { G l; };
+typedef N (*M)(N &);
+struct H { const char *o; M s; };
+N foo (N &);
+H r { "", [](auto &x) { return foo (x); }};
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr84496.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr84496.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr84496.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr84496.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,44 @@
+// PR c++/84496
+// { dg-do compile { target c++14 } }
+
+template <typename T, T n> struct C { static constexpr T D = n; };
+struct E : C<bool, false> {};
+template <typename> struct F : C<bool, false> {};
+template <typename T> T foo ();
+template <typename> struct H { typedef int G; };
+template <typename> class I;
+struct L;
+template <typename, typename> struct J;
+template <bool, bool, typename...> struct K;
+struct R {
+  template <typename M, typename... N>
+  static J<decltype (foo<M> () (foo<N>...)), L> o;
+};
+template <typename P, typename... Q> struct K<false, false, P, Q...> : R {
+  typedef decltype (o<P, Q...>) G;
+};
+template <typename P, typename... Q>
+struct D : K<E::D, F<typename H<P>::G>::D, P, Q...> {};
+template <typename P, typename... Q> struct I<P (Q...)> : D<P, Q...> {};
+template <typename> class function;
+template <typename S, typename... Q> struct function<S (Q...)> {
+  template <typename T, typename = typename I<T (Q...)>::G> struct C;
+  template <typename, typename> using U = int;
+  template <typename P, typename = U<int, void>, typename = U<C<P>, void>>
+  function (P);
+};
+template <typename S, typename... Q>
+template <typename P, typename, typename>
+function<S (Q...)>::function (P)
+{
+}
+void bar (function<void (int)>);
+
+void
+baz ()
+{
+  auto a = [] {
+    static int counter;
+    bar ([] (auto) { counter++; });
+  };
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr84558.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr84558.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr84558.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr84558.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,6 @@
+// PR c++/84558
+// { dg-do compile { target c++14 } }
+
+struct A { static int i; constexpr A () { i = 0; } };
+struct B { A a[2][3][4]; };
+B b;
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr84662.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr84662.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr84662.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr84662.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,6 @@
+// PR c++/84662
+// { dg-do compile { target c++14 } }
+// { dg-options "" }
+
+double b;
+a (__attribute__((c (0 && int() - ([] {} && b) || auto))));	// { dg-error "expected constructor, destructor, or type conversion before" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr85076.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr85076.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/pr85076.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/pr85076.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,6 @@
+// PR c++/85076
+// { dg-do compile { target c++14 } }
+
+template<typename> struct A*;	// { dg-error "expected unqualified-id before" }
+
+auto a = [](A<auto>) {};	// { dg-error "is not a template|has incomplete type" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/var-templ58a.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/var-templ58a.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/var-templ58a.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/var-templ58a.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,14 @@
+// PR c++/71569
+// { dg-do compile { target c++14 } }
+
+template <class T>
+struct A {
+  template <class U>
+  static const U u;
+};
+
+template <class T>
+template <class U>
+const U* A<T>::u<U*> = 0;
+
+const int *p = A<char>::u<int*>;
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/var-templ58.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/var-templ58.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/var-templ58.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/var-templ58.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,12 @@
+// PR c++/71569
+// { dg-do compile { target c++14 } }
+
+template <class T>
+struct A {
+  template <class U>
+  static const U u;
+};
+
+template <class T>
+template <class U>
+const U A<T>::u<U> = 0;	// { dg-error "does not specialize" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/var-templ59.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/var-templ59.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1y/var-templ59.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1y/var-templ59.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,14 @@
+// PR c++/71569
+// { dg-do compile { target c++14 } }
+
+template <class T>
+struct A {
+  template <class U>
+  static U u;
+};
+
+int main()
+{
+  decltype(A<int>::u) a;	// { dg-error "missing template arguments" }
+  return a;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/class-deduction49.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/class-deduction49.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/class-deduction49.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/class-deduction49.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,15 @@
+// PR c++/84015
+// { dg-additional-options -std=c++17 }
+
+template <int I>
+struct A { };
+
+template <int I>
+struct B
+{
+  template<template<auto>class T>
+  B(T<I>);
+};
+
+A<42> a;
+B b (a);
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/class-deduction50.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/class-deduction50.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/class-deduction50.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/class-deduction50.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,22 @@
+// PR c++/84355
+// { dg-additional-options -std=c++17 }
+
+template <class, class> struct same;
+template <class T> struct same<T,T> {};
+
+template<typename T> struct A
+{
+  template<class U> struct B
+  {
+    B(U);
+  };
+
+  A() {
+    B b(0);
+    same<decltype(b),B<int>>{};
+  }
+};
+
+struct C {};
+
+A<C> a;
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/class-deduction51.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/class-deduction51.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/class-deduction51.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/class-deduction51.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,11 @@
+// PR c++/84937
+// { dg-additional-options -std=c++17 }
+
+template<int, int> struct A {};
+
+template<int I> struct B
+{
+  template<auto J> B(A<I,J>);
+};
+
+B b(A<0,0>{});
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/class-deduction54.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/class-deduction54.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/class-deduction54.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/class-deduction54.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,15 @@
+// PR c++/82152
+// { dg-additional-options -std=c++17 }
+
+struct Base {};
+
+template<typename T>
+struct Derived : public Base {
+  using Base::Base;
+};
+
+Derived() -> Derived< void >;
+
+int main() {
+  Derived x;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/constexpr-84684.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/constexpr-84684.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/constexpr-84684.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/constexpr-84684.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,163 @@
+// PR c++/84684
+// { dg-options -std=c++17 }
+
+typedef decltype (sizeof (0)) size_t;
+
+namespace std {
+  template<class _E>
+  struct initializer_list
+  {
+    typedef _E value_type;
+    typedef const _E& reference;
+    typedef const _E& const_reference;
+    typedef size_t size_type;
+    typedef const _E* iterator;
+    typedef const _E* const_iterator;
+    iterator _M_array;
+    size_type _M_len;
+    constexpr initializer_list(const_iterator __a, size_type __l) : _M_array(__a), _M_len(__l) { }
+    constexpr initializer_list() noexcept : _M_array(0), _M_len(0) { }
+    constexpr size_type size() const noexcept { return _M_len; }
+    constexpr const_iterator begin() const noexcept { return _M_array; }
+    constexpr const_iterator end() const noexcept { return begin() + size(); }
+  };
+}
+
+template <typename E, size_t N>
+struct array
+{
+  constexpr E &operator[](size_t n) noexcept { return elems[n]; }
+  constexpr const E &operator[](size_t n) const noexcept { return elems[n]; }
+  constexpr size_t size() const { return N; }
+  E elems[N];
+};
+
+template<typename T>
+constexpr
+inline T
+max (std::initializer_list<T> i)
+{
+  const T *b = i.begin ();
+  const T *e = i.end ();
+  if (b == e) return *b;
+  const T *r = b;
+  while (++b != e)
+  if (*r < *b)
+    r = b;
+  return *r;
+}
+
+template <typename alphabet_type>
+constexpr char to_char(alphabet_type const alph)
+{
+  return alph.to_char();
+}
+
+template <typename ...alphabet_types>
+struct union_composition
+{
+  static constexpr size_t value_size = (alphabet_types::value_size + ... );
+  unsigned char _value;
+  template <size_t fixed_size, typename alphabet_t>
+  static constexpr auto value_to_char_helper(alphabet_t alphabet)
+  {
+    array<char, fixed_size> value_to_char{};
+    for (size_t i = 0u; i < alphabet_t::value_size; ++i)
+      value_to_char[i] = to_char(alphabet.assign_rank(i));
+    return value_to_char;
+  }
+
+  static constexpr auto make_value_to_char()
+  {
+    constexpr auto N = sizeof...(alphabet_types);
+    constexpr array<size_t, N> alphabet_sizes { alphabet_types::value_size... };
+    constexpr size_t fixed_size = max({alphabet_types::value_size...});
+    array value_to_char_tables = array<array<char, fixed_size>, N> {
+      value_to_char_helper<fixed_size>(alphabet_types{})...
+    };
+    array<char, value_size> value_to_char{};
+    for (size_t i = 0u, value = 0u; i < N; ++i)
+      for (size_t k = 0u; k < alphabet_sizes[i]; ++k, ++value)
+        value_to_char[value] = value_to_char_tables[i][k];
+    return value_to_char;
+  }
+};
+
+struct gap
+{
+  constexpr char to_char() const noexcept { return '-'; }
+  constexpr gap & assign_rank([[maybe_unused]] bool const i) noexcept { return *this; }
+  static constexpr size_t value_size{1};
+};
+
+struct dna4
+{
+  constexpr char to_char() const noexcept { return value_to_char[_value]; }
+  constexpr dna4 & assign_rank(unsigned char const c) { _value = c; return *this; }
+  static constexpr size_t value_size{4};
+  static constexpr char value_to_char[value_size] { 'A', 'C', 'G', 'T' };
+  unsigned char _value;
+};
+
+struct dna5
+{
+  constexpr char to_char() const noexcept { return value_to_char[_value]; }
+  constexpr dna5 & assign_rank(unsigned char const c) { _value = c; return *this; }
+  static constexpr size_t value_size{5};
+  static constexpr char value_to_char[value_size] { 'A', 'C', 'G', 'T', 'N' };
+  unsigned char _value;
+};
+
+constexpr array value_to_char1 = union_composition<dna4>::make_value_to_char();
+static_assert(value_to_char1.size() == 4u);
+static_assert(value_to_char1[0] == 'A');
+static_assert(value_to_char1[1] == 'C');
+static_assert(value_to_char1[2] == 'G');
+static_assert(value_to_char1[3] == 'T');
+
+constexpr array value_to_char2 = union_composition<dna4, gap>::make_value_to_char();
+static_assert(value_to_char2.size() == 5u);
+static_assert(value_to_char2[0] == 'A');
+static_assert(value_to_char2[1] == 'C');
+static_assert(value_to_char2[2] == 'G');
+static_assert(value_to_char2[3] == 'T');
+static_assert(value_to_char2[4] == '-');
+
+constexpr array value_to_char3 = union_composition<dna4, gap, dna5>::make_value_to_char();
+static_assert(value_to_char3.size() == 10u);
+static_assert(value_to_char3[0] == 'A');
+static_assert(value_to_char3[1] == 'C');
+static_assert(value_to_char3[2] == 'G');
+static_assert(value_to_char3[3] == 'T');
+static_assert(value_to_char3[4] == '-');
+static_assert(value_to_char3[5] == 'A');
+static_assert(value_to_char3[6] == 'C');
+static_assert(value_to_char3[7] == 'G');
+static_assert(value_to_char3[8] == 'T');
+static_assert(value_to_char3[9] == 'N');
+
+constexpr array value_to_char4 = union_composition<dna5, gap, dna4>::make_value_to_char();
+static_assert(value_to_char4.size() == 10u);
+static_assert(value_to_char4[0] == 'A');
+static_assert(value_to_char4[1] == 'C');
+static_assert(value_to_char4[2] == 'G');
+static_assert(value_to_char4[3] == 'T');
+static_assert(value_to_char4[4] == 'N');
+static_assert(value_to_char4[5] == '-');
+static_assert(value_to_char4[6] == 'A');
+static_assert(value_to_char4[7] == 'C');
+static_assert(value_to_char4[8] == 'G');
+static_assert(value_to_char4[9] == 'T');
+
+constexpr array value_to_char5 = union_composition<gap, dna4, dna5>::make_value_to_char();
+static_assert(value_to_char5.size() == 10u);
+static_assert(value_to_char5[0] == '-');
+static_assert(value_to_char5[1] == 'A');
+static_assert(value_to_char5[2] == 'C');
+static_assert(value_to_char5[3] == 'G');
+static_assert(value_to_char5[4] == 'T');
+static_assert(value_to_char5[5] == 'A');
+static_assert(value_to_char5[6] == 'C');
+static_assert(value_to_char5[7] == 'G');
+static_assert(value_to_char5[8] == 'T');
+static_assert(value_to_char5[9] == 'N');
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/constexpr-if13.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/constexpr-if13.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/constexpr-if13.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/constexpr-if13.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,11 @@
+// PR c++/84854
+// { dg-options -std=c++17 }
+
+constexpr int foo () { return 1; }
+constexpr int foo (int) { return 2; }
+
+template <typename>
+void a()
+{
+  if constexpr(foo) { };
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp10.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp10.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp10.C	2017-12-15 16:41:10.275950000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp10.C	2019-06-25 02:27:21.161930989 -0700
@@ -20,7 +20,7 @@
 
 struct A3a { int i,j; int get(); } a3a;
 template<> struct std::tuple_size<A3a> { enum { value = 1 }; };
-void f3a() { auto [ x ] = a3a; }	// { dg-error "get<0>" }
+void f3a() { auto [ x ] = a3a; }	// { dg-error "get" }
 
 struct A3b { int i,j; } a3b;
 int get(A3b&&);
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp35.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp35.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp35.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp35.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,35 @@
+// PR c++/83958
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+template <typename = void> struct A;
+class B;
+template <typename, typename, typename = A<>> class C;
+template <typename, typename> struct D;
+template <typename T, typename U, typename V, typename, typename, typename W>
+struct E {
+  using X = W;
+  X operator* ();
+  T operator++ ();
+  template <typename P, typename R, typename S, typename Q>
+  bool operator!= (E<P, U, V, R, S, Q>);
+};
+template <typename T, typename U, typename>
+struct F {
+  class G;
+  using H = D<T, U>;
+  using I = E<G, T, U, G, H, H &>;
+  class G : public I {};
+  G begin ();
+  G end ();
+};
+template <typename T, typename U, typename V> struct C : F<T, U, V> {
+  using J = F<T, U, V>;
+  using J::begin;
+  using J::end;
+};
+using K = class L;
+struct M {
+  void foo () { for (auto & [ a ] : m) {} }	// { dg-error "incomplete type" }
+  C<K, B> m;					// { dg-warning "only available with" "" { target c++14_down } .-1 }
+};
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp36.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp36.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp36.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp36.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,19 @@
+// PR c++/84031
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+struct A { unsigned char : 1, a1 : 1, a2 : 2, : 1, a3 : 3; };
+struct B { unsigned char : 1, : 7; };
+struct C : B { constexpr C () : c1 (1), c2 (2), c3 (3) {} unsigned char : 1, c1 : 1, c2 : 2, : 1, c3 : 3; };
+struct D : C { constexpr D () {} unsigned char : 1, : 7; };
+
+int
+main ()
+{
+  static constexpr A a { 1, 2, 3 };
+  const auto &[a1, a2, a3] = a;		// { dg-warning "only available with" "" { target c++14_down } }
+  static_assert (a1 == 1 && a2 == 2 && a3 == 3, "");
+  static constexpr D d;
+  const auto &[d1, d2, d3] = d;		// { dg-warning "only available with" "" { target c++14_down } }
+  static_assert (d1 == 1 && d2 == 2 && d3 == 3, "");
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp37.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp37.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp37.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp37.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,62 @@
+// { dg-additional-options -std=c++17 }
+// { dg-do compile }
+
+#include <memory>
+#include <tuple>
+#include <string>
+
+struct X : private std::shared_ptr<int>
+{
+  std::string fun_payload;
+};
+
+template<int N> std::string& get(X& x)
+{
+  if constexpr(N==0) return x.fun_payload;
+}
+
+namespace std {
+  template<> class tuple_size<X> : public std::integral_constant<int, 1> {};
+  template<> class tuple_element<0, X> {public: using type = std::string;};
+}
+
+struct X2 : private std::shared_ptr<int>
+{
+  int fun_payload;
+  template <class T> void get();
+};
+
+template<int N> int& get(X2& x)
+{
+  if constexpr(N==0) return x.fun_payload;
+}
+
+namespace std {
+  template<> class tuple_size<X2> : public std::integral_constant<int, 1> {};
+  template<> class tuple_element<0, X2> {public: using type = int;};
+}
+
+class X3
+{
+  double fun_payload;
+public:
+  template <int N> double& get()
+  {
+    if constexpr(N==0) return fun_payload;
+  }
+};
+
+namespace std {
+  template<> class tuple_size<X3> : public std::integral_constant<int, 1> {};
+  template<> class tuple_element<0, X3> {public: using type = double;};
+}
+
+int main()
+{
+  X x;
+  auto& [b1] = x;
+  X2 x2;
+  auto& [b2] = x2;
+  X3 x3;
+  auto& [b3] = x3;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp38.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp38.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp38.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp38.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,48 @@
+// { dg-additional-options -std=c++17 }
+// { dg-do compile }
+
+class X
+{
+   int a, b;
+   void f()
+   {
+     auto[x,y] = *this;
+   }
+};
+
+class X2
+{
+   int a, b;
+   void f(X2& other)
+   {
+     auto[x,y] = other;
+   }
+};
+
+struct X3
+{
+  friend void foo();
+private:
+  int a;
+};
+
+void foo()
+{
+  X3 x;
+  auto [a] = x;
+}
+
+struct X4
+{
+  int a;
+};
+
+struct X5 : private X4
+{
+  friend void foo2();
+};
+
+void foo2() {
+  X5 x;
+  auto [a] = x;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp41.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp41.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp41.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp41.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,9 @@
+// PR c++/85208
+// { dg-do compile { target c++11 } }
+// { dg-require-weak "" }
+// { dg-options "" }
+
+#pragma weak _ZDC1d1e1fE
+struct A { int i, j, k; };
+auto [a, b, c] = A ();	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+auto [d, e, f] = A ();	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp42.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp42.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp42.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp42.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,18 @@
+// PR c++/85210
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+struct A { int i; };
+
+template <int>
+void
+foo (int j)
+{
+  auto [j] = A{j};	// { dg-error "shadows a parameter" }
+}			// { dg-warning "decomposition declaration only available with" "" { target c++14_down } .-1 }
+
+void
+bar ()
+{
+  foo<0> (0);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp4.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp4.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp4.C	2017-01-11 03:47:30.124041000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp4.C	2019-06-25 02:27:21.161930989 -0700
@@ -18,10 +18,10 @@
 					// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } .-1 }
   auto [ k ] { b };			// { dg-error "cannot decompose class type 'B' because it has an anonymous union member" }
 					// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } .-1 }
-  auto [ l, l2 ] = c;			// { dg-error "cannot decompose non-public member 'C::b' of 'C'" }
+  auto [ l, l2 ] = c;			// { dg-error "cannot decompose inaccessible member 'C::b' of 'C'" }
 					// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } .-1 }
   auto [ m ] = d;			// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } }
-  auto [ n ] { e };			// { dg-error "cannot decompose non-public member 'E::a' of 'E'" }
+  auto [ n ] { e };			// { dg-error "cannot decompose inaccessible member 'E::a' of 'E'" }
 					// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } .-1 }
   auto [ o ] { f };			// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } }
   auto & [ p ] { g };			// { dg-error "cannot decompose class type 'G': both it and its base class 'F' have non-static data members" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp-lambda1.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp-lambda1.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/decomp-lambda1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/decomp-lambda1.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,10 @@
+// PR c++/84420
+// { dg-additional-options -std=c++17 }
+
+int main(){
+    int a[1]{};
+    [&a]{
+        auto [v] = a;
+        (void)v;
+    }();
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/desig7.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/desig7.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/desig7.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/desig7.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,18 @@
+// PR c++/84874
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+struct A { int a, b; };
+struct B { A d; };
+
+void
+foo (B *x)
+{
+  *x = { .d = { .b = 5 } };	// { dg-message "non-trivial designated initializers not supported" }
+}
+
+void
+bar (A *x)
+{
+  *x = { .b = 6 };		// { dg-message "non-trivial designated initializers not supported" }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/desig8.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/desig8.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/desig8.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/desig8.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,18 @@
+// PR c++/84874
+// { dg-do compile { target c++1z } }
+// { dg-options "" }
+
+struct A { int a; struct { int b; }; };
+struct B { A d; };
+
+void
+foo (B *x)
+{
+  *x = { .d = { .b = 5 } };	// { dg-message "non-trivial designated initializers not supported" }
+}
+
+void
+bar (A *x)
+{
+  *x = { .b = 6 };		// { dg-message "non-trivial designated initializers not supported" }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C	2017-01-20 09:53:44.365080000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C	2019-06-25 02:27:21.161930989 -0700
@@ -1,17 +1,19 @@
 // { dg-do run { target c++11 } }
 // PR78495 failed to propagate pass-by-value struct to base ctor.
 
+static int moves = 0;
+
 struct Ptr {
   void *ptr = 0;
 
   Ptr() {}
   Ptr(Ptr const&) = delete;
-  Ptr(Ptr&& other) : ptr (other.ptr) {}
+  Ptr(Ptr&& other) : ptr (other.ptr) {moves++;}
 };
 
 struct Base {
   Ptr val;
-  Base(Ptr val_) : val(static_cast<Ptr&&>(val_)) {}
+  Base(Ptr val_);
 };
 
 struct Derived: Base {
@@ -27,5 +29,13 @@
 }
 
 int main () {
-  return Foo () != 0;
+  if (Foo ())
+    return 1;
+
+  if (moves != 2)
+    return 2;
+
+  return 0;
 }
+
+Base::Base(Ptr val_) : val(static_cast<Ptr&&>(val_)) {}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/launder7.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/launder7.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/launder7.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/launder7.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,10 @@
+// PR c++/84445
+// { dg-do compile }
+
+struct A { virtual void foo (); };
+
+void
+bar (A *p)
+{
+  __builtin_launder (p)->foo ();
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/launder8.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/launder8.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/launder8.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/launder8.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,11 @@
+// PR c++/84444
+// { dg-do compile }
+// { dg-options "-O2" }
+
+struct A {};
+
+__UINTPTR_TYPE__
+foo (A *p)
+{
+  return (__UINTPTR_TYPE__) __builtin_launder (p);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.C	2019-06-25 02:27:21.161930989 -0700
@@ -0,0 +1,12 @@
+// { dg-do compile { target c++11 } }
+
+#include "noexcept-type19.h"
+
+extern "C" void *malloc (size_t);
+
+template<class T> void f(T*);
+
+int main()
+{
+  f<decltype(malloc)>(operator new);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.h gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.h
--- gcc-7.3.0/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.h	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.h	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,4 @@
+#pragma GCC system_header
+
+typedef decltype(sizeof(0)) size_t;
+extern "C" void *malloc (size_t) throw();
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/diagnostic/pr85464.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/diagnostic/pr85464.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/diagnostic/pr85464.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/diagnostic/pr85464.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,5 @@
+// { dg-options "-Wignored-qualifiers" }
+struct Test {
+   operator int const(); // { dg-warning "type qualifiers ignored" }
+   operator int const() const; // { dg-warning "type qualifiers ignored" }
+};
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/asm14.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/asm14.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/asm14.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/asm14.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,10 @@
+// PR c++/85659
+// { dg-do compile }
+
+struct S { S (); ~S (); int s; };
+
+void
+foo (S &s)
+{
+  __asm volatile ("" : "+m,r" (s) : : "memory");
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/asm15.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/asm15.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/asm15.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/asm15.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,10 @@
+// PR c++/85659
+// { dg-do compile }
+
+struct S { S (); ~S (); int s; };
+
+void
+foo (S &s)
+{
+  __asm volatile ("" : "+r" (s) : : "memory");	// { dg-error "" }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/asm16.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/asm16.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/asm16.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/asm16.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,10 @@
+// PR c++/85659
+// { dg-do compile }
+
+struct S { S (); ~S (); int s[64]; } s;
+
+void
+foo ()
+{
+  __asm volatile ("" : "=r" (s) : : "memory");	// { dg-error "" }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/atomic-4.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/atomic-4.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/atomic-4.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/atomic-4.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,9 @@
+// PR inline-asm/85172
+// { dg-do compile }
+// { dg-options "" }
+
+int
+foo (int *p)
+{
+  return !__atomic_always_lock_free (4, ({ __asm (""); p; }));
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/attr-noinline-4.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/attr-noinline-4.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/attr-noinline-4.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/attr-noinline-4.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,10 @@
+// PR c++/84665
+
+struct S {} a[1];
+
+template <int N>
+void
+foo ()
+{
+  __attribute__ ((noinline (a[0]))) int c = 0; // { dg-error "wrong number of arguments" }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/builtin12.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/builtin12.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/builtin12.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/builtin12.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,10 @@
+// PR c++/85113
+// { dg-do compile { target c++14 } }
+
+template<bool> struct A {};
+
+constexpr int foo()
+{
+  A<__builtin_constant_p(0)> a{};
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/builtin13.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/builtin13.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/builtin13.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/builtin13.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,9 @@
+// PR inline-asm/85172
+// { dg-do compile }
+// { dg-options "" }
+
+int
+foo ()
+{
+  return !__builtin_constant_p (({ __asm (""); 0; }));
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/is_trivially_constructible6.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/is_trivially_constructible6.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/is_trivially_constructible6.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/is_trivially_constructible6.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,10 @@
+// PR c++/81589
+
+template <typename k>
+struct z {
+  z() {
+    k::error;
+  }
+};
+
+int x = __is_trivially_constructible(z<int>);
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/offsetof2.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/offsetof2.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/offsetof2.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/offsetof2.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,6 @@
+// PR c++/85662
+// { dg-do compile { target c++11 } }
+
+struct S { unsigned long x[31]; };
+struct T { bool b; S f; };
+static_assert (__builtin_offsetof (T, f.x[31 - 1]) == __builtin_offsetof (T, f.x[30]), "");
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/offsetof3.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/offsetof3.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/offsetof3.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/offsetof3.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,5 @@
+// PR c++/85662
+// { dg-do compile { target c++11 } }
+// { dg-options "-O2" }
+
+#include "offsetof2.C"
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/stmtexpr22.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/stmtexpr22.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/stmtexpr22.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/stmtexpr22.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,13 @@
+// PR c++/81853
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+namespace N {
+  enum { i };
+}
+
+int g ()
+{
+  constexpr int j = ({ using namespace N; i; });
+  return j;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/visibility/lambda1.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/visibility/lambda1.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/visibility/lambda1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/visibility/lambda1.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,14 @@
+// PR c++/85646
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -fvisibility=hidden }
+
+template<typename T>
+void foo() {
+    struct inner {
+        inner() {
+            (void)([this] { });
+        }
+    };
+}
+
+int main() { foo<int>(); }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ext/vla18.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/vla18.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ext/vla18.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ext/vla18.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,19 @@
+// PR c++/84767
+// { dg-do compile }
+// { dg-options "" }
+
+int v[1][10];
+
+struct A
+{
+  A (int);
+};
+
+A::A (int i)
+{
+  typedef int T[1][i];
+  T *x = (T *) v;
+  (*x)[0][0] = 0;
+}
+
+A a = 10;
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/gomp/pr84430.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/gomp/pr84430.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/gomp/pr84430.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/gomp/pr84430.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,12 @@
+// PR c++/84430
+// { dg-do compile { target c++11 } }
+
+void
+foo ()
+{
+  auto a = [] {
+    #pragma omp simd
+    for (int i = 0; i < 10; ++i)
+      ;
+  };
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/gomp/pr84448.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/gomp/pr84448.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/gomp/pr84448.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/gomp/pr84448.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,17 @@
+// PR c++/84448
+// { dg-do compile }
+
+struct A
+{
+  operator int () const;
+  A& operator += (int);
+  A& operator ++ ();
+};
+
+void
+foo (A a, A b)
+{
+  #pragma omp for
+  for (A i = a; i <=; ++i)	// { dg-error "expected primary-expression before" }
+    ;				// { dg-error "invalid controlling predicate" "" { target *-*-* } .-1 }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/gomp/pr84556.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/gomp/pr84556.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/gomp/pr84556.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/gomp/pr84556.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,14 @@
+// PR c++/84556
+// { dg-do compile }
+// { dg-options "-std=c++17 -fopenmp-simd" }
+
+void
+foo ()
+{
+  auto x = [] ()
+  {
+    #pragma omp simd
+    for (int i = 0; i < 8; ++i)
+      ;
+  };
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/gomp/pr84557.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/gomp/pr84557.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/gomp/pr84557.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/gomp/pr84557.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,14 @@
+// PR c++/84557
+// { dg-do compile }
+
+template<int> struct A {};
+template<int> struct B {};
+
+void
+foo ()
+{
+  #pragma omp parallel firstprivate (A)		// { dg-error "is not a variable in clause" }
+  ;
+  #pragma omp parallel firstprivate (B<0>)	// { dg-error "is not a variable in clause" }
+  ;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/gomp/pr84791.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/gomp/pr84791.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/gomp/pr84791.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/gomp/pr84791.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,15 @@
+// PR c++/84791
+// { dg-do compile }
+
+typedef int I;
+
+template <int>
+void
+foo ()
+{
+  I i;
+  #pragma omp parallel reduction (I::I: i)	// { dg-error "'I' is not a class, namespace, or enumeration" "" { target c++11 } }
+    ;						// { dg-error "'I' is not a class or namespace" "" { target c++98_only } .-1 }
+}
+
+template void foo<0> ();
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/inherit/covariant22.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/inherit/covariant22.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/inherit/covariant22.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/inherit/covariant22.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,19 @@
+// PR c++/85068
+// { dg-do compile }
+
+struct A;
+
+struct B
+{
+  virtual A *foo ();	// { dg-error "overriding" }
+};
+
+struct C : virtual B
+{
+  virtual C *foo ();	// { dg-error "invalid covariant return type for" }
+};
+
+struct D : C
+{
+  virtual C *foo ();
+};
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/init/new44.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/init/new44.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/init/new44.C	2015-11-11 06:47:03.392251000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/init/new44.C	2019-06-25 02:27:21.165930961 -0700
@@ -87,10 +87,10 @@
 static void __attribute__ ((used))
 test_two_dim_char_array ()
 {
-    p = new char [1][MAX];              // { dg-error "size of unnamed array" }
-    p = new char [1][MAX - 1];          // { dg-error "size of unnamed array" }
-    p = new char [1][MAX - 2];          // { dg-error "size of unnamed array" }
-    p = new char [1][MAX - 99];         // { dg-error "size of unnamed array" }
+    p = new char [1][MAX];              // { dg-error "size of (unnamed )?array" }
+    p = new char [1][MAX - 1];          // { dg-error "size of (unnamed )?array" }
+    p = new char [1][MAX - 2];          // { dg-error "size of (unnamed )?array" }
+    p = new char [1][MAX - 99];         // { dg-error "size of (unnamed )?array" }
     p = new char [1][MAX / 2];          // { dg-error "size of array" }
     p = new char [1][MAX / 2 - 1];      // { dg-error "size of array" }
     p = new char [1][MAX / 2 - 2];      // { dg-error "size of array" }
@@ -104,18 +104,18 @@
     p = new char [1][MAX / 2 - 7];      // okay
     p = new char [1][MAX / 2 - 8];      // okay
 
-    p = new char [2][MAX];              // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 1];          // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 2];          // { dg-error "size of unnamed array" }
+    p = new char [2][MAX];              // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 1];          // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 2];          // { dg-error "size of (unnamed )?array" }
     p = new char [2][MAX / 2];          // { dg-error "size of array" }
     p = new char [2][MAX / 2 - 1];      // { dg-error "size of array" }
     p = new char [2][MAX / 2 - 2];      // { dg-error "size of array" }
     p = new char [2][MAX / 2 - 7];      // { dg-error "size of array" }
     p = new char [2][MAX / 2 - 8];      // { dg-error "size of array" }
 
-    p = new char [MAX][MAX];            // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX - 1];        // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX - 2];        // { dg-error "size of unnamed array" }
+    p = new char [MAX][MAX];            // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX - 1];        // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX - 2];        // { dg-error "size of (unnamed )?array" }
     p = new char [MAX][MAX / 2];        // { dg-error "size of array" }
     p = new char [MAX][MAX / 2 - 1];    // { dg-error "size of array" }
     p = new char [MAX][MAX / 2 - 2];    // { dg-error "size of array" }
@@ -142,10 +142,10 @@
 static __attribute__ ((used)) void
 test_three_dim_char_array ()
 {
-    p = new char [1][1][MAX];           // { dg-error "size of unnamed array" }
-    p = new char [1][1][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new char [1][1][MAX - 2];       // { dg-error "size of unnamed array" }
-    p = new char [1][1][MAX - 99];      // { dg-error "size of unnamed array" }
+    p = new char [1][1][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new char [1][1][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][1][MAX - 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][1][MAX - 99];      // { dg-error "size of (unnamed )?array" }
     p = new char [1][1][MAX / 2];       // { dg-error "size of array" }
     p = new char [1][1][MAX / 2 - 1];   // { dg-error "size of array" }
     p = new char [1][1][MAX / 2 - 2];   // { dg-error "size of array" }
@@ -159,19 +159,19 @@
     p = new char [1][1][MAX / 2 - 7];   // okay
     p = new char [1][1][MAX / 2 - 8];   // okay
 
-    p = new char [1][2][MAX];           // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX - 2];       // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX - 99];      // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2];       // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 1];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 2];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 3];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 4];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 5];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 6];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 7];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 8];   // { dg-error "size of unnamed array" }
+    p = new char [1][2][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX - 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX - 99];      // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 1];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 3];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 4];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 5];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 6];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 7];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 8];   // { dg-error "size of (unnamed )?array" }
     p = new char [1][2][MAX / 4];       // { dg-error "size of array" }
 
     // Avoid exercising data model-dependent expressions.
@@ -181,10 +181,10 @@
     p = new char [1][2][MAX / 4 - 3];   // okay
     p = new char [1][2][MAX / 4 - 4];   // okay
 
-    p = new char [2][1][MAX];           // { dg-error "size of unnamed array" }
-    p = new char [2][1][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new char [2][1][MAX - 2];       // { dg-error "size of unnamed array" }
-    p = new char [2][1][MAX - 99];      // { dg-error "size of unnamed array" }
+    p = new char [2][1][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new char [2][1][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][1][MAX - 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][1][MAX - 99];      // { dg-error "size of (unnamed )?array" }
     p = new char [2][1][MAX / 2];       // { dg-error "size of array" }
     p = new char [2][1][MAX / 2 - 1];   // { dg-error "size of array" }
     p = new char [2][1][MAX / 2 - 2];   // { dg-error "size of array" }
@@ -203,19 +203,19 @@
     p = new char [2][1][MAX / 4 - 3];   // okay
     p = new char [2][1][MAX / 4 - 4];   // okay
 
-    p = new char [2][2][MAX];           // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX - 2];       // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX - 99];      // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2];       // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 1];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 2];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 3];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 4];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 5];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 6];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 7];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 8];   // { dg-error "size of unnamed array" }
+    p = new char [2][2][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX - 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX - 99];      // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 1];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 3];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 4];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 5];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 6];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 7];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 8];   // { dg-error "size of (unnamed )?array" }
     p = new char [2][2][MAX / 4];       // { dg-error "size of array" }
     p = new char [2][2][MAX / 4 - 1];   // { dg-error "size of array" }
     p = new char [2][2][MAX / 4 - 2];   // { dg-error "size of array" }
@@ -227,19 +227,19 @@
     p = new char [2][2][MAX / 8 - 2];
     p = new char [2][2][MAX / 8 - 3];
 
-    p = new char [2][MAX][2];           // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 1][2];       // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 2][2];       // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 99][2];      // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2][2];       // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 1][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 2][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 3][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 4][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 5][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 6][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 7][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 8][2];   // { dg-error "size of unnamed array" }
+    p = new char [2][MAX][2];           // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 1][2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 2][2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 99][2];      // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2][2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 1][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 2][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 3][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 4][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 5][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 6][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 7][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 8][2];   // { dg-error "size of (unnamed )?array" }
     p = new char [2][MAX / 4][2];       // { dg-error "size of array" }
     p = new char [2][MAX / 4 - 1][2];   // { dg-error "size of array" }
     p = new char [2][MAX / 4 - 2][2];   // { dg-error "size of array" }
@@ -275,11 +275,11 @@
     p = new char [MAX / 8 - 2][2][2];
     p = new char [MAX / 8 - 3][2][2];
 
-    p = new char [MAX][MAX][MAX];         // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX][MAX / 2];     // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX / 2][MAX];     // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX / 2][MAX / 2]; // { dg-error "size of unnamed array" }
-    p = new char [MAX / 2][MAX / 2][MAX / 2]; // { dg-error "size of unnamed array" }
+    p = new char [MAX][MAX][MAX];         // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX][MAX / 2];     // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX / 2][MAX];     // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX / 2][MAX / 2]; // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX / 2][MAX / 2][MAX / 2]; // { dg-error "size of (unnamed )?array" }
 }
 
 // Exercise new expression with N-dimensional arrays where N is
@@ -342,10 +342,10 @@
 static void __attribute__ ((used))
 test_placement_two_dim_byte_struct_array (void *p)
 {
-    p = new (p) B [1][MAX];             // { dg-error "size of unnamed array" }
-    p = new (p) B [1][MAX - 1];         // { dg-error "size of unnamed array" }
-    p = new (p) B [1][MAX - 2];         // { dg-error "size of unnamed array" }
-    p = new (p) B [1][MAX - 99];        // { dg-error "size of unnamed array" }
+    p = new (p) B [1][MAX];             // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][MAX - 1];         // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][MAX - 2];         // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][MAX - 99];        // { dg-error "size of (unnamed )?array" }
     p = new (p) B [1][MAX / 2];         // { dg-error "size of array" }
     p = new (p) B [1][MAX / 2 - 1];     // { dg-error "size of array" }
     p = new (p) B [1][MAX / 2 - 2];     // { dg-error "size of array" }
@@ -359,18 +359,18 @@
     p = new (p) B [1][MAX / 2 - 7];      // okay
     p = new (p) B [1][MAX / 2 - 8];      // okay
 
-    p = new (p) B [2][MAX];             // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 1];         // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 2];         // { dg-error "size of unnamed array" }
+    p = new (p) B [2][MAX];             // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 1];         // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 2];         // { dg-error "size of (unnamed )?array" }
     p = new (p) B [2][MAX / 2];         // { dg-error "size of array" }
     p = new (p) B [2][MAX / 2 - 1];     // { dg-error "size of array" }
     p = new (p) B [2][MAX / 2 - 2];     // { dg-error "size of array" }
     p = new (p) B [2][MAX / 2 - 7];     // { dg-error "size of array" }
     p = new (p) B [2][MAX / 2 - 8];     // { dg-error "size of array" }
 
-    p = new (p) B [MAX][MAX];           // { dg-error "size of unnamed array" }
-    p = new (p) B [MAX][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new (p) B [MAX][MAX - 2];       // { dg-error "size of unnamed array" }
+    p = new (p) B [MAX][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [MAX][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [MAX][MAX - 2];       // { dg-error "size of (unnamed )?array" }
     p = new (p) B [MAX][MAX / 2];       // { dg-error "size of array" }
     p = new (p) B [MAX][MAX / 2 - 1];   // { dg-error "size of array" }
     p = new (p) B [MAX][MAX / 2 - 2];   // { dg-error "size of array" }
@@ -397,10 +397,10 @@
 static __attribute__ ((used)) void
 test_placement_three_dim_byte_struct_array (void *p)
 {
-    p = new (p) B [1][1][MAX];          // { dg-error "size of unnamed array" }
-    p = new (p) B [1][1][MAX - 1];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][1][MAX - 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][1][MAX - 99];     // { dg-error "size of unnamed array" }
+    p = new (p) B [1][1][MAX];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][1][MAX - 1];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][1][MAX - 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][1][MAX - 99];     // { dg-error "size of (unnamed )?array" }
     p = new (p) B [1][1][MAX / 2];      // { dg-error "size of array" }
     p = new (p) B [1][1][MAX / 2 - 1];  // { dg-error "size of array" }
     p = new (p) B [1][1][MAX / 2 - 2];  // { dg-error "size of array" }
@@ -414,19 +414,19 @@
     p = new (p) B [1][1][MAX / 2 - 7];   // okay
     p = new (p) B [1][1][MAX / 2 - 8];   // okay
 
-    p = new (p) B [1][2][MAX];          // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX - 1];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX - 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX - 99];     // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 1];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 3];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 4];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 5];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 6];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 7];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 8];  // { dg-error "size of unnamed array" }
+    p = new (p) B [1][2][MAX];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX - 1];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX - 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX - 99];     // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 1];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 3];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 4];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 5];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 6];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 7];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 8];  // { dg-error "size of (unnamed )?array" }
     p = new (p) B [1][2][MAX / 4];      // { dg-error "size of array" }
 
     // Avoid exercising data model-dependent expressions.
@@ -436,10 +436,10 @@
     p = new (p) B [1][2][MAX / 4 - 3];   // okay
     p = new (p) B [1][2][MAX / 4 - 4];   // okay
 
-    p = new (p) B [2][1][MAX];          // { dg-error "size of unnamed array" }
-    p = new (p) B [2][1][MAX - 1];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][1][MAX - 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][1][MAX - 99];     // { dg-error "size of unnamed array" }
+    p = new (p) B [2][1][MAX];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][1][MAX - 1];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][1][MAX - 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][1][MAX - 99];     // { dg-error "size of (unnamed )?array" }
     p = new (p) B [2][1][MAX / 2];      // { dg-error "size of array" }
     p = new (p) B [2][1][MAX / 2 - 1];  // { dg-error "size of array" }
     p = new (p) B [2][1][MAX / 2 - 2];  // { dg-error "size of array" }
@@ -458,19 +458,19 @@
     p = new (p) B [2][1][MAX / 4 - 3];   // okay
     p = new (p) B [2][1][MAX / 4 - 4];   // okay
 
-    p = new (p) B [2][2][MAX];          // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX - 1];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX - 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX - 99];     // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 1];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 3];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 4];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 5];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 6];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 7];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 8];  // { dg-error "size of unnamed array" }
+    p = new (p) B [2][2][MAX];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX - 1];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX - 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX - 99];     // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 1];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 3];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 4];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 5];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 6];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 7];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 8];  // { dg-error "size of (unnamed )?array" }
     p = new (p) B [2][2][MAX / 4];      // { dg-error "size of array" }
     p = new (p) B [2][2][MAX / 4 - 1];  // { dg-error "size of array" }
     p = new (p) B [2][2][MAX / 4 - 2];  // { dg-error "size of array" }
@@ -482,19 +482,19 @@
     p = new (p) B [2][2][MAX / 8 - 2];
     p = new (p) B [2][2][MAX / 8 - 3];
 
-    p = new (p) B [2][MAX][2];          // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 1][2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 2][2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 99][2];     // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2][2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 1][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 2][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 3][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 4][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 5][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 6][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 7][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 8][2];  // { dg-error "size of unnamed array" }
+    p = new (p) B [2][MAX][2];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 1][2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 2][2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 99][2];     // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2][2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 1][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 2][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 3][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 4][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 5][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 6][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 7][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 8][2];  // { dg-error "size of (unnamed )?array" }
     p = new (p) B [2][MAX / 4][2];      // { dg-error "size of array" }
     p = new (p) B [2][MAX / 4 - 1][2];  // { dg-error "size of array" }
     p = new (p) B [2][MAX / 4 - 2][2];  // { dg-error "size of array" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/init/pr83993-2.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/init/pr83993-2.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/init/pr83993-2.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/init/pr83993-2.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,14 @@
+// PR c++/83993
+// { dg-do compile }
+// { dg-options "-w" }
+
+int a[5];
+extern int b[];
+int *const c = &a[6];
+int *const d = &b[1];
+
+int
+foo ()
+{
+  return c[-4] + d[-1];
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/init/struct2.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/init/struct2.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/init/struct2.C	2008-10-01 00:38:53.251049000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/init/struct2.C	2019-06-25 02:27:21.165930961 -0700
@@ -15,7 +15,7 @@
     };    
 
     SaveLoadEntry trackEntries = {
-	((long) (__SIZE_TYPE__) (&((Track *) 42)->soundName[0])) - 42,
+	((int) (__SIZE_TYPE__) (&((Track *) 42)->soundName[0])) - 42,
         0, 1
     };
     saveLoadEntries(&trackEntries);
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ipa/pr84658.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ipa/pr84658.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ipa/pr84658.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ipa/pr84658.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,30 @@
+/* PR ipa/84658 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fmerge-all-constants -std=c++11" } */
+
+const int kTestCasesFoo[] = { 0, 1, 2, 3, 4, 5, 8, 15, 16, 17, 512, 1020, 1021, 1022, 1023, 1024 };
+const int kTestCasesBar[] = { 0, 1, 2, 3, 4, 5, 8, 15, 16, 17, 512, 1020, 1021, 1022, 1023, 1024 };
+
+void Foo() {
+    __builtin_printf("foo:");
+    for (int count : kTestCasesFoo) {
+        __builtin_printf("%d,", count);
+    }
+    __builtin_printf(";\n");
+}
+
+void Bar() {
+    __builtin_printf("bar:");
+    for (int count : kTestCasesBar) {
+        __builtin_printf("%d,", count);
+    }
+    __builtin_printf(";\n");
+}
+
+int main() {
+    Foo();
+    Bar();
+}
+
+/* { dg-output "foo:0,1,2,3,4,5,8,15,16,17,512,1020,1021,1022,1023,1024,;(\n|\n\r|\r)*" } */
+/* { dg-output "bar:0,1,2,3,4,5,8,15,16,17,512,1020,1021,1022,1023,1024,;(\n|\n\r|\r)*" } */
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/lto/20080908-1_0.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/lto/20080908-1_0.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/lto/20080908-1_0.C	2016-11-04 08:30:52.211762000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/lto/20080908-1_0.C	2019-06-25 02:27:21.165930961 -0700
@@ -30,7 +30,10 @@
 
 int main ()
 {
-  if (Foo () != 0.0)
-    return 1;
+  if (sizeof (int) == sizeof (float))
+    {
+      if (Foo () != 0.0)
+	return 1;
+    }
   return 0;
 }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/opt/pr47280.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/opt/pr47280.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/opt/pr47280.C	2011-01-14 05:20:22.352779000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/opt/pr47280.C	2019-06-25 02:27:21.165930961 -0700
@@ -1,5 +1,6 @@
 // { dg-do compile }
 // { dg-options "-O -fnon-call-exceptions -ftrapv" }
+// { dg-require-effective-target trapping }
 
 void bar (int n, char *p)
 {
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/opt/pr47632.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/opt/pr47632.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/opt/pr47632.C	2011-02-08 02:44:06.315291000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/opt/pr47632.C	2019-06-25 02:27:21.165930961 -0700
@@ -1,5 +1,6 @@
 // { dg-do compile }
 // { dg-options "-O -fnon-call-exceptions -ftrapv" }
+// { dg-require-effective-target trapping }
 
 template < typename > struct S
 {
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/opt/pr79085.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/opt/pr79085.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/opt/pr79085.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/opt/pr79085.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,24 @@
+// PR c++/79085
+// { dg-do compile }
+// { dg-options "-Os" }
+// { dg-additional-options "-mstrict-align" { target { aarch64*-*-* powerpc*-*-linux* powerpc*-*-elf* } } }
+
+void *operator new (__SIZE_TYPE__, void *p) { return p; }
+
+struct S
+{
+  S ();
+  S (const S &);
+  ~S (void);
+  int i;
+};
+
+S foo ();
+
+static char buf [sizeof (S) + 1];
+
+S *
+bar ()
+{
+  return new (buf + 1) S (foo ());
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/opt/pr85196.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/opt/pr85196.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/opt/pr85196.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/opt/pr85196.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,89 @@
+// PR target/85196
+// Testcase by Rainer Orth <ro@gcc.gnu.org>
+
+// { dg-do compile }
+// { dg-options "-O -fpermissive -w" }
+// { dg-additional-options "-fPIC" { target fpic } }
+
+class a;
+template <typename> class b;
+template <typename k> class d : public b<k> {};
+class e {};
+void f(int);
+template <class> class g {
+public:
+  h();
+  a i();
+};
+template <> class b<e> : public g<e> {};
+typedef (*j)(d<e>);
+template <class k> class l {
+public:
+  k operator->() { return 0; }
+};
+enum m { n, aa, o, ab, q, p };
+inline s(m ac) {
+  switch (ac) {
+  case n:
+  case aa:
+  case p:
+    return 1;
+  case o:
+  case ab:
+    return 2;
+  }
+}
+class D {
+  int ad;
+
+public:
+  *ae() { return &ad; }
+};
+class a {
+  l<D *> af;
+
+public:
+  *r() { return af->ae(); }
+  t(int *c) {
+    int *w = af->ae();
+    return w == c;
+  }
+};
+class F : a {
+public:
+  static int ah[];
+  static e v(F *);
+  unsigned long ai() const;
+};
+inline unsigned long F::ai() const {
+  m aj = r() - &ah[0];
+  return s(aj);
+}
+inline e F::v(F *ak) {
+  long al = ak->ai();
+  f(al);
+}
+template <typename> am() { return q; }
+class an : F {
+public:
+  static ao(d<e> u) {
+    int *ap;
+    m aq = am<unsigned>();
+    ap = &ah[aq];
+    return u.h() && u.i().t(ap);
+  }
+  template <e ar(F *)> static as() {
+    F at;
+    ar(&at);
+  }
+  template <e ar(F *)> static au(int *, unsigned, e *) {
+    j av = ao;
+    d<e> aw;
+    if (av(aw))
+      as<ar>();
+  }
+};
+int *ax;
+int ay;
+e az;
+ba() { an::au<an::v>(ax, ay, &az); }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/other/anon5.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/other/anon5.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/other/anon5.C	2016-02-01 14:20:47.138436000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/other/anon5.C	2019-06-25 02:27:21.165930961 -0700
@@ -4,7 +4,7 @@
 // Ignore additional message on powerpc-ibm-aix
 // { dg-prune-output "obtain more information" } */
 // Ignore additional messages on Linux/x86 with PIE
-// { dg-prune-output "Bad value" } */
+// { dg-prune-output "\[Bb\]ad value" } */
 
 namespace {
   struct c
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/other/pr50212.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/other/pr50212.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/other/pr50212.C	2011-09-12 10:55:36.146568000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/other/pr50212.C	2019-06-25 02:27:21.165930961 -0700
@@ -1,6 +1,7 @@
 // PR rtl-optimization/50212
 // { dg-do compile }
 // { dg-require-effective-target freorder }
+// { dg-require-effective-target trapping }
 // { dg-options "-O -fnon-call-exceptions -ftrapv -freorder-blocks-and-partition" }
 
 void
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/parse/array-size2.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/parse/array-size2.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/parse/array-size2.C	2015-11-13 16:08:05.435688000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/parse/array-size2.C	2019-06-25 02:27:21.165930961 -0700
@@ -15,6 +15,6 @@
 foo (void)
 {
   char g[(char *) &((struct S *) 0)->b - (char *) 0]; // { dg-error "constant" }
-  char h[(__SIZE_TYPE__) &((struct S *) 8)->b];	      // { dg-error "constant" "" { xfail *-*-* } }
+  char h[(__SIZE_TYPE__) &((struct S *) 8)->b];	      // { dg-error "constant" }
   bar (g, h);
 }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/parse/crash67.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/parse/crash67.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/parse/crash67.C	2017-02-27 03:55:19.806956000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/parse/crash67.C	2019-06-25 02:27:21.165930961 -0700
@@ -2,4 +2,4 @@
 
 class x0;
 template <x1> x2() {  // { dg-error "declared|type" }
-x0 x3 = x3.  // { dg-error "expected" }
+x0 x3 = x3.  // { dg-error "expected|incomplete type" }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/pr84279.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/pr84279.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/pr84279.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/pr84279.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,35 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-O3 -mcpu=power8 -g -fPIC -fvisibility=hidden -fstack-protector-strong" } */
+
+template <typename, typename T> struct E { T e; };
+struct J {
+  unsigned k, l;
+  J (unsigned x, unsigned y) : k(x), l(y) {}
+};
+typedef struct A {
+  J n, p;
+  A ();
+  A (J x, J y) : n(x), p(y) {}
+} *S;
+S t;
+struct B {
+  struct C {
+    S q, r;
+    int u, v;
+    bool m1 (S, A &);
+    J m2 () const;
+    J m3 () const;
+    A m4 () const;
+  };
+  typedef E<unsigned, S> D;
+  void m5 (D *);
+  void m6 (unsigned, A);
+};
+bool B::C::m1 (S, A &x) { bool o; x = m4 (); return o; }
+J B::C::m2 () const { unsigned g (u == 0); unsigned h (v); return J (g, h); }
+J B::C::m3 () const { unsigned g (q != t); unsigned h (r != t); return J (g, h); }
+A B::C::m4 () const { return A (m2 (), m3 ()); }
+void B::m5 (D *c) { unsigned x; C ar; A am; if (ar.m1 (c->e, am)) m6 (x, am); }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/pr85026.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/pr85026.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/pr85026.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/pr85026.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,61 @@
+/* PR target/85026.  */
+/* { dg-do assemble } */
+/* { dg-options "-O2 -std=gnu++11" } */
+
+template <class> class a;
+class b;
+struct c {
+  typedef a<b> &g;
+};
+template <typename d> struct e { typedef typename d::f iter; };
+class h {
+public:
+  void __attribute__((noreturn)) i();
+} ab;
+template <class> class a {
+public:
+  typedef b *f;
+  b &operator[](unsigned m) {
+    if (ac)
+      ab.i();
+    return ad[m];
+  }
+  f n() { return ad; }
+  f m_fn3();
+  b *ad;
+  unsigned ac;
+};
+class b {
+public:
+  short j;
+  short k;
+  signed l;
+} __attribute__((__packed__));
+void o(a<b> &m, b &p2, b &p) {
+  p2 = p = m[0];
+  if (bool at = false)
+    ;
+  else
+    for (c::g au(m);; at = true)
+      if (bool av = false)
+        ;
+      else
+        for (e<a<int>>::iter aw = au.n(), ax = au.m_fn3(); ax;
+             av ? (void)0 : (void)0)
+          if (bool ay = 0)
+            ;
+          else
+            for (b az = *aw; !ay; ay = true) {
+              if (p2.j)
+                p2.j = az.j;
+              else if (p.j)
+                p.j = az.j;
+              if (p2.k)
+                p2.k = az.k;
+              else if (az.k > p.k)
+                p.k = az.k;
+              if (az.l < p2.l)
+                if (az.l > p.l)
+                  p.l = az.l;
+            }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/template/dependent-base3.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/template/dependent-base3.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/template/dependent-base3.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/template/dependent-base3.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,26 @@
+// PR c++/85060
+// { dg-do compile { target c++14 } }
+
+struct CA {
+  constexpr int foo() const { return 42; }
+};
+
+template <class T>
+struct CB : CA { };
+
+template <class T>
+struct CC : CB<T> {
+  constexpr int bar() const {
+    const int m = CA::foo();
+    return m;
+  }
+
+  constexpr int baz() const {
+    const T m = CA::foo();
+    return m;
+  }
+};
+
+constexpr CC<double> c;
+
+static_assert( c.bar() == 42, "" );
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/template/incomplete11.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/template/incomplete11.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/template/incomplete11.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/template/incomplete11.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,10 @@
+// PR c++/84082
+// { dg-do compile }
+// { dg-options "" }
+
+struct A;
+
+template<typename> void foo()
+{
+  static int a[A().operator=(A())];	// { dg-error "invalid use of incomplete type 'struct A'" }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/template/nontype-fn1.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/template/nontype-fn1.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/template/nontype-fn1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/template/nontype-fn1.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,11 @@
+// PR c++/82664
+
+template < typename > struct target_disambiguator;
+template < typename R, typename A1 > struct target_disambiguator< R(A1) > {
+  typedef A1 type;
+  template < R (&)() > struct layout;
+};
+
+int main() {
+  typedef target_disambiguator< void (int) > ::type target_type ;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr62175.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr62175.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr62175.C	2014-08-26 01:03:32.118417000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr62175.C	2019-06-25 02:27:21.165930961 -0700
@@ -1,4 +1,5 @@
 // { dg-do compile }
+// { dg-require-effective-target trapping }
 // { dg-additional-options "-ftrapv" }
 
 struct B {
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr83659.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr83659.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr83659.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr83659.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,18 @@
+// PR c++/83659
+// { dg-do compile }
+
+typedef int V __attribute__ ((__vector_size__ (16)));
+V a;
+V b[2];
+
+int
+foo ()
+{
+  return reinterpret_cast <int *> (&a)[-1] += 1;
+}
+
+int
+bar ()
+{
+  return reinterpret_cast <int *> (&a[1])[-1];
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr84190.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr84190.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr84190.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr84190.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,20 @@
+// { dg-do compile }
+// For slim LTO there's no optimized dump
+// { dg-skip-if "" { *-*-* } { "-flto" } { "" } }
+// { dg-additional-options "-fdump-tree-optimized" }
+
+typedef double T;
+static int equalfn (volatile T* x, volatile T* y);
+T gx, gy;
+int main ()
+{
+  T x = gx, y = gy;
+  return equalfn (&x, &y);
+}
+static int equalfn (volatile T* x, volatile T* y)
+{
+  return (*x == *y);
+}
+
+// There should be exactly two volatile accesses (ignoring clobbers).
+// { dg-final { scan-tree-dump-times " ={v} \[^\{\]" 2 "optimized" } }
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr84233.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr84233.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr84233.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr84233.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,25 @@
+// { dg-do compile }
+// { dg-additional-options "-w" }
+
+void a(const char *, int, const char *, const char *);
+template <typename b> void c(b);
+struct d {
+    long e;
+    template <typename> union f;
+    template <typename h> union f<h *> {
+	f(h *i) : j(i) {}
+	h *j;
+	long bits;
+    };
+    static int k(volatile long &i) { return *(int *)f<volatile long *>(&i).bits; }
+    typedef long g;
+    operator g() volatile {
+	int l = k(e);
+	c(l);
+    }
+};
+struct : d {
+	 } m, n;
+bool o;
+void p() { (o ? m : n) ? (void)0 : a("", 5, "", ""); }
+
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr84961-1.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr84961-1.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr84961-1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr84961-1.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,24 @@
+// PR c++/84961
+// { dg-do compile }
+
+short a;
+volatile int b;
+int c, d;
+
+void
+foo ()
+{
+  asm volatile ("" : "=r" (b = a));
+}
+
+void
+bar ()
+{
+  asm volatile ("" : "=r" (++c, ++d, b = a));
+}
+
+void
+baz ()
+{
+  asm volatile ("" : "=r" (--b));
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr84961-2.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr84961-2.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr84961-2.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr84961-2.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,24 @@
+// PR c++/84961
+// { dg-do compile }
+
+short a;
+volatile int b;
+int c, d;
+
+void
+foo ()
+{
+  asm volatile ("" : : "m" (b = a));
+}
+
+void
+bar ()
+{
+  asm volatile ("" : : "m" (++c, ++d, b = a));
+}
+
+void
+baz ()
+{
+  asm volatile ("" : : "m" (--b));
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr85496.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr85496.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr85496.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr85496.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,18 @@
+// PR middle-end/85496
+// Reported by Marek Polacek <mpolacek@gcc.gnu.org>
+
+template <typename> class complex;
+template <typename _Tp> complex<_Tp> operator*(complex<_Tp>, complex<_Tp>);
+template <> struct complex<float> { _Complex float _M_value; };
+class A {
+  complex<float> _f0, _f1;
+
+public:
+  complex<float> &m_fn1() { return _f1; }
+};
+complex<float> a;
+void cos() {
+  A b;
+  complex<float> c;
+  b.m_fn1() = c * a;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr86763.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr86763.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr86763.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr86763.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,37 @@
+// { dg-do run { target { *-*-linux* } } }
+// { dg-additional-options "-fschedule-insns2 -fstrict-aliasing" }
+// { dg-additional-options "-lrt" }
+
+#include <cstdint>
+#include <cassert>
+#include <time.h>
+struct ID {
+  uint64_t value;
+};
+uint64_t value(ID id) { return id.value; }
+uint64_t gen { 1000 };
+struct Msg {
+  uint64_t time;
+  ID id;
+};
+struct V {
+  V() { }
+  V(Msg const & msg) : msg(msg) { }
+  Msg & get() { return msg; }
+  Msg msg;
+  char pad[237 - sizeof(Msg)];
+};
+struct T : V { using V::V; };
+Msg init_msg() {
+  Msg msg;
+  timespec t;
+  clock_gettime(CLOCK_REALTIME, &t);
+  msg.time = t.tv_sec + t.tv_nsec;
+  msg.id.value = ++gen;
+  return msg;
+}
+int main() {
+  T t;
+  t = init_msg();
+  assert(value(t.get().id) == 1001);
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr87014.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr87014.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/torture/pr87014.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/torture/pr87014.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,37 @@
+// { dg-do run }
+
+void
+fillstack ()
+{
+  long long foo[] =
+    {
+      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    };
+}
+
+void
+f (long long=-1,long long=-1,long long=-1,long long=-1,
+   long long=-1,long long=-1,long long arg7_on_stack=-1)
+{
+  throw 0;
+}
+
+void
+g()
+{
+  try
+    {
+      f ();
+    }
+  catch (int)
+    {
+    }
+}
+
+int
+main()
+{
+  fillstack ();
+  g ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/tree-ssa/pr83523.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/tree-ssa/pr83523.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/tree-ssa/pr83523.C	2017-12-22 00:52:28.138170000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/tree-ssa/pr83523.C	2019-06-25 02:27:21.165930961 -0700
@@ -1,6 +1,7 @@
 // PR tree-optimization/83523
 // { dg-do compile }
 // { dg-options "-O2 -fexceptions -fnon-call-exceptions -ftrapv" }
+// { dg-require-effective-target trapping }
 
 #ifdef __SIZEOF_INT128__
 typedef __int128 T;
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/tree-ssa/volatile1.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/tree-ssa/volatile1.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/tree-ssa/volatile1.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/tree-ssa/volatile1.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,28 @@
+// PR c++/84151
+// { dg-additional-options "-fdump-tree-gimple" }
+// { dg-final { scan-tree-dump-not {\*this} "gimple" } }
+
+struct A {
+  static int& bar(int& a) {
+    return a;
+  }
+  static int i;
+
+  int foo() volatile {
+    int v = c;
+    return i + bar(v);
+  }
+
+  int c;
+};
+
+int A::i = 0;
+
+A a;
+
+int main() {
+  a.c = 2;
+  a.foo();
+
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/tree-ssa/volatile2.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/tree-ssa/volatile2.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/tree-ssa/volatile2.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/tree-ssa/volatile2.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,20 @@
+// PR c++/84686
+// { dg-additional-options -fdump-tree-gimple }
+// { dg-final { scan-tree-dump-times "= i" 10 "gimple" } }
+
+volatile int i;
+
+int main()
+{
+  i; //evaluated (a load is performed)
+  (i); //unevaluated => the load shall be performed
+
+  (void)i; //evaluated (a load is performed)
+  (void)(i); //unevaluated => the load shall be performed
+
+  (void)i; //evaluated (a load is performed)
+  (void)(i); //unevaluated => the load shall be performed
+
+  (i,i); // the two subexpression are evaluated
+  ((i),(i)); // no evaluation, => two loads shall happen
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ubsan/pr71512.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ubsan/pr71512.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ubsan/pr71512.C	2016-08-12 12:56:26.105797000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ubsan/pr71512.C	2019-06-25 02:27:21.165930961 -0700
@@ -1,6 +1,7 @@
 /* PR c/71512 */
 /* { dg-do compile } */
 /* { dg-options "-O2 -ftrapv -fnon-call-exceptions -fsanitize=undefined" } */
+/* { dg-require-effective-target trapping } */
 
 bool
 foo (int *x, int *y, int *z)
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ubsan/pr83987-2.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ubsan/pr83987-2.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ubsan/pr83987-2.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ubsan/pr83987-2.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,24 @@
+// PR sanitizer/83987
+// { dg-do compile { target fopenmp } }
+// { dg-options "-fopenmp -fsanitize=vptr" }
+
+struct A
+{
+  int i;
+};
+
+struct B : virtual A
+{
+  void foo();
+};
+
+void B::foo()
+{
+#pragma omp parallel
+  {
+  #pragma omp sections lastprivate (i)
+    {
+      i = 0;
+    }
+  }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/ubsan/pr83987.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ubsan/pr83987.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/ubsan/pr83987.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/ubsan/pr83987.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,15 @@
+// PR sanitizer/83987
+// { dg-do compile { target fopenmp } }
+// { dg-options "-fopenmp -fsanitize=vptr -O0" }
+
+struct A { int i; };
+struct B : virtual A { void foo (); };
+
+void
+B::foo ()
+{
+#pragma omp sections lastprivate (i)
+  {
+    i = 0;
+  }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/vect/pr84556.cc gcc-7.3.0-msp430/gcc/testsuite/g++.dg/vect/pr84556.cc
--- gcc-7.3.0/gcc/testsuite/g++.dg/vect/pr84556.cc	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/vect/pr84556.cc	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,21 @@
+// PR c++/84556
+// { dg-do run { target c++11 } }
+// { dg-options "-O2 -fopenmp-simd" }
+// { dg-additional-options "-mavx" { target avx_runtime } }
+
+int
+main ()
+{
+  int y[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
+  auto x = [&y] ()
+  {
+    #pragma omp simd
+    for (int i = 0; i < 8; ++i)
+      y[i]++;
+  };
+  x ();
+  x ();
+  for (int i = 0; i < 8; ++i)
+    if (y[i] != i + 3)
+      __builtin_abort ();
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/warn/deprecated-13.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/deprecated-13.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/warn/deprecated-13.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/deprecated-13.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,44 @@
+// PR c++/84222
+// { dg-do compile }
+
+struct __attribute__((deprecated)) C {		// { dg-message "declared here" }
+  C () {}
+  C (const C &);				// { dg-bogus "'C' is deprecated" }
+  C (const C &x, const C &y) { C z = x; }	// { dg-bogus "'C' is deprecated" }
+  void foo (const C &x, const C &y);		// { dg-bogus "'C' is deprecated" }
+};
+
+void
+C::foo (const C &x, const C &y)			// { dg-bogus "'C' is deprecated" }
+{
+  C z = x;					// { dg-bogus "'C' is deprecated" }
+}
+
+void
+bar (const C &x, const C &y)			// { dg-warning "'C' is deprecated" }
+{
+  C z = x;					// { dg-warning "'C' is deprecated" }
+}
+
+template <int N>
+struct __attribute__((deprecated)) D {		// { dg-message "declared here" }
+  D () {}
+  D (const D &);				// { dg-bogus "is deprecated" }
+  D (const D &x, const D &y) { D z = x; }	// { dg-bogus "is deprecated" }
+  void foo (const D &x, const D &y);		// { dg-bogus "is deprecated" }
+};
+
+template <int N>
+void
+D<N>::foo					// { dg-bogus "is deprecated" "" { xfail *-*-* } }
+(const D &x, const D &y)			// { dg-bogus "is deprecated" }
+{
+  D z = x;					// { dg-bogus "is deprecated" }
+}
+
+template <int N>
+void
+bar (const D<N> &x, const D<N> &y)		// { dg-warning "is deprecated" }
+{
+  D<N> z = x;					// { dg-warning "is deprecated" }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/warn/deprecated-6.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/deprecated-6.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/warn/deprecated-6.C	2017-04-18 23:55:33.851493000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/deprecated-6.C	2019-06-25 02:27:21.165930961 -0700
@@ -98,7 +98,7 @@
 
 inline void T::member1(int) {}
 
-int T::member3(T *p)		// { dg-warning "'T' is deprecated: Please avoid T" }
+int T::member3(T *p)		// { dg-bogus "'T' is deprecated: Please avoid T" }
 {
   p->member1(1);			/* { dg-warning "'void T::member1\\(int\\)' is deprecated: Please avoid member1" "" } */
   (*p).member1(2);			/* { dg-warning "'void T::member1\\(int\\)' is deprecated: Please avoid member1" "" } */
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/warn/deprecated.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/deprecated.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/warn/deprecated.C	2017-04-18 23:55:33.851493000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/deprecated.C	2019-06-25 02:27:21.165930961 -0700
@@ -102,7 +102,7 @@
 
 inline void T::member1(int) {}
 
-int T::member3(T *p)		// { dg-warning "'T' is deprecated" }
+int T::member3(T *p)		// { dg-bogus "'T' is deprecated" }
 {
   p->member1(1);			/* { dg-warning "'void T::member1\\(int\\)' is deprecated" "" } */
   (*p).member1(2);			/* { dg-warning "'void T::member1\\(int\\)' is deprecated" "" } */
@@ -113,5 +113,3 @@
   return f1(); 				/* { dg-warning "'INT1 f1\\(\\)' is deprecated" "" } */
 }
 #endif
-
-
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/warn/Wformat-2.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/Wformat-2.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/warn/Wformat-2.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/Wformat-2.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,17 @@
+// PR c++/84076
+// { dg-do compile }
+// { dg-options "-Wformat" }
+
+struct S { ~S (); };
+struct T { T (); T (const T &); };
+
+void
+foo ()
+{
+  S s;
+  T t;
+  __builtin_printf ("%s\n", s);	// { dg-warning "format '%s' expects argument of type 'char\\*', but argument 2 has type 'S'" }
+  __builtin_printf ("%s\n", t);	// { dg-warning "format '%s' expects argument of type 'char\\*', but argument 2 has type 'T'" }
+  __builtin_printf ("%s\n", &s);// { dg-warning "format '%s' expects argument of type 'char\\*', but argument 2 has type 'S\\*'" }
+  __builtin_printf ("%s\n", &t);// { dg-warning "format '%s' expects argument of type 'char\\*', but argument 2 has type 'T\\*'" }
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/warn/Wnonnull4.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/Wnonnull4.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/warn/Wnonnull4.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/Wnonnull4.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,21 @@
+// PR c++/86210
+// { dg-do compile }
+// { dg-options "-Wnonnull" }
+
+void *declared_not_defined (void *p) __attribute__((nonnull));
+
+inline void *declared_and_defined (void *p) __attribute__((nonnull));
+
+int
+main ()
+{
+  int *const p = 0;
+  declared_not_defined (p);	// { dg-warning "null argument where non-null required" }
+  declared_and_defined (p);	// { dg-warning "null argument where non-null required" }
+}
+
+void *
+declared_and_defined (void *p)
+{
+  return p;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/warn/Wunused-function4.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/Wunused-function4.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/warn/Wunused-function4.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/Wunused-function4.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,21 @@
+// PR c++/80598
+// { dg-do compile }
+// { dg-options "-Wunused-function" }
+
+static void
+foo ()		// { dg-bogus "defined but not used" }
+{
+}
+
+static void
+bar ()		// { dg-warning "defined but not used" }
+{
+}
+
+template <class T>
+int
+baz (T x)
+{
+  foo ();
+  return 0;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/g++.dg/warn/Wunused-var-33.C gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/Wunused-var-33.C
--- gcc-7.3.0/gcc/testsuite/g++.dg/warn/Wunused-var-33.C	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/g++.dg/warn/Wunused-var-33.C	2019-06-25 02:27:21.165930961 -0700
@@ -0,0 +1,37 @@
+// PR c++/85952
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wunused-but-set-variable" }
+
+int
+foo ()
+{
+  int a[2] = {1, 2};	// { dg-bogus "set but not used" } */
+  auto [x, y] = a;	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+  return x + y;
+}
+
+struct S { int d, e; };
+
+int
+bar ()
+{
+  S a = {1, 2};
+  auto [x, y] = a;	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+  return x + y;
+}
+
+int
+baz ()
+{
+  S a = {1, 2};
+  auto & [x, y] = a;	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+  return x + y;
+}
+
+int
+qux ()
+{
+  int a[2] = {1, 2};
+  auto & [x, y] = a;	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+  return x + y;
+}
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90	2012-06-08 10:26:11.639557000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90	2019-06-25 02:27:21.181930845 -0700
@@ -22,7 +22,7 @@
   allocate(i(2))) ! { dg-error "Syntax error in ALLOCATE" }
   allocate(i(2), errmsg=err, errmsg=err) ! { dg-error "Redundant ERRMSG" }
   allocate(i(2), errmsg=err) ! { dg-warning "useless without a STAT" }
-  allocate(i(2), stat=j, errmsg=x) ! { dg-error "must be a scalar CHARACTER" }
+  allocate(i(2), stat=j, errmsg=x) ! { dg-error "shall be a scalar default CHARACTER" }
 
   allocate(err) ! { dg-error "neither a data pointer nor an allocatable" }
 
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/allocate_stat_2.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/allocate_stat_2.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/allocate_stat_2.f90	2009-09-07 08:23:15.954207000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/allocate_stat_2.f90	2019-06-25 02:27:21.181930845 -0700
@@ -5,6 +5,6 @@
   character(len=30), dimension(2) :: er
   integer, dimension (:), allocatable :: a
   allocate (a (16), stat = ier) ! { dg-error "must be a scalar INTEGER" }
-  allocate (a (14), stat=ier(1),errmsg=er) ! { dg-error "must be a scalar CHARACTER" }
+  allocate (a (14), stat=ier(1),errmsg=er) ! { dg-error "shall be a scalar default CHARACTER" }
 end
 
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/associate_30.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/associate_30.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/associate_30.f90	2017-10-16 12:44:04.299991000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/associate_30.f90	2019-06-25 02:27:21.181930845 -0700
@@ -8,8 +8,3 @@
       associate (x => null())   ! { dg-error "cannot be NULL()" }
       end associate
    end subroutine
-
-   subroutine s2
-      associate (x => [null()]) ! { dg-error "has no type" }
-      end associate
-   end subroutine
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/automatic_module_variable.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/automatic_module_variable.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/automatic_module_variable.f90	2012-05-15 03:42:32.075376000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/automatic_module_variable.f90	2019-06-25 02:27:21.181930845 -0700
@@ -1,10 +1,12 @@
 ! { dg-do compile }
 ! Tests fix for PR15976
 !
+! Error message update with patch for PR fortran/83633
+!
 module sd
   integer, parameter :: n = 20
   integer :: i(n)
-  integer :: j(m) ! { dg-error "must have constant shape" }
+  integer :: j(m) ! { dg-error "array with nonconstant bounds" }
   integer, pointer :: p(:)
   integer, allocatable :: q(:)
 contains
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90	2012-05-15 03:42:32.075376000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90	2019-06-25 02:27:21.181930845 -0700
@@ -5,16 +5,18 @@
 !
 ! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>
 !
+! Error message update with patch for PR fortran/83633
+!
 module foo
   integer    ::  i
 end module foo
 module bar
   use foo
-  integer, dimension (i) :: j ! { dg-error "must have constant shape" }
+  integer, dimension (i) :: j ! { dg-error "array with nonconstant bounds" }
   character (len = i) :: c1   ! { dg-error "must have constant character length" }
 end module bar
 program foobar
   use foo
-  integer, dimension (i) :: k ! { dg-error "must have constant shape" }
+  integer, dimension (i) :: k ! { dg-error "array with nonconstant bounds" }
   character (len = i) :: c2   ! { dg-error "must have constant character length" }
 end program foobar
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/coarray_3.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/coarray_3.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/coarray_3.f90	2014-12-31 09:16:06.073035000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/coarray_3.f90	2019-06-25 02:27:21.181930845 -0700
@@ -13,7 +13,7 @@
 
 sync all (stat=1) ! { dg-error "Syntax error in SYNC ALL" }
 sync all ( stat = n,stat=k) ! { dg-error "Redundant STAT" }
-sync memory (errmsg=str)
+sync memory (errmsg=str) ! { dg-error "must be a scalar CHARACTER variable" }
 sync memory (errmsg=n) ! { dg-error "must be a scalar CHARACTER variable" }
 sync images (*, stat=1.0) ! { dg-error "Syntax error in SYNC IMAGES" }
 sync images (-1) ! { dg-error "must between 1 and num_images" }
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/coarray_8.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/coarray_8.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/coarray_8.f90	2016-02-28 11:07:42.841046000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/coarray_8.f90	2019-06-25 02:27:21.181930845 -0700
@@ -145,7 +145,7 @@
 
 subroutine tfgh()
   integer :: i(2)
-  DATA i/(i, i=1,2)/ ! { dg-error "Expected PARAMETER symbol" }
+  DATA i/(i, i=1,2)/ ! { dg-error "Syntax error in DATA" }
   do i = 1, 5 ! { dg-error "cannot be an array" }
   end do ! { dg-error "Expecting END SUBROUTINE" }
 end subroutine tfgh
@@ -153,7 +153,7 @@
 subroutine tfgh2()
   integer, save :: x[*]
   integer :: i(2)
-  DATA i/(x, x=1,2)/ ! { dg-error "Expected PARAMETER symbol" }
+  DATA i/(x, x=1,2)/ ! { dg-error "Syntax error in DATA" }
   do x = 1, 5 ! { dg-error "cannot be a coarray" }
   end do ! { dg-error "Expecting END SUBROUTINE" }
 end subroutine tfgh2
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90	2016-11-30 05:27:49.621409000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90	2019-06-25 02:27:21.181930845 -0700
@@ -38,9 +38,8 @@
 if (any (A-B /= 0)) call abort
 end
 
-! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, &parm.\[0-9\]+, 4, 4, 0, 0B\\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, &parm.\[0-9\]+, 4, 4, 1, 0B\\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, &parm.\[0-9\]+, 4, 4, 1, 0B\\\);" 2 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, &p, 4, 4, 1, 0B\\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.1, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) b, 1, &parm.\[0-9\]+, 0B, &p, 4, 4, 0, 0B\\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "_gfortran_caf_sendget \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, 4, 4, 0, 0B\\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_sendget \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, 4, 4, 1, 0B\\\);" 1 "original" } }
 
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/constant_shape.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/constant_shape.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/constant_shape.f90	2016-12-12 10:54:54.539941000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/constant_shape.f90	2019-06-25 02:27:21.181930845 -0700
@@ -3,7 +3,8 @@
 ! PR 78392: ICE in gfc_trans_auto_array_allocation, at fortran/trans-array.c:5979
 !
 ! Contributed by Janus Weil <janus@gcc.gnu.org>
-
+! Error message update with patch for PR fortran/83633
+!
 module mytypes
    implicit none
  contains
@@ -15,6 +16,6 @@
 program test
   use mytypes
   implicit none
-  integer, dimension(get_i()) :: x  ! { dg-error "must have constant shape" }
-  print *, size (x)
+  integer, dimension(get_i()) :: x  ! { dg-error "array with nonconstant bounds" }
+  print *, size (x)                 ! { dg-error "has no IMPLICIT type" }
 end
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/data_bounds_1.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/data_bounds_1.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/data_bounds_1.f90	2008-02-05 03:16:33.254353000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/data_bounds_1.f90	2019-06-25 02:27:21.181930845 -0700
@@ -1,4 +1,5 @@
 ! { dg-do compile }
+! { dg-options "-std=gnu" }
 ! Checks the fix for PR32315, in which the bounds checks below were not being done.
 !
 ! Contributed by Tobias Burnus <burnus@gcc.gnu.org>
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/data_char_1.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/data_char_1.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/data_char_1.f90	2010-05-19 05:55:26.986342000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/data_char_1.f90	2019-06-25 02:27:21.185930818 -0700
@@ -1,4 +1,5 @@
 ! { dg-do run }
+! { dg-options "-std=gnu" }
 ! Test character variables in data statements
 ! Also substrings of character variables.
 ! PR14976 PR16228 
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90	2012-03-28 13:45:16.516676000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90	2019-06-25 02:27:21.185930818 -0700
@@ -22,7 +22,7 @@
   deallocate(i)) ! { dg-error "Syntax error in DEALLOCATE" }
   deallocate(i, errmsg=err, errmsg=err) ! { dg-error "Redundant ERRMSG" }
   deallocate(i, errmsg=err) ! { dg-warning "useless without a STAT" }
-  deallocate(i, stat=j, errmsg=x) ! { dg-error "must be a scalar CHARACTER" }
+  deallocate(i, stat=j, errmsg=x) ! { dg-error "shall be a scalar default CHARACTER" }
 
   deallocate(err) ! { dg-error "nonprocedure pointer nor an allocatable" }
 
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/dec_parameter_1.f gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/dec_parameter_1.f
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/dec_parameter_1.f	2016-11-03 09:00:58.286658000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/dec_parameter_1.f	2019-06-25 02:27:21.185930818 -0700
@@ -22,7 +22,6 @@
           two = 2.0d0
           x = two * pi_1 * f_1 * t
           y = two * pi_2 * f_2 * t
-          z = two * pi_3 * f_3 * t
           return
         end subroutine
 
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/dec_parameter_2.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/dec_parameter_2.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/dec_parameter_2.f90	2016-11-03 09:00:58.286658000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/dec_parameter_2.f90	2019-06-25 02:27:21.185930818 -0700
@@ -21,7 +21,6 @@
   two = 2.0d0
   x = two * pi_1 * f_1 * t
   y = two * pi_2 * f_2 * t
-  z = two * pi_3 * f_3 * t
   return
 end subroutine
 
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/dec_structure_8.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/dec_structure_8.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/dec_structure_8.f90	2016-05-07 16:16:23.513020000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/dec_structure_8.f90	2019-06-25 02:27:21.185930818 -0700
@@ -6,7 +6,7 @@
 
 ! Old-style (clist) initialization
 integer,parameter :: as = 3
-structure /t1/
+structure /t1/              ! { dg-error "Type definition.*T1" }
   integer*1 a /300_2/       ! { dg-error "Arithmetic overflow" }
   integer   b //            ! { dg-error "Empty old style initializer list" }
   integer   c /2*3/         ! { dg-error "Repeat spec invalid in scalar" }
@@ -44,14 +44,14 @@
 
 structure /t2/
   ENTRY here           ! { dg-error "ENTRY statement.*cannot appear" }
-  integer a
+  integer a            ! { dg-error "Component.*already declared" }
   integer a            ! { dg-error "Component.*already declared" }
   structure $z         ! { dg-error "Invalid character in name" }
   structure //         ! { dg-error "Invalid character in name" }
   structure // x       ! { dg-error "Invalid character in name" }
   structure /t3/       ! { dg-error "Invalid character in name" }
   structure /t3/ x,$y  ! { dg-error "Invalid character in name" }
-  structure /t4/ y
+  structure /t4/ y     ! { dg-error "Type definition.*T4" }
     integer i, j, k
   end structure
   structure /t4/ z     ! { dg-error "Type definition.*T4" }
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/internal_references_1.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/internal_references_1.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/internal_references_1.f90	2012-05-15 03:42:32.075376000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/internal_references_1.f90	2019-06-25 02:27:21.185930818 -0700
@@ -11,7 +11,7 @@
   implicit none
 contains
 
-  subroutine p (i)   ! { dg-error "is already defined" }
+  subroutine p (i)   ! { dg-error "(1)" }
     integer :: i
   end subroutine
 
@@ -22,14 +22,15 @@
 !
 ! PR25124 - would happily ignore the declaration of foo in the main program.
 program test
-real :: foo, x      ! { dg-error "explicit interface and must not have attributes declared" }
+real :: foo, x
 x = bar ()          ! This is OK because it is a regular reference.
 x = foo ()
 contains
-    function foo () ! { dg-error "explicit interface and must not have attributes declared" }
+    function foo () ! { dg-error "explicit interface from a previous" }
       foo = 1.0
     end function foo
     function bar ()
       bar = 1.0
     end function bar
 end program test
+
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/pr67803.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/pr67803.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/pr67803.f90	2015-11-14 09:31:16.430375000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/pr67803.f90	2019-06-25 02:27:21.185930818 -0700
@@ -10,5 +10,4 @@
   x = '0' // [character :: 1d1]     ! { dg-error "Incompatible typespec for" }
   x = '0' // [character :: (0.,1.)] ! { dg-error "Incompatible typespec for" }
   x = '0' // [character :: .true.]  ! { dg-error "Incompatible typespec for" }
-  x = '0' // [character :: null()]  ! { dg-error "Incompatible typespec for" }
 end
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/pr67805.f90 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/pr67805.f90
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/pr67805.f90	2015-10-24 09:20:26.863061000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/pr67805.f90	2019-06-25 02:27:21.185930818 -0700
@@ -22,7 +22,6 @@
    s = [character([1.]) :: 'x', 'y']      ! { dg-error "INTEGER expression expected" }
    s = [character([1d1]) :: 'x', 'y']     ! { dg-error "INTEGER expression expected" }
    s = [character([(0.,1.)]) :: 'x', 'y'] ! { dg-error "INTEGER expression expected" }
-   s = [character([null()]) :: 'x', 'y']  ! { dg-error "INTEGER expression expected" }
    s =  [character(null()) :: 'x', 'y']   ! { dg-error "INTEGER expression expected" }
    call foo(s)
 end subroutine p
diff -ruN gcc-7.3.0/gcc/testsuite/gfortran.dg/typebound_operator_4.f03 gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/typebound_operator_4.f03
--- gcc-7.3.0/gcc/testsuite/gfortran.dg/typebound_operator_4.f03	2014-12-27 14:40:21.459192000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gfortran.dg/typebound_operator_4.f03	2019-06-25 02:27:21.185930818 -0700
@@ -84,6 +84,6 @@
   TYPE(myint) :: x
 
   x = 0 ! { dg-error "Can't convert" }
-  x = x + 42 ! { dg-error "Operands of" }
+  x = x + 42 ! { dg-error "binary intrinsic numeric operator" }
   x = x .PLUS. 5 ! { dg-error "Unknown operator" }
 END PROGRAM main
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/array11.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/array11.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/array11.adb	2010-05-30 03:38:00.925435000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/array11.adb	2019-06-25 02:27:21.185930818 -0700
@@ -1,15 +1,17 @@
 -- { dg-do compile }
 
+with System;
+
 procedure Array11 is
 
   type Rec is null record;
-  type Ptr is access all Rec;
+  type Index_T is mod System.Memory_Size;
 
-  type Arr1 is array (1..8) of aliased Rec; -- { dg-warning "padded" }
-  type Arr2 is array (Long_Integer) of aliased Rec; -- { dg-warning "padded" }
+  type Arr1 is array (1 .. 8) of aliased Rec; -- { dg-warning "padded" }
+  type Arr2 is array (Index_T) of aliased Rec; -- { dg-warning "padded" }
 
   A1 : Arr1;
-  A2 : Arr2; -- { dg-warning "Storage_Error" }
+  A2 : Arr2;
 
 begin
   null;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch1.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch1.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch1.adb	2006-10-31 10:20:42.966598000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch1.adb	2019-06-25 02:27:29.505871294 -0700
@@ -1,3 +1,12 @@
+-- a/{ dg-do run }
+
+with dispatch1_p; use dispatch1_p;
+procedure dispatch1 is
+   O   : DT_I1;
+   Ptr : access I1'Class;
+begin
+   Ptr := new I1'Class'(I1'Class (O));
+end;
 -- { dg-do run }
 
 with dispatch1_p; use dispatch1_p;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch1.adb.orig gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch1.adb.orig
--- gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch1.adb.orig	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch1.adb.orig	2006-10-31 10:20:42.966598000 -0800
@@ -0,0 +1,9 @@
+-- { dg-do run }
+
+with dispatch1_p; use dispatch1_p;
+procedure dispatch1 is
+   O   : DT_I1;
+   Ptr : access I1'Class;
+begin
+   Ptr := new I1'Class'(I1'Class (O));
+end;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch1_p.ads gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch1_p.ads
--- gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch1_p.ads	2006-10-31 10:20:42.966598000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch1_p.ads	2019-06-25 02:27:29.505871294 -0700
@@ -1,4 +0,0 @@
-package dispatch1_p is
-   type I1 is interface;
-   type DT_I1 is new I1 with null record;
-end;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch2.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch2.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch2.adb	2007-08-16 06:29:34.868652000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch2.adb	2019-06-25 02:27:31.481857156 -0700
@@ -1,3 +1,13 @@
+-- a/ { dg-do run }
+
+with dispatch2_p; use dispatch2_p;
+procedure dispatch2 is
+   Obj : Object_Ptr := new Object;
+begin
+   if Obj.Get_Ptr /= Obj.Impl_Of then
+      raise Program_Error;
+   end if;
+end;
 --  { dg-do run }
 
 with dispatch2_p; use dispatch2_p;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch2.adb.orig gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch2.adb.orig
--- gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch2.adb.orig	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch2.adb.orig	2007-08-16 06:29:34.868652000 -0700
@@ -0,0 +1,10 @@
+--  { dg-do run }
+
+with dispatch2_p; use dispatch2_p;
+procedure dispatch2 is
+   Obj : Object_Ptr := new Object;
+begin
+   if Obj.Get_Ptr /= Obj.Impl_Of then
+      raise Program_Error;
+   end if;
+end;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch2_p.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch2_p.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch2_p.adb	2007-08-16 06:29:34.868652000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch2_p.adb	2019-06-25 02:27:31.481857156 -0700
@@ -1,7 +0,0 @@
---
-package body dispatch2_p is
-  function Impl_Of (Self : access Object) return Object_Ptr is
-  begin
-    return Object_Ptr (Self);
-  end Impl_Of;
-end;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch2_p.ads gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch2_p.ads
--- gcc-7.3.0/gcc/testsuite/gnat.dg/dispatch2_p.ads	2007-08-16 06:29:34.868652000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/dispatch2_p.ads	2019-06-25 02:27:31.481857156 -0700
@@ -1,8 +0,0 @@
-package dispatch2_p is
-  type Object     is tagged null record;
-  type Object_Ptr is access all Object'CLASS;
---
-  function Impl_Of (Self : access Object) return Object_Ptr;
-  function Get_Ptr (Self : access Object) return Object_Ptr
-    renames Impl_Of;
-end;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/generic_dispatch.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/generic_dispatch.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/generic_dispatch.adb	2006-10-31 10:20:42.966598000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/generic_dispatch.adb	2019-06-25 02:27:32.249851663 -0700
@@ -1,3 +1,12 @@
+-- a/ { dg-do run }
+
+with generic_dispatch_p; use generic_dispatch_p;
+procedure generic_dispatch is
+   I : aliased Integer := 0;
+   D : Iface'Class := Dispatching_Constructor (DT'Tag, I'access);
+begin   
+   null;   
+end generic_dispatch;
 --  { dg-do run }
 
 with generic_dispatch_p; use generic_dispatch_p;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/generic_dispatch.adb.orig gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/generic_dispatch.adb.orig
--- gcc-7.3.0/gcc/testsuite/gnat.dg/generic_dispatch.adb.orig	1969-12-31 16:00:00.000000000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/generic_dispatch.adb.orig	2006-10-31 10:20:42.966598000 -0800
@@ -0,0 +1,9 @@
+--  { dg-do run }
+
+with generic_dispatch_p; use generic_dispatch_p;
+procedure generic_dispatch is
+   I : aliased Integer := 0;
+   D : Iface'Class := Dispatching_Constructor (DT'Tag, I'access);
+begin   
+   null;   
+end generic_dispatch;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/generic_dispatch_p.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/generic_dispatch_p.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/generic_dispatch_p.adb	2006-10-31 10:20:42.966598000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/generic_dispatch_p.adb	2019-06-25 02:27:32.249851663 -0700
@@ -1,7 +0,0 @@
-package body generic_dispatch_p is
-   function Constructor (I : not null access Integer) return DT is
-      R : DT; 
-  begin
-      return R;
-   end Constructor;
-end;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/generic_dispatch_p.ads gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/generic_dispatch_p.ads
--- gcc-7.3.0/gcc/testsuite/gnat.dg/generic_dispatch_p.ads	2006-10-31 10:20:42.966598000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/generic_dispatch_p.ads	2019-06-25 02:27:32.249851663 -0700
@@ -1,13 +0,0 @@
-with Ada.Tags.Generic_Dispatching_Constructor;
-package generic_dispatch_p is
-   type Iface is interface;
-   function Constructor (I : not null access Integer) return Iface is abstract;
-   function Dispatching_Constructor
-      is new Ada.Tags.Generic_Dispatching_Constructor
-               (T           => Iface,
-                Parameters  => Integer,
-                Constructor => Constructor);
-   type DT is new Iface with null record; 
-   overriding
-   function Constructor (I : not null access Integer) return DT;
-end;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/null_pointer_deref1.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/null_pointer_deref1.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/null_pointer_deref1.adb	2011-02-14 04:32:11.701644000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/null_pointer_deref1.adb	2019-06-25 02:27:32.249851663 -0700
@@ -17,5 +17,5 @@
 begin
    Data.all := 1;
 exception
-   when Constraint_Error | Storage_Error => null;
+   when others => null;
 end;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/null_pointer_deref2.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/null_pointer_deref2.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/null_pointer_deref2.adb	2009-10-27 12:41:13.306863000 -0700
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/null_pointer_deref2.adb	2019-06-25 02:27:32.249851663 -0700
@@ -20,7 +20,7 @@
    begin
       Data.all := 1;
    exception
-      when Constraint_Error | Storage_Error => null;
+      when others => null;
    end T;
 
 begin
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/object_overflow1.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/object_overflow1.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/object_overflow1.adb	2012-11-28 02:51:19.299372000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/object_overflow1.adb	2019-06-25 02:27:32.249851663 -0700
@@ -1,10 +1,12 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow1 is
 
   procedure Proc (x : Boolean) is begin null; end;
 
-  type Arr is array(Long_Integer) of Boolean;
+  type Arr is array(ptrdiff_t) of Boolean;
   Obj : Arr; -- { dg-warning "Storage_Error" }
 
 begin
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/object_overflow2.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/object_overflow2.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/object_overflow2.adb	2012-11-28 02:51:19.299372000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/object_overflow2.adb	2019-06-25 02:27:32.249851663 -0700
@@ -1,10 +1,12 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow2 is
 
   procedure Proc (x : Boolean) is begin null; end;
 
-  type Arr is array(0 .. Long_Integer'Last) of Boolean;
+  type Arr is array(0 .. ptrdiff_t'Last) of Boolean;
   Obj : Arr; -- { dg-warning "Storage_Error" }
 
 begin
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/object_overflow3.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/object_overflow3.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/object_overflow3.adb	2012-11-28 02:51:19.299372000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/object_overflow3.adb	2019-06-25 02:27:32.249851663 -0700
@@ -1,10 +1,12 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow3 is
 
   procedure Proc (x : Boolean) is begin null; end;
 
-  type Arr is array(0 .. Long_Integer'Last) of Boolean;
+  type Arr is array(0 .. ptrdiff_t'Last) of Boolean;
 
   type Rec is record
     A : Arr;
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/object_overflow4.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/object_overflow4.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/object_overflow4.adb	2012-11-28 02:51:19.299372000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/object_overflow4.adb	2019-06-25 02:27:32.249851663 -0700
@@ -1,14 +1,16 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow4 is
 
   procedure Proc (x : Integer) is begin null; end;
 
-  type Index is new Long_Integer range 0 .. Long_Integer'Last;
+  type Index_T is new ptrdiff_t range 0 .. ptrdiff_t'Last;
 
-  type Arr is array(Index range <>) of Integer;
+  type Arr is array(Index_T range <>) of Integer;
 
-  type Rec (Size: Index := 6) is record -- { dg-warning "Storage_Error" }
+  type Rec (Size: Index_T := 6) is record -- { dg-warning "Storage_Error" }
     A: Arr (0..Size);
   end record;
 
diff -ruN gcc-7.3.0/gcc/testsuite/gnat.dg/object_overflow5.adb gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/object_overflow5.adb
--- gcc-7.3.0/gcc/testsuite/gnat.dg/object_overflow5.adb	2015-03-03 09:56:07.214429000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/gnat.dg/object_overflow5.adb	2019-06-25 02:27:32.249851663 -0700
@@ -1,14 +1,16 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow5 is
 
   procedure Proc (c : Character) is begin null; end;
 
-  type Index is new Long_Integer range 0 .. Long_Integer'Last;
+  type Index_T is new ptrdiff_t range 0 .. ptrdiff_t'Last;
 
-  type Arr is array(Index range <>) of Character;
+  type Arr is array(Index_T range <>) of Character;
 
-  type Rec (Size: Index := 6) is record -- { dg-warning "Storage_Error" }
+  type Rec (Size: Index_T := 6) is record -- { dg-warning "Storage_Error" }
     A: Arr (0..Size);
   end record;
 
diff -ruN gcc-7.3.0/gcc/testsuite/lib/c-torture.exp gcc-7.3.0-msp430/gcc/testsuite/lib/c-torture.exp
--- gcc-7.3.0/gcc/testsuite/lib/c-torture.exp	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/lib/c-torture.exp	2019-06-25 02:27:32.249851663 -0700
@@ -166,9 +166,17 @@
 
     set count 0
     set oldstatus "foo"
+    set status "foo"
     foreach option $option_list {
 	if { $count > 0 } {
+	    # oldexec is the execname from two iterations ago.
+	    # execname from the previous iteration must be kept until the end
+	    # of this iteration.
+	    if { [info exists oldexec] && $oldstatus == "pass" } {
+		file_on_host delete $oldexec
+	    }
 	    set oldexec $execname
+	    set oldstatus $status
 	}
 	set execname "${executable}${count}"
 	incr count
@@ -206,6 +214,7 @@
 	if [target_info exists no_long_long] then {
 	    if [expr [search_for $src "long long"]] then {
 		unsupported "$testcase execution, $option"
+		file_on_host delete $execname
 		continue
 	    }
 	}
@@ -243,16 +252,13 @@
 	    set status [lindex $result 0]
 	    set output [lindex $result 1]
 	}
-        if { $oldstatus == "pass" } {
-	    file_on_host delete $oldexec
-        }
 	$status "$testcase execution, $option"
-	set oldstatus $status
     }
-    if [info exists status] {
-	if { $status == "pass" } {
-	    file_on_host delete $execname
-	}
+    if { [info exists oldexec] && $oldstatus == "pass" } {
+	file_on_host delete $oldexec
+    }
+    if { [info exists execname] && $status == "pass" } {
+	file_on_host delete $execname
     }
 }
 
diff -ruN gcc-7.3.0/gcc/testsuite/lib/gcc-dg.exp gcc-7.3.0-msp430/gcc/testsuite/lib/gcc-dg.exp
--- gcc-7.3.0/gcc/testsuite/lib/gcc-dg.exp	2017-01-03 08:25:31.856818000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/lib/gcc-dg.exp	2019-06-25 02:27:32.249851663 -0700
@@ -363,6 +363,14 @@
         return "::unsupported::memory full"
     }
 
+    if [regexp "(^|\n)\[^\n\]* section.*will not fit in region" $text] {
+	return "::unsupported::memory full"
+    }
+
+    if [regexp "(^|\n)\[^\n\]* region.*overflowed by" $text] {
+	return "::unsupported::memory full"
+    }
+
     # Likewise, if we see ".text exceeds local store range" or
     # similar.
     if {[string match "spu-*" $system] && \
diff -ruN gcc-7.3.0/gcc/testsuite/lib/prune.exp gcc-7.3.0-msp430/gcc/testsuite/lib/prune.exp
--- gcc-7.3.0/gcc/testsuite/lib/prune.exp	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/lib/prune.exp	2019-06-25 02:27:32.249851663 -0700
@@ -28,7 +28,7 @@
 
     #send_user "Before:$text\n"
 
-    regsub -all "(^|\n)(\[^\n\]*: )?In ((static member |lambda )?function|member|method|(copy )?constructor|destructor|instantiation|substitution|program|subroutine|block-data)\[^\n\]*" $text "" text
+    regsub -all "(^|\n)(\[^\n\]*: \[iI\]|I)n ((static member |lambda )?function|member|method|(copy )?constructor|destructor|instantiation|substitution|program|subroutine|block-data)\[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*(: )?At (top level|global scope):\[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*:   (recursively )?required \[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*:   . skipping \[0-9\]* instantiation contexts \[^\n\]*" $text "" text
diff -ruN gcc-7.3.0/gcc/testsuite/lib/target-supports.exp gcc-7.3.0-msp430/gcc/testsuite/lib/target-supports.exp
--- gcc-7.3.0/gcc/testsuite/lib/target-supports.exp	2017-11-21 01:31:12.135035000 -0800
+++ gcc-7.3.0-msp430/gcc/testsuite/lib/target-supports.exp	2019-06-25 02:27:32.249851663 -0700
@@ -266,6 +266,14 @@
     return 0
 }
 
+# Return 1 if GCC was not configured with $pattern.
+proc check_not_configured_with { pattern } {
+    if { [check_configured_with $pattern] } {
+	return 0
+    }
+    return 1
+}
+
 ###############################
 # proc check_weak_available { }
 ###############################
@@ -5940,7 +5948,8 @@
 	verbose "check_effective_target_vect_load_lanes: using cached result" 2
     } else {
 	set et_vect_load_lanes 0
-	if { ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok])
+	# We don't support load_lanes correctly on big-endian arm.
+	if { ([check_effective_target_arm_little_endian] && [check_effective_target_arm_neon_ok])
 	     || [istarget aarch64*-*-*] } {
 	    set et_vect_load_lanes 1
 	}
@@ -7348,11 +7357,22 @@
 proc check_effective_target_avx512f { } {
     return [check_no_compiler_messages avx512f object {
 	typedef double __m512d __attribute__ ((__vector_size__ (64)));
+	typedef double __m128d __attribute__ ((__vector_size__ (16)));
 
 	__m512d _mm512_add (__m512d a)
 	{
 	  return __builtin_ia32_addpd512_mask (a, a, a, 1, 4);
 	}
+
+	__m128d _mm128_add (__m128d a)
+	{
+	  return __builtin_ia32_addsd_round (a, a, 8);
+	}
+
+	__m128d _mm128_getmant (__m128d a)
+	{
+	  return __builtin_ia32_getmantsd_round (a, a, 0, 8);
+	}
     } "-O2 -mavx512f" ]
 }
 
@@ -8013,6 +8033,7 @@
 	 || [istarget avr*-*-*]
 	 || [istarget crisv32-*-*] || [istarget cris-*-*]
 	 || [istarget mmix-*-*]
+	 || [istarget msp430-*-*]
 	 || [istarget s390*-*-*]
 	 || [istarget powerpc*-*-*]
 	 || [istarget nios2*-*-*]
@@ -8404,3 +8425,33 @@
     return [check_cached_effective_target arm_coproc4_ok \
 		check_effective_target_arm_coproc4_ok_nocache]
 }
+
+# Return true if the underlying type of __SIZE_TYPE__ is compatible with ISO C
+proc check_effective_target_size_t_ansi_compatible {} {
+    return [check_no_compiler_messages size_t_iso assembly {
+	typedef __SIZE_TYPE__ foo_size_t;
+    } "-ansi -pedantic-errors"]
+}
+
+# Return true if the underlying type of __INTPTR_TYPE__ is compatible with ISO C
+proc check_effective_target_ptr_t_ansi_compatible {} {
+    return [check_no_compiler_messages ptr_t_iso assembly {
+	typedef __INTPTR_TYPE__ foo_ptr_t;
+    } "-ansi -pedantic-errors"]
+}
+
+proc check_effective_target_newlib_nano_io { } {
+    return [check_configured_with "--enable-newlib-nano-formatted-io"]
+}
+
+proc check_effective_target_not_newlib_nano_io { } {
+    return [check_not_configured_with "--enable-newlib-nano-formatted-io"]
+}
+
+proc check_effective_target_msp430_large_memory_model {} {
+    return [check_no_compiler_messages msp430_large assembly {
+	#ifndef __MSP430X_LARGE__
+	#error
+	#endif
+    } ""]
+}
diff -ruN gcc-7.3.0/gcc/tree.c gcc-7.3.0-msp430/gcc/tree.c
--- gcc-7.3.0/gcc/tree.c	2017-11-29 14:13:34.210836000 -0800
+++ gcc-7.3.0-msp430/gcc/tree.c	2019-06-25 02:27:32.257851604 -0700
@@ -4960,9 +4960,8 @@
   return l1 == l2;
 }
 
-/* Compare two identifier nodes representing attributes.  Either one may
-   be in wrapped __ATTR__ form.  Return true if they are the same, false
-   otherwise.  */
+/* Compare two identifier nodes representing attributes.
+   Return true if they are the same, false otherwise.  */
 
 static bool
 cmp_attrib_identifiers (const_tree attr1, const_tree attr2)
@@ -4975,34 +4974,8 @@
   if (attr1 == attr2)
     return true;
 
-  /* If they are not equal, they may still be one in the form
-     'text' while the other one is in the form '__text__'.  TODO:
-     If we were storing attributes in normalized 'text' form, then
-     this could all go away and we could take full advantage of
-     the fact that we're comparing identifiers. :-)  */
-  const size_t attr1_len = IDENTIFIER_LENGTH (attr1);
-  const size_t attr2_len = IDENTIFIER_LENGTH (attr2);
-
-  if (attr2_len == attr1_len + 4)
-    {
-      const char *p = IDENTIFIER_POINTER (attr2);
-      const char *q = IDENTIFIER_POINTER (attr1);
-      if (p[0] == '_' && p[1] == '_'
-	  && p[attr2_len - 2] == '_' && p[attr2_len - 1] == '_'
-	  && strncmp (q, p + 2, attr1_len) == 0)
-	return true;;
-    }
-  else if (attr2_len + 4 == attr1_len)
-    {
-      const char *p = IDENTIFIER_POINTER (attr2);
-      const char *q = IDENTIFIER_POINTER (attr1);
-      if (q[0] == '_' && q[1] == '_'
-	  && q[attr1_len - 2] == '_' && q[attr1_len - 1] == '_'
-	  && strncmp (q + 2, p, attr2_len) == 0)
-	return true;
-    }
-
-  return false;
+  return cmp_attribs (IDENTIFIER_POINTER (attr1), IDENTIFIER_LENGTH (attr1),
+		      IDENTIFIER_POINTER (attr2), IDENTIFIER_LENGTH (attr2));
 }
 
 /* Compare two attributes for their value identity.  Return true if the
@@ -5454,9 +5427,10 @@
 	 At this point, it is not needed anymore.  */
       DECL_SAVED_TREE (decl) = NULL_TREE;
 
-      /* Clear the abstract origin if it refers to a method.  Otherwise
-         dwarf2out.c will ICE as we clear TYPE_METHODS and thus the
-	 origin will not be output correctly.  */
+      /* Clear the abstract origin if it refers to a method.
+         Otherwise dwarf2out.c will ICE as we splice functions out of
+         TYPE_FIELDS and thus the origin will not be output
+         correctly.  */
       if (DECL_ABSTRACT_ORIGIN (decl)
 	  && DECL_CONTEXT (DECL_ABSTRACT_ORIGIN (decl))
 	  && RECORD_OR_UNION_TYPE_P
@@ -6106,25 +6080,11 @@
 {
   while (list)
     {
-      size_t ident_len = IDENTIFIER_LENGTH (get_attribute_name (list));
-
-      if (ident_len == attr_len)
-	{
-	  if (!strcmp (attr_name,
-		       IDENTIFIER_POINTER (get_attribute_name (list))))
-	    break;
-	}
-      /* TODO: If we made sure that attributes were stored in the
-	 canonical form without '__...__' (ie, as in 'text' as opposed
-	 to '__text__') then we could avoid the following case.  */
-      else if (ident_len == attr_len + 4)
-	{
-	  const char *p = IDENTIFIER_POINTER (get_attribute_name (list));
-	  if (p[0] == '_' && p[1] == '_'
-	      && p[ident_len - 2] == '_' && p[ident_len - 1] == '_'
-	      && strncmp (attr_name, p + 2, attr_len) == 0)
-	    break;
-	}
+      tree attr = get_attribute_name (list);
+      size_t ident_len = IDENTIFIER_LENGTH (attr);
+      if (cmp_attribs (attr_name, attr_len, IDENTIFIER_POINTER (attr),
+		       ident_len))
+	break;
       list = TREE_CHAIN (list);
     }
 
@@ -6133,8 +6093,7 @@
 
 /* Given an attribute name ATTR_NAME and a list of attributes LIST,
    return a pointer to the attribute's list first element if the attribute
-   starts with ATTR_NAME. ATTR_NAME must be in the form 'text' (not
-   '__text__').  */
+   starts with ATTR_NAME.  */
 
 tree
 private_lookup_attribute_by_prefix (const char *attr_name, size_t attr_len,
@@ -6151,17 +6110,11 @@
 	}
 
       const char *p = IDENTIFIER_POINTER (get_attribute_name (list));
+      gcc_checking_assert (attr_len == 0 || p[0] != '_');
 
       if (strncmp (attr_name, p, attr_len) == 0)
 	break;
 
-      /* TODO: If we made sure that attributes were stored in the
-	 canonical form without '__...__' (ie, as in 'text' as opposed
-	 to '__text__') then we could avoid the following case.  */
-      if (p[0] == '_' && p[1] == '_' &&
-	  strncmp (attr_name, p + 2, attr_len) == 0)
-	break;
-
       list = TREE_CHAIN (list);
     }
 
@@ -6207,16 +6160,14 @@
 remove_attribute (const char *attr_name, tree list)
 {
   tree *p;
-  size_t attr_len = strlen (attr_name);
-
   gcc_checking_assert (attr_name[0] != '_');
 
   for (p = &list; *p; )
     {
       tree l = *p;
-      /* TODO: If we were storing attributes in normalized form, here
-	 we could use a simple strcmp().  */
-      if (private_is_attribute_p (attr_name, attr_len, get_attribute_name (l)))
+
+      tree attr = get_attribute_name (l);
+      if (is_attribute_p (attr_name, attr))
 	*p = TREE_CHAIN (l);
       else
 	p = &TREE_CHAIN (l);
@@ -7887,6 +7838,9 @@
       for (i = 0; i < TREE_VEC_LENGTH (t); ++i)
 	inchash::add_expr (TREE_VEC_ELT (t, i), hstate, flags);
       return;
+    case IDENTIFIER_NODE:
+      hstate.add_object (IDENTIFIER_HASH_VALUE (t));
+      return;
     case FUNCTION_DECL:
       /* When referring to a built-in FUNCTION_DECL, use the __builtin__ form.
 	 Otherwise nodes that compare equal according to operand_equal_p might
@@ -10302,11 +10256,8 @@
     {
       int_n_trees[i].signed_type = make_signed_type (int_n_data[i].bitsize);
       int_n_trees[i].unsigned_type = make_unsigned_type (int_n_data[i].bitsize);
-      TYPE_SIZE (int_n_trees[i].signed_type) = bitsize_int (int_n_data[i].bitsize);
-      TYPE_SIZE (int_n_trees[i].unsigned_type) = bitsize_int (int_n_data[i].bitsize);
 
-      if (int_n_data[i].bitsize > LONG_LONG_TYPE_SIZE
-	  && int_n_enabled_p[i])
+      if (int_n_enabled_p[i])
 	{
 	  integer_types[itk_intN_0 + i * 2] = int_n_trees[i].signed_type;
 	  integer_types[itk_unsigned_intN_0 + i * 2] = int_n_trees[i].unsigned_type;
diff -ruN gcc-7.3.0/gcc/tree-core.h gcc-7.3.0-msp430/gcc/tree-core.h
--- gcc-7.3.0/gcc/tree-core.h	2017-04-12 00:35:49.004848000 -0700
+++ gcc-7.3.0-msp430/gcc/tree-core.h	2019-06-25 02:27:32.249851663 -0700
@@ -1905,11 +1905,11 @@
   bool function_type_required;
   /* Function to handle this attribute.  NODE points to the node to which
      the attribute is to be applied.  If a DECL, it should be modified in
-     place; if a TYPE, a copy should be created.  NAME is the name of the
-     attribute (possibly with leading or trailing __).  ARGS is the TREE_LIST
-     of the arguments (which may be NULL).  FLAGS gives further information
-     about the context of the attribute.  Afterwards, the attributes will
-     be added to the DECL_ATTRIBUTES or TYPE_ATTRIBUTES, as appropriate,
+     place; if a TYPE, a copy should be created.  NAME is the canonicalized
+     name of the attribute i.e. without any leading or trailing "__".  ARGS is
+     the TREE_LIST of the arguments (which may be NULL).  FLAGS gives further
+     information about the context of the attribute.  Afterwards, the attributes
+     will be added to the DECL_ATTRIBUTES or TYPE_ATTRIBUTES, as appropriate,
      unless *NO_ADD_ATTRS is set to true (which should be done on error,
      as well as in any other cases when the attributes should not be added
      to the DECL or TYPE).  Depending on FLAGS, any attributes to be
diff -ruN gcc-7.3.0/gcc/tree-dfa.c gcc-7.3.0-msp430/gcc/tree-dfa.c
--- gcc-7.3.0/gcc/tree-dfa.c	2017-01-05 11:32:09.821357000 -0800
+++ gcc-7.3.0-msp430/gcc/tree-dfa.c	2019-06-25 02:27:32.249851663 -0700
@@ -438,7 +438,7 @@
 		   referenced the last field of a struct or a union member
 		   then we have to adjust maxsize by the padding at the end
 		   of our field.  */
-		if (seen_variable_array_ref && maxsize != -1)
+		if (seen_variable_array_ref)
 		  {
 		    tree stype = TREE_TYPE (TREE_OPERAND (exp, 0));
 		    tree next = DECL_CHAIN (field);
@@ -454,7 +454,7 @@
 			    || ssize == NULL
 			    || TREE_CODE (ssize) != INTEGER_CST)
 			  maxsize = -1;
-			else
+			else if (maxsize != -1)
 			  {
 			    offset_int tem = (wi::to_offset (ssize)
 					      - wi::to_offset (fsize));
@@ -463,6 +463,11 @@
 			    maxsize += tem;
 			  }
 		      }
+		    /* An component ref with an adjacent field up in the
+		       structure hierarchy constrains the size of any variable
+		       array ref lower in the access hierarchy.  */
+		    else
+		      seen_variable_array_ref = false;
 		  }
 	      }
 	    else
@@ -617,7 +622,9 @@
 
   if (DECL_P (exp))
     {
-      if (flag_unconstrained_commons && VAR_P (exp) && DECL_COMMON (exp))
+      if (VAR_P (exp)
+	  && ((flag_unconstrained_commons && DECL_COMMON (exp))
+	      || (DECL_EXTERNAL (exp) && seen_variable_array_ref)))
 	{
 	  tree sz_tree = TYPE_SIZE (TREE_TYPE (exp));
 	  /* If size is unknown, or we have read to the end, assume there
diff -ruN gcc-7.3.0/gcc/tree-eh.c gcc-7.3.0-msp430/gcc/tree-eh.c
--- gcc-7.3.0/gcc/tree-eh.c	2017-07-27 00:32:15.405748000 -0700
+++ gcc-7.3.0-msp430/gcc/tree-eh.c	2019-06-25 02:27:32.249851663 -0700
@@ -44,6 +44,7 @@
 #include "cfgloop.h"
 #include "gimple-low.h"
 #include "asan.h"
+#include "gimplify.h"
 
 /* In some instances a tree and a gimple need to be stored in a same table,
    i.e. in hash tables. This is a structure to do this. */
@@ -2438,7 +2439,7 @@
     case ROUND_MOD_EXPR:
     case TRUNC_MOD_EXPR:
     case RDIV_EXPR:
-      if (honor_snans || honor_trapv)
+      if (honor_snans)
 	return true;
       if (fp_operation)
 	return flag_trapping_math;
@@ -2722,6 +2723,91 @@
     }
 }
 
+/* Return non-NULL if there is an integer operation with trapping overflow
+   we can rewrite into non-trapping.  Called via walk_tree from
+   rewrite_to_non_trapping_overflow.  */
+
+static tree
+find_trapping_overflow (tree *tp, int *walk_subtrees, void *data)
+{
+  if (EXPR_P (*tp)
+      && !operation_no_trapping_overflow (TREE_TYPE (*tp), TREE_CODE (*tp)))
+    return *tp;
+  if (IS_TYPE_OR_DECL_P (*tp)
+      || (TREE_CODE (*tp) == SAVE_EXPR && data == NULL))
+    *walk_subtrees = 0;
+  return NULL_TREE;
+}
+
+/* Rewrite selected operations into unsigned arithmetics, so that they
+   don't trap on overflow.  */
+
+static tree
+replace_trapping_overflow (tree *tp, int *walk_subtrees, void *data)
+{
+  if (find_trapping_overflow (tp, walk_subtrees, data))
+    {
+      tree type = TREE_TYPE (*tp);
+      tree utype = unsigned_type_for (type);
+      *walk_subtrees = 0;
+      int len = TREE_OPERAND_LENGTH (*tp);
+      for (int i = 0; i < len; ++i)
+	walk_tree (&TREE_OPERAND (*tp, i), replace_trapping_overflow,
+		   data, (hash_set<tree> *) data);
+
+      if (TREE_CODE (*tp) == ABS_EXPR)
+	{
+	  tree op = TREE_OPERAND (*tp, 0);
+	  op = save_expr (op);
+	  /* save_expr skips simple arithmetics, which is undesirable
+	     here, if it might trap due to flag_trapv.  We need to
+	     force a SAVE_EXPR in the COND_EXPR condition, to evaluate
+	     it before the comparison.  */
+	  if (EXPR_P (op)
+	      && TREE_CODE (op) != SAVE_EXPR
+	      && walk_tree (&op, find_trapping_overflow, NULL, NULL))
+	    {
+	      op = build1_loc (EXPR_LOCATION (op), SAVE_EXPR, type, op);
+	      TREE_SIDE_EFFECTS (op) = 1;
+	    }
+	  /* Change abs (op) to op < 0 ? -op : op and handle the NEGATE_EXPR
+	     like other signed integer trapping operations.  */
+	  tree cond = fold_build2 (LT_EXPR, boolean_type_node,
+				   op, build_int_cst (type, 0));
+	  tree neg = fold_build1 (NEGATE_EXPR, utype,
+				  fold_convert (utype, op));
+	  *tp = fold_build3 (COND_EXPR, type, cond,
+			     fold_convert (type, neg), op);
+	}
+      else
+	{
+	  TREE_TYPE (*tp) = utype;
+	  len = TREE_OPERAND_LENGTH (*tp);
+	  for (int i = 0; i < len; ++i)
+	    TREE_OPERAND (*tp, i)
+	      = fold_convert (utype, TREE_OPERAND (*tp, i));
+	  *tp = fold_convert (type, *tp);
+	}
+    }
+  return NULL_TREE;
+}
+
+/* If any subexpression of EXPR can trap due to -ftrapv, rewrite it
+   using unsigned arithmetics to avoid traps in it.  */
+
+tree
+rewrite_to_non_trapping_overflow (tree expr)
+{
+  if (!flag_trapv)
+    return expr;
+  hash_set<tree> pset;
+  if (!walk_tree (&expr, find_trapping_overflow, &pset, &pset))
+    return expr;
+  expr = unshare_expr (expr);
+  hash_set<tree> pset2;
+  walk_tree (&expr, replace_trapping_overflow, &pset2, &pset2);
+  return expr;
+}
 
 /* Helper for stmt_could_throw_p.  Return true if STMT (assumed to be a
    an assignment or a conditional) may throw.  */
diff -ruN gcc-7.3.0/gcc/tree-eh.h gcc-7.3.0-msp430/gcc/tree-eh.h
--- gcc-7.3.0/gcc/tree-eh.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/tree-eh.h	2019-06-25 02:27:32.249851663 -0700
@@ -37,6 +37,7 @@
 					   bool, tree, bool *);
 extern bool operation_could_trap_p (enum tree_code, bool, bool, tree);
 extern bool tree_could_trap_p (tree);
+extern tree rewrite_to_non_trapping_overflow (tree);
 extern bool stmt_could_throw_p (gimple *);
 extern bool tree_could_throw_p (tree);
 extern bool stmt_can_throw_external (gimple *);
diff -ruN gcc-7.3.0/gcc/tree-emutls.c gcc-7.3.0-msp430/gcc/tree-emutls.c
--- gcc-7.3.0/gcc/tree-emutls.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/tree-emutls.c	2019-06-25 02:27:32.253851633 -0700
@@ -34,6 +34,7 @@
 #include "gimple-walk.h"
 #include "langhooks.h"
 #include "tree-iterator.h"
+#include "gimplify.h"
 
 /* Whenever a target does not support thread-local storage (TLS) natively,
    we can emulate it with some run-time support in libgcc.  This will in
@@ -430,6 +431,20 @@
   return addr;
 }
 
+/* Callback for lower_emutls_1, return non-NULL if there is any TLS
+   VAR_DECL in the subexpressions.  */
+
+static tree
+lower_emutls_2 (tree *ptr, int *walk_subtrees, void *)
+{
+  tree t = *ptr;
+  if (TREE_CODE (t) == VAR_DECL)
+    return DECL_THREAD_LOCAL_P (t) ? t : NULL_TREE;
+  else if (!EXPR_P (t))
+    *walk_subtrees = 0;
+  return NULL_TREE;
+}
+
 /* Callback for walk_gimple_op.  D = WI->INFO is a struct lower_emutls_data.
    Given an operand *PTR within D->STMT, if the operand references a TLS
    variable, then lower the reference to a call to the runtime.  Insert
@@ -456,6 +471,13 @@
 	{
 	  bool save_changed;
 
+	  /* Gimple invariants are shareable trees, so before changing
+	     anything in them if we will need to change anything, unshare
+	     them.  */
+	  if (is_gimple_min_invariant (t)
+	      && walk_tree (&TREE_OPERAND (t, 0), lower_emutls_2, NULL, NULL))
+	    *ptr = t = unshare_expr (t);
+
 	  /* If we're allowed more than just is_gimple_val, continue.  */
 	  if (!wi->val_only)
 	    {
diff -ruN gcc-7.3.0/gcc/tree.h gcc-7.3.0-msp430/gcc/tree.h
--- gcc-7.3.0/gcc/tree.h	2017-11-29 14:13:34.210836000 -0800
+++ gcc-7.3.0-msp430/gcc/tree.h	2019-06-25 02:27:32.257851604 -0700
@@ -4211,29 +4211,8 @@
 					       list);
 }
 
-
-/* This function is a private implementation detail of
-   is_attribute_p() and you should never call it directly.  */
-extern bool private_is_attribute_p (const char *, size_t, const_tree);
-
-/* Given an identifier node IDENT and a string ATTR_NAME, return true
-   if the identifier node is a valid attribute name for the string.
-   ATTR_NAME must be in the form 'text' (not '__text__').  IDENT could
-   be the identifier for 'text' or for '__text__'.  */
-
-static inline bool
-is_attribute_p (const char *attr_name, const_tree ident)
-{
-  gcc_checking_assert (attr_name[0] != '_');
-  /* Do the strlen() before calling the out-of-line implementation.
-     In most cases attr_name is a string constant, and the compiler
-     will optimize the strlen() away.  */
-  return private_is_attribute_p (attr_name, strlen (attr_name), ident);
-}
-
 /* Remove any instances of attribute ATTR_NAME in LIST and return the
-   modified list.  ATTR_NAME must be in the form 'text' (not
-   '__text__').  */
+   modified list.  */
 
 extern tree remove_attribute (const char *, tree);
 
diff -ruN gcc-7.3.0/gcc/tree-if-conv.c gcc-7.3.0-msp430/gcc/tree-if-conv.c
--- gcc-7.3.0/gcc/tree-if-conv.c	2017-10-20 04:19:03.930299000 -0700
+++ gcc-7.3.0-msp430/gcc/tree-if-conv.c	2019-06-25 02:27:32.253851633 -0700
@@ -2248,10 +2248,7 @@
 					 TREE_OPERAND (cond, 0),
 					 TREE_OPERAND (cond, 1));
 		  else
-		    {
-		      gcc_assert (TREE_CODE (cond) == SSA_NAME);
-		      mask = cond;
-		    }
+		    mask = cond;
 
 		  if (swap)
 		    {
diff -ruN gcc-7.3.0/gcc/tree-inline.c gcc-7.3.0-msp430/gcc/tree-inline.c
--- gcc-7.3.0/gcc/tree-inline.c	2017-10-27 13:33:35.593168000 -0700
+++ gcc-7.3.0-msp430/gcc/tree-inline.c	2019-06-25 02:27:32.253851633 -0700
@@ -57,7 +57,8 @@
 #include "cfgloop.h"
 #include "builtins.h"
 #include "tree-chkp.h"
-
+#include "stringpool.h"
+#include "attribs.h"
 
 /* I'm not real happy about this, but we need to handle gimple and
    non-gimple trees.  */
@@ -1182,6 +1183,7 @@
 	      *tp = gimple_fold_indirect_ref (ptr);
 	      if (! *tp)
 	        {
+		  type = remap_type (type, id);
 		  if (TREE_CODE (ptr) == ADDR_EXPR)
 		    {
 		      *tp
@@ -6024,6 +6026,25 @@
       = copy_arguments_for_versioning (DECL_ARGUMENTS (old_decl), &id,
 				       args_to_skip, &vars);
 
+  /* Remove omp declare simd attribute from the new attributes.  */
+  if (tree a = lookup_attribute ("omp declare simd",
+				 DECL_ATTRIBUTES (new_decl)))
+    {
+      while (tree a2 = lookup_attribute ("omp declare simd", TREE_CHAIN (a)))
+	a = a2;
+      a = TREE_CHAIN (a);
+      for (tree *p = &DECL_ATTRIBUTES (new_decl); *p != a;)
+	if (is_attribute_p ("omp declare simd", get_attribute_name (*p)))
+	  *p = TREE_CHAIN (*p);
+	else
+	  {
+	    tree chain = TREE_CHAIN (*p);
+	    *p = copy_node (*p);
+	    p = &TREE_CHAIN (*p);
+	    *p = chain;
+	  }
+    }
+
   DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.src_fn), &id);
   BLOCK_SUPERCONTEXT (DECL_INITIAL (new_decl)) = new_decl;
 
diff -ruN gcc-7.3.0/gcc/tree-ssa.c gcc-7.3.0-msp430/gcc/tree-ssa.c
--- gcc-7.3.0/gcc/tree-ssa.c	2017-03-28 10:24:57.120673000 -0700
+++ gcc-7.3.0-msp430/gcc/tree-ssa.c	2019-06-25 02:27:32.253851633 -0700
@@ -1423,7 +1423,8 @@
       if (! DECL_P (decl))
 	return NULL_TREE;
       if (! is_gimple_reg_type (TREE_TYPE (base))
-	  || VOID_TYPE_P (TREE_TYPE (base)))
+	  || VOID_TYPE_P (TREE_TYPE (base))
+	  || TREE_THIS_VOLATILE (decl) != TREE_THIS_VOLATILE (base))
 	return decl;
       if ((TREE_CODE (TREE_TYPE (decl)) == VECTOR_TYPE
 	   || TREE_CODE (TREE_TYPE (decl)) == COMPLEX_TYPE)
diff -ruN gcc-7.3.0/gcc/tree-ssa-loop-niter.c gcc-7.3.0-msp430/gcc/tree-ssa-loop-niter.c
--- gcc-7.3.0/gcc/tree-ssa-loop-niter.c	2017-07-25 01:56:26.467528000 -0700
+++ gcc-7.3.0-msp430/gcc/tree-ssa-loop-niter.c	2019-06-25 02:27:32.253851633 -0700
@@ -2320,11 +2320,11 @@
 
   tree iv0_niters = NULL_TREE;
   if (!simple_iv_with_niters (loop, loop_containing_stmt (stmt),
-			      op0, &iv0, &iv0_niters, false))
+			      op0, &iv0, safe ? &iv0_niters : NULL, false))
     return false;
   tree iv1_niters = NULL_TREE;
   if (!simple_iv_with_niters (loop, loop_containing_stmt (stmt),
-			      op1, &iv1, &iv1_niters, false))
+			      op1, &iv1, safe ? &iv1_niters : NULL, false))
     return false;
   /* Give up on complicated case.  */
   if (iv0_niters && iv1_niters)
diff -ruN gcc-7.3.0/gcc/tree-ssa-phiprop.c gcc-7.3.0-msp430/gcc/tree-ssa-phiprop.c
--- gcc-7.3.0/gcc/tree-ssa-phiprop.c	2017-12-15 00:12:10.699115000 -0800
+++ gcc-7.3.0-msp430/gcc/tree-ssa-phiprop.c	2019-06-25 02:27:32.253851633 -0700
@@ -270,6 +270,7 @@
   use_operand_p arg_p, use;
   ssa_op_iter i;
   bool phi_inserted;
+  bool changed;
   tree type = NULL_TREE;
 
   if (!POINTER_TYPE_P (TREE_TYPE (ptr))
@@ -317,6 +318,7 @@
   /* Replace the first dereference of *ptr if there is one and if we
      can move the loads to the place of the ptr phi node.  */
   phi_inserted = false;
+  changed = false;
   FOR_EACH_IMM_USE_STMT (use_stmt, ui, ptr)
     {
       gimple *def_stmt;
@@ -403,7 +405,7 @@
 	  unlink_stmt_vdef (use_stmt);
 	  gsi_remove (&gsi, true);
 
-	  phi_inserted = true;
+	  changed = true;
 	}
 
       /* Found a proper dereference.  Insert a phi node if this
@@ -424,6 +426,7 @@
 	  gsi_remove (&gsi, true);
 
 	  phi_inserted = true;
+	  changed = true;
 	}
       else
 	{
@@ -431,13 +434,14 @@
 	     load.  */
 	  gimple_assign_set_rhs1 (use_stmt, res);
 	  update_stmt (use_stmt);
+	  changed = true;
 	}
 
 next:;
       /* Continue searching for a proper dereference.  */
     }
 
-  return phi_inserted;
+  return changed;
 }
 
 /* Main entry for phiprop pass.  */
diff -ruN gcc-7.3.0/gcc/tree-ssa-pre.c gcc-7.3.0-msp430/gcc/tree-ssa-pre.c
--- gcc-7.3.0/gcc/tree-ssa-pre.c	2017-12-15 12:45:36.126255000 -0800
+++ gcc-7.3.0-msp430/gcc/tree-ssa-pre.c	2019-06-25 02:27:32.253851633 -0700
@@ -2787,11 +2787,7 @@
 	  unsigned int operand = 1;
 	  vn_reference_op_t currop = &ref->operands[0];
 	  tree sc = NULL_TREE;
-	  tree fn;
-	  if (TREE_CODE (currop->op0) == FUNCTION_DECL)
-	    fn = currop->op0;
-	  else
-	    fn = find_or_generate_expression (block, currop->op0, stmts);
+	  tree fn  = find_or_generate_expression (block, currop->op0, stmts);
 	  if (!fn)
 	    return NULL_TREE;
 	  if (currop->op1)
@@ -2809,14 +2805,27 @@
 		return NULL_TREE;
 	      args.quick_push (arg);
 	    }
-	  gcall *call
-	    = gimple_build_call_vec ((TREE_CODE (fn) == FUNCTION_DECL
-				      ? build_fold_addr_expr (fn) : fn), args);
+	  gcall *call = gimple_build_call_vec (fn, args);
 	  gimple_call_set_with_bounds (call, currop->with_bounds);
 	  if (sc)
 	    gimple_call_set_chain (call, sc);
 	  tree forcedname = make_ssa_name (currop->type);
 	  gimple_call_set_lhs (call, forcedname);
+	  /* There's no CCP pass after PRE which would re-compute alignment
+	     information so make sure we re-materialize this here.  */
+	  if (gimple_call_builtin_p (call, BUILT_IN_ASSUME_ALIGNED)
+	      && args.length () - 2 <= 1
+	      && tree_fits_uhwi_p (args[1])
+	      && (args.length () != 3 || tree_fits_uhwi_p (args[2])))
+	    {
+	      unsigned HOST_WIDE_INT halign = tree_to_uhwi (args[1]);
+	      unsigned HOST_WIDE_INT hmisalign
+		= args.length () == 3 ? tree_to_uhwi (args[2]) : 0;
+	      if ((halign & (halign - 1)) == 0
+		  && (hmisalign & ~(halign - 1)) == 0)
+		set_ptr_info_alignment (get_ptr_info (forcedname),
+					halign, hmisalign);
+	    }
 	  gimple_set_vuse (call, BB_LIVE_VOP_ON_EXIT (block));
 	  gimple_seq_add_stmt_without_update (&forced_stmts, call);
 	  folded = forcedname;
diff -ruN gcc-7.3.0/gcc/tree-ssa-reassoc.c gcc-7.3.0-msp430/gcc/tree-ssa-reassoc.c
--- gcc-7.3.0/gcc/tree-ssa-reassoc.c	2017-08-01 01:43:45.376098000 -0700
+++ gcc-7.3.0-msp430/gcc/tree-ssa-reassoc.c	2019-06-25 02:27:32.253851633 -0700
@@ -470,7 +470,8 @@
 
 /* We want integer ones to end up last no matter what, since they are
    the ones we can do the most with.  */
-#define INTEGER_CONST_TYPE 1 << 3
+#define INTEGER_CONST_TYPE 1 << 4
+#define FLOAT_ONE_CONST_TYPE 1 << 3
 #define FLOAT_CONST_TYPE 1 << 2
 #define OTHER_CONST_TYPE 1 << 1
 
@@ -482,7 +483,14 @@
   if (INTEGRAL_TYPE_P (TREE_TYPE (t)))
     return INTEGER_CONST_TYPE;
   else if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (t)))
-    return FLOAT_CONST_TYPE;
+    {
+      /* Sort -1.0 and 1.0 constants last, while in some cases
+	 const_binop can't optimize some inexact operations, multiplication
+	 by -1.0 or 1.0 can be always merged with others.  */
+      if (real_onep (t) || real_minus_onep (t))
+	return FLOAT_ONE_CONST_TYPE;
+      return FLOAT_CONST_TYPE;
+    }
   else
     return OTHER_CONST_TYPE;
 }
@@ -501,7 +509,7 @@
   if (oeb->rank == 0 && oea->rank == 0)
     {
       if (constant_type (oeb->op) != constant_type (oea->op))
-	return constant_type (oeb->op) - constant_type (oea->op);
+	return constant_type (oea->op) - constant_type (oeb->op);
       else
 	/* To make sorting result stable, we use unique IDs to determine
 	   order.  */
@@ -2870,7 +2878,8 @@
 static bool
 optimize_range_tests_var_bound (enum tree_code opcode, int first, int length,
 				vec<operand_entry *> *ops,
-				struct range_entry *ranges)
+				struct range_entry *ranges,
+				basic_block first_bb)
 {
   int i;
   bool any_changes = false;
@@ -2967,6 +2976,60 @@
       if (idx == NULL)
 	continue;
 
+      /* maybe_optimize_range_tests allows statements without side-effects
+	 in the basic blocks as long as they are consumed in the same bb.
+	 Make sure rhs2's def stmt is not among them, otherwise we can't
+	 use safely get_nonzero_bits on it.  E.g. in:
+	  # RANGE [-83, 1] NONZERO 173
+	  # k_32 = PHI <k_47(13), k_12(9)>
+	 ...
+	  if (k_32 >= 0)
+	    goto <bb 5>; [26.46%]
+	  else
+	    goto <bb 9>; [73.54%]
+
+	  <bb 5> [local count: 140323371]:
+	  # RANGE [0, 1] NONZERO 1
+	  _5 = (int) k_32;
+	  # RANGE [0, 4] NONZERO 4
+	  _21 = _5 << 2;
+	  # RANGE [0, 4] NONZERO 4
+	  iftmp.0_44 = (char) _21;
+	  if (k_32 < iftmp.0_44)
+	    goto <bb 6>; [84.48%]
+	  else
+	    goto <bb 9>; [15.52%]
+	 the ranges on _5/_21/iftmp.0_44 are flow sensitive, assume that
+	 k_32 >= 0.  If we'd optimize k_32 >= 0 to true and k_32 < iftmp.0_44
+	 to (unsigned) k_32 < (unsigned) iftmp.0_44, then we would execute
+	 those stmts even for negative k_32 and the value ranges would be no
+	 longer guaranteed and so the optimization would be invalid.  */
+      if (opcode == ERROR_MARK)
+	{
+	  gimple *g = SSA_NAME_DEF_STMT (rhs2);
+	  basic_block bb2 = gimple_bb (g);
+	  if (bb2
+	      && bb2 != first_bb
+	      && dominated_by_p (CDI_DOMINATORS, bb2, first_bb))
+	    {
+	      /* As an exception, handle a few common cases.  */
+	      if (gimple_assign_cast_p (g)
+		  && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (g)))
+		  && TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (g)))
+		  && (TYPE_PRECISION (TREE_TYPE (rhs2))
+		      > TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (g)))))
+		/* Zero-extension is always ok.  */ ;
+	      else if (is_gimple_assign (g)
+		       && gimple_assign_rhs_code (g) == BIT_AND_EXPR
+		       && TREE_CODE (gimple_assign_rhs2 (g)) == INTEGER_CST
+		       && !wi::neg_p (gimple_assign_rhs2 (g)))
+		/* Masking with INTEGER_CST with MSB clear is always ok
+		   too.  */ ;
+	      else
+		continue;
+	    }
+	}
+
       wide_int nz = get_nonzero_bits (rhs2);
       if (wi::neg_p (nz))
 	continue;
@@ -3093,11 +3156,12 @@
    maybe_optimize_range_tests for inter-bb range optimization.
    In that case if oe->op is NULL, oe->id is bb->index whose
    GIMPLE_COND is && or ||ed into the test, and oe->rank says
-   the actual opcode.  */
+   the actual opcode.
+   FIRST_BB is the first basic block if OPCODE is ERROR_MARK.  */
 
 static bool
 optimize_range_tests (enum tree_code opcode,
-		      vec<operand_entry *> *ops)
+		      vec<operand_entry *> *ops, basic_block first_bb)
 {
   unsigned int length = ops->length (), i, j, first;
   operand_entry *oe;
@@ -3175,7 +3239,7 @@
     any_changes |= optimize_range_tests_to_bit_test (opcode, first, length,
 						     ops, ranges);
   any_changes |= optimize_range_tests_var_bound (opcode, first, length, ops,
-						 ranges);
+						 ranges, first_bb);
 
   if (any_changes && opcode != ERROR_MARK)
     {
@@ -3922,7 +3986,7 @@
 	break;
     }
   if (ops.length () > 1)
-    any_changes = optimize_range_tests (ERROR_MARK, &ops);
+    any_changes = optimize_range_tests (ERROR_MARK, &ops, first_bb);
   if (any_changes)
     {
       unsigned int idx, max_idx = 0;
@@ -5674,7 +5738,7 @@
 		  if (is_vector)
 		    optimize_vec_cond_expr (rhs_code, &ops);
 		  else
-		    optimize_range_tests (rhs_code, &ops);
+		    optimize_range_tests (rhs_code, &ops, NULL);
 	        }
 
 	      if (rhs_code == MULT_EXPR && !is_vector)
diff -ruN gcc-7.3.0/gcc/tree-ssa-sccvn.c gcc-7.3.0-msp430/gcc/tree-ssa-sccvn.c
--- gcc-7.3.0/gcc/tree-ssa-sccvn.c	2017-11-15 04:50:39.715429000 -0800
+++ gcc-7.3.0-msp430/gcc/tree-ssa-sccvn.c	2019-06-25 02:27:32.253851633 -0700
@@ -1245,7 +1245,9 @@
 	  return true;
 	}
       if (!addr_base
-	  || TREE_CODE (addr_base) != MEM_REF)
+	  || TREE_CODE (addr_base) != MEM_REF
+	  || (TREE_CODE (TREE_OPERAND (addr_base, 0)) == SSA_NAME
+	      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (addr_base, 0))))
 	return false;
 
       off += addr_offset;
@@ -1258,6 +1260,7 @@
       ptr = gimple_assign_rhs1 (def_stmt);
       ptroff = gimple_assign_rhs2 (def_stmt);
       if (TREE_CODE (ptr) != SSA_NAME
+	  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ptr)
 	  || TREE_CODE (ptroff) != INTEGER_CST)
 	return false;
 
@@ -1978,8 +1981,9 @@
 	  if (TREE_CODE (rhs) == SSA_NAME)
 	    rhs = SSA_VAL (rhs);
 	  len = native_encode_expr (gimple_assign_rhs1 (def_stmt),
-				    buffer, sizeof (buffer));
-	  if (len > 0)
+				    buffer, sizeof (buffer),
+				    (offset - offset2) / BITS_PER_UNIT);
+	  if (len > 0 && len * BITS_PER_UNIT >= ref->size)
 	    {
 	      tree type = vr->type;
 	      /* Make sure to interpret in a type that has a range
@@ -1988,10 +1992,7 @@
 		  && ref->size != TYPE_PRECISION (vr->type))
 		type = build_nonstandard_integer_type (ref->size,
 						       TYPE_UNSIGNED (type));
-	      tree val = native_interpret_expr (type,
-						buffer
-						+ ((offset - offset2)
-						   / BITS_PER_UNIT),
+	      tree val = native_interpret_expr (type, buffer,
 						ref->size / BITS_PER_UNIT);
 	      /* If we chop off bits because the types precision doesn't
 		 match the memory access size this is ok when optimizing
diff -ruN gcc-7.3.0/gcc/tree-ssa-tail-merge.c gcc-7.3.0-msp430/gcc/tree-ssa-tail-merge.c
--- gcc-7.3.0/gcc/tree-ssa-tail-merge.c	2017-07-03 01:32:20.444245000 -0700
+++ gcc-7.3.0-msp430/gcc/tree-ssa-tail-merge.c	2019-06-25 02:27:32.253851633 -0700
@@ -1454,7 +1454,8 @@
       /* TODO: handle blocks with phi-nodes.  We'll have to find corresponding
 	 phi-nodes in bb1 and bb2, with the same alternatives for the same
 	 preds.  */
-      if (bb_has_non_vop_phi (bb1) || bb_has_eh_pred (bb1))
+      if (bb_has_non_vop_phi (bb1) || bb_has_eh_pred (bb1)
+	  || bb_has_abnormal_pred (bb1))
 	continue;
 
       nr_comparisons = 0;
@@ -1462,7 +1463,8 @@
 	{
 	  bb2 = BASIC_BLOCK_FOR_FN (cfun, j);
 
-	  if (bb_has_non_vop_phi (bb2) || bb_has_eh_pred (bb2))
+	  if (bb_has_non_vop_phi (bb2) || bb_has_eh_pred (bb2)
+	      || bb_has_abnormal_pred (bb2))
 	    continue;
 
 	  if (BB_CLUSTER (bb1) != NULL && BB_CLUSTER (bb1) == BB_CLUSTER (bb2))
diff -ruN gcc-7.3.0/gcc/tree-tailcall.c gcc-7.3.0-msp430/gcc/tree-tailcall.c
--- gcc-7.3.0/gcc/tree-tailcall.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/gcc/tree-tailcall.c	2019-06-25 02:27:32.253851633 -0700
@@ -473,7 +473,7 @@
     {
       tree arg;
 
-      for (param = DECL_ARGUMENTS (func), idx = 0;
+      for (param = DECL_ARGUMENTS (current_function_decl), idx = 0;
 	   param && idx < gimple_call_num_args (call);
 	   param = DECL_CHAIN (param), idx ++)
 	{
diff -ruN gcc-7.3.0/gcc/tree-vect-data-refs.c gcc-7.3.0-msp430/gcc/tree-vect-data-refs.c
--- gcc-7.3.0/gcc/tree-vect-data-refs.c	2017-06-07 06:07:06.244562000 -0700
+++ gcc-7.3.0-msp430/gcc/tree-vect-data-refs.c	2019-06-25 02:27:32.253851633 -0700
@@ -394,6 +394,16 @@
 		}
 	    }
 
+	  unsigned int step_prec = TYPE_PRECISION (TREE_TYPE (DR_STEP (dra)));
+	  if (loop->safelen < 2
+	      && !expr_not_equal_to (DR_STEP (dra), wi::zero (step_prec)))
+	    {
+	      if (dump_enabled_p ())
+		dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+				 "step could be zero.\n");
+	      return true;
+	    }
+
 	  continue;
 	}
 
@@ -2515,7 +2525,7 @@
       /* Allow references with zero step for outer loops marked
 	 with pragma omp simd only - it guarantees absence of
 	 loop-carried dependencies between inner loop iterations.  */
-      if (!loop->force_vectorize)
+      if (!loop->force_vectorize || loop->safelen < 2)
 	{
 	  if (dump_enabled_p ())
 	    dump_printf_loc (MSG_NOTE, vect_location,
diff -ruN gcc-7.3.0/gcc/tree-vect-loop.c gcc-7.3.0-msp430/gcc/tree-vect-loop.c
--- gcc-7.3.0/gcc/tree-vect-loop.c	2017-12-15 14:12:46.166944000 -0800
+++ gcc-7.3.0-msp430/gcc/tree-vect-loop.c	2019-06-25 02:27:32.257851604 -0700
@@ -50,6 +50,7 @@
 #include "cgraph.h"
 #include "tree-cfg.h"
 #include "tree-if-conv.h"
+#include "tree-eh.h"
 
 /* Loop Vectorization Pass.
 
@@ -1055,7 +1056,8 @@
 							  may_be_zero));
 	  else
 	    niter = fold_build3 (COND_EXPR, TREE_TYPE (niter), may_be_zero,
-				 build_int_cst (TREE_TYPE (niter), 0), niter);
+				 build_int_cst (TREE_TYPE (niter), 0),
+				 rewrite_to_non_trapping_overflow (niter));
 
 	  may_be_zero = NULL_TREE;
 	}
diff -ruN gcc-7.3.0/gcc/tree-vect-stmts.c gcc-7.3.0-msp430/gcc/tree-vect-stmts.c
--- gcc-7.3.0/gcc/tree-vect-stmts.c	2017-09-18 03:13:54.724995000 -0700
+++ gcc-7.3.0-msp430/gcc/tree-vect-stmts.c	2019-06-25 02:27:32.257851604 -0700
@@ -2753,7 +2753,7 @@
       if (cfn != CFN_LAST)
 	fndecl = targetm.vectorize.builtin_vectorized_function
 	  (cfn, vectype_out, vectype_in);
-      else
+      else if (callee)
 	fndecl = targetm.vectorize.builtin_md_vectorized_function
 	  (callee, vectype_out, vectype_in);
     }
@@ -5479,15 +5479,34 @@
       /* Handle uses.  */
       if (j == 0)
 	{
-	  if (op_type == binary_op || op_type == ternary_op)
+	  if (op_type == binary_op)
 	    vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,
 			       slp_node, -1);
+	  else if (op_type == ternary_op)
+	    {
+	      if (slp_node)
+		{
+		  auto_vec<tree> ops(3);
+		  ops.quick_push (op0);
+		  ops.quick_push (op1);
+		  ops.quick_push (op2);
+		  auto_vec<vec<tree> > vec_defs(3);
+		  vect_get_slp_defs (ops, slp_node, &vec_defs, -1);
+		  vec_oprnds0 = vec_defs[0];
+		  vec_oprnds1 = vec_defs[1];
+		  vec_oprnds2 = vec_defs[2];
+		}
+	      else
+		{ 
+		  vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,
+				     NULL, -1);
+		  vect_get_vec_defs (op2, NULL_TREE, stmt, &vec_oprnds2, NULL,
+				     NULL, -1);
+		}
+	    }
 	  else
 	    vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,
 			       slp_node, -1);
-	  if (op_type == ternary_op)
-	    vect_get_vec_defs (op2, NULL_TREE, stmt, &vec_oprnds2, NULL,
-			       slp_node, -1);
 	}
       else
 	{
diff -ruN gcc-7.3.0/gcc/tree-vrp.c gcc-7.3.0-msp430/gcc/tree-vrp.c
--- gcc-7.3.0/gcc/tree-vrp.c	2017-09-26 03:16:40.635453000 -0700
+++ gcc-7.3.0-msp430/gcc/tree-vrp.c	2019-06-25 02:27:32.257851604 -0700
@@ -8671,9 +8671,9 @@
 	  if (TREE_CODE (*vr0min) == INTEGER_CST)
 	    {
 	      *vr0type = vr1type;
-	      *vr0min = vr1min;
 	      *vr0max = int_const_binop (MINUS_EXPR, *vr0min,
 					 build_int_cst (TREE_TYPE (*vr0min), 1));
+	      *vr0min = vr1min;
 	    }
 	  else
 	    goto give_up;
diff -ruN gcc-7.3.0/gcc/varasm.c gcc-7.3.0-msp430/gcc/varasm.c
--- gcc-7.3.0/gcc/varasm.c	2017-12-15 00:12:10.699115000 -0800
+++ gcc-7.3.0-msp430/gcc/varasm.c	2019-06-25 02:27:32.257851604 -0700
@@ -1241,10 +1241,9 @@
   if (!VAR_P (decl) && TREE_CODE (decl) != CONST_DECL)
     return false;
 
-  /* Detect decls created by dw2_force_const_mem.  Such decls are
-     special because DECL_INITIAL doesn't specify the decl's true value.
-     dw2_output_indirect_constants will instead call assemble_variable
-     with dont_output_data set to 1 and then print the contents itself.  */
+  /* DECL_INITIAL (decl) set to decl is a hack used for some decls that
+     are never used from code directly and we never want object block handling
+     for those.  */
   if (DECL_INITIAL (decl) == decl)
     return false;
 
diff -ruN gcc-7.3.0/libada/ChangeLog gcc-7.3.0-msp430/libada/ChangeLog
--- gcc-7.3.0/libada/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libada/ChangeLog	2019-06-25 02:27:32.257851604 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libada/configure gcc-7.3.0-msp430/libada/configure
--- gcc-7.3.0/libada/configure	2017-06-01 03:51:50.257915000 -0700
+++ gcc-7.3.0-msp430/libada/configure	2019-06-25 02:27:32.257851604 -0700
@@ -3018,7 +3018,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libatomic/ChangeLog gcc-7.3.0-msp430/libatomic/ChangeLog
--- gcc-7.3.0/libatomic/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libatomic/ChangeLog	2019-06-25 02:27:32.257851604 -0700
@@ -1,3 +1,19 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-03-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/exch_n.c: New file.
+	* configure.tgt: Add the config directory for s390.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libatomic/configure gcc-7.3.0-msp430/libatomic/configure
--- gcc-7.3.0/libatomic/configure	2018-01-25 00:17:54.135232057 -0800
+++ gcc-7.3.0-msp430/libatomic/configure	2019-06-25 02:27:32.261851577 -0700
@@ -12333,6 +12333,7 @@
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load/store for size 2" >&5
 $as_echo_n "checking for __atomic_load/store for size 2... " >&6; }
 if test "${libat_cv_have_at_ldst_2+set}" = set; then :
@@ -12400,6 +12401,7 @@
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load/store for size 4" >&5
 $as_echo_n "checking for __atomic_load/store for size 4... " >&6; }
 if test "${libat_cv_have_at_ldst_4+set}" = set; then :
@@ -12467,6 +12469,7 @@
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load/store for size 8" >&5
 $as_echo_n "checking for __atomic_load/store for size 8... " >&6; }
 if test "${libat_cv_have_at_ldst_8+set}" = set; then :
@@ -12534,6 +12537,7 @@
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load/store for size 16" >&5
 $as_echo_n "checking for __atomic_load/store for size 16... " >&6; }
 if test "${libat_cv_have_at_ldst_16+set}" = set; then :
@@ -12602,6 +12606,7 @@
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_test_and_set for size 1" >&5
 $as_echo_n "checking for __atomic_test_and_set for size 1... " >&6; }
 if test "${libat_cv_have_at_tas_1+set}" = set; then :
@@ -15267,7 +15272,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libatomic/configure.tgt gcc-7.3.0-msp430/libatomic/configure.tgt
--- gcc-7.3.0/libatomic/configure.tgt	2017-02-06 13:38:57.075886000 -0800
+++ gcc-7.3.0-msp430/libatomic/configure.tgt	2019-06-25 02:27:32.261851577 -0700
@@ -114,6 +114,11 @@
 	config_path="${config_path} linux/arm posix"
 	;;
 
+  s390*-*-linux*)
+	# OS support for atomic primitives.
+	config_path="${config_path} s390 posix"
+	;;
+
   *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu \
   | *-*-netbsd* | *-*-freebsd* | *-*-openbsd* | *-*-dragonfly* \
   | *-*-solaris2* | *-*-sysv4* | *-*-irix6* | *-*-osf* | *-*-hpux11* \
diff -ruN gcc-7.3.0/libcc1/ChangeLog gcc-7.3.0-msp430/libcc1/ChangeLog
--- gcc-7.3.0/libcc1/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libcc1/ChangeLog	2019-06-25 02:27:32.261851577 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libcc1/configure gcc-7.3.0-msp430/libcc1/configure
--- gcc-7.3.0/libcc1/configure	2017-01-17 01:38:48.048122000 -0800
+++ gcc-7.3.0-msp430/libcc1/configure	2019-06-25 02:27:32.261851577 -0700
@@ -14315,7 +14315,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libcilkrts/ChangeLog gcc-7.3.0-msp430/libcilkrts/ChangeLog
--- gcc-7.3.0/libcilkrts/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libcilkrts/ChangeLog	2019-06-25 02:27:32.261851577 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libcilkrts/configure gcc-7.3.0-msp430/libcilkrts/configure
--- gcc-7.3.0/libcilkrts/configure	2017-01-17 01:38:48.048122000 -0800
+++ gcc-7.3.0-msp430/libcilkrts/configure	2019-06-25 02:27:32.261851577 -0700
@@ -15413,7 +15413,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libcpp/ChangeLog gcc-7.3.0-msp430/libcpp/ChangeLog
--- gcc-7.3.0/libcpp/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libcpp/ChangeLog	2019-06-25 02:27:32.261851577 -0700
@@ -1,3 +1,19 @@
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-01-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/69869
+	* traditional.c (skip_macro_block_comment): Return bool, true if
+	the macro block comment is unterminated.
+	(copy_comment): Use return value from skip_macro_block_comment instead
+	of always false.
+
+	2018-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* include/cpplib.h (enum cpp_builtin_type): Change BT_LAST_USER from
+	BT_FIRST_USER + 31 to BT_FIRST_USER + 63.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libcpp/include/cpplib.h gcc-7.3.0-msp430/libcpp/include/cpplib.h
--- gcc-7.3.0/libcpp/include/cpplib.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libcpp/include/cpplib.h	2019-06-25 02:27:32.261851577 -0700
@@ -702,7 +702,7 @@
   BT_COUNTER,			/* `__COUNTER__' */
   BT_HAS_ATTRIBUTE,		/* `__has_attribute__(x)' */
   BT_FIRST_USER,		/* User defined builtin macros.  */
-  BT_LAST_USER = BT_FIRST_USER + 31
+  BT_LAST_USER = BT_FIRST_USER + 63
 };
 
 #define CPP_HASHNODE(HNODE)	((cpp_hashnode *) (HNODE))
diff -ruN gcc-7.3.0/libcpp/lex.c gcc-7.3.0-msp430/libcpp/lex.c
--- gcc-7.3.0/libcpp/lex.c	2018-01-05 05:58:54.564962000 -0800
+++ gcc-7.3.0-msp430/libcpp/lex.c	2019-06-25 02:27:32.265851547 -0700
@@ -568,7 +568,7 @@
     {
       vc m_nl, m_cr, m_bs, m_qm;
 
-      data = *((const vc *)s);
+      data = __builtin_vec_vsx_ld (0, s);
       s += 16;
 
       m_nl = (vc) __builtin_vec_cmpeq(data, repl_nl);
diff -ruN gcc-7.3.0/libcpp/traditional.c gcc-7.3.0-msp430/libcpp/traditional.c
--- gcc-7.3.0/libcpp/traditional.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libcpp/traditional.c	2019-06-25 02:27:32.265851547 -0700
@@ -119,8 +119,11 @@
 }
 
 /* Skip a C-style block comment in a macro as a result of -CC.
-   Buffer->cur points to the initial asterisk of the comment.  */
-static void
+   PFILE->buffer->cur points to the initial asterisk of the comment,
+   change it to point to after the '*' and '/' characters that terminate it.
+   Return true if the macro has not been termined, in that case set
+   PFILE->buffer->cur to the end of the buffer.  */
+static bool
 skip_macro_block_comment (cpp_reader *pfile)
 {
   const uchar *cur = pfile->buffer->cur;
@@ -131,10 +134,15 @@
 
   /* People like decorating comments with '*', so check for '/'
      instead for efficiency.  */
-  while(! (*cur++ == '/' && cur[-2] == '*') )
-    ;
+  while (! (*cur++ == '/' && cur[-2] == '*'))
+    if (cur[-1] == '\n')
+      {
+	pfile->buffer->cur = cur - 1;
+	return true;
+      }
 
   pfile->buffer->cur = cur;
+  return false;
 }
 
 /* CUR points to the asterisk introducing a comment in the current
@@ -158,7 +166,7 @@
 
   buffer->cur = cur;
   if (pfile->context->prev)
-    unterminated = false, skip_macro_block_comment (pfile);
+    unterminated = skip_macro_block_comment (pfile);
   else
     unterminated = _cpp_skip_block_comment (pfile);
     
diff -ruN gcc-7.3.0/libffi/ChangeLog gcc-7.3.0-msp430/libffi/ChangeLog
--- gcc-7.3.0/libffi/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libffi/ChangeLog	2019-06-25 02:27:32.265851547 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libffi/configure gcc-7.3.0-msp430/libffi/configure
--- gcc-7.3.0/libffi/configure	2018-01-25 00:17:54.047232054 -0800
+++ gcc-7.3.0-msp430/libffi/configure	2019-06-25 02:27:32.265851547 -0700
@@ -16444,7 +16444,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libgcc/ChangeLog gcc-7.3.0-msp430/libgcc/ChangeLog
--- gcc-7.3.0/libgcc/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libgcc/ChangeLog	2019-06-25 02:27:32.265851547 -0700
@@ -1,3 +1,69 @@
+2018-08-17  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-08-11  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/linux-atomic.c: Update comment.
+	(FETCH_AND_OP_2, OP_AND_FETCH_2, FETCH_AND_OP_WORD, OP_AND_FETCH_WORD,
+	COMPARE_AND_SWAP_2, __sync_val_compare_and_swap_4,
+	SYNC_LOCK_TEST_AND_SET_2, __sync_lock_test_and_set_4): Use
+	__ATOMIC_RELAXED for atomic loads.
+	(SYNC_LOCK_RELEASE_1): New define.  Use __sync_synchronize() and
+	unordered store to release lock.
+	(__sync_lock_release_8): Likewise.
+	(SYNC_LOCK_RELEASE_2): Remove define.
+	 
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2018-05-17  Jerome Lambourg  <lambourg@adacore.com>
+
+	* config/arm/cmse.c (cmse_check_address_range): Replace
+	UINTPTR_MAX with __UINTPTR_MAX__ and uintptr_t with __UINTPTR_TYPE__.
+
+2018-04-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-03-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/85100
+	* config/i386/cpuinfo.c (XCR_XFEATURE_ENABLED_MASK): New.
+	(XSTATE_FP): Likewise.
+	(XSTATE_SSE): Likewise.
+	(XSTATE_YMM): Likewise.
+	(XSTATE_OPMASK): Likewise.
+	(XSTATE_ZMM): Likewise.
+	(XSTATE_HI_ZMM): Likewise.
+	(XCR_AVX_ENABLED_MASK): Likewise.
+	(XCR_AVX512F_ENABLED_MASK): Likewise.
+	(get_available_features): Enable AVX and AVX512 features only
+	if their states are supported by OSXSAVE.
+
+2018-03-11  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-03-06  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/fptr.c (_dl_read_access_allowed): New.
+	(__canonicalize_funcptr_for_compare): Use it.
+	
+2018-02-20  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	2018-02-20  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/ieee754-df.S (__adddf3_aux): Add
+	.literal_position directive.
+	* config/xtensa/ieee754-sf.S (__addsf3_aux): Likewise.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libgcc/config/arm/cmse.c gcc-7.3.0-msp430/libgcc/config/arm/cmse.c
--- gcc-7.3.0/libgcc/config/arm/cmse.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libgcc/config/arm/cmse.c	2019-06-25 02:27:32.265851547 -0700
@@ -36,7 +36,7 @@
   char *pb = (char *) p, *pe;
 
   /* Check if the range wraps around.  */
-  if (UINTPTR_MAX - (uintptr_t) p < size)
+  if (__UINTPTR_MAX__ - (__UINTPTR_TYPE__) p < size)
     return NULL;
 
   /* Check if an unknown flag is present.  */
@@ -51,7 +51,8 @@
 
   /* Execute the right variant of the TT instructions.  */
   pe = pb + size - 1;
-  const int singleCheck = (((uintptr_t) pb ^ (uintptr_t) pe) < 32);
+  const int singleCheck
+    = (((__UINTPTR_TYPE__) pb ^ (__UINTPTR_TYPE__) pe) < 32);
   switch (flags & known_secure_level)
     {
     case 0:
diff -ruN gcc-7.3.0/libgcc/config/i386/cpuinfo.c gcc-7.3.0-msp430/libgcc/config/i386/cpuinfo.c
--- gcc-7.3.0/libgcc/config/i386/cpuinfo.c	2017-01-12 09:30:03.499113000 -0800
+++ gcc-7.3.0-msp430/libgcc/config/i386/cpuinfo.c	2019-06-25 02:27:32.265851547 -0700
@@ -220,6 +220,40 @@
 
   unsigned int features = 0;
 
+  /* Get XCR_XFEATURE_ENABLED_MASK register with xgetbv.  */
+#define XCR_XFEATURE_ENABLED_MASK	0x0
+#define XSTATE_FP			0x1
+#define XSTATE_SSE			0x2
+#define XSTATE_YMM			0x4
+#define XSTATE_OPMASK			0x20
+#define XSTATE_ZMM			0x40
+#define XSTATE_HI_ZMM			0x80
+
+#define XCR_AVX_ENABLED_MASK \
+  (XSTATE_SSE | XSTATE_YMM)
+#define XCR_AVX512F_ENABLED_MASK \
+  (XSTATE_SSE | XSTATE_YMM | XSTATE_OPMASK | XSTATE_ZMM | XSTATE_HI_ZMM)
+
+  /* Check if AVX and AVX512 are usable.  */
+  int avx_usable = 0;
+  int avx512_usable = 0;
+  if ((ecx & bit_OSXSAVE))
+    {
+      /* Check if XMM, YMM, OPMASK, upper 256 bits of ZMM0-ZMM15 and
+         ZMM16-ZMM31 states are supported by OSXSAVE.  */
+      unsigned int xcrlow;
+      unsigned int xcrhigh;
+      asm (".byte 0x0f, 0x01, 0xd0"
+	   : "=a" (xcrlow), "=d" (xcrhigh)
+	   : "c" (XCR_XFEATURE_ENABLED_MASK));
+      if ((xcrlow & XCR_AVX_ENABLED_MASK) == XCR_AVX_ENABLED_MASK)
+	{
+	  avx_usable = 1;
+	  avx512_usable = ((xcrlow & XCR_AVX512F_ENABLED_MASK)
+			   == XCR_AVX512F_ENABLED_MASK);
+	}
+    }
+
   if (edx & bit_CMOV)
     features |= (1 << FEATURE_CMOV);
   if (edx & bit_MMX)
@@ -242,10 +276,13 @@
     features |= (1 << FEATURE_SSE4_1);
   if (ecx & bit_SSE4_2)
     features |= (1 << FEATURE_SSE4_2);
-  if (ecx & bit_AVX)
-    features |= (1 << FEATURE_AVX);
-  if (ecx & bit_FMA)
-    features |= (1 << FEATURE_FMA);
+  if (avx_usable)
+    {
+      if (ecx & bit_AVX)
+	features |= (1 << FEATURE_AVX);
+      if (ecx & bit_FMA)
+	features |= (1 << FEATURE_FMA);
+    }
 
   /* Get Advanced Features at level 7 (eax = 7, ecx = 0). */
   if (max_cpuid_level >= 7)
@@ -253,34 +290,40 @@
       __cpuid_count (7, 0, eax, ebx, ecx, edx);
       if (ebx & bit_BMI)
         features |= (1 << FEATURE_BMI);
-      if (ebx & bit_AVX2)
-	features |= (1 << FEATURE_AVX2);
+      if (avx_usable)
+	{
+	  if (ebx & bit_AVX2)
+	    features |= (1 << FEATURE_AVX2);
+	}
       if (ebx & bit_BMI2)
         features |= (1 << FEATURE_BMI2);
-      if (ebx & bit_AVX512F)
-	features |= (1 << FEATURE_AVX512F);
-      if (ebx & bit_AVX512VL)
-	features |= (1 << FEATURE_AVX512VL);
-      if (ebx & bit_AVX512BW)
-	features |= (1 << FEATURE_AVX512BW);
-      if (ebx & bit_AVX512DQ)
-	features |= (1 << FEATURE_AVX512DQ);
-      if (ebx & bit_AVX512CD)
-	features |= (1 << FEATURE_AVX512CD);
-      if (ebx & bit_AVX512PF)
-	features |= (1 << FEATURE_AVX512PF);
-      if (ebx & bit_AVX512ER)
-	features |= (1 << FEATURE_AVX512ER);
-      if (ebx & bit_AVX512IFMA)
-	features |= (1 << FEATURE_AVX512IFMA);
-      if (ecx & bit_AVX512VBMI)
-	features |= (1 << FEATURE_AVX512VBMI);
-      if (ecx & bit_AVX512VPOPCNTDQ)
-	features |= (1 << FEATURE_AVX512VPOPCNTDQ);
-      if (edx & bit_AVX5124VNNIW)
-	features |= (1 << FEATURE_AVX5124VNNIW);
-      if (edx & bit_AVX5124FMAPS)
-	features |= (1 << FEATURE_AVX5124FMAPS);
+      if (avx512_usable)
+	{
+	  if (ebx & bit_AVX512F)
+	    features |= (1 << FEATURE_AVX512F);
+	  if (ebx & bit_AVX512VL)
+	    features |= (1 << FEATURE_AVX512VL);
+	  if (ebx & bit_AVX512BW)
+	    features |= (1 << FEATURE_AVX512BW);
+	  if (ebx & bit_AVX512DQ)
+	    features |= (1 << FEATURE_AVX512DQ);
+	  if (ebx & bit_AVX512CD)
+	    features |= (1 << FEATURE_AVX512CD);
+	  if (ebx & bit_AVX512PF)
+	    features |= (1 << FEATURE_AVX512PF);
+	  if (ebx & bit_AVX512ER)
+	    features |= (1 << FEATURE_AVX512ER);
+	  if (ebx & bit_AVX512IFMA)
+	    features |= (1 << FEATURE_AVX512IFMA);
+	  if (ecx & bit_AVX512VBMI)
+	    features |= (1 << FEATURE_AVX512VBMI);
+	  if (ecx & bit_AVX512VPOPCNTDQ)
+	    features |= (1 << FEATURE_AVX512VPOPCNTDQ);
+	  if (edx & bit_AVX5124VNNIW)
+	    features |= (1 << FEATURE_AVX5124VNNIW);
+	  if (edx & bit_AVX5124FMAPS)
+	    features |= (1 << FEATURE_AVX5124FMAPS);
+	}
     }
 
   /* Check cpuid level of extended features.  */
@@ -292,10 +335,13 @@
 
       if (ecx & bit_SSE4a)
 	features |= (1 << FEATURE_SSE4_A);
-      if (ecx & bit_FMA4)
-	features |= (1 << FEATURE_FMA4);
-      if (ecx & bit_XOP)
-	features |= (1 << FEATURE_XOP);
+      if (avx_usable)
+	{
+	  if (ecx & bit_FMA4)
+	    features |= (1 << FEATURE_FMA4);
+	  if (ecx & bit_XOP)
+	    features |= (1 << FEATURE_XOP);
+	}
     }
     
   __cpu_model.__cpu_features[0] = features;
diff -ruN gcc-7.3.0/libgcc/config/pa/fptr.c gcc-7.3.0-msp430/libgcc/config/pa/fptr.c
--- gcc-7.3.0/libgcc/config/pa/fptr.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libgcc/config/pa/fptr.c	2019-06-25 02:27:32.265851547 -0700
@@ -52,6 +52,16 @@
 typedef int (*fixup_t) (struct link_map *, unsigned int);
 extern unsigned int _GLOBAL_OFFSET_TABLE_;
 
+static inline int
+_dl_read_access_allowed (unsigned int *addr)
+{
+  int result;
+
+  asm ("proberi (%1),3,%0" : "=r" (result) : "r" (addr) : );
+
+  return result;
+}
+
 /* __canonicalize_funcptr_for_compare must be hidden so that it is not
    placed in the dynamic symbol table.  Like millicode functions, it
    must be linked into all binaries in order access the got table of 
@@ -82,6 +92,16 @@
      The second word in the plabel contains the relocation offset for the
      function.  */
   plabel = (unsigned int *) ((unsigned int) fptr & ~3);
+  if (!_dl_read_access_allowed (plabel))
+    return (unsigned int) fptr;
+
+  /* Load first word of candidate descriptor.  It should be a pointer
+     with word alignment and point to memory that can be read.  */
+  got = (unsigned int *) plabel[0];
+  if (((unsigned int) got & 3) != 0
+      || !_dl_read_access_allowed (got))
+    return (unsigned int) fptr;
+
   got = (unsigned int *) (plabel[0] + GOT_FROM_PLT_STUB);
 
   /* Return the address of the function if the plabel has been resolved.  */
diff -ruN gcc-7.3.0/libgcc/config/pa/linux-atomic.c gcc-7.3.0-msp430/libgcc/config/pa/linux-atomic.c
--- gcc-7.3.0/libgcc/config/pa/linux-atomic.c	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libgcc/config/pa/linux-atomic.c	2019-06-25 02:27:32.265851547 -0700
@@ -28,14 +28,9 @@
 #define EBUSY   16
 #define ENOSYS 251 
 
-/* All PA-RISC implementations supported by linux have strongly
-   ordered loads and stores.  Only cache flushes and purges can be
-   delayed.  The data cache implementations are all globally
-   coherent.  Thus, there is no need to synchonize memory accesses.
-
-   GCC automatically issues a asm memory barrier when it encounters
-   a __sync_synchronize builtin.  Thus, we do not need to define this
-   builtin.
+/* PA-RISC 2.0 supports out-of-order execution for loads and stores.
+   Thus, we need to synchonize memory accesses.  For more info, see:
+   "Advanced Performance Features of the 64-bit PA-8000" by Doug Hunt.
 
    We implement byte, short and int versions of each atomic operation
    using the kernel helper defined below.  There is no support for
@@ -119,7 +114,7 @@
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       newval = PFX_OP (tmp INF_OP val);					\
       failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);		\
     } while (failure != 0);						\
@@ -156,7 +151,7 @@
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       newval = PFX_OP (tmp INF_OP val);					\
       failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);		\
     } while (failure != 0);						\
@@ -193,7 +188,7 @@
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));	\
     } while (failure != 0);						\
 									\
@@ -215,7 +210,7 @@
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));	\
     } while (failure != 0);						\
 									\
@@ -241,7 +236,7 @@
 									\
     while (1)								\
       {									\
-	actual_oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);	\
+	actual_oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);	\
 									\
 	if (__builtin_expect (oldval != actual_oldval, 0))		\
 	  return actual_oldval;						\
@@ -273,7 +268,7 @@
     
   while (1)
     {
-      actual_oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
+      actual_oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);
 
       if (__builtin_expect (oldval != actual_oldval, 0))
 	return actual_oldval;
@@ -300,7 +295,7 @@
     long failure;							\
 									\
     do {								\
-      oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       failure = __kernel_cmpxchg2 (ptr, &oldval, &val, INDEX);		\
     } while (failure != 0);						\
 									\
@@ -318,38 +313,31 @@
   int oldval;
 
   do {
-    oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
+    oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);
     failure = __kernel_cmpxchg (ptr, oldval, val);
   } while (failure != 0);
 
   return oldval;
 }
 
-#define SYNC_LOCK_RELEASE_2(TYPE, WIDTH, INDEX)			\
+void HIDDEN
+__sync_lock_release_8 (long long *ptr)
+{
+  /* All accesses must be complete before we release the lock.  */
+  __sync_synchronize ();
+  *(double *)ptr = 0;
+}
+
+#define SYNC_LOCK_RELEASE_1(TYPE, WIDTH)			\
   void HIDDEN							\
   __sync_lock_release_##WIDTH (TYPE *ptr)			\
   {								\
-    TYPE oldval, zero = 0;					\
-    long failure;						\
-								\
-    do {							\
-      oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);		\
-      failure = __kernel_cmpxchg2 (ptr, &oldval, &zero, INDEX);	\
-    } while (failure != 0);					\
+    /* All accesses must be complete before we release		\
+       the lock.  */						\
+    __sync_synchronize ();					\
+    *ptr = 0;							\
   }
 
-SYNC_LOCK_RELEASE_2 (long long, 8, 3)
-SYNC_LOCK_RELEASE_2 (short, 2, 1)
-SYNC_LOCK_RELEASE_2 (signed char, 1, 0)
-
-void HIDDEN
-__sync_lock_release_4 (int *ptr)
-{
-  long failure;
-  int oldval;
-
-  do {
-    oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
-    failure = __kernel_cmpxchg (ptr, oldval, 0);
-  } while (failure != 0);
-}
+SYNC_LOCK_RELEASE_1 (int, 4)
+SYNC_LOCK_RELEASE_1 (short, 2)
+SYNC_LOCK_RELEASE_1 (signed char, 1)
diff -ruN gcc-7.3.0/libgcc/config/xtensa/ieee754-df.S gcc-7.3.0-msp430/libgcc/config/xtensa/ieee754-df.S
--- gcc-7.3.0/libgcc/config/xtensa/ieee754-df.S	2018-01-23 13:47:51.958328000 -0800
+++ gcc-7.3.0-msp430/libgcc/config/xtensa/ieee754-df.S	2019-06-25 02:27:32.265851547 -0700
@@ -55,6 +55,7 @@
 
 #ifdef L_addsubdf3
 
+	.literal_position
 	/* Addition */
 __adddf3_aux:
 	
diff -ruN gcc-7.3.0/libgcc/config/xtensa/ieee754-sf.S gcc-7.3.0-msp430/libgcc/config/xtensa/ieee754-sf.S
--- gcc-7.3.0/libgcc/config/xtensa/ieee754-sf.S	2018-01-23 13:47:51.958328000 -0800
+++ gcc-7.3.0-msp430/libgcc/config/xtensa/ieee754-sf.S	2019-06-25 02:27:32.265851547 -0700
@@ -55,6 +55,7 @@
 
 #ifdef L_addsubsf3
 
+	.literal_position
 	/* Addition */
 __addsf3_aux:
 
diff -ruN gcc-7.3.0/libgcc/configure gcc-7.3.0-msp430/libgcc/configure
--- gcc-7.3.0/libgcc/configure	2017-11-21 01:31:12.135035000 -0800
+++ gcc-7.3.0-msp430/libgcc/configure	2019-06-25 02:27:32.265851547 -0700
@@ -5298,7 +5298,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libgfortran/ChangeLog gcc-7.3.0-msp430/libgfortran/ChangeLog
--- gcc-7.3.0/libgfortran/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libgfortran/ChangeLog	2019-06-25 02:27:32.265851547 -0700
@@ -1,3 +1,32 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-06-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk.
+	PR libgfortran/86070
+	* io/write_float.def (build_float_string): Initialize *len.
+
+2018-06-01  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk.
+	PR libgfortran/85840
+	* io/write.c (write_float_0, write_real, write_real_g0,
+	write_complex): Use separate local variables for the float
+	string length.
+
+2018-02-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR libgfortran/84412
+	* io/transfer.c (finalize_transfer): After completng an internal unit
+	I/O operation, clear internal_unit_kind.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libgfortran/configure gcc-7.3.0-msp430/libgfortran/configure
--- gcc-7.3.0/libgfortran/configure	2018-01-25 00:17:54.067232055 -0800
+++ gcc-7.3.0-msp430/libgfortran/configure	2019-06-25 02:27:32.269851519 -0700
@@ -26370,7 +26370,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libgfortran/io/transfer.c gcc-7.3.0-msp430/libgfortran/io/transfer.c
--- gcc-7.3.0/libgfortran/io/transfer.c	2017-12-16 11:59:14.227188000 -0800
+++ gcc-7.3.0-msp430/libgfortran/io/transfer.c	2019-06-25 02:27:32.269851519 -0700
@@ -3987,6 +3987,10 @@
 
   if (dtp->u.p.unit_is_internal)
     {
+      /* The unit structure may be reused later so clear the
+	 internal unit kind.  */
+      dtp->u.p.current_unit->internal_unit_kind = 0;
+
       fbuf_destroy (dtp->u.p.current_unit);
       if (dtp->u.p.current_unit
 	  && (dtp->u.p.current_unit->child_dtio  == 0)
diff -ruN gcc-7.3.0/libgfortran/io/write.c gcc-7.3.0-msp430/libgfortran/io/write.c
--- gcc-7.3.0/libgfortran/io/write.c	2018-01-14 13:44:50.959185000 -0800
+++ gcc-7.3.0-msp430/libgfortran/io/write.c	2019-06-25 02:27:32.269851519 -0700
@@ -1483,7 +1483,7 @@
 
 /* Floating point helper functions.  */
 
-#define BUF_STACK_SZ 256
+#define BUF_STACK_SZ 384
 
 static int
 get_precision (st_parameter_dt *dtp, const fnode *f, const char *source, int kind)
@@ -1584,7 +1584,7 @@
   char buf_stack[BUF_STACK_SZ];
   char str_buf[BUF_STACK_SZ];
   char *buffer, *result;
-  size_t buf_size, res_len;
+  size_t buf_size, res_len, flt_str_len;
 
   /* Precision for snprintf call.  */
   int precision = get_precision (dtp, f, source, kind);
@@ -1595,8 +1595,8 @@
   buffer = select_buffer (dtp, f, precision, buf_stack, &buf_size, kind);
   
   get_float_string (dtp, f, source , kind, 0, buffer,
-                           precision, buf_size, result, &res_len);
-  write_float_string (dtp, result, res_len);
+                           precision, buf_size, result, &flt_str_len);
+  write_float_string (dtp, result, flt_str_len);
 
   if (buf_size > BUF_STACK_SZ)
     free (buffer);
@@ -1699,7 +1699,7 @@
   char buf_stack[BUF_STACK_SZ];
   char str_buf[BUF_STACK_SZ];
   char *buffer, *result;
-  size_t buf_size, res_len;
+  size_t buf_size, res_len, flt_str_len;
   int orig_scale = dtp->u.p.scale_factor;
   dtp->u.p.scale_factor = 1;
   set_fnode_default (dtp, &f, kind);
@@ -1714,8 +1714,8 @@
   buffer = select_buffer (dtp, &f, precision, buf_stack, &buf_size, kind);
   
   get_float_string (dtp, &f, source , kind, 1, buffer,
-                           precision, buf_size, result, &res_len);
-  write_float_string (dtp, result, res_len);
+                           precision, buf_size, result, &flt_str_len);
+  write_float_string (dtp, result, flt_str_len);
 
   dtp->u.p.scale_factor = orig_scale;
   if (buf_size > BUF_STACK_SZ)
@@ -1734,7 +1734,7 @@
   char buf_stack[BUF_STACK_SZ];
   char str_buf[BUF_STACK_SZ];
   char *buffer, *result;
-  size_t buf_size, res_len;
+  size_t buf_size, res_len, flt_str_len;
   int comp_d;
   set_fnode_default (dtp, &f, kind);
 
@@ -1758,8 +1758,8 @@
   buffer = select_buffer (dtp, &f, precision, buf_stack, &buf_size, kind);
 
   get_float_string (dtp, &f, source , kind, comp_d, buffer,
-                           precision, buf_size, result, &res_len);
-  write_float_string (dtp, result, res_len);
+                           precision, buf_size, result, &flt_str_len);
+  write_float_string (dtp, result, flt_str_len);
 
   dtp->u.p.g0_no_blanks = 0;
   if (buf_size > BUF_STACK_SZ)
@@ -1784,7 +1784,7 @@
   char str1_buf[BUF_STACK_SZ];
   char str2_buf[BUF_STACK_SZ];
   char *buffer, *result1, *result2;
-  size_t buf_size, res_len1, res_len2;
+  size_t buf_size, res_len1, res_len2, flt_str_len1, flt_str_len2;
   int width, lblanks, orig_scale = dtp->u.p.scale_factor;
 
   dtp->u.p.scale_factor = 1;
@@ -1807,18 +1807,18 @@
   buffer = select_buffer (dtp, &f, precision, buf_stack, &buf_size, kind);
 
   get_float_string (dtp, &f, source , kind, 0, buffer,
-                           precision, buf_size, result1, &res_len1);
+                           precision, buf_size, result1, &flt_str_len1);
   get_float_string (dtp, &f, source + size / 2 , kind, 0, buffer,
-                           precision, buf_size, result2, &res_len2);
+                           precision, buf_size, result2, &flt_str_len2);
   if (!dtp->u.p.namelist_mode)
     {
-      lblanks = width - res_len1 - res_len2 - 3;
+      lblanks = width - flt_str_len1 - flt_str_len2 - 3;
       write_x (dtp, lblanks, lblanks);
     }
   write_char (dtp, '(');
-  write_float_string (dtp, result1, res_len1);
+  write_float_string (dtp, result1, flt_str_len1);
   write_char (dtp, semi_comma);
-  write_float_string (dtp, result2, res_len2);
+  write_float_string (dtp, result2, flt_str_len2);
   write_char (dtp, ')');
 
   dtp->u.p.scale_factor = orig_scale;
diff -ruN gcc-7.3.0/libgfortran/io/write_float.def gcc-7.3.0-msp430/libgfortran/io/write_float.def
--- gcc-7.3.0/libgfortran/io/write_float.def	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libgfortran/io/write_float.def	2019-06-25 02:27:32.269851519 -0700
@@ -135,6 +135,7 @@
   w = f->u.real.w;
   d = f->u.real.d;
   p = dtp->u.p.scale_factor;
+  *len = 0;
 
   rchar = '5';
 
diff -ruN gcc-7.3.0/libgo/config.h.in gcc-7.3.0-msp430/libgo/config.h.in
--- gcc-7.3.0/libgo/config.h.in	2017-10-09 09:59:38.748785000 -0700
+++ gcc-7.3.0-msp430/libgo/config.h.in	2019-06-25 02:27:32.269851519 -0700
@@ -340,9 +340,6 @@
 /* Define to 1 if you have the `unshare' function. */
 #undef HAVE_UNSHARE
 
-/* Define to 1 if you have the <ustat.h> header file and it works. */
-#undef HAVE_USTAT_H
-
 /* Define to 1 if you have the `utimensat' function. */
 #undef HAVE_UTIMENSAT
 
diff -ruN gcc-7.3.0/libgo/configure gcc-7.3.0-msp430/libgo/configure
--- gcc-7.3.0/libgo/configure	2017-11-21 01:31:12.135035000 -0800
+++ gcc-7.3.0-msp430/libgo/configure	2019-06-25 02:27:32.269851519 -0700
@@ -14784,39 +14784,6 @@
 done
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether <ustat.h> can be used" >&5
-$as_echo_n "checking whether <ustat.h> can be used... " >&6; }
-if test "${libgo_cv_c_ustat_h+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  CFLAGS_hold=$CFLAGS
-CFLAGS="$CFLAGS -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE $OSCFLAGS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#ifdef HAVE_LINUX_FILTER_H
-#include <linux/filter.h>
-#endif
-#include <ustat.h>
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  libgo_cv_c_ustat_h=yes
-else
-  libgo_cv_c_ustat_h=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-CFLAGS=$CFLAGS_hold
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libgo_cv_c_ustat_h" >&5
-$as_echo "$libgo_cv_c_ustat_h" >&6; }
-if test $libgo_cv_c_ustat_h = yes; then
-
-$as_echo "#define HAVE_USTAT_H 1" >>confdefs.h
-
-fi
-
  if test "$ac_cv_header_sys_mman_h" = yes; then
   HAVE_SYS_MMAN_H_TRUE=
   HAVE_SYS_MMAN_H_FALSE='#'
diff -ruN gcc-7.3.0/libgo/configure.ac gcc-7.3.0-msp430/libgo/configure.ac
--- gcc-7.3.0/libgo/configure.ac	2017-11-21 01:31:12.135035000 -0800
+++ gcc-7.3.0-msp430/libgo/configure.ac	2019-06-25 02:27:32.269851519 -0700
@@ -572,24 +572,6 @@
 #endif
 ])
 
-AC_CACHE_CHECK([whether <ustat.h> can be used],
-[libgo_cv_c_ustat_h],
-[CFLAGS_hold=$CFLAGS
-CFLAGS="$CFLAGS -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE $OSCFLAGS"
-AC_COMPILE_IFELSE(
-[AC_LANG_SOURCE([
-#include <sys/types.h>
-#ifdef HAVE_LINUX_FILTER_H
-#include <linux/filter.h>
-#endif
-#include <ustat.h>
-])], [libgo_cv_c_ustat_h=yes], [libgo_cv_c_ustat_h=no])
-CFLAGS=$CFLAGS_hold])
-if test $libgo_cv_c_ustat_h = yes; then
-  AC_DEFINE(HAVE_USTAT_H, 1,
-    [Define to 1 if you have the <ustat.h> header file and it works.])
-fi
-
 AM_CONDITIONAL(HAVE_SYS_MMAN_H, test "$ac_cv_header_sys_mman_h" = yes)
 
 AC_CHECK_FUNCS(strerror_r strsignal wait4 mincore setenv unsetenv dl_iterate_phdr)
diff -ruN gcc-7.3.0/libgo/go/os/wait_waitid.go gcc-7.3.0-msp430/libgo/go/os/wait_waitid.go
--- gcc-7.3.0/libgo/go/os/wait_waitid.go	2017-06-23 10:12:32.853408000 -0700
+++ gcc-7.3.0-msp430/libgo/go/os/wait_waitid.go	2019-06-25 02:27:32.269851519 -0700
@@ -25,9 +25,12 @@
 	// We don't care about the values it returns.
 	var siginfo [16]uint64
 	psig := &siginfo[0]
-	_, _, e := syscall.Syscall6(syscall.SYS_WAITID, _P_PID, uintptr(p.Pid), uintptr(unsafe.Pointer(psig)), syscall.WEXITED|syscall.WNOWAIT, 0, 0)
+	r, _, e := syscall.Syscall6(syscall.SYS_WAITID, _P_PID, uintptr(p.Pid), uintptr(unsafe.Pointer(psig)), syscall.WEXITED|syscall.WNOWAIT, 0, 0)
 	runtime.KeepAlive(p)
-	if e != 0 {
+	// Check r as well as e because syscall.Syscall6 currently
+	// just returns errno, and the SIGCHLD signal handler may
+	// change errno. See https://gcc.gnu.org/PR86331.
+	if r != 0 && e != 0 {
 		// waitid has been available since Linux 2.6.9, but
 		// reportedly is not available in Ubuntu on Windows.
 		// See issue 16610.
diff -ruN gcc-7.3.0/libgo/go/syscall/libcall_linux_ustat.go gcc-7.3.0-msp430/libgo/go/syscall/libcall_linux_ustat.go
--- gcc-7.3.0/libgo/go/syscall/libcall_linux_ustat.go	2016-08-05 17:36:33.790804000 -0700
+++ gcc-7.3.0-msp430/libgo/go/syscall/libcall_linux_ustat.go	2019-06-25 02:27:32.269851519 -0700
@@ -1,12 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// GNU/Linux library ustat call.
-// This is not supported on some kernels, such as arm64.
-// +build !arm64
-
-package syscall
-
-//sys	Ustat(dev int, ubuf *Ustat_t) (err error)
-//ustat(dev _dev_t, ubuf *Ustat_t) _C_int
diff -ruN gcc-7.3.0/libgo/mksysinfo.sh gcc-7.3.0-msp430/libgo/mksysinfo.sh
--- gcc-7.3.0/libgo/mksysinfo.sh	2017-11-21 01:31:12.135035000 -0800
+++ gcc-7.3.0-msp430/libgo/mksysinfo.sh	2019-06-25 02:27:32.269851519 -0700
@@ -1107,20 +1107,6 @@
       -e 's/mem_unit/Unit/' \
     >> ${OUT}
 
-# The ustat struct.
-grep '^type _ustat ' gen-sysinfo.go | \
-    sed -e 's/_ustat/Ustat_t/' \
-      -e 's/f_tfree/Tfree/' \
-      -e 's/f_tinode/Tinoe/' \
-      -e 's/f_fname/Fname/' \
-      -e 's/f_fpack/Fpack/' \
-    >> ${OUT}
-# Force it to be defined, as on some older GNU/Linux systems the
-# header file fails when using with <linux/filter.h>.
-if ! grep 'type _ustat ' gen-sysinfo.go >/dev/null 2>&1; then
-  echo 'type Ustat_t struct { Tfree int32; Tinoe uint64; Fname [5+1]int8; Fpack [5+1]int8; }' >> ${OUT}
-fi
-
 # The utimbuf struct.
 grep '^type _utimbuf ' gen-sysinfo.go | \
     sed -e 's/_utimbuf/Utimbuf/' \
diff -ruN gcc-7.3.0/libgo/sysinfo.c gcc-7.3.0-msp430/libgo/sysinfo.c
--- gcc-7.3.0/libgo/sysinfo.c	2017-10-09 09:59:38.748785000 -0700
+++ gcc-7.3.0-msp430/libgo/sysinfo.c	2019-06-25 02:27:32.269851519 -0700
@@ -135,9 +135,6 @@
 #if defined(HAVE_SYS_SYSINFO_H)
 #include <sys/sysinfo.h>
 #endif
-#if defined(HAVE_USTAT_H)
-#include <ustat.h>
-#endif
 #if defined(HAVE_UTIME_H)
 #include <utime.h>
 #endif
diff -ruN gcc-7.3.0/libgomp/ChangeLog gcc-7.3.0-msp430/libgomp/ChangeLog
--- gcc-7.3.0/libgomp/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libgomp/ChangeLog	2019-06-25 02:27:32.273851489 -0700
@@ -1,3 +1,49 @@
+2018-06-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86291
+	* testsuite/libgomp.c++/pr86291.C: New test.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-05-01  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2018-04-16  Cesar Philippidis  <cesar@codesourcery.com>
+		    Tom de Vries  <tom@codesourcery.com>
+
+	PR middle-end/84955
+	* testsuite/libgomp.oacc-c-c++-common/pr84955.c: New test.
+	* testsuite/libgomp.oacc-fortran/pr84955.f90: New test.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/84418
+	* libgomp.fortran/pr84418-1.f90: New test.
+	* libgomp.fortran/pr84418-2.f90: New test.
+
+	2018-01-29  Christoph Spiel  <cspiel@freenet.de>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/84096
+	* omp.h.in (omp_init_nest_lock_with_hint): Use omp_nest_lock_t
+	instead of omp_lock_t.
+
+2018-02-09  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Martin Jambor  <mjambor@suse.cz>
+
+	* testsuite/libgomp.hsa.c/staticvar.c: New test.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libgomp/configure gcc-7.3.0-msp430/libgomp/configure
--- gcc-7.3.0/libgomp/configure	2018-01-25 00:17:54.091232056 -0800
+++ gcc-7.3.0-msp430/libgomp/configure	2019-06-25 02:27:32.273851489 -0700
@@ -16823,7 +16823,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libgomp/omp.h.in gcc-7.3.0-msp430/libgomp/omp.h.in
--- gcc-7.3.0/libgomp/omp.h.in	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libgomp/omp.h.in	2019-06-25 02:27:32.273851489 -0700
@@ -101,7 +101,7 @@
 extern int omp_test_lock (omp_lock_t *) __GOMP_NOTHROW;
 
 extern void omp_init_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;
-extern void omp_init_nest_lock_with_hint (omp_lock_t *, omp_lock_hint_t)
+extern void omp_init_nest_lock_with_hint (omp_nest_lock_t *, omp_lock_hint_t)
   __GOMP_NOTHROW;
 extern void omp_destroy_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;
 extern void omp_set_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;
diff -ruN gcc-7.3.0/libhsail-rt/ChangeLog gcc-7.3.0-msp430/libhsail-rt/ChangeLog
--- gcc-7.3.0/libhsail-rt/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libhsail-rt/ChangeLog	2019-06-25 02:27:32.273851489 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libhsail-rt/configure gcc-7.3.0-msp430/libhsail-rt/configure
--- gcc-7.3.0/libhsail-rt/configure	2018-01-25 00:17:54.103232056 -0800
+++ gcc-7.3.0-msp430/libhsail-rt/configure	2019-06-25 02:27:32.273851489 -0700
@@ -14414,7 +14414,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libitm/ChangeLog gcc-7.3.0-msp430/libitm/ChangeLog
--- gcc-7.3.0/libitm/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libitm/ChangeLog	2019-06-25 02:27:32.273851489 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libitm/configure gcc-7.3.0-msp430/libitm/configure
--- gcc-7.3.0/libitm/configure	2018-01-25 00:17:54.119232056 -0800
+++ gcc-7.3.0-msp430/libitm/configure	2019-06-25 02:27:32.277851461 -0700
@@ -17647,7 +17647,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libmpx/ChangeLog gcc-7.3.0-msp430/libmpx/ChangeLog
--- gcc-7.3.0/libmpx/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libmpx/ChangeLog	2019-06-25 02:27:32.277851461 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libmpx/configure gcc-7.3.0-msp430/libmpx/configure
--- gcc-7.3.0/libmpx/configure	2017-01-19 04:23:00.162040000 -0800
+++ gcc-7.3.0-msp430/libmpx/configure	2019-06-25 02:27:32.277851461 -0700
@@ -11596,7 +11596,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libobjc/ChangeLog gcc-7.3.0-msp430/libobjc/ChangeLog
--- gcc-7.3.0/libobjc/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libobjc/ChangeLog	2019-06-25 02:27:32.277851461 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libobjc/configure gcc-7.3.0-msp430/libobjc/configure
--- gcc-7.3.0/libobjc/configure	2017-01-18 07:48:54.659854000 -0800
+++ gcc-7.3.0-msp430/libobjc/configure	2019-06-25 02:27:32.277851461 -0700
@@ -11708,7 +11708,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/liboffloadmic/ChangeLog gcc-7.3.0-msp430/liboffloadmic/ChangeLog
--- gcc-7.3.0/liboffloadmic/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/liboffloadmic/ChangeLog	2019-06-25 02:27:32.277851461 -0700
@@ -1,3 +1,12 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+	* plugin/confugure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/liboffloadmic/configure gcc-7.3.0-msp430/liboffloadmic/configure
--- gcc-7.3.0/liboffloadmic/configure	2017-01-17 01:38:48.048122000 -0800
+++ gcc-7.3.0-msp430/liboffloadmic/configure	2019-06-25 02:27:32.277851461 -0700
@@ -14492,7 +14492,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/liboffloadmic/plugin/configure gcc-7.3.0-msp430/liboffloadmic/plugin/configure
--- gcc-7.3.0/liboffloadmic/plugin/configure	2017-01-21 00:47:11.020689000 -0800
+++ gcc-7.3.0-msp430/liboffloadmic/plugin/configure	2019-06-25 02:27:32.281851434 -0700
@@ -14187,7 +14187,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libquadmath/ChangeLog gcc-7.3.0-msp430/libquadmath/ChangeLog
--- gcc-7.3.0/libquadmath/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libquadmath/ChangeLog	2019-06-25 02:27:32.281851434 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libquadmath/configure gcc-7.3.0-msp430/libquadmath/configure
--- gcc-7.3.0/libquadmath/configure	2018-01-25 00:17:54.063232055 -0800
+++ gcc-7.3.0-msp430/libquadmath/configure	2019-06-25 02:27:32.281851434 -0700
@@ -12929,7 +12929,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libsanitizer/asan/asan_allocator.h gcc-7.3.0-msp430/libsanitizer/asan/asan_allocator.h
--- gcc-7.3.0/libsanitizer/asan/asan_allocator.h	2016-11-08 14:04:09.630329000 -0800
+++ gcc-7.3.0-msp430/libsanitizer/asan/asan_allocator.h	2019-06-25 02:27:32.281851434 -0700
@@ -115,7 +115,7 @@
 
 #if SANITIZER_CAN_USE_ALLOCATOR64
 # if defined(__powerpc64__)
-const uptr kAllocatorSpace =  0xa0000000000ULL;
+const uptr kAllocatorSpace = ~(uptr)0;
 const uptr kAllocatorSize  =  0x20000000000ULL;  // 2T.
 typedef DefaultSizeClassMap SizeClassMap;
 # elif defined(__aarch64__) && SANITIZER_ANDROID
diff -ruN gcc-7.3.0/libsanitizer/ChangeLog gcc-7.3.0-msp430/libsanitizer/ChangeLog
--- gcc-7.3.0/libsanitizer/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libsanitizer/ChangeLog	2019-06-25 02:27:32.281851434 -0700
@@ -1,3 +1,57 @@
+2018-08-16  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-08-02  Martin Liska  <mliska@suse.cz>
+
+        PR sanitizer/86022
+	* sanitizer_common/sanitizer_linux_libcdep.cc (ThreadDescriptorSize):
+        Cherry-pick compiler-rt revision 338606.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-06-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/84761
+	* sanitizer_common/sanitizer_linux_libcdep.cc (__GLIBC_PREREQ):
+	Define if not defined.
+	(DL_INTERNAL_FUNCTION): Don't define.
+	(InitTlsSize): For __i386__ if not compiled against glibc 2.27+
+	determine at runtime whether to use regparm(3), stdcall calling
+	convention for older glibcs or normal calling convention for
+	newer glibcs for call to _dl_get_tls_static_info.
+
+2018-05-31  Matthias Klose  <doko@ubuntu.com>
+
+	PR sanitizer/86012
+	* sanitizer_common/sanitizer_platform_limits_posix.cc: Define
+	SIZEOF_STRUCT_USTAT for 32bit sparc.
+
+2018-05-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR sanitizer/85835
+	* sanitizer_common/sanitizer_platform_limits_posix.cc: Don't
+	include <sys/ustat.h> for Linux.
+	(SIZEOF_STRUCT_USTAT): New.
+	(struct_ustat_sz): Use SIZEOF_STRUCT_USTAT for Linux.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-18  Bill Seurer  <seurer@linux.vnet.ibm.com>
+
+	PR sanitizer/85389
+	* asan/asan_allocator.h (kAllocatorSpace): For __powerpc64__ change
+	from 0xa0000000000ULL to ~(uptr)0.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libsanitizer/configure gcc-7.3.0-msp430/libsanitizer/configure
--- gcc-7.3.0/libsanitizer/configure	2018-01-25 00:17:54.147232057 -0800
+++ gcc-7.3.0-msp430/libsanitizer/configure	2019-06-25 02:27:32.281851434 -0700
@@ -16511,7 +16511,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc gcc-7.3.0-msp430/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc
--- gcc-7.3.0/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc	2016-11-08 14:04:09.630329000 -0800
+++ gcc-7.3.0-msp430/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc	2019-06-25 02:27:32.281851434 -0700
@@ -153,28 +153,43 @@
 #endif
 }
 
+#ifndef __GLIBC_PREREQ
+#define __GLIBC_PREREQ(x, y) 0
+#endif
+
 #if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO
 static uptr g_tls_size;
 
-#ifdef __i386__
-# define DL_INTERNAL_FUNCTION __attribute__((regparm(3), stdcall))
-#else
-# define DL_INTERNAL_FUNCTION
-#endif
-
 void InitTlsSize() {
 // all current supported platforms have 16 bytes stack alignment
   const size_t kStackAlign = 16;
-  typedef void (*get_tls_func)(size_t*, size_t*) DL_INTERNAL_FUNCTION;
-  get_tls_func get_tls;
-  void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, "_dl_get_tls_static_info");
-  CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));
-  internal_memcpy(&get_tls, &get_tls_static_info_ptr,
-                  sizeof(get_tls_static_info_ptr));
-  CHECK_NE(get_tls, 0);
   size_t tls_size = 0;
   size_t tls_align = 0;
-  get_tls(&tls_size, &tls_align);
+  void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, "_dl_get_tls_static_info");
+#if defined(__i386__) && !__GLIBC_PREREQ(2, 27)
+  /* On i?86, _dl_get_tls_static_info used to be internal_function, i.e.
+     __attribute__((regparm(3), stdcall)) before glibc 2.27 and is normal
+     function in 2.27 and later.  */
+  if (!dlvsym(RTLD_NEXT, "glob", "GLIBC_2.27")) {
+    typedef void (*get_tls_func)(size_t*, size_t*)
+      __attribute__((regparm(3), stdcall));
+    get_tls_func get_tls;
+    CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));
+    internal_memcpy(&get_tls, &get_tls_static_info_ptr,
+                    sizeof(get_tls_static_info_ptr));
+    CHECK_NE(get_tls, 0);
+    get_tls(&tls_size, &tls_align);
+  } else
+#endif
+  {
+    typedef void (*get_tls_func)(size_t*, size_t*);
+    get_tls_func get_tls;
+    CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));
+    internal_memcpy(&get_tls, &get_tls_static_info_ptr,
+                    sizeof(get_tls_static_info_ptr));
+    CHECK_NE(get_tls, 0);
+    get_tls(&tls_size, &tls_align);
+  }
   if (tls_align < kStackAlign)
     tls_align = kStackAlign;
   g_tls_size = RoundUpTo(tls_size, tls_align);
@@ -221,7 +236,7 @@
         val = FIRST_32_SECOND_64(1168, 1776);
       else if (minor == 11 || (minor == 12 && patch == 1))
         val = FIRST_32_SECOND_64(1168, 2288);
-      else if (minor <= 13)
+      else if (minor <= 14)
         val = FIRST_32_SECOND_64(1168, 2304);
       else
         val = FIRST_32_SECOND_64(1216, 2304);
diff -ruN gcc-7.3.0/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc gcc-7.3.0-msp430/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc
--- gcc-7.3.0/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc	2017-02-16 13:23:51.526073000 -0800
+++ gcc-7.3.0-msp430/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc	2019-06-25 02:27:32.281851434 -0700
@@ -154,7 +154,6 @@
 # include <sys/procfs.h>
 #endif
 #include <sys/user.h>
-#include <sys/ustat.h>
 #include <linux/cyclades.h>
 #include <linux/if_eql.h>
 #include <linux/if_plip.h>
@@ -247,7 +246,19 @@
 #endif // SANITIZER_LINUX || SANITIZER_FREEBSD
 
 #if SANITIZER_LINUX && !SANITIZER_ANDROID
-  unsigned struct_ustat_sz = sizeof(struct ustat);
+  // Use pre-computed size of struct ustat to avoid <sys/ustat.h> which
+  // has been removed from glibc 2.28.
+#if defined(__aarch64__) || defined(__s390x__) || defined (__mips64) \
+  || defined(__powerpc64__) || defined(__arch64__) || defined(__sparcv9) \
+  || defined(__x86_64__)
+#define SIZEOF_STRUCT_USTAT 32
+#elif defined(__arm__) || defined(__i386__) || defined(__mips__) \
+  || defined(__powerpc__) || defined(__s390__) || defined(__sparc__)
+#define SIZEOF_STRUCT_USTAT 20
+#else
+#error Unknown size of struct ustat
+#endif
+  unsigned struct_ustat_sz = SIZEOF_STRUCT_USTAT;
   unsigned struct_rlimit64_sz = sizeof(struct rlimit64);
   unsigned struct_statvfs64_sz = sizeof(struct statvfs64);
 #endif // SANITIZER_LINUX && !SANITIZER_ANDROID
diff -ruN gcc-7.3.0/libssp/ChangeLog gcc-7.3.0-msp430/libssp/ChangeLog
--- gcc-7.3.0/libssp/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libssp/ChangeLog	2019-06-25 02:27:32.281851434 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libssp/configure gcc-7.3.0-msp430/libssp/configure
--- gcc-7.3.0/libssp/configure	2017-01-17 01:38:48.048122000 -0800
+++ gcc-7.3.0-msp430/libssp/configure	2019-06-25 02:27:32.285851404 -0700
@@ -11082,7 +11082,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
diff -ruN gcc-7.3.0/libstdc++-v3/acinclude.m4 gcc-7.3.0-msp430/libstdc++-v3/acinclude.m4
--- gcc-7.3.0/libstdc++-v3/acinclude.m4	2017-06-16 05:18:53.726871000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/acinclude.m4	2019-06-25 02:27:32.285851404 -0700
@@ -3062,7 +3062,7 @@
 dnl
 dnl Defines:
 dnl  _GLIBCXX_USE_INT128
-dnl  _GLIBCXX_USE_FLOAT128
+dnl  ENABLE_FLOAT128
 dnl
 AC_DEFUN([GLIBCXX_ENABLE_INT128_FLOAT128], [
 
@@ -3117,13 +3117,12 @@
 
     AC_MSG_CHECKING([for __float128])
     if AC_TRY_EVAL(ac_compile); then
-      AC_DEFINE(_GLIBCXX_USE_FLOAT128, 1,
-      [Define if __float128 is supported on this host.])
       enable_float128=yes
     else
       enable_float128=no
     fi
     AC_MSG_RESULT($enable_float128)
+    GLIBCXX_CONDITIONAL(ENABLE_FLOAT128, test $enable_float128 = yes)
     rm -f conftest*
 
   AC_LANG_RESTORE
diff -ruN gcc-7.3.0/libstdc++-v3/ChangeLog gcc-7.3.0-msp430/libstdc++-v3/ChangeLog
--- gcc-7.3.0/libstdc++-v3/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/ChangeLog	2019-06-25 02:27:32.285851404 -0700
@@ -1,3 +1,564 @@
+2018-08-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Revert
+	2018-08-10  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	PR target/85904
+	* configure.ac: Define HAVE_ALIGNED_ALLOC if building for
+	Newlib.
+	* configure: Regenerate.
+
+2018-08-10  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2018-08-10  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	PR target/85904
+	* configure.ac: Define HAVE_ALIGNED_ALLOC if building for
+	Newlib.
+	* configure: Regenerate.
+
+2018-08-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* libsupc++/new_opa.cc (aligned_alloc): Declare inside namespace to
+	avoid clashing with an ::aligned_alloc function that was not detected
+	by configure.
+
+	* doc/xml/manual/using.xml: Remove empty table cell.
+	* doc/html/*: Regenerate.
+
+	* doc/xml/manual/using.xml: Add missing header to table and fix typo.
+	Remove C++17 and C++2a headers not present on gcc-7-branch.
+	* doc/html/*: Regenerate.
+
+2018-08-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-06-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86138
+	* include/bits/basic_string.tcc: [_GLIBCXX_EXTERN_TEMPLATE < 0]
+	Declare explicit instantiations of COW empty reps and I/O functions.
+
+	Backport from mainline
+	2018-05-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85672
+	* include/Makefile.am [!ENABLE_FLOAT128]: Change c++config.h entry
+	to #undef _GLIBCXX_USE_FLOAT128 instead of defining it to zero.
+	* include/Makefile.in: Regenerate.
+	* include/bits/c++config (_GLIBCXX_USE_FLOAT128): Move definition
+	within conditional block.
+
+	Backport from mainline
+	2018-05-01  Tulio Magno Quites Machado Filho  <tuliom@linux.vnet.ibm.com>
+
+	PR libstdc++/84654
+	* acinclude.m4: Set ENABLE_FLOAT128 instead of _GLIBCXX_USE_FLOAT128.
+	* config.h.in: Remove references to _GLIBCXX_USE_FLOAT128.
+	* configure: Regenerate.
+	* include/Makefile.am: Replace the value of _GLIBCXX_USE_FLOAT128
+	based on ENABLE_FLOAT128.
+	* include/Makefile.in: Regenerate.
+	* include/bits/c++config: Define _GLIBCXX_USE_FLOAT128.
+	[!defined(__FLOAT128__) && !defined(__SIZEOF_FLOAT128__)]: Undefine
+	_GLIBCXX_USE_FLOAT128.
+
+	Backport from mainline
+	2017-06-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/80893
+	* testsuite/23_containers/vector/bool/80893.cc: Add { target c++11 }.
+
+	Backport from mainline
+	2017-05-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/80893
+	* include/bits/stl_bvector.h (vector<bool>::_M_initialize): Avoid
+	null pointer dereference when size is zero.
+	* testsuite/23_containers/vector/bool/80893.cc: New.
+	* testsuite/util/testsuite_allocator.h (PointerBase::PointerBase):
+	Add non-explicit constructor from nullptr.
+	(PointerBase::derived() const): Add const-qualified overload.
+
+	Backport from mainline
+	2017-12-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/68519
+	* include/std/condition_variable (condition_variable::wait_for):
+	Convert duration to native clock's duration before addition.
+	* testsuite/30_threads/condition_variable/members/68519.cc: New test.
+
+	Backport from mainline
+	2018-06-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86292
+	* include/bits/stl_vector.h (vector::_M_range_initialize<InputIter>):
+	Add try-catch block.
+	* testsuite/23_containers/vector/cons/86292.cc: New.
+
+	Backport from mainline
+	2018-07-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/test.xml: Improve documentation on writing tests for
+	newer standards.
+	* doc/xml/manual/using.xml: Document all headers for C++11 and later.
+	* doc/html/*: Regenerate.
+
+	Backport from mainline
+	2018-08-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/system_error.cc
+	(system_error_category::default_error_condition): Add workaround for
+	ENOTEMPTY and EEXIST having the same value on AIX.
+	* testsuite/19_diagnostics/error_category/system_category.cc: Add
+	extra testcases for EDOM, EILSEQ, ERANGE, EEXIST and ENOTEMPTY.
+
+	Backport from mainline
+	2018-08-01  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/60555
+	* src/c++11/system_error.cc
+	(system_error_category::default_error_condition): New override to
+	check for POSIX errno values.
+	* testsuite/19_diagnostics/error_category/generic_category.cc: New
+	* testsuite/19_diagnostics/error_category/system_category.cc: New
+	test.
+
+	Backport from mainline
+	2018-08-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86861
+	* libsupc++/new_opa.cc [_GLIBCXX_HAVE_MEMALIGN] (aligned_alloc):
+	Replace macro with inline function.
+	[__sun]: Increase alignment to meet memalign precondition.
+	[!HAVE__ALIGNED_MALLOC && !HAVE_POSIX_MEMALIGN && !HAVE_MEMALIGN]
+	(aligned_alloc): Move check for valid alignment to operator new.
+	Remove redundant check for non-zero size, it's enforced by the caller.
+	(operator new): Move check for valid alignment here. Use
+	__builtin_expect on check for zero size.
+
+	Backport from mainline
+	2018-07-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* libsupc++/new_opa.cc (operator new(size_t, align_val_t)): Add
+	workaround for aligned_alloc bug on AIX.
+	* testsuite/18_support/new_aligned.cc: New test.
+
+	Backport from mainline
+	2018-07-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86734
+	* include/bits/stl_iterator.h (reverse_iterator::operator->): Use
+	addressof (LWG 2188).
+	* testsuite/24_iterators/reverse_iterator/dr2188.cc: New test.
+
+	Backport from mainline
+	2018-05-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/codecvt.cc (__codecvt_utf8_base<wchar_t>::do_in)
+	[__SIZEOF_WCHAR_T__==2 && __BYTE_ORDER__!=__ORDER_BIG_ENDIAN__]: Set
+	little_endian element in bitmask.
+	* testsuite/22_locale/codecvt/codecvt_utf8/69703.cc: Run all tests.
+	* testsuite/22_locale/codecvt/codecvt_utf8/wchar_t/1.cc: New.
+
+2018-07-05  Franois Dumont  <fdumont@gcc.gnu.org>
+
+	Backport from mainline
+	2018-07-04  Franois Dumont  <fdumont@gcc.gnu.org>
+
+	PR libstdc++/86272
+	* include/debug/string
+	(__gnu_debug::basic_string<>::insert<_Ite>(const_iterator, _Ite, _Ite)):
+	Use __glibcxx_check_insert_range.
+
+2018-07-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-03-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	src/filesystem/ops.cc (create_dir): Pass error_code to is_directory.
+
+	Backport from mainline
+	2018-06-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	LWG 3050 Fix cv-qualification of convertibility constraints
+	* include/std/chrono (duration, operator*, operator/, operator%): Use
+	const-qualified type as source type in is_convertible constraints.
+	* testsuite/20_util/duration/arithmetic/dr3050.cc: New.
+	* testsuite/20_util/duration/cons/dr3050.cc: New.
+	* testsuite/20_util/duration/literals/range.cc: Rename to...
+	* testsuite/20_util/duration/literals/range_neg.cc: Here. Adjust
+	dg-error lineno.
+
+	Backport from mainline
+	2018-06-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86127
+	* include/bits/forward_list.h (_Fwd_list_base::_Tp_alloc_type): Remove
+	unused typedef.
+	(_Fwd_list_base::_M_create_node, _Fwd_list_base::_M_erase_after):
+	Use node allocator to create and destroy elements.
+	(forward_list::_Tp_alloc_type): Remove unused typedef.
+	(forward_list::_Alloc_traits): Use allocator_traits instead of
+	__gnu_cxx::__alloc_traits.
+	* include/bits/forward_list.tcc (_Fwd_list_base::_M_erase_after):
+	Use node allocator to create and destroy elements.
+
+	Backport from mainline
+	2018-05-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (__erased_dtor): Qualify call to __get.
+
+	Backport from mainline
+	2018-05-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (__gen_vtable_impl::__visit_invoke): Qualify
+	__invoke to prevent ADL.
+
+	Backport from mainline
+	2018-04-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (_VARIANT_RELATION_FUNCTION_TEMPLATE): Qualify
+	__get calls to avoid ADL and avoid ambiguity due to Clang bug.
+
+	Backport from mainline
+	2018-03-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (__get): Qualify calls to avoid ADL.
+	(__select_index): Adjust whitespace.
+	(variant): Add using-declaration to workaround Clang bug.
+
+	Backport from mainline
+	2018-05-24  Maya Rashish  <coypu@sdf.org>
+
+	PR target/85904
+	* crossconfig.m4: Test for aligned_alloc on netbsd.
+	* configure: Regenerate.
+
+	Backport from mainline
+	2018-05-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85098
+	* include/bits/regex.h [__cplusplus < 201703L] (basic_regex::icase)
+	(basic_regex::nosubs, basic_regex::optimize, basic_regex::collate)
+	(basic_regex::ECMAScript, basic_regex::basic, basic_regex::extended)
+	(basic_regex::awk, basic_regex::grep, basic_regex::egrep): Add
+	definitions.
+	* include/bits/regex_automaton.h (_NFA::_M_insert_state): Adjust
+	whitespace.
+	* testsuite/28_regex/basic_regex/85098.cc: New
+
+	Backport from mainline
+	2018-05-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85671
+	* include/experimental/bits/fs_path.h (operator/): Likewise.
+
+	Backport from mainline
+	2018-06-14  Daniel Trebbien <dtrebbien@gmail.com>
+		    Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/83982
+	* include/bits/vector.tcc (vector::_M_default_append(size_type)):
+	Default-construct new elements before moving existing ones.
+	* testsuite/23_containers/vector/capacity/resize/strong_guarantee.cc:
+	New.
+
+	Backport from mainline
+	2018-05-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84087 LWG DR 2268 basic_string default arguments
+	* include/bits/basic_string.h [_GLIBCXX_USE_CXX11_ABI=1]
+	(append(const basic_string&, size_type, size_type)
+	(assign(const basic_string&, size_type, size_type)
+	(insert(size_type, const basic_string&, size_type, size_type)
+	(replace(size_type,size_type,const basic_string&,size_type,size_type)
+	(compare(size_type,size_type,constbasic_string&,size_type,size_type)):
+	Add default arguments (LWG 2268).
+	[_GLIBCXX_USE_CXX11_ABI=0]
+	(append(const basic_string&, size_type, size_type)
+	(assign(const basic_string&, size_type, size_type)
+	(insert(size_type, const basic_string&, size_type, size_type)
+	(replace(size_type,size_type,const basic_string&,size_type,size_type)
+	(compare(size_type,size_type,constbasic_string&,size_type,size_type)):
+	Likewise.
+	* testsuite/21_strings/basic_string/dr2268.cc: New test.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-06-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-06-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86138
+	* include/bits/basic_string.tcc:
+	[__cplusplus > 201402 && !_GLIBCXX_USE_CXX11_ABI]
+	(basic_string<char>::_Rep::_S_empty_rep_storage)
+	(basic_string<wchar_t>::_Rep::_S_empty_rep_storage): Add explicit
+	instantiation declarations.
+	[__cplusplus > 201402] (operator>>, operator<<, getline): Re-enable
+	explicit instantiation declarations.
+	* testsuite/21_strings/basic_string/cons/char/86138.cc: New.
+	* testsuite/21_strings/basic_string/cons/wchar_t/86138.cc: New.
+
+2018-06-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	* config/abi/post/x86_64-linux-gnu/baseline_symbols.txt: Update.
+
+2018-06-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/utility: Remove unused <exception> header.
+
+2018-06-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86169
+	* include/bits/basic_string.h [!_GLIBCXX_USE_CXX11_ABI]
+	(basic_string::data()): Unshare string.
+	* testsuite/21_strings/basic_string/operations/data/char/86169.cc:
+	New.
+
+2018-06-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/char_traits.h (__cpp_lib_constexpr_char_traits): Only
+	define for C++17 and above.
+
+2018-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85812
+	* libsupc++/cxxabi_init_exception.h (__cxa_free_exception): Declare.
+	* libsupc++/exception_ptr.h (make_exception_ptr) [__cpp_exceptions]:
+	Refactor to separate non-throwing and throwing implementations.
+	[__cpp_rtti && !_GLIBCXX_HAVE_CDTOR_CALLABI]: Deallocate the memory
+	if constructing the object throws.
+
+2018-05-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/67554
+	* include/bits/valarray_array.h (_Array_copy_ctor<_Tp, true>)
+	(_Array_copier<_Tp, true>): Do not pass null pointers to memcpy.
+
+	PR libstdc++/82966
+	* include/bits/node_handle.h (_Node_handle_common::_M_swap): Use value
+	instead of type.
+	* testsuite/23_containers/set/modifiers/node_swap.cc: New.
+
+2018-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/faq.xml: Link to C++17 status. Add note to outdated answer.
+	* doc/xml/manual/debug_mode.xml: Add array and forward_list to list
+	of C++11 containers with Debug Mode support.
+	* doc/xml/manual/using.xml: Document Dual ABI for ios_base::failure.
+	* doc/html/*: Regenerate.
+
+2018-05-07  Edward Smith-Rowland  <3dw4rd@verizon.net>
+	    Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-05-07  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	PR libstdc++/80506
+	* include/bits/random.tcc (gamma_distribution::operator()): Fix magic
+	number used in loop condition.
+	(gamma_distribution::__generate_impl()): Ditto.
+
+2018-05-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84769
+	* include/std/variant (visit): Qualify std::get call.
+
+	PR libstdc++/85632 use uintmax_t for arithmetic
+	* src/filesystem/ops.cc (experimental::filesystem::space): Perform
+	arithmetic in result type.
+	* testsuite/experimental/filesystem/operations/space.cc: New.
+
+2018-04-30  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	PR libstdc++/pr66689 - comp_ellint_3 and ellint_3 return garbage values
+	* include/tr1/ell_integral.tcc: Correct the nu sign convention
+	in ellint_3 and comp_ellint_3.
+	* testsuite/tr1/5_numerical_facilities/special_functions/
+	06_comp_ellint_3/check_value.cc: Regen with correct values.
+	* testsuite/tr1/5_numerical_facilities/special_functions/
+	14_ellint_3/check_value.cc: Ditto.
+	* testsuite/special_functions/06_comp_ellint_3/check_value.cc: Ditto.
+	* testsuite/special_functions/13_ellint_3/check_value.cc: Ditto.
+	* testsuite/special_functions/06_comp_ellint_3/pr66689.cc: New.
+	* testsuite/special_functions/13_ellint_3/pr66689.cc: New.
+	* testsuite/tr1/5_numerical_facilities/special_functions/
+	06_comp_ellint_3/pr66689.cc: New.
+	* testsuite/tr1/5_numerical_facilities/special_functions/
+	14_ellint_3/pr66689.cc: New.
+
+2018-04-30  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	PR libstdc++/68397 std::tr1::expint fails ... long double arguments.
+	* include/tr1/exp_integral.tcc: Increase iteration limits.
+	* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/
+	pr68397.cc: New test.
+	* testsuite/special_functions/14_expint/pr68397.cc: New test.
+
+2018-04-18  Jonathan Wakely  <jwakely@redhat.com>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR libstdc++/85442
+	* src/c++11/Makefile.am: Don't generate debuginfo again for
+	cxx11-ios_failure-lt.s and cxx11-ios_failure.s files.
+	* src/c++11/Makefile.in: Regenerate.
+
+2018-04-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/Makefile.am: Fix sed command.
+	* src/c++11/Makefile.in: Regenerate.
+
+	* src/c++11/Makefile.am: Rewrite sed rule to be less fragile and to
+	handle mangled names starting with double underscores on darwin.
+	* src/c++11/Makefile.in: Regenerate.
+
+2018-04-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/Makefile.am: Fix comment.
+	* src/c++11/Makefile.in: Regenerate.
+	* src/c++11/cxx11-ios_failure.cc: Fix comment.
+	* src/c++98/ios_failure.cc: Likewise.
+
+	Backport from mainline
+	2018-04-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85222
+	* src/c++11/Makefile.am [ENABLE_DUAL_ABI]: Add special rules for
+	cxx11-ios_failure.cc to rewrite type info for __ios_failure.
+	* src/c++11/Makefile.in: Regenerate.
+	* src/c++11/cxx11-ios_failure.cc (__ios_failure, __iosfail_type_info):
+	New types.
+	[_GLIBCXX_USE_DUAL_ABI] (__throw_ios_failure): Define here.
+	* src/c++11/ios.cc (__throw_ios_failure): Remove definition.
+	(_GLIBCXX_USE_CXX11_ABI): Don't define here.
+	* src/c++98/ios_failure.cc (__construct_ios_failure)
+	(__destroy_ios_failure, is_ios_failure_handler): New functions.
+	[!_GLIBCXX_USE_DUAL_ABI] (__throw_ios_failure): Define here.
+	* testsuite/27_io/ios_base/failure/dual_abi.cc: New.
+	* testsuite/27_io/basic_ios/copyfmt/char/1.cc: Revert changes to
+	handler types, to always catch std::ios_base::failure.
+	* testsuite/27_io/basic_ios/exceptions/char/1.cc: Likewise.
+	* testsuite/27_io/basic_istream/extractors_arithmetic/char/
+	exceptions_failbit.cc: Likewise.
+	* testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/
+	exceptions_failbit.cc: Likewise.
+	* testsuite/27_io/basic_istream/extractors_other/char/
+	exceptions_null.cc: Likewise.
+	* testsuite/27_io/basic_istream/extractors_other/wchar_t/
+	exceptions_null.cc: Likewise.
+	* testsuite/27_io/basic_istream/sentry/char/12297.cc: Likewise.
+	* testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc: Likewise.
+	* testsuite/27_io/basic_ostream/inserters_other/char/
+	exceptions_null.cc: Likewise.
+	* testsuite/27_io/basic_ostream/inserters_other/wchar_t/
+	exceptions_null.cc: Likewise.
+	* testsuite/27_io/ios_base/storage/2.cc: Likewise.
+
+2018-03-22  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR libstdc++/77691
+	* testsuite/experimental/memory_resource/resource_adaptor.cc:
+	xfail execution on 32-bit Solaris/x86.
+
+2018-03-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-03-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84769
+	* include/std/variant (get<_Tp, _Types...>, get_if<_Tp, _Types...>):
+	Qualify calls to get<_Np, Types...> and get_if<_Np, _Types...>.
+
+2018-03-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84773
+	PR libstdc++/83662
+	* crossconfig.m4: Check for aligned_alloc etc. on freebsd and mingw32.
+	* configure: Regenerate.
+	* include/c_global/cstdlib [_GLIBCXX_HAVE_ALIGNED_ALLOC]
+	(aligned_alloc): Add using-declaration.
+	* testsuite/18_support/aligned_alloc/aligned_alloc.cc: New test.
+
+2018-03-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-03-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84671
+	* include/bits/parse_numbers.h (_Number_help): Add partial
+	specialization to handle digit separators. Adjust partial
+	specialization for recursion temrination to require _Pow == 1ULL.
+	* testsuite/20_util/duration/literals/84671.cc: New
+
+2018-02-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-02-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84532
+	* include/std/thread (thread::__make_invoker): Construct tuple
+	directly instead of using make_tuple.
+	* testsuite/30_threads/async/84532.cc: New.
+	* testsuite/30_threads/thread/84532.cc: New.
+
+2018-02-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-02-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81797
+	* configure.ac (INCLUDE_DIR_NOTPARALLEL): Define.
+	* configure: Regenerate.
+	* include/Makefile.am (INCLUDE_DIR_NOTPARALLEL): Add .NOTPARALLEL when
+	defined.
+	* include/Makefile.in: Regenerate.
+
+2018-01-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/83833
+	* testsuite/26_numerics/random/chi_squared_distribution/83833.cc:
+	Add -ffloat-store to options for m68k and ia32.
+
+	PR libstdc++/83658
+	* include/std/any (any::__do_emplace): Only set _M_manager after
+	constructing the contained object.
+	* testsuite/20_util/any/misc/any_cast_neg.cc: Adjust dg-error line.
+	* testsuite/20_util/any/modifiers/83658.cc: New test.
+
+	Backport from mainline
+	2018-01-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/83833
+	* include/bits/random.h (chi_squared_distribution::param): Update
+	gamma distribution parameter.
+	* testsuite/26_numerics/random/chi_squared_distribution/83833.cc: New
+	test.
+
+2018-01-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81076
+	* include/c_global/cstddef (__byte_operand): Define primary template.
+	* testsuite/18_support/byte/81076.cc: New test.
+
+	Backport from mainline
+	2018-01-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/83830
+	* include/std/type_traits (has_unique_object_representations_v): Add
+	variable template.
+	* testsuite/20_util/has_unique_object_representations/value.cc: Check
+	variable template.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt gcc-7.3.0-msp430/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
--- gcc-7.3.0/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt	2017-02-13 07:38:33.493123000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt	2019-06-25 02:27:32.285851404 -0700
@@ -4004,6 +4004,7 @@
 OBJECT:0:GLIBCXX_3.4.21
 OBJECT:0:GLIBCXX_3.4.22
 OBJECT:0:GLIBCXX_3.4.23
+OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
diff -ruN gcc-7.3.0/libstdc++-v3/config.h.in gcc-7.3.0-msp430/libstdc++-v3/config.h.in
--- gcc-7.3.0/libstdc++-v3/config.h.in	2017-03-15 08:23:44.375067000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/config.h.in	2019-06-25 02:27:32.285851404 -0700
@@ -912,9 +912,6 @@
 /* Define if fchmodat is available in <sys/stat.h>. */
 #undef _GLIBCXX_USE_FCHMODAT
 
-/* Define if __float128 is supported on this host. */
-#undef _GLIBCXX_USE_FLOAT128
-
 /* Defined if gettimeofday is available. */
 #undef _GLIBCXX_USE_GETTIMEOFDAY
 
diff -ruN gcc-7.3.0/libstdc++-v3/configure gcc-7.3.0-msp430/libstdc++-v3/configure
--- gcc-7.3.0/libstdc++-v3/configure	2017-06-21 01:55:52.630537000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/configure	2019-06-25 02:27:32.289851375 -0700
@@ -620,6 +620,8 @@
 ATOMIC_FLAGS
 ATOMIC_WORD_SRCDIR
 ATOMICITY_SRCDIR
+INCLUDE_DIR_NOTPARALLEL_FALSE
+INCLUDE_DIR_NOTPARALLEL_TRUE
 BUILD_PDF_FALSE
 BUILD_PDF_TRUE
 PDFLATEX
@@ -726,6 +728,8 @@
 CSTDIO_H
 SECTION_FLAGS
 WERROR
+ENABLE_FLOAT128_FALSE
+ENABLE_FLOAT128_TRUE
 thread_header
 glibcxx_PCHFLAGS
 GLIBCXX_BUILD_PCH_FALSE
@@ -11601,7 +11605,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11604 "configure"
+#line 11608 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11707,7 +11711,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11710 "configure"
+#line 11714 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15393,7 +15397,7 @@
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15396 "configure"
+#line 15400 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15428,7 +15432,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15431 "configure"
+#line 15435 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15463,7 +15467,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15466 "configure"
+#line 15470 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15499,7 +15503,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15502 "configure"
+#line 15506 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15580,7 +15584,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15583 "configure"
+#line 15587 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -15622,7 +15626,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15625 "configure"
+#line 15629 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15656,7 +15660,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15659 "configure"
+#line 15663 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15678,15 +15682,13 @@
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }; then
-
-$as_echo "#define _GLIBCXX_USE_FLOAT128 1" >>confdefs.h
-
       enable_float128=yes
     else
       enable_float128=no
     fi
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_float128" >&5
 $as_echo "$enable_float128" >&6; }
+
     rm -f conftest*
 
   ac_ext=c
@@ -53327,6 +53329,19 @@
 fi
 done
 
+    for ac_func in aligned_alloc posix_memalign memalign _aligned_malloc
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
     ;;
 
   *-fuchsia*)
@@ -66077,6 +66092,19 @@
 
   CXXFLAGS="$ac_save_CXXFLAGS"
 
+    for ac_func in aligned_alloc posix_memalign memalign _aligned_malloc
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
     ;;
   *-netbsd*)
     SECTION_FLAGS='-ffunction-sections -fdata-sections'
@@ -66244,6 +66272,19 @@
       $as_echo "#define HAVE_ISNANL 1" >>confdefs.h
 
     fi
+    for ac_func in aligned_alloc posix_memalign memalign _aligned_malloc
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
     ;;
   *-qnx6.1* | *-qnx6.2*)
     SECTION_FLAGS='-ffunction-sections -fdata-sections'
@@ -81219,6 +81260,18 @@
 fi
 
 
+case "$build" in
+ *-*-darwin* ) glibcxx_include_dir_notparallel=yes ;;
+ * ) glibcxx_include_dir_notparallel=no ;;
+esac
+ if test $glibcxx_include_dir_notparallel = "yes"; then
+  INCLUDE_DIR_NOTPARALLEL_TRUE=
+  INCLUDE_DIR_NOTPARALLEL_FALSE='#'
+else
+  INCLUDE_DIR_NOTPARALLEL_TRUE='#'
+  INCLUDE_DIR_NOTPARALLEL_FALSE=
+fi
+
 
 # Propagate the target-specific source directories through the build chain.
 ATOMICITY_SRCDIR=config/${atomicity_dir}
@@ -81262,6 +81315,15 @@
 fi
 
 
+    if test $enable_float128 = yes; then
+  ENABLE_FLOAT128_TRUE=
+  ENABLE_FLOAT128_FALSE='#'
+else
+  ENABLE_FLOAT128_TRUE='#'
+  ENABLE_FLOAT128_FALSE=
+fi
+
+
     if test $enable_libstdcxx_allocator_flag = new; then
   ENABLE_ALLOCATOR_NEW_TRUE=
   ENABLE_ALLOCATOR_NEW_FALSE='#'
@@ -81657,7 +81719,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
@@ -81805,6 +81867,10 @@
   as_fn_error "conditional \"GLIBCXX_BUILD_PCH\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${ENABLE_FLOAT128_TRUE}" && test -z "${ENABLE_FLOAT128_FALSE}"; then
+  as_fn_error "conditional \"ENABLE_FLOAT128\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${ENABLE_ALLOCATOR_NEW_TRUE}" && test -z "${ENABLE_ALLOCATOR_NEW_FALSE}"; then
   as_fn_error "conditional \"ENABLE_ALLOCATOR_NEW\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
@@ -81913,6 +81979,10 @@
   as_fn_error "conditional \"BUILD_PDF\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${INCLUDE_DIR_NOTPARALLEL_TRUE}" && test -z "${INCLUDE_DIR_NOTPARALLEL_FALSE}"; then
+  as_fn_error "conditional \"INCLUDE_DIR_NOTPARALLEL\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 
 : ${CONFIG_STATUS=./config.status}
 ac_write_fail=0
diff -ruN gcc-7.3.0/libstdc++-v3/configure.ac gcc-7.3.0-msp430/libstdc++-v3/configure.ac
--- gcc-7.3.0/libstdc++-v3/configure.ac	2017-01-17 01:38:48.048122000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/configure.ac	2019-06-25 02:27:32.289851375 -0700
@@ -467,6 +467,12 @@
 	       test $ac_cv_prog_DBLATEX = "yes" &&
 	       test $ac_cv_prog_PDFLATEX = "yes")
 
+case "$build" in
+ *-*-darwin* ) glibcxx_include_dir_notparallel=yes ;;
+ * ) glibcxx_include_dir_notparallel=no ;;
+esac
+AM_CONDITIONAL(INCLUDE_DIR_NOTPARALLEL,
+               test $glibcxx_include_dir_notparallel = "yes")
 
 # Propagate the target-specific source directories through the build chain.
 ATOMICITY_SRCDIR=config/${atomicity_dir}
diff -ruN gcc-7.3.0/libstdc++-v3/crossconfig.m4 gcc-7.3.0-msp430/libstdc++-v3/crossconfig.m4
--- gcc-7.3.0/libstdc++-v3/crossconfig.m4	2017-01-17 15:36:12.846709000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/crossconfig.m4	2019-06-25 02:27:32.289851375 -0700
@@ -133,6 +133,7 @@
       AC_DEFINE(HAVE_ISNANL)
     fi
     AC_CHECK_FUNCS(__cxa_thread_atexit)
+    AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)
     ;;
 
   *-fuchsia*)
@@ -197,6 +198,7 @@
     GLIBCXX_CHECK_LINKER_FEATURES
     GLIBCXX_CHECK_MATH_SUPPORT
     GLIBCXX_CHECK_STDLIB_SUPPORT
+    AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)
     ;;
   *-netbsd*)
     SECTION_FLAGS='-ffunction-sections -fdata-sections'
@@ -215,6 +217,7 @@
       AC_DEFINE(HAVE_ISINFL)
       AC_DEFINE(HAVE_ISNANL)
     fi
+    AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)
     ;;
   *-qnx6.1* | *-qnx6.2*)
     SECTION_FLAGS='-ffunction-sections -fdata-sections'
diff -ruN gcc-7.3.0/libstdc++-v3/doc/html/faq.html gcc-7.3.0-msp430/libstdc++-v3/doc/html/faq.html
--- gcc-7.3.0/libstdc++-v3/doc/html/faq.html	2017-10-25 07:18:43.456751000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/doc/html/faq.html	2019-06-25 02:27:32.289851375 -0700
@@ -534,14 +534,15 @@
     except for some corner cases.  Support for localization
     in <code class="classname">locale</code> may be incomplete on some non-GNU
     platforms. Also dependent on the underlying platform is support
-    for <span class="type">wchar_t</span> and <span class="type">long
-    long</span> specializations, and details of thread support.
+    for <span class="type">wchar_t</span> and <span class="type">long long</span> specializations,
+    and details of thread support.
     </p><p>    
     Long answer: See the implementation status pages for 
     <a class="link" href="manual/status.html#status.iso.1998" title="C++ 1998/2003">C++98</a>,
-    <a class="link" href="manual/status.html#status.iso.tr1" title="C++ TR1">TR1</a>, and 
-    <a class="link" href="manual/status.html#status.iso.2011" title="C++ 2011">C++11</a>.
-    <a class="link" href="manual/status.html#status.iso.2014" title="C++ 2014">C++14</a>.
+    <a class="link" href="manual/status.html#status.iso.tr1" title="C++ TR1">TR1</a>,
+    <a class="link" href="manual/status.html#status.iso.2011" title="C++ 2011">C++11</a>,
+    <a class="link" href="manual/status.html#status.iso.2014" title="C++ 2014">C++14</a>, and
+    <a class="link" href="manual/status.html#status.iso.2017" title="C++ 2017">C++17</a>.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.standard_bugs"></a><a id="q-standard_bugs"></a><p><strong>5.2.</strong></p></td><td align="left" valign="top"><p>
       Bugs in the ISO C++ language or library specification
     </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-standard_bugs"></a></td><td align="left" valign="top"><p>
@@ -633,7 +634,7 @@
     without other drawbacks, send us a patch.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.ambiguous_overloads"></a><a id="q-ambiguous_overloads"></a><p><strong>6.3.</strong></p></td><td align="left" valign="top"><p>
       Ambiguous overloads after including an old-style header
-    </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-ambiguous_overloads"></a></td><td align="left" valign="top"><p>
+    </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-ambiguous_overloads"></a></td><td align="left" valign="top"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This answer is old and probably no longer be relevant.</p></div><p>
     Another problem is the <code class="literal">rel_ops</code> namespace and the template
     comparison operator functions contained therein.  If they become
     visible in the same namespace as other comparison functions
diff -ruN gcc-7.3.0/libstdc++-v3/doc/html/manual/debug_mode_using.html gcc-7.3.0-msp430/libstdc++-v3/doc/html/manual/debug_mode_using.html
--- gcc-7.3.0/libstdc++-v3/doc/html/manual/debug_mode_using.html	2017-10-25 07:18:43.456751000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/doc/html/manual/debug_mode_using.html	2019-06-25 02:27:32.289851375 -0700
@@ -20,4 +20,4 @@
   containers:
 </p><div class="table"><a id="table.debug_mode_containers"></a><p class="title"><strong>Table17.1.Debugging Containers</strong></p><div class="table-contents"><table class="table" summary="Debugging Containers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Container</th><th align="left">Header</th><th align="left">Debug container</th><th align="left">Debug header</th></tr></thead><tbody><tr><td align="left"><code class="classname">std::bitset</code></td><td align="left"><code class="filename">bitset</code></td><td align="left"><code class="classname">__gnu_debug::bitset</code></td><td align="left"><code class="filename">&lt;debug/bitset&gt;</code></td></tr><tr><td align="left"><code class="classname">std::deque</code></td><td align="left"><code class="filename">deque</code></td><td align="left"><code class="classname">__gnu_debug::deque</code></td><td align="left"><code class="filename">&lt;debug/deque&gt;</code></td></tr><tr><td align="left"><code class="classname">std::list</code></td><td align="left"><code class="filename">list</code></td><td align="left"><code class="classname">__gnu_debug::list</code></td><td align="left"><code class="filename">&lt;debug/list&gt;</code></td></tr><tr><td align="left"><code class="classname">std::map</code></td><td align="left"><code class="filename">map</code></td><td align="left"><code class="classname">__gnu_debug::map</code></td><td align="left"><code class="filename">&lt;debug/map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::multimap</code></td><td align="left"><code class="filename">map</code></td><td align="left"><code class="classname">__gnu_debug::multimap</code></td><td align="left"><code class="filename">&lt;debug/map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::multiset</code></td><td align="left"><code class="filename">set</code></td><td align="left"><code class="classname">__gnu_debug::multiset</code></td><td align="left"><code class="filename">&lt;debug/set&gt;</code></td></tr><tr><td align="left"><code class="classname">std::set</code></td><td align="left"><code class="filename">set</code></td><td align="left"><code class="classname">__gnu_debug::set</code></td><td align="left"><code class="filename">&lt;debug/set&gt;</code></td></tr><tr><td align="left"><code class="classname">std::string</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="classname">__gnu_debug::string</code></td><td align="left"><code class="filename">&lt;debug/string&gt;</code></td></tr><tr><td align="left"><code class="classname">std::wstring</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="classname">__gnu_debug::wstring</code></td><td align="left"><code class="filename">&lt;debug/string&gt;</code></td></tr><tr><td align="left"><code class="classname">std::basic_string</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="classname">__gnu_debug::basic_string</code></td><td align="left"><code class="filename">&lt;debug/string&gt;</code></td></tr><tr><td align="left"><code class="classname">std::vector</code></td><td align="left"><code class="filename">vector</code></td><td align="left"><code class="classname">__gnu_debug::vector</code></td><td align="left"><code class="filename">&lt;debug/vector&gt;</code></td></tr></tbody></table></div></div><br class="table-break" /><p>In addition, when compiling in C++11 mode, these additional
 containers have additional debug capability.
-</p><div class="table"><a id="table.debug_mode_containers_cxx11"></a><p class="title"><strong>Table17.2.Debugging Containers C++11</strong></p><div class="table-contents"><table class="table" summary="Debugging Containers C++11" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Container</th><th align="left">Header</th><th align="left">Debug container</th><th align="left">Debug header</th></tr></thead><tbody><tr><td align="left"><code class="classname">std::unordered_map</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="classname">__gnu_debug::unordered_map</code></td><td align="left"><code class="filename">&lt;debug/unordered_map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_multimap</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="classname">__gnu_debug::unordered_multimap</code></td><td align="left"><code class="filename">&lt;debug/unordered_map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_set</code></td><td align="left"><code class="filename">unordered_set</code></td><td align="left"><code class="classname">__gnu_debug::unordered_set</code></td><td align="left"><code class="filename">&lt;debug/unordered_set&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_multiset</code></td><td align="left"><code class="filename">unordered_set</code></td><td align="left"><code class="classname">__gnu_debug::unordered_multiset</code></td><td align="left"><code class="filename">&lt;debug/unordered_set&gt;</code></td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="debug_mode_semantics.html">Prev</a></td><td width="20%" align="center"><a accesskey="u" href="debug_mode.html">Up</a></td><td width="40%" align="right"><a accesskey="n" href="debug_mode_design.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Semantics</td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top">Design</td></tr></table></div></body></html>
\ No newline at end of file
+</p><div class="table"><a id="table.debug_mode_containers_cxx11"></a><p class="title"><strong>Table17.2.Debugging Containers C++11</strong></p><div class="table-contents"><table class="table" summary="Debugging Containers C++11" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Container</th><th align="left">Header</th><th align="left">Debug container</th><th align="left">Debug header</th></tr></thead><tbody><tr><td align="left"><code class="classname">std::array</code></td><td align="left"><code class="filename">array</code></td><td align="left"><code class="classname">__gnu_debug::array</code></td><td align="left"><code class="filename">&lt;debug/array&gt;</code></td></tr><tr><td align="left"><code class="classname">std::forward_list</code></td><td align="left"><code class="filename">forward_list</code></td><td align="left"><code class="classname">__gnu_debug::forward_list</code></td><td align="left"><code class="filename">&lt;debug/forward_list&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_map</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="classname">__gnu_debug::unordered_map</code></td><td align="left"><code class="filename">&lt;debug/unordered_map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_multimap</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="classname">__gnu_debug::unordered_multimap</code></td><td align="left"><code class="filename">&lt;debug/unordered_map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_set</code></td><td align="left"><code class="filename">unordered_set</code></td><td align="left"><code class="classname">__gnu_debug::unordered_set</code></td><td align="left"><code class="filename">&lt;debug/unordered_set&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_multiset</code></td><td align="left"><code class="filename">unordered_set</code></td><td align="left"><code class="classname">__gnu_debug::unordered_multiset</code></td><td align="left"><code class="filename">&lt;debug/unordered_set&gt;</code></td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="debug_mode_semantics.html">Prev</a></td><td width="20%" align="center"><a accesskey="u" href="debug_mode.html">Up</a></td><td width="40%" align="right"><a accesskey="n" href="debug_mode_design.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Semantics</td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top">Design</td></tr></table></div></body></html>
\ No newline at end of file
diff -ruN gcc-7.3.0/libstdc++-v3/doc/html/manual/index.html gcc-7.3.0-msp430/libstdc++-v3/doc/html/manual/index.html
--- gcc-7.3.0/libstdc++-v3/doc/html/manual/index.html	2018-01-18 12:31:32.065863000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/doc/html/manual/index.html	2019-06-25 02:27:32.289851375 -0700
@@ -149,7 +149,7 @@
 	  </a></dt><dt>22.10. <a href="policy_data_structures_design.html#id-1.3.5.9.4.3.3.3.23">Non-unique Mapping Containers</a></dt><dt>22.11. <a href="policy_data_structures_design.html#id-1.3.5.9.4.3.4.3.5">Point Iterator Hierarchy</a></dt><dt>22.12. <a href="policy_data_structures_design.html#id-1.3.5.9.4.3.4.4.5">Invalidation Guarantee Tags Hierarchy</a></dt><dt>22.13. <a href="policy_data_structures_design.html#id-1.3.5.9.4.3.5.7.4">Container Tag Hierarchy</a></dt><dt>22.14. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.2.3">Hash functions, ranged-hash functions, and
 	      range-hashing functions</a></dt><dt>22.15. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.5.3.4">Insert hash sequence diagram</a></dt><dt>22.16. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.5.3.6">Insert hash sequence diagram with a null policy</a></dt><dt>22.17. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.5.5.5">Hash policy class diagram</a></dt><dt>22.18. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.3.4.7">Balls and bins</a></dt><dt>22.19. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.3.5.3.6">Insert resize sequence diagram</a></dt><dt>22.20. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.3.5.3.9">Standard resize policy trigger sequence
 		diagram</a></dt><dt>22.21. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.3.5.3.10">Standard resize policy size sequence
-		diagram</a></dt><dt>22.22. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.5">Tree node invariants</a></dt><dt>22.23. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.8">Tree node invalidation</a></dt><dt>22.24. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.3">A tree and its update policy</a></dt><dt>22.25. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.8">Restoring node invariants</a></dt><dt>22.26. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.10">Insert update sequence</a></dt><dt>22.27. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.20">Useless update path</a></dt><dt>22.28. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.4.3.2.10">A PATRICIA trie</a></dt><dt>22.29. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.4.3.3.5">A trie and its update policy</a></dt><dt>22.30. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.5.3.3.3">A simple list</a></dt><dt>22.31. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.5.3.3.6">The counter algorithm</a></dt><dt>22.32. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.6.3.3.3">Underlying Priority-Queue Data-Structures.</a></dt><dt>22.33. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.6.3.4.4">Priority-Queue Data-Structure Tags.</a></dt><dt>B.1. <a href="appendix_porting.html#fig.build_hacking.deps">Configure and Build File Dependencies</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>1.1. <a href="status.html#table.cxx98_status">C++ 1998/2003 Implementation Status</a></dt><dt>1.2. <a href="status.html#table.cxx11_status">C++ 2011 Implementation Status</a></dt><dt>1.3. <a href="status.html#table.cxx14_status">C++ 2014 Implementation Status</a></dt><dt>1.4. <a href="status.html#table.ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.5. <a href="status.html#table.cxx17_status">C++ 2017 Implementation Status</a></dt><dt>1.6. <a href="status.html#table.cxx17_ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.7. <a href="status.html#table.tr1_status">C++ TR1 Implementation Status</a></dt><dt>1.8. <a href="status.html#table.decfp_status">C++ TR 24733 Implementation Status</a></dt><dt>1.9. <a href="status.html#table.specfun_status">C++ Special Functions Implementation Status</a></dt><dt>3.1. <a href="using.html#table.cmd_options">C++ Command Options</a></dt><dt>3.2. <a href="using_headers.html#table.cxx98_headers">C++ 1998 Library Headers</a></dt><dt>3.3. <a href="using_headers.html#table.cxx98_cheaders">C++ 1998 Library Headers for C Library Facilities</a></dt><dt>3.4. <a href="using_headers.html#table.cxx11_headers">C++ 2011 Library Headers</a></dt><dt>3.5. <a href="using_headers.html#table.cxx11_cheaders">C++ 2011 Library Headers for C Library Facilities</a></dt><dt>3.6. <a href="using_headers.html#table.tr1_headers">C++ TR 1 Library Headers</a></dt><dt>3.7. <a href="using_headers.html#table.tr1_cheaders">C++ TR 1 Library Headers for C Library Facilities</a></dt><dt>3.8. <a href="using_headers.html#table.decfp_headers">C++ TR 24733 Decimal Floating-Point Header</a></dt><dt>3.9. <a href="using_headers.html#table.abi_headers">C++ ABI Headers</a></dt><dt>3.10. <a href="using_headers.html#table.ext_headers">Extension Headers</a></dt><dt>3.11. <a href="using_headers.html#table.debug_headers">Extension Debug Headers</a></dt><dt>3.12. <a href="using_headers.html#table.profile_headers">Extension Profile Headers</a></dt><dt>3.13. <a href="using_headers.html#table.parallel_headers">Extension Parallel Headers</a></dt><dt>17.1. <a href="debug_mode_using.html#table.debug_mode_containers">Debugging Containers</a></dt><dt>17.2. <a href="debug_mode_using.html#table.debug_mode_containers_cxx11">Debugging Containers C++11</a></dt><dt>18.1. <a href="parallel_mode_using.html#table.parallel_algos">Parallel Algorithms</a></dt><dt>19.1. <a href="profile_mode_design.html#table.profile_code_loc">Profile Code Location</a></dt><dt>19.2. <a href="profile_mode_diagnostics.html#table.profile_diagnostics">Profile Diagnostics</a></dt><dt>21.1. <a href="bitmap_allocator_impl.html#table.bitmap_alloc">Bitmap Allocator Memory Map</a></dt><dt>B.1. <a href="documentation_hacking.html#table.doxygen_prereq">Doxygen Prerequisites</a></dt><dt>B.2. <a href="documentation_hacking.html#table.doxygen_cmp">HTML to Doxygen Markup Comparison</a></dt><dt>B.3. <a href="documentation_hacking.html#table.docbook_prereq">Docbook Prerequisites</a></dt><dt>B.4. <a href="documentation_hacking.html#table.docbook_cmp">HTML to Docbook XML Markup Comparison</a></dt><dt>B.5. <a href="documentation_hacking.html#table.docbook_elem">Docbook XML Element Use</a></dt><dt>B.6. <a href="api.html#table.extension_allocators">Extension Allocators</a></dt><dt>B.7. <a href="api.html#table.extension_allocators2">Extension Allocators Continued</a></dt></dl></div><div class="list-of-equations"><p><strong>List of Equations</strong></p><dl><dt>22.1. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.2.15">Ranged Hash Function</a></dt><dt>22.2. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.3.3">Range-Hashing, Division Method</a></dt><dt>22.3. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.3.9">Division via Prime Modulo</a></dt><dt>22.4. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.3.11">Division via Bit Mask</a></dt><dt>22.5. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.4.7">
+		diagram</a></dt><dt>22.22. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.5">Tree node invariants</a></dt><dt>22.23. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.8">Tree node invalidation</a></dt><dt>22.24. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.3">A tree and its update policy</a></dt><dt>22.25. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.8">Restoring node invariants</a></dt><dt>22.26. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.10">Insert update sequence</a></dt><dt>22.27. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.3.3.2.11.20">Useless update path</a></dt><dt>22.28. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.4.3.2.10">A PATRICIA trie</a></dt><dt>22.29. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.4.3.3.5">A trie and its update policy</a></dt><dt>22.30. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.5.3.3.3">A simple list</a></dt><dt>22.31. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.5.3.3.6">The counter algorithm</a></dt><dt>22.32. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.6.3.3.3">Underlying Priority-Queue Data-Structures.</a></dt><dt>22.33. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.6.3.4.4">Priority-Queue Data-Structure Tags.</a></dt><dt>B.1. <a href="appendix_porting.html#fig.build_hacking.deps">Configure and Build File Dependencies</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>1.1. <a href="status.html#table.cxx98_status">C++ 1998/2003 Implementation Status</a></dt><dt>1.2. <a href="status.html#table.cxx11_status">C++ 2011 Implementation Status</a></dt><dt>1.3. <a href="status.html#table.cxx14_status">C++ 2014 Implementation Status</a></dt><dt>1.4. <a href="status.html#table.ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.5. <a href="status.html#table.cxx17_status">C++ 2017 Implementation Status</a></dt><dt>1.6. <a href="status.html#table.cxx17_ts_status">C++ Technical Specifications Implementation Status</a></dt><dt>1.7. <a href="status.html#table.tr1_status">C++ TR1 Implementation Status</a></dt><dt>1.8. <a href="status.html#table.decfp_status">C++ TR 24733 Implementation Status</a></dt><dt>1.9. <a href="status.html#table.specfun_status">C++ Special Functions Implementation Status</a></dt><dt>3.1. <a href="using.html#table.cmd_options">C++ Command Options</a></dt><dt>3.2. <a href="using_headers.html#table.cxx98_headers">C++ 1998 Library Headers</a></dt><dt>3.3. <a href="using_headers.html#table.cxx98_cheaders">C++ 1998 Library Headers for C Library Facilities</a></dt><dt>3.4. <a href="using_headers.html#table.cxx98_deprheaders">C++ 1998 Deprecated Library Header</a></dt><dt>3.5. <a href="using_headers.html#table.cxx11_headers">C++ 2011 Library Headers</a></dt><dt>3.6. <a href="using_headers.html#table.cxx11_cheaders">C++ 2011 Library Headers for C Library Facilities</a></dt><dt>3.7. <a href="using_headers.html#table.cxx14_headers">C++ 2014 Library Header</a></dt><dt>3.8. <a href="using_headers.html#table.cxx17_headers">C++ 2017 Library Headers</a></dt><dt>3.9. <a href="using_headers.html#table.filesystemts_headers">File System TS Header</a></dt><dt>3.10. <a href="using_headers.html#table.libfundts_headers">Library Fundamentals TS Headers</a></dt><dt>3.11. <a href="using_headers.html#table.tr1_headers">C++ TR 1 Library Headers</a></dt><dt>3.12. <a href="using_headers.html#table.tr1_cheaders">C++ TR 1 Library Headers for C Library Facilities</a></dt><dt>3.13. <a href="using_headers.html#table.decfp_headers">C++ TR 24733 Decimal Floating-Point Header</a></dt><dt>3.14. <a href="using_headers.html#table.abi_headers">C++ ABI Headers</a></dt><dt>3.15. <a href="using_headers.html#table.ext_headers">Extension Headers</a></dt><dt>3.16. <a href="using_headers.html#table.debug_headers">Extension Debug Headers</a></dt><dt>3.17. <a href="using_headers.html#table.profile_headers">Extension Profile Headers</a></dt><dt>3.18. <a href="using_headers.html#table.parallel_headers">Extension Parallel Headers</a></dt><dt>17.1. <a href="debug_mode_using.html#table.debug_mode_containers">Debugging Containers</a></dt><dt>17.2. <a href="debug_mode_using.html#table.debug_mode_containers_cxx11">Debugging Containers C++11</a></dt><dt>18.1. <a href="parallel_mode_using.html#table.parallel_algos">Parallel Algorithms</a></dt><dt>19.1. <a href="profile_mode_design.html#table.profile_code_loc">Profile Code Location</a></dt><dt>19.2. <a href="profile_mode_diagnostics.html#table.profile_diagnostics">Profile Diagnostics</a></dt><dt>21.1. <a href="bitmap_allocator_impl.html#table.bitmap_alloc">Bitmap Allocator Memory Map</a></dt><dt>B.1. <a href="documentation_hacking.html#table.doxygen_prereq">Doxygen Prerequisites</a></dt><dt>B.2. <a href="documentation_hacking.html#table.doxygen_cmp">HTML to Doxygen Markup Comparison</a></dt><dt>B.3. <a href="documentation_hacking.html#table.docbook_prereq">Docbook Prerequisites</a></dt><dt>B.4. <a href="documentation_hacking.html#table.docbook_cmp">HTML to Docbook XML Markup Comparison</a></dt><dt>B.5. <a href="documentation_hacking.html#table.docbook_elem">Docbook XML Element Use</a></dt><dt>B.6. <a href="api.html#table.extension_allocators">Extension Allocators</a></dt><dt>B.7. <a href="api.html#table.extension_allocators2">Extension Allocators Continued</a></dt></dl></div><div class="list-of-equations"><p><strong>List of Equations</strong></p><dl><dt>22.1. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.2.15">Ranged Hash Function</a></dt><dt>22.2. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.3.3">Range-Hashing, Division Method</a></dt><dt>22.3. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.3.9">Division via Prime Modulo</a></dt><dt>22.4. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.3.11">Division via Bit Mask</a></dt><dt>22.5. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.4.7">
 		A Standard String Hash Function
 	      </a></dt><dt>22.6. <a href="policy_data_structures_design.html#id-1.3.5.9.4.4.2.3.2.4.12">
 		Only k String DNA Hash
diff -ruN gcc-7.3.0/libstdc++-v3/doc/html/manual/test.html gcc-7.3.0-msp430/libstdc++-v3/doc/html/manual/test.html
--- gcc-7.3.0/libstdc++-v3/doc/html/manual/test.html	2017-10-25 07:18:43.456751000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/doc/html/manual/test.html	2019-06-25 02:27:32.289851375 -0700
@@ -456,12 +456,15 @@
     possible variations.
   </p><p>
     Similarly, tests which depend on a newer standard than the default
-    should use <code class="literal">dg-options</code> instead of an effective target,
-    so that they are not skipped by default.
+    must use <code class="literal">dg-options</code> instead of (or in addition to)
+    an effective target, so that they are not skipped by default.
     For example, tests for C++17 features should use
 </p><pre class="programlisting">    // { dg-options "-std=gnu++17" }</pre><p>
-    and not
-</p><pre class="programlisting">    // { dg-do run "c++1z" }</pre><p>
+    before any <code class="literal">dg-do</code> such as:
+</p><pre class="programlisting">    // { dg-do run "c++17" }</pre><p>
+    The <code class="literal">dg-options</code> directive must come first, so that
+    the <code class="literal">-std</code> flag has already been added to the options
+    before checking the <code class="literal">c++17</code> target.
   </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="tests.dg.examples"></a>Examples of Test Directives</h4></div></div></div><p>
 Example 1: Testing compilation only:
 </p><pre class="programlisting">
diff -ruN gcc-7.3.0/libstdc++-v3/doc/html/manual/using_dual_abi.html gcc-7.3.0-msp430/libstdc++-v3/doc/html/manual/using_dual_abi.html
--- gcc-7.3.0/libstdc++-v3/doc/html/manual/using_dual_abi.html	2017-10-25 07:18:43.456751000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/doc/html/manual/using_dual_abi.html	2019-06-25 02:27:32.289851375 -0700
@@ -14,7 +14,7 @@
   for the new implementations have different names the definitions for both
   versions can be present in the same library.
 </p><p> The <span class="symbol">_GLIBCXX_USE_CXX11_ABI</span> macro (see
-<a class="xref" href="using_macros.html" title="Macros">Macros</a>) controls whether
+  <a class="xref" href="using_macros.html" title="Macros">Macros</a>) controls whether
   the declarations in the library headers use the old or new ABI.
   So the decision of which ABI to use can be made separately for each
   source file being compiled.
@@ -43,10 +43,35 @@
   facet that derives from one or other version of
   <code class="classname">time_get</code> is installed in the locale).
 </p><p> Although the standard exception types defined in
-  <code class="filename">&lt;stdexcept&gt;</code> use strings, they
+  <code class="filename">&lt;stdexcept&gt;</code> use strings, most
   are not defined twice, so that a <code class="classname">std::out_of_range</code>
   exception thrown in one file can always be caught by a suitable handler in
   another file, even if the two files are compiled with different ABIs.
+</p><p> One exception type does change when using the new ABI, namely
+  <code class="classname">std::ios_base::failure</code>.
+  This is necessary because the 2011 standard changed its base class from
+  <code class="classname">std::exception</code> to
+  <code class="classname">std::system_error</code>, which causes its layout to change.
+  Exceptions due to iostream errors are thrown by a function inside
+  <code class="filename">libstdc++.so</code>, so whether the thrown
+  exception uses the old <code class="classname">std::ios_base::failure</code> type
+  or the new one depends on the ABI that was active when
+  <code class="filename">libstdc++.so</code> was built,
+  <span class="emphasis"><em>not</em></span> the ABI active in the user code that is using
+  iostreams.
+  This means that for a given build of GCC the type thrown is fixed.
+  In current releases the library throws a special type that can be caught
+  by handlers for either the old or new type,
+  but for GCC 7.1, 7.2 and 7.3 the library throws the new
+  <code class="classname">std::ios_base::failure</code> type,
+  and for GCC 5.x and 6.x the library throws the old type.
+  Catch handlers of type <code class="classname">std::ios_base::failure</code>
+  will only catch the exceptions if using a newer release,
+  or if the handler is compiled with the same ABI as the type thrown by
+  the library.
+  Handlers for <code class="classname">std::exception</code> will always catch
+  iostreams exceptions, because the old and new type both inherit from
+  <code class="classname">std::exception</code>.
 </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual.intro.using.abi.trouble"></a>Troubleshooting</h3></div></div></div><p> If you get linker errors about undefined references to symbols
   that involve types in the <code class="code">std::__cxx11</code> namespace or the tag
   <code class="code">[abi:cxx11]</code> then it probably indicates that you are trying to
diff -ruN gcc-7.3.0/libstdc++-v3/doc/html/manual/using_headers.html gcc-7.3.0-msp430/libstdc++-v3/doc/html/manual/using_headers.html
--- gcc-7.3.0/libstdc++-v3/doc/html/manual/using_headers.html	2017-10-25 07:18:43.456751000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/doc/html/manual/using_headers.html	2019-06-25 02:27:32.289851375 -0700
@@ -4,7 +4,7 @@
      must be available to all hosted implementations.  Actually, the
      word "files" is a misnomer, since the contents of the
      headers don't necessarily have to be in any kind of external
-     file.  The only rule is that when one <code class="code">#include</code>'s a
+     file.  The only rule is that when one <code class="code">#include</code>s a
      header, the contents of that header become available, no matter
      how.
    </p><p>
@@ -12,25 +12,71 @@
    </p><p>
      There are two main types of include files: header files related
      to a specific version of the ISO C++ standard (called Standard
-     Headers), and all others (TR1, C++ ABI, and Extensions).
+     Headers), and all others (TS, TR1, C++ ABI, and Extensions).
    </p><p>
-     Two dialects of standard headers are supported, corresponding to
-     the 1998 standard as updated for 2003, and the current 2011 standard.
+     Multiple dialects of standard headers are supported, corresponding to
+     the 1998 standard as updated for 2003, the 2011 standard, the 2014
+     standard, and so on.
    </p><p>
-     C++98/03 include files. These are available in the default compilation mode, i.e. <code class="code">-std=c++98</code> or <code class="code">-std=gnu++98</code>.
-   </p><div class="table"><a id="table.cxx98_headers"></a><p class="title"><strong>Table3.2.C++ 1998 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ 1998 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">algorithm</code></td><td align="left"><code class="filename">bitset</code></td><td align="left"><code class="filename">complex</code></td><td align="left"><code class="filename">deque</code></td><td align="left"><code class="filename">exception</code></td></tr><tr><td align="left"><code class="filename">fstream</code></td><td align="left"><code class="filename">functional</code></td><td align="left"><code class="filename">iomanip</code></td><td align="left"><code class="filename">ios</code></td><td align="left"><code class="filename">iosfwd</code></td></tr><tr><td align="left"><code class="filename">iostream</code></td><td align="left"><code class="filename">istream</code></td><td align="left"><code class="filename">iterator</code></td><td align="left"><code class="filename">limits</code></td><td align="left"><code class="filename">list</code></td></tr><tr><td align="left"><code class="filename">locale</code></td><td align="left"><code class="filename">map</code></td><td align="left"><code class="filename">memory</code></td><td align="left"><code class="filename">new</code></td><td align="left"><code class="filename">numeric</code></td></tr><tr><td align="left"><code class="filename">ostream</code></td><td align="left"><code class="filename">queue</code></td><td align="left"><code class="filename">set</code></td><td align="left"><code class="filename">sstream</code></td><td align="left"><code class="filename">stack</code></td></tr><tr><td align="left"><code class="filename">stdexcept</code></td><td align="left"><code class="filename">streambuf</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="filename">utility</code></td><td align="left"><code class="filename">typeinfo</code></td></tr><tr><td align="left"><code class="filename">valarray</code></td><td align="left"><code class="filename">vector</code></td><td class="auto-generated"></td><td class="auto-generated"></td><td class="auto-generated"></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.cxx98_cheaders"></a><p class="title"><strong>Table3.3.C++ 1998 Library Headers for C Library Facilities</strong></p><div class="table-contents"><table class="table" summary="C++ 1998 Library Headers for C Library Facilities" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">cassert</code></td><td align="left"><code class="filename">cerrno</code></td><td align="left"><code class="filename">cctype</code></td><td align="left"><code class="filename">cfloat</code></td><td align="left"><code class="filename">ciso646</code></td></tr><tr><td align="left"><code class="filename">climits</code></td><td align="left"><code class="filename">clocale</code></td><td align="left"><code class="filename">cmath</code></td><td align="left"><code class="filename">csetjmp</code></td><td align="left"><code class="filename">csignal</code></td></tr><tr><td align="left"><code class="filename">cstdarg</code></td><td align="left"><code class="filename">cstddef</code></td><td align="left"><code class="filename">cstdio</code></td><td align="left"><code class="filename">cstdlib</code></td><td align="left"><code class="filename">cstring</code></td></tr><tr><td align="left"><code class="filename">ctime</code></td><td align="left"><code class="filename">cwchar</code></td><td align="left"><code class="filename">cwctype</code></td><td class="auto-generated"></td><td class="auto-generated"></td></tr></tbody></table></div></div><br class="table-break" /><p>
-C++11 include files. These are only available in C++11 compilation
+     <a class="xref" href="using_headers.html#table.cxx98_headers" title="Table3.2.C++ 1998 Library Headers">Table3.2, C++ 1998 Library Headers</a> and
+     <a class="xref" href="using_headers.html#table.cxx98_cheaders" title="Table3.3.C++ 1998 Library Headers for C Library Facilities">Table3.3, C++ 1998 Library Headers for C Library Facilities</a> and
+     <a class="xref" href="using_headers.html#table.cxx98_deprheaders" title="Table3.4.C++ 1998 Deprecated Library Header">Table3.4, C++ 1998 Deprecated Library Header</a>
+     show the C++98/03 include files.
+     These are available in the C++98 compilation mode,
+     i.e. <code class="code">-std=c++98</code> or <code class="code">-std=gnu++98</code>.
+     Unless specified otherwise below, they are also available in later modes
+     (C++11, C++14 etc).
+   </p><div class="table"><a id="table.cxx98_headers"></a><p class="title"><strong>Table3.2.C++ 1998 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ 1998 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">algorithm</code></td><td align="left"><code class="filename">bitset</code></td><td align="left"><code class="filename">complex</code></td><td align="left"><code class="filename">deque</code></td><td align="left"><code class="filename">exception</code></td></tr><tr><td align="left"><code class="filename">fstream</code></td><td align="left"><code class="filename">functional</code></td><td align="left"><code class="filename">iomanip</code></td><td align="left"><code class="filename">ios</code></td><td align="left"><code class="filename">iosfwd</code></td></tr><tr><td align="left"><code class="filename">iostream</code></td><td align="left"><code class="filename">istream</code></td><td align="left"><code class="filename">iterator</code></td><td align="left"><code class="filename">limits</code></td><td align="left"><code class="filename">list</code></td></tr><tr><td align="left"><code class="filename">locale</code></td><td align="left"><code class="filename">map</code></td><td align="left"><code class="filename">memory</code></td><td align="left"><code class="filename">new</code></td><td align="left"><code class="filename">numeric</code></td></tr><tr><td align="left"><code class="filename">ostream</code></td><td align="left"><code class="filename">queue</code></td><td align="left"><code class="filename">set</code></td><td align="left"><code class="filename">sstream</code></td><td align="left"><code class="filename">stack</code></td></tr><tr><td align="left"><code class="filename">stdexcept</code></td><td align="left"><code class="filename">streambuf</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="filename">utility</code></td><td align="left"><code class="filename">typeinfo</code></td></tr><tr><td align="left"><code class="filename">valarray</code></td><td align="left"><code class="filename">vector</code></td><td colspan="3" align="left"></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.cxx98_cheaders"></a><p class="title"><strong>Table3.3.C++ 1998 Library Headers for C Library Facilities</strong></p><div class="table-contents"><table class="table" summary="C++ 1998 Library Headers for C Library Facilities" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">cassert</code></td><td align="left"><code class="filename">cerrno</code></td><td align="left"><code class="filename">cctype</code></td><td align="left"><code class="filename">cfloat</code></td><td align="left"><code class="filename">ciso646</code></td></tr><tr><td align="left"><code class="filename">climits</code></td><td align="left"><code class="filename">clocale</code></td><td align="left"><code class="filename">cmath</code></td><td align="left"><code class="filename">csetjmp</code></td><td align="left"><code class="filename">csignal</code></td></tr><tr><td align="left"><code class="filename">cstdarg</code></td><td align="left"><code class="filename">cstddef</code></td><td align="left"><code class="filename">cstdio</code></td><td align="left"><code class="filename">cstdlib</code></td><td align="left"><code class="filename">cstring</code></td></tr><tr><td align="left"><code class="filename">ctime</code></td><td align="left"><code class="filename">cwchar</code></td><td align="left"><code class="filename">cwctype</code></td><td colspan="2" align="left"></td></tr></tbody></table></div></div><br class="table-break" /><p>
+  The following header is deprecated
+  and might be removed from a future C++ standard.
+</p><div class="table"><a id="table.cxx98_deprheaders"></a><p class="title"><strong>Table3.4.C++ 1998 Deprecated Library Header</strong></p><div class="table-contents"><table class="table" summary="C++ 1998 Deprecated Library Header" border="1"><colgroup><col align="left" class="c1" /></colgroup><tbody><tr><td align="left"><code class="filename">strstream</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+<a class="xref" href="using_headers.html#table.cxx11_headers" title="Table3.5.C++ 2011 Library Headers">Table3.5, C++ 2011 Library Headers</a> and
+<a class="xref" href="using_headers.html#table.cxx11_cheaders" title="Table3.6.C++ 2011 Library Headers for C Library Facilities">Table3.6, C++ 2011 Library Headers for C Library Facilities</a> show the C++11 include files.
+These are available in C++11 compilation
 mode, i.e. <code class="literal">-std=c++11</code> or <code class="literal">-std=gnu++11</code>.
-</p><p></p><div class="table"><a id="table.cxx11_headers"></a><p class="title"><strong>Table3.4.C++ 2011 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ 2011 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">algorithm</code></td><td align="left"><code class="filename">array</code></td><td align="left"><code class="filename">bitset</code></td><td align="left"><code class="filename">chrono</code></td><td align="left"><code class="filename">complex</code></td></tr><tr><td align="left"><code class="filename">condition_variable</code></td><td align="left"><code class="filename">deque</code></td><td align="left"><code class="filename">exception</code></td><td align="left"><code class="filename">forward_list</code></td><td align="left"><code class="filename">fstream</code></td></tr><tr><td align="left"><code class="filename">functional</code></td><td align="left"><code class="filename">future</code></td><td align="left"><code class="filename">initalizer_list</code></td><td align="left"><code class="filename">iomanip</code></td><td align="left"><code class="filename">ios</code></td></tr><tr><td align="left"><code class="filename">iosfwd</code></td><td align="left"><code class="filename">iostream</code></td><td align="left"><code class="filename">istream</code></td><td align="left"><code class="filename">iterator</code></td><td align="left"><code class="filename">limits</code></td></tr><tr><td align="left"><code class="filename">list</code></td><td align="left"><code class="filename">locale</code></td><td align="left"><code class="filename">map</code></td><td align="left"><code class="filename">memory</code></td><td align="left"><code class="filename">mutex</code></td></tr><tr><td align="left"><code class="filename">new</code></td><td align="left"><code class="filename">numeric</code></td><td align="left"><code class="filename">ostream</code></td><td align="left"><code class="filename">queue</code></td><td align="left"><code class="filename">random</code></td></tr><tr><td align="left"><code class="filename">ratio</code></td><td align="left"><code class="filename">regex</code></td><td align="left"><code class="filename">set</code></td><td align="left"><code class="filename">sstream</code></td><td align="left"><code class="filename">stack</code></td></tr><tr><td align="left"><code class="filename">stdexcept</code></td><td align="left"><code class="filename">streambuf</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="filename">system_error</code></td><td align="left"><code class="filename">thread</code></td></tr><tr><td align="left"><code class="filename">tuple</code></td><td align="left"><code class="filename">type_traits</code></td><td align="left"><code class="filename">typeinfo</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="filename">unordered_set</code></td></tr><tr><td align="left"><code class="filename">utility</code></td><td align="left"><code class="filename">valarray</code></td><td align="left"><code class="filename">vector</code></td><td class="auto-generated"></td><td class="auto-generated"></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.cxx11_cheaders"></a><p class="title"><strong>Table3.5.C++ 2011 Library Headers for C Library Facilities</strong></p><div class="table-contents"><table class="table" summary="C++ 2011 Library Headers for C Library Facilities" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">cassert</code></td><td align="left"><code class="filename">ccomplex</code></td><td align="left"><code class="filename">cctype</code></td><td align="left"><code class="filename">cerrno</code></td><td align="left"><code class="filename">cfenv</code></td></tr><tr><td align="left"><code class="filename">cfloat</code></td><td align="left"><code class="filename">cinttypes</code></td><td align="left"><code class="filename">ciso646</code></td><td align="left"><code class="filename">climits</code></td><td align="left"><code class="filename">clocale</code></td></tr><tr><td align="left"><code class="filename">cmath</code></td><td align="left"><code class="filename">csetjmp</code></td><td align="left"><code class="filename">csignal</code></td><td align="left"><code class="filename">cstdarg</code></td><td align="left"><code class="filename">cstdbool</code></td></tr><tr><td align="left"><code class="filename">cstddef</code></td><td align="left"><code class="filename">cstdint</code></td><td align="left"><code class="filename">cstdlib</code></td><td align="left"><code class="filename">cstdio</code></td><td align="left"><code class="filename">cstring</code></td></tr><tr><td align="left"><code class="filename">ctgmath</code></td><td align="left"><code class="filename">ctime</code></td><td align="left"><code class="filename">cuchar</code></td><td align="left"><code class="filename">cwchar</code></td><td align="left"><code class="filename">cwctype</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+Including these headers in C++98/03 mode may result in compilation errors.
+Unless specified otherwise below, they are also available in later modes
+(C++14 etc).
+</p><p></p><div class="table"><a id="table.cxx11_headers"></a><p class="title"><strong>Table3.5.C++ 2011 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ 2011 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">array</code></td><td align="left"><code class="filename">atomic</code></td><td align="left"><code class="filename">chrono</code></td><td align="left"><code class="filename">codecvt</code></td><td align="left"><code class="filename">condition_variable</code></td></tr><tr><td align="left"><code class="filename">forward_list</code></td><td align="left"><code class="filename">future</code></td><td align="left"><code class="filename">initalizer_list</code></td><td align="left"><code class="filename">mutex</code></td><td align="left"><code class="filename">random</code></td></tr><tr><td align="left"><code class="filename">ratio</code></td><td align="left"><code class="filename">regex</code></td><td align="left"><code class="filename">scoped_allocator</code></td><td align="left"><code class="filename">system_error</code></td><td align="left"><code class="filename">thread</code></td></tr><tr><td align="left"><code class="filename">tuple</code></td><td align="left"><code class="filename">typeindex</code></td><td align="left"><code class="filename">type_traits</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="filename">unordered_set</code></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.cxx11_cheaders"></a><p class="title"><strong>Table3.6.C++ 2011 Library Headers for C Library Facilities</strong></p><div class="table-contents"><table class="table" summary="C++ 2011 Library Headers for C Library Facilities" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">ccomplex</code></td><td align="left"><code class="filename">cfenv</code></td><td align="left"><code class="filename">cinttypes</code></td><td align="left"><code class="filename">cstdalign</code></td><td align="left"><code class="filename">cstdbool</code></td></tr><tr><td align="left"><code class="filename">cstdint</code></td><td align="left"><code class="filename">ctgmath</code></td><td align="left"><code class="filename">cuchar</code></td><td colspan="2" align="left"></td></tr></tbody></table></div></div><br class="table-break" /><p>
+<a class="xref" href="using_headers.html#table.cxx14_headers" title="Table3.7.C++ 2014 Library Header">Table3.7, C++ 2014 Library Header</a> shows the C++14 include file.
+This is available in C++14 compilation
+mode, i.e. <code class="literal">-std=c++14</code> or <code class="literal">-std=gnu++14</code>.
+Including this header in C++98/03 mode or C++11 will not result in
+compilation errors, but will not define anything.
+Unless specified otherwise below, it is also available in later modes
+(C++17 etc).
+</p><p></p><div class="table"><a id="table.cxx14_headers"></a><p class="title"><strong>Table3.7.C++ 2014 Library Header</strong></p><div class="table-contents"><table class="table" summary="C++ 2014 Library Header" border="1"><colgroup><col align="left" class="c1" /></colgroup><tbody><tr><td align="left"><code class="filename">shared_mutex</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+<a class="xref" href="using_headers.html#table.cxx17_headers" title="Table3.8.C++ 2017 Library Headers">Table3.8, C++ 2017 Library Headers</a> shows the C++17 include files.
+These are available in C++17 compilation
+mode, i.e. <code class="literal">-std=c++17</code> or <code class="literal">-std=gnu++17</code>.
+Including these headers in earlier modes will not result in
+compilation errors, but will not define anything.
+Unless specified otherwise below, they are also available in later modes
+(C++20 etc).
+</p><p></p><div class="table"><a id="table.cxx17_headers"></a><p class="title"><strong>Table3.8.C++ 2017 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ 2017 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><tbody><tr><td align="left"><code class="filename">any</code></td><td align="left"><code class="filename">optional</code></td><td align="left"><code class="filename">string_view</code></td><td align="left"><code class="filename">variant</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+<a class="xref" href="using_headers.html#table.filesystemts_headers" title="Table3.9.File System TS Header">Table3.9, File System TS Header</a>,
+shows the additional include file define by the
+File System Technical Specification, ISO/IEC TS 18822.
+This is available in C++11 and later compilation modes.
+Including this header in earlier modes will not result in
+compilation errors, but will not define anything.
+</p><p></p><div class="table"><a id="table.filesystemts_headers"></a><p class="title"><strong>Table3.9.File System TS Header</strong></p><div class="table-contents"><table class="table" summary="File System TS Header" border="1"><colgroup><col align="left" class="c1" /></colgroup><tbody><tr><td align="left"><code class="filename">experimental/filesystem</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+<a class="xref" href="using_headers.html#table.libfundts_headers" title="Table3.10.Library Fundamentals TS Headers">Table3.10, Library Fundamentals TS Headers</a>,
+shows the additional include files define by the C++ Extensions for 
+Library Fundamentals Technical Specification, ISO/IEC TS 19568.
+These are available in C++14 and later compilation modes.
+Including these headers in earlier modes will not result in
+compilation errors, but will not define anything.
+</p><p></p><div class="table"><a id="table.libfundts_headers"></a><p class="title"><strong>Table3.10.Library Fundamentals TS Headers</strong></p><div class="table-contents"><table class="table" summary="Library Fundamentals TS Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">experimental/algorithm</code></td><td align="left"><code class="filename">experimental/any</code></td><td align="left"><code class="filename">experimental/array</code></td><td align="left"><code class="filename">experimental/chrono</code></td><td align="left"><code class="filename">experimental/deque</code></td></tr><tr><td align="left"><code class="filename">experimental/forward_list</code></td><td align="left"><code class="filename">experimental/functional</code></td><td align="left"><code class="filename">experimental/iterator</code></td><td align="left"><code class="filename">experimental/list</code></td><td align="left"><code class="filename">experimental/map</code></td></tr><tr><td align="left"><code class="filename">experimental/memory</code></td><td align="left"><code class="filename">experimental/memory_resource</code></td><td align="left"><code class="filename">experimental/numeric</code></td><td align="left"><code class="filename">experimental/optional</code></td><td align="left"><code class="filename">experimental/propagate_const</code></td></tr><tr><td align="left"><code class="filename">experimental/random</code></td><td align="left"><code class="filename">experimental/ratio</code></td><td align="left"><code class="filename">experimental/regex</code></td><td align="left"><code class="filename">experimental/set</code></td><td align="left"><code class="filename">experimental/source_location</code></td></tr><tr><td align="left"><code class="filename">experimental/string</code></td><td align="left"><code class="filename">experimental/string_view</code></td><td align="left"><code class="filename">experimental/system_error</code></td><td align="left"><code class="filename">experimental/tuple</code></td><td align="left"><code class="filename">experimental/type_traits</code></td></tr><tr><td align="left"><code class="filename">experimental/unordered_map</code></td><td align="left"><code class="filename">experimental/unordered_set</code></td><td align="left"><code class="filename">experimental/utility</code></td><td align="left"><code class="filename">experimental/vector</code></td><td align="left"></td></tr></tbody></table></div></div><br class="table-break" /><p>
   In addition, TR1 includes as:
-</p><div class="table"><a id="table.tr1_headers"></a><p class="title"><strong>Table3.6.C++ TR 1 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ TR 1 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">tr1/array</code></td><td align="left"><code class="filename">tr1/complex</code></td><td align="left"><code class="filename">tr1/memory</code></td><td align="left"><code class="filename">tr1/functional</code></td><td align="left"><code class="filename">tr1/random</code></td></tr><tr><td align="left"><code class="filename">tr1/regex</code></td><td align="left"><code class="filename">tr1/tuple</code></td><td align="left"><code class="filename">tr1/type_traits</code></td><td align="left"><code class="filename">tr1/unordered_map</code></td><td align="left"><code class="filename">tr1/unordered_set</code></td></tr><tr><td align="left"><code class="filename">tr1/utility</code></td><td class="auto-generated"></td><td class="auto-generated"></td><td class="auto-generated"></td><td class="auto-generated"></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.tr1_cheaders"></a><p class="title"><strong>Table3.7.C++ TR 1 Library Headers for C Library Facilities</strong></p><div class="table-contents"><table class="table" summary="C++ TR 1 Library Headers for C Library Facilities" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">tr1/ccomplex</code></td><td align="left"><code class="filename">tr1/cfenv</code></td><td align="left"><code class="filename">tr1/cfloat</code></td><td align="left"><code class="filename">tr1/cmath</code></td><td align="left"><code class="filename">tr1/cinttypes</code></td></tr><tr><td align="left"><code class="filename">tr1/climits</code></td><td align="left"><code class="filename">tr1/cstdarg</code></td><td align="left"><code class="filename">tr1/cstdbool</code></td><td align="left"><code class="filename">tr1/cstdint</code></td><td align="left"><code class="filename">tr1/cstdio</code></td></tr><tr><td align="left"><code class="filename">tr1/cstdlib</code></td><td align="left"><code class="filename">tr1/ctgmath</code></td><td align="left"><code class="filename">tr1/ctime</code></td><td align="left"><code class="filename">tr1/cwchar</code></td><td align="left"><code class="filename">tr1/cwctype</code></td></tr></tbody></table></div></div><br class="table-break" /><p>Decimal floating-point arithmetic is available if the C++
+</p><div class="table"><a id="table.tr1_headers"></a><p class="title"><strong>Table3.11.C++ TR 1 Library Headers</strong></p><div class="table-contents"><table class="table" summary="C++ TR 1 Library Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">tr1/array</code></td><td align="left"><code class="filename">tr1/complex</code></td><td align="left"><code class="filename">tr1/memory</code></td><td align="left"><code class="filename">tr1/functional</code></td><td align="left"><code class="filename">tr1/random</code></td></tr><tr><td align="left"><code class="filename">tr1/regex</code></td><td align="left"><code class="filename">tr1/tuple</code></td><td align="left"><code class="filename">tr1/type_traits</code></td><td align="left"><code class="filename">tr1/unordered_map</code></td><td align="left"><code class="filename">tr1/unordered_set</code></td></tr><tr><td align="left"><code class="filename">tr1/utility</code></td><td colspan="4" align="left"></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.tr1_cheaders"></a><p class="title"><strong>Table3.12.C++ TR 1 Library Headers for C Library Facilities</strong></p><div class="table-contents"><table class="table" summary="C++ TR 1 Library Headers for C Library Facilities" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">tr1/ccomplex</code></td><td align="left"><code class="filename">tr1/cfenv</code></td><td align="left"><code class="filename">tr1/cfloat</code></td><td align="left"><code class="filename">tr1/cmath</code></td><td align="left"><code class="filename">tr1/cinttypes</code></td></tr><tr><td align="left"><code class="filename">tr1/climits</code></td><td align="left"><code class="filename">tr1/cstdarg</code></td><td align="left"><code class="filename">tr1/cstdbool</code></td><td align="left"><code class="filename">tr1/cstdint</code></td><td align="left"><code class="filename">tr1/cstdio</code></td></tr><tr><td align="left"><code class="filename">tr1/cstdlib</code></td><td align="left"><code class="filename">tr1/ctgmath</code></td><td align="left"><code class="filename">tr1/ctime</code></td><td align="left"><code class="filename">tr1/cwchar</code></td><td align="left"><code class="filename">tr1/cwctype</code></td></tr></tbody></table></div></div><br class="table-break" /><p>Decimal floating-point arithmetic is available if the C++
 compiler supports scalar decimal floating-point types defined via
 <code class="code">__attribute__((mode(SD|DD|LD)))</code>.
-</p><div class="table"><a id="table.decfp_headers"></a><p class="title"><strong>Table3.8.C++ TR 24733 Decimal Floating-Point Header</strong></p><div class="table-contents"><table class="table" summary="C++ TR 24733 Decimal Floating-Point Header" border="1"><colgroup><col align="left" class="c1" /></colgroup><tbody><tr><td align="left"><code class="filename">decimal/decimal</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+</p><div class="table"><a id="table.decfp_headers"></a><p class="title"><strong>Table3.13.C++ TR 24733 Decimal Floating-Point Header</strong></p><div class="table-contents"><table class="table" summary="C++ TR 24733 Decimal Floating-Point Header" border="1"><colgroup><col align="left" class="c1" /></colgroup><tbody><tr><td align="left"><code class="filename">decimal/decimal</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
   Also included are files for the C++ ABI interface:
-</p><div class="table"><a id="table.abi_headers"></a><p class="title"><strong>Table3.9.C++ ABI Headers</strong></p><div class="table-contents"><table class="table" summary="C++ ABI Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><tbody><tr><td align="left"><code class="filename">cxxabi.h</code></td><td align="left"><code class="filename">cxxabi_forced.h</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+</p><div class="table"><a id="table.abi_headers"></a><p class="title"><strong>Table3.14.C++ ABI Headers</strong></p><div class="table-contents"><table class="table" summary="C++ ABI Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><tbody><tr><td align="left"><code class="filename">cxxabi.h</code></td><td align="left"><code class="filename">cxxabi_forced.h</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
   And a large variety of extensions.
-</p><div class="table"><a id="table.ext_headers"></a><p class="title"><strong>Table3.10.Extension Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">ext/algorithm</code></td><td align="left"><code class="filename">ext/atomicity.h</code></td><td align="left"><code class="filename">ext/array_allocator.h</code></td><td align="left"><code class="filename">ext/bitmap_allocator.h</code></td><td align="left"><code class="filename">ext/cast.h</code></td></tr><tr><td align="left"><code class="filename">ext/codecvt_specializations.h</code></td><td align="left"><code class="filename">ext/concurrence.h</code></td><td align="left"><code class="filename">ext/debug_allocator.h</code></td><td align="left"><code class="filename">ext/enc_filebuf.h</code></td><td align="left"><code class="filename">ext/extptr_allocator.h</code></td></tr><tr><td align="left"><code class="filename">ext/functional</code></td><td align="left"><code class="filename">ext/iterator</code></td><td align="left"><code class="filename">ext/malloc_allocator.h</code></td><td align="left"><code class="filename">ext/memory</code></td><td align="left"><code class="filename">ext/mt_allocator.h</code></td></tr><tr><td align="left"><code class="filename">ext/new_allocator.h</code></td><td align="left"><code class="filename">ext/numeric</code></td><td align="left"><code class="filename">ext/numeric_traits.h</code></td><td align="left"><code class="filename">ext/pb_ds/assoc_container.h</code></td><td align="left"><code class="filename">ext/pb_ds/priority_queue.h</code></td></tr><tr><td align="left"><code class="filename">ext/pod_char_traits.h</code></td><td align="left"><code class="filename">ext/pool_allocator.h</code></td><td align="left"><code class="filename">ext/rb_tree</code></td><td align="left"><code class="filename">ext/rope</code></td><td align="left"><code class="filename">ext/slist</code></td></tr><tr><td align="left"><code class="filename">ext/stdio_filebuf.h</code></td><td align="left"><code class="filename">ext/stdio_sync_filebuf.h</code></td><td align="left"><code class="filename">ext/throw_allocator.h</code></td><td align="left"><code class="filename">ext/typelist.h</code></td><td align="left"><code class="filename">ext/type_traits.h</code></td></tr><tr><td align="left"><code class="filename">ext/vstring.h</code></td><td class="auto-generated"></td><td class="auto-generated"></td><td class="auto-generated"></td><td class="auto-generated"></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.debug_headers"></a><p class="title"><strong>Table3.11.Extension Debug Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Debug Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">debug/bitset</code></td><td align="left"><code class="filename">debug/deque</code></td><td align="left"><code class="filename">debug/list</code></td><td align="left"><code class="filename">debug/map</code></td><td align="left"><code class="filename">debug/set</code></td></tr><tr><td align="left"><code class="filename">debug/string</code></td><td align="left"><code class="filename">debug/unordered_map</code></td><td align="left"><code class="filename">debug/unordered_set</code></td><td align="left"><code class="filename">debug/vector</code></td><td class="auto-generated"></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.profile_headers"></a><p class="title"><strong>Table3.12.Extension Profile Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Profile Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><tbody><tr><td align="left"><code class="filename">profile/bitset</code></td><td align="left"><code class="filename">profile/deque</code></td><td align="left"><code class="filename">profile/list</code></td><td align="left"><code class="filename">profile/map</code></td></tr><tr><td align="left"><code class="filename">profile/set</code></td><td align="left"><code class="filename">profile/unordered_map</code></td><td align="left"><code class="filename">profile/unordered_set</code></td><td align="left"><code class="filename">profile/vector</code></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.parallel_headers"></a><p class="title"><strong>Table3.13.Extension Parallel Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Parallel Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><tbody><tr><td align="left"><code class="filename">parallel/algorithm</code></td><td align="left"><code class="filename">parallel/numeric</code></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual.intro.using.headers.mixing"></a>Mixing Headers</h3></div></div></div><p> A few simple rules.
+</p><div class="table"><a id="table.ext_headers"></a><p class="title"><strong>Table3.15.Extension Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">ext/algorithm</code></td><td align="left"><code class="filename">ext/atomicity.h</code></td><td align="left"><code class="filename">ext/array_allocator.h</code></td><td align="left"><code class="filename">ext/bitmap_allocator.h</code></td><td align="left"><code class="filename">ext/cast.h</code></td></tr><tr><td align="left"><code class="filename">ext/codecvt_specializations.h</code></td><td align="left"><code class="filename">ext/concurrence.h</code></td><td align="left"><code class="filename">ext/debug_allocator.h</code></td><td align="left"><code class="filename">ext/enc_filebuf.h</code></td><td align="left"><code class="filename">ext/extptr_allocator.h</code></td></tr><tr><td align="left"><code class="filename">ext/functional</code></td><td align="left"><code class="filename">ext/iterator</code></td><td align="left"><code class="filename">ext/malloc_allocator.h</code></td><td align="left"><code class="filename">ext/memory</code></td><td align="left"><code class="filename">ext/mt_allocator.h</code></td></tr><tr><td align="left"><code class="filename">ext/new_allocator.h</code></td><td align="left"><code class="filename">ext/numeric</code></td><td align="left"><code class="filename">ext/numeric_traits.h</code></td><td align="left"><code class="filename">ext/pb_ds/assoc_container.h</code></td><td align="left"><code class="filename">ext/pb_ds/priority_queue.h</code></td></tr><tr><td align="left"><code class="filename">ext/pod_char_traits.h</code></td><td align="left"><code class="filename">ext/pool_allocator.h</code></td><td align="left"><code class="filename">ext/rb_tree</code></td><td align="left"><code class="filename">ext/rope</code></td><td align="left"><code class="filename">ext/slist</code></td></tr><tr><td align="left"><code class="filename">ext/stdio_filebuf.h</code></td><td align="left"><code class="filename">ext/stdio_sync_filebuf.h</code></td><td align="left"><code class="filename">ext/throw_allocator.h</code></td><td align="left"><code class="filename">ext/typelist.h</code></td><td align="left"><code class="filename">ext/type_traits.h</code></td></tr><tr><td align="left"><code class="filename">ext/vstring.h</code></td><td colspan="4" align="left"></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.debug_headers"></a><p class="title"><strong>Table3.16.Extension Debug Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Debug Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><tbody><tr><td align="left"><code class="filename">debug/array</code></td><td align="left"><code class="filename">debug/bitset</code></td><td align="left"><code class="filename">debug/deque</code></td><td align="left"><code class="filename">debug/forward_list</code></td><td align="left"><code class="filename">debug/list</code></td></tr><tr><td align="left"><code class="filename">debug/map</code></td><td align="left"><code class="filename">debug/set</code></td><td align="left"><code class="filename">debug/string</code></td><td align="left"><code class="filename">debug/unordered_map</code></td><td align="left"><code class="filename">debug/unordered_set</code></td></tr><tr><td align="left"><code class="filename">debug/vector</code></td><td colspan="4" align="left"></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.profile_headers"></a><p class="title"><strong>Table3.17.Extension Profile Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Profile Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><tbody><tr><td align="left"><code class="filename">profile/bitset</code></td><td align="left"><code class="filename">profile/deque</code></td><td align="left"><code class="filename">profile/list</code></td><td align="left"><code class="filename">profile/map</code></td></tr><tr><td align="left"><code class="filename">profile/set</code></td><td align="left"><code class="filename">profile/unordered_map</code></td><td align="left"><code class="filename">profile/unordered_set</code></td><td align="left"><code class="filename">profile/vector</code></td></tr></tbody></table></div></div><br class="table-break" /><p></p><div class="table"><a id="table.parallel_headers"></a><p class="title"><strong>Table3.18.Extension Parallel Headers</strong></p><div class="table-contents"><table class="table" summary="Extension Parallel Headers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><tbody><tr><td align="left"><code class="filename">parallel/algorithm</code></td><td align="left"><code class="filename">parallel/numeric</code></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual.intro.using.headers.mixing"></a>Mixing Headers</h3></div></div></div><p> A few simple rules.
 </p><p>First, mixing different dialects of the standard headers is not
 possible. It's an all-or-nothing affair. Thus, code like
 </p><pre class="programlisting">
diff -ruN gcc-7.3.0/libstdc++-v3/doc/xml/faq.xml gcc-7.3.0-msp430/libstdc++-v3/doc/xml/faq.xml
--- gcc-7.3.0/libstdc++-v3/doc/xml/faq.xml	2017-04-11 15:36:40.579699000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/doc/xml/faq.xml	2019-06-25 02:27:32.289851375 -0700
@@ -734,15 +734,16 @@
     except for some corner cases.  Support for localization
     in <classname>locale</classname> may be incomplete on some non-GNU
     platforms. Also dependent on the underlying platform is support
-    for <type>wchar_t</type> and <type>long
-    long</type> specializations, and details of thread support.
+    for <type>wchar_t</type> and <type>long long</type> specializations,
+    and details of thread support.
     </para>
     <para>    
     Long answer: See the implementation status pages for 
     <link linkend="status.iso.1998">C++98</link>,
-    <link linkend="status.iso.tr1">TR1</link>, and 
-    <link linkend="status.iso.2011">C++11</link>.
-    <link linkend="status.iso.2014">C++14</link>.
+    <link linkend="status.iso.tr1">TR1</link>,
+    <link linkend="status.iso.2011">C++11</link>,
+    <link linkend="status.iso.2014">C++14</link>, and
+    <link linkend="status.iso.2017">C++17</link>.
     </para> 
   </answer>
 </qandaentry>
@@ -875,6 +876,9 @@
     </para>
   </question>
   <answer xml:id="a-ambiguous_overloads">
+    <note>
+      <para>This answer is old and probably no longer be relevant.</para>
+    </note>
     <para>
     Another problem is the <literal>rel_ops</literal> namespace and the template
     comparison operator functions contained therein.  If they become
diff -ruN gcc-7.3.0/libstdc++-v3/doc/xml/manual/debug_mode.xml gcc-7.3.0-msp430/libstdc++-v3/doc/xml/manual/debug_mode.xml
--- gcc-7.3.0/libstdc++-v3/doc/xml/manual/debug_mode.xml	2017-03-02 11:11:50.155264000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/doc/xml/manual/debug_mode.xml	2019-06-25 02:27:32.293851348 -0700
@@ -285,7 +285,19 @@
   </row>
 </thead>
 <tbody>
-    <row>
+  <row>
+    <entry><classname>std::array</classname></entry>
+    <entry><filename class="headerfile">array</filename></entry>
+    <entry><classname>__gnu_debug::array</classname></entry>
+    <entry><filename class="headerfile">&lt;debug/array&gt;</filename></entry>
+  </row>
+  <row>
+    <entry><classname>std::forward_list</classname></entry>
+    <entry><filename class="headerfile">forward_list</filename></entry>
+    <entry><classname>__gnu_debug::forward_list</classname></entry>
+    <entry><filename class="headerfile">&lt;debug/forward_list&gt;</filename></entry>
+  </row>
+  <row>
     <entry><classname>std::unordered_map</classname></entry>
     <entry><filename class="headerfile">unordered_map</filename></entry>
     <entry><classname>__gnu_debug::unordered_map</classname></entry>
diff -ruN gcc-7.3.0/libstdc++-v3/doc/xml/manual/test.xml gcc-7.3.0-msp430/libstdc++-v3/doc/xml/manual/test.xml
--- gcc-7.3.0/libstdc++-v3/doc/xml/manual/test.xml	2017-06-16 05:19:54.630334000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/doc/xml/manual/test.xml	2019-06-25 02:27:32.293851348 -0700
@@ -753,12 +753,15 @@
 
   <para>
     Similarly, tests which depend on a newer standard than the default
-    should use <literal>dg-options</literal> instead of an effective target,
-    so that they are not skipped by default.
+    must use <literal>dg-options</literal> instead of (or in addition to)
+    an effective target, so that they are not skipped by default.
     For example, tests for C++17 features should use
 <programlisting>    // { dg-options "-std=gnu++17" }</programlisting>
-    and not
-<programlisting>    // { dg-do run "c++1z" }</programlisting>
+    before any <literal>dg-do</literal> such as:
+<programlisting>    // { dg-do run "c++17" }</programlisting>
+    The <literal>dg-options</literal> directive must come first, so that
+    the <literal>-std</literal> flag has already been added to the options
+    before checking the <literal>c++17</literal> target.
   </para>
 
 <section xml:id="tests.dg.examples"><info><title>Examples of Test Directives</title></info>
diff -ruN gcc-7.3.0/libstdc++-v3/doc/xml/manual/using.xml gcc-7.3.0-msp430/libstdc++-v3/doc/xml/manual/using.xml
--- gcc-7.3.0/libstdc++-v3/doc/xml/manual/using.xml	2017-03-28 05:43:06.349913000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/doc/xml/manual/using.xml	2019-06-25 02:27:32.293851348 -0700
@@ -126,7 +126,7 @@
      must be available to all hosted implementations.  Actually, the
      word "files" is a misnomer, since the contents of the
      headers don't necessarily have to be in any kind of external
-     file.  The only rule is that when one <code>#include</code>'s a
+     file.  The only rule is that when one <code>#include</code>s a
      header, the contents of that header become available, no matter
      how.
    </para>
@@ -138,16 +138,24 @@
    <para>
      There are two main types of include files: header files related
      to a specific version of the ISO C++ standard (called Standard
-     Headers), and all others (TR1, C++ ABI, and Extensions).
+     Headers), and all others (TS, TR1, C++ ABI, and Extensions).
    </para>
 
    <para>
-     Two dialects of standard headers are supported, corresponding to
-     the 1998 standard as updated for 2003, and the current 2011 standard.
+     Multiple dialects of standard headers are supported, corresponding to
+     the 1998 standard as updated for 2003, the 2011 standard, the 2014
+     standard, and so on.
    </para>
 
    <para>
-     C++98/03 include files. These are available in the default compilation mode, i.e. <code>-std=c++98</code> or <code>-std=gnu++98</code>.
+     <xref linkend="table.cxx98_headers"/> and
+     <xref linkend="table.cxx98_cheaders"/> and
+     <xref linkend="table.cxx98_deprheaders"/>
+     show the C++98/03 include files.
+     These are available in the C++98 compilation mode,
+     i.e. <code>-std=c++98</code> or <code>-std=gnu++98</code>.
+     Unless specified otherwise below, they are also available in later modes
+     (C++11, C++14 etc).
    </para>
 
 <table frame="all" xml:id="table.cxx98_headers">
@@ -205,6 +213,7 @@
 <row>
 <entry><filename class="headerfile">valarray</filename></entry>
 <entry><filename class="headerfile">vector</filename></entry>
+<entry namest="c3" nameend="c5"/>
 </row>
 </tbody>
 </tgroup>
@@ -246,14 +255,38 @@
 <entry><filename class="headerfile">ctime</filename></entry>
 <entry><filename class="headerfile">cwchar</filename></entry>
 <entry><filename class="headerfile">cwctype</filename></entry>
+<entry namest="c4" nameend="c5"/>
 </row>
 </tbody>
 </tgroup>
 </table>
 
 <para>
-C++11 include files. These are only available in C++11 compilation
+  The following header is deprecated
+  and might be removed from a future C++ standard.
+</para>
+
+<table frame="all" xml:id="table.cxx98_deprheaders">
+<title>C++ 1998 Deprecated Library Header</title>
+
+<tgroup cols="1" align="left" colsep="1" rowsep="1">
+<colspec colname="c1"/>
+<tbody>
+<row>
+<entry><filename class="headerfile">strstream</filename></entry>
+</row>
+</tbody>
+</tgroup>
+</table>
+
+<para>
+<xref linkend="table.cxx11_headers"/> and
+<xref linkend="table.cxx11_cheaders"/> show the C++11 include files.
+These are available in C++11 compilation
 mode, i.e. <literal>-std=c++11</literal> or <literal>-std=gnu++11</literal>.
+Including these headers in C++98/03 mode may result in compilation errors.
+Unless specified otherwise below, they are also available in later modes
+(C++14 etc).
 </para>
 
 <para/>
@@ -269,73 +302,33 @@
 <tbody>
 
 <row>
-<entry><filename class="headerfile">algorithm</filename></entry>
 <entry><filename class="headerfile">array</filename></entry>
-<entry><filename class="headerfile">bitset</filename></entry>
+<entry><filename class="headerfile">atomic</filename></entry>
 <entry><filename class="headerfile">chrono</filename></entry>
-<entry><filename class="headerfile">complex</filename></entry>
-</row>
-<row>
+<entry><filename class="headerfile">codecvt</filename></entry>
 <entry><filename class="headerfile">condition_variable</filename></entry>
-<entry><filename class="headerfile">deque</filename></entry>
-<entry><filename class="headerfile">exception</filename></entry>
-<entry><filename class="headerfile">forward_list</filename></entry>
-<entry><filename class="headerfile">fstream</filename></entry>
 </row>
 <row>
-<entry><filename class="headerfile">functional</filename></entry>
+<entry><filename class="headerfile">forward_list</filename></entry>
 <entry><filename class="headerfile">future</filename></entry>
 <entry><filename class="headerfile">initalizer_list</filename></entry>
-<entry><filename class="headerfile">iomanip</filename></entry>
-<entry><filename class="headerfile">ios</filename></entry>
-</row>
-<row>
-<entry><filename class="headerfile">iosfwd</filename></entry>
-<entry><filename class="headerfile">iostream</filename></entry>
-<entry><filename class="headerfile">istream</filename></entry>
-<entry><filename class="headerfile">iterator</filename></entry>
-<entry><filename class="headerfile">limits</filename></entry>
-</row>
-<row>
-<entry><filename class="headerfile">list</filename></entry>
-<entry><filename class="headerfile">locale</filename></entry>
-<entry><filename class="headerfile">map</filename></entry>
-<entry><filename class="headerfile">memory</filename></entry>
 <entry><filename class="headerfile">mutex</filename></entry>
-</row>
-<row>
-<entry><filename class="headerfile">new</filename></entry>
-<entry><filename class="headerfile">numeric</filename></entry>
-<entry><filename class="headerfile">ostream</filename></entry>
-<entry><filename class="headerfile">queue</filename></entry>
 <entry><filename class="headerfile">random</filename></entry>
 </row>
 <row>
 <entry><filename class="headerfile">ratio</filename></entry>
 <entry><filename class="headerfile">regex</filename></entry>
-<entry><filename class="headerfile">set</filename></entry>
-<entry><filename class="headerfile">sstream</filename></entry>
-<entry><filename class="headerfile">stack</filename></entry>
-</row>
-<row>
-<entry><filename class="headerfile">stdexcept</filename></entry>
-<entry><filename class="headerfile">streambuf</filename></entry>
-<entry><filename class="headerfile">string</filename></entry>
+<entry><filename class="headerfile">scoped_allocator</filename></entry>
 <entry><filename class="headerfile">system_error</filename></entry>
 <entry><filename class="headerfile">thread</filename></entry>
 </row>
 <row>
 <entry><filename class="headerfile">tuple</filename></entry>
+<entry><filename class="headerfile">typeindex</filename></entry>
 <entry><filename class="headerfile">type_traits</filename></entry>
-<entry><filename class="headerfile">typeinfo</filename></entry>
 <entry><filename class="headerfile">unordered_map</filename></entry>
 <entry><filename class="headerfile">unordered_set</filename></entry>
 </row>
-<row>
-<entry><filename class="headerfile">utility</filename></entry>
-<entry><filename class="headerfile">valarray</filename></entry>
-<entry><filename class="headerfile">vector</filename></entry>
-</row>
 
 </tbody>
 </tgroup>
@@ -354,39 +347,162 @@
 <colspec colname="c5"/>
 <tbody>
 <row>
-<entry><filename class="headerfile">cassert</filename></entry>
 <entry><filename class="headerfile">ccomplex</filename></entry>
-<entry><filename class="headerfile">cctype</filename></entry>
-<entry><filename class="headerfile">cerrno</filename></entry>
 <entry><filename class="headerfile">cfenv</filename></entry>
+<entry><filename class="headerfile">cinttypes</filename></entry>
+<entry><filename class="headerfile">cstdalign</filename></entry>
+<entry><filename class="headerfile">cstdbool</filename></entry>
 </row>
 <row>
-<entry><filename class="headerfile">cfloat</filename></entry>
-<entry><filename class="headerfile">cinttypes</filename></entry>
-<entry><filename class="headerfile">ciso646</filename></entry>
-<entry><filename class="headerfile">climits</filename></entry>
-<entry><filename class="headerfile">clocale</filename></entry>
+<entry><filename class="headerfile">cstdint</filename></entry>
+<entry><filename class="headerfile">ctgmath</filename></entry>
+<entry><filename class="headerfile">cuchar</filename></entry>
+<entry namest="c4" nameend="c5"/>
 </row>
+</tbody>
+</tgroup>
+</table>
+
+<para>
+<xref linkend="table.cxx14_headers"/> shows the C++14 include file.
+This is available in C++14 compilation
+mode, i.e. <literal>-std=c++14</literal> or <literal>-std=gnu++14</literal>.
+Including this header in C++98/03 mode or C++11 will not result in
+compilation errors, but will not define anything.
+Unless specified otherwise below, it is also available in later modes
+(C++17 etc).
+</para>
+
+<para/>
+<table frame="all" xml:id="table.cxx14_headers">
+<title>C++ 2014 Library Header</title>
+
+<tgroup cols="1" align="left" colsep="1" rowsep="1">
+<colspec colname="c1"/>
+<tbody>
 <row>
-<entry><filename class="headerfile">cmath</filename></entry>
-<entry><filename class="headerfile">csetjmp</filename></entry>
-<entry><filename class="headerfile">csignal</filename></entry>
-<entry><filename class="headerfile">cstdarg</filename></entry>
-<entry><filename class="headerfile">cstdbool</filename></entry>
+<entry><filename class="headerfile">shared_mutex</filename></entry>
 </row>
+</tbody>
+</tgroup>
+</table>
+
+<para>
+<xref linkend="table.cxx17_headers"/> shows the C++17 include files.
+These are available in C++17 compilation
+mode, i.e. <literal>-std=c++17</literal> or <literal>-std=gnu++17</literal>.
+Including these headers in earlier modes will not result in
+compilation errors, but will not define anything.
+Unless specified otherwise below, they are also available in later modes
+(C++20 etc).
+</para>
+
+<para/>
+<table frame="all" xml:id="table.cxx17_headers">
+<title>C++ 2017 Library Headers</title>
+
+<tgroup cols="4" align="left" colsep="1" rowsep="1">
+<colspec colname="c1"/>
+<colspec colname="c2"/>
+<colspec colname="c3"/>
+<colspec colname="c4"/>
+<tbody>
 <row>
-<entry><filename class="headerfile">cstddef</filename></entry>
-<entry><filename class="headerfile">cstdint</filename></entry>
-<entry><filename class="headerfile">cstdlib</filename></entry>
-<entry><filename class="headerfile">cstdio</filename></entry>
-<entry><filename class="headerfile">cstring</filename></entry>
+<entry><filename class="headerfile">any</filename></entry>
+<entry><filename class="headerfile">optional</filename></entry>
+<entry><filename class="headerfile">string_view</filename></entry>
+<entry><filename class="headerfile">variant</filename></entry>
 </row>
+</tbody>
+</tgroup>
+</table>
+
+
+<para>
+<xref linkend="table.filesystemts_headers"/>,
+shows the additional include file define by the
+File System Technical Specification, ISO/IEC TS 18822.
+This is available in C++11 and later compilation modes.
+Including this header in earlier modes will not result in
+compilation errors, but will not define anything.
+</para>
+
+<para/>
+<table frame="all" xml:id="table.filesystemts_headers">
+<title>File System TS Header</title>
+
+<tgroup cols="1" align="left" colsep="1" rowsep="1">
+<colspec colname="c1"/>
+<tbody>
 <row>
-<entry><filename class="headerfile">ctgmath</filename></entry>
-<entry><filename class="headerfile">ctime</filename></entry>
-<entry><filename class="headerfile">cuchar</filename></entry>
-<entry><filename class="headerfile">cwchar</filename></entry>
-<entry><filename class="headerfile">cwctype</filename></entry>
+<entry><filename class="headerfile">experimental/filesystem</filename></entry>
+</row>
+</tbody>
+</tgroup>
+</table>
+
+
+<para>
+<xref linkend="table.libfundts_headers"/>,
+shows the additional include files define by the C++ Extensions for 
+Library Fundamentals Technical Specification, ISO/IEC TS 19568.
+These are available in C++14 and later compilation modes.
+Including these headers in earlier modes will not result in
+compilation errors, but will not define anything.
+</para>
+
+<para/>
+<table frame="all" xml:id="table.libfundts_headers">
+<title>Library Fundamentals TS Headers</title>
+
+<tgroup cols="5" align="left" colsep="1" rowsep="1">
+<colspec colname="c1"/>
+<colspec colname="c2"/>
+<colspec colname="c3"/>
+<colspec colname="c4"/>
+<colspec colname="c5"/>
+<tbody>
+<row>
+<entry><filename class="headerfile">experimental/algorithm</filename></entry>
+<entry><filename class="headerfile">experimental/any</filename></entry>
+<entry><filename class="headerfile">experimental/array</filename></entry>
+<entry><filename class="headerfile">experimental/chrono</filename></entry>
+<entry><filename class="headerfile">experimental/deque</filename></entry>
+</row>
+<row>
+<entry><filename class="headerfile">experimental/forward_list</filename></entry>
+<entry><filename class="headerfile">experimental/functional</filename></entry>
+<entry><filename class="headerfile">experimental/iterator</filename></entry>
+<entry><filename class="headerfile">experimental/list</filename></entry>
+<entry><filename class="headerfile">experimental/map</filename></entry>
+</row>
+<row>
+<entry><filename class="headerfile">experimental/memory</filename></entry>
+<entry><filename class="headerfile">experimental/memory_resource</filename></entry>
+<entry><filename class="headerfile">experimental/numeric</filename></entry>
+<entry><filename class="headerfile">experimental/optional</filename></entry>
+<entry><filename class="headerfile">experimental/propagate_const</filename></entry>
+</row>
+<row>
+<entry><filename class="headerfile">experimental/random</filename></entry>
+<entry><filename class="headerfile">experimental/ratio</filename></entry>
+<entry><filename class="headerfile">experimental/regex</filename></entry>
+<entry><filename class="headerfile">experimental/set</filename></entry>
+<entry><filename class="headerfile">experimental/source_location</filename></entry>
+</row>
+<row>
+<entry><filename class="headerfile">experimental/string</filename></entry>
+<entry><filename class="headerfile">experimental/string_view</filename></entry>
+<entry><filename class="headerfile">experimental/system_error</filename></entry>
+<entry><filename class="headerfile">experimental/tuple</filename></entry>
+<entry><filename class="headerfile">experimental/type_traits</filename></entry>
+</row>
+<row>
+<entry><filename class="headerfile">experimental/unordered_map</filename></entry>
+<entry><filename class="headerfile">experimental/unordered_set</filename></entry>
+<entry><filename class="headerfile">experimental/utility</filename></entry>
+<entry><filename class="headerfile">experimental/vector</filename></entry>
+<entry />
 </row>
 </tbody>
 </tgroup>
@@ -424,6 +540,7 @@
 </row>
 <row>
 <entry><filename class="headerfile">tr1/utility</filename></entry>
+<entry namest="c2" nameend="c5"/>
 </row>
 
 </tbody>
@@ -564,6 +681,7 @@
 </row>
 <row>
 <entry><filename class="headerfile">ext/vstring.h</filename></entry>
+<entry namest="c2" nameend="c5"/>
 </row>
 
 </tbody>
@@ -584,18 +702,22 @@
 <tbody>
 
 <row>
+<entry><filename class="headerfile">debug/array</filename></entry>
 <entry><filename class="headerfile">debug/bitset</filename></entry>
 <entry><filename class="headerfile">debug/deque</filename></entry>
+<entry><filename class="headerfile">debug/forward_list</filename></entry>
 <entry><filename class="headerfile">debug/list</filename></entry>
-<entry><filename class="headerfile">debug/map</filename></entry>
-<entry><filename class="headerfile">debug/set</filename></entry>
 </row>
-
 <row>
+<entry><filename class="headerfile">debug/map</filename></entry>
+<entry><filename class="headerfile">debug/set</filename></entry>
 <entry><filename class="headerfile">debug/string</filename></entry>
 <entry><filename class="headerfile">debug/unordered_map</filename></entry>
 <entry><filename class="headerfile">debug/unordered_set</filename></entry>
+</row>
+<row>
 <entry><filename class="headerfile">debug/vector</filename></entry>
+<entry namest="c2" nameend="c5"/>
 </row>
 
 </tbody>
@@ -1016,7 +1138,7 @@
 </para>
 
 <para> The <symbol>_GLIBCXX_USE_CXX11_ABI</symbol> macro (see
-<xref linkend="manual.intro.using.macros"/>) controls whether
+  <xref linkend="manual.intro.using.macros"/>) controls whether
   the declarations in the library headers use the old or new ABI.
   So the decision of which ABI to use can be made separately for each
   source file being compiled.
@@ -1051,12 +1173,39 @@
 </para>
 
 <para> Although the standard exception types defined in
-  <filename class="headerfile">&lt;stdexcept&gt;</filename> use strings, they
+  <filename class="headerfile">&lt;stdexcept&gt;</filename> use strings, most
   are not defined twice, so that a <classname>std::out_of_range</classname>
   exception thrown in one file can always be caught by a suitable handler in
   another file, even if the two files are compiled with different ABIs.
 </para>
 
+<para> One exception type does change when using the new ABI, namely
+  <classname>std::ios_base::failure</classname>.
+  This is necessary because the 2011 standard changed its base class from
+  <classname>std::exception</classname> to
+  <classname>std::system_error</classname>, which causes its layout to change.
+  Exceptions due to iostream errors are thrown by a function inside
+  <filename class="libraryfile">libstdc++.so</filename>, so whether the thrown
+  exception uses the old <classname>std::ios_base::failure</classname> type
+  or the new one depends on the ABI that was active when
+  <filename class="libraryfile">libstdc++.so</filename> was built,
+  <emphasis>not</emphasis> the ABI active in the user code that is using
+  iostreams.
+  This means that for a given build of GCC the type thrown is fixed.
+  In current releases the library throws a special type that can be caught
+  by handlers for either the old or new type,
+  but for GCC 7.1, 7.2 and 7.3 the library throws the new
+  <classname>std::ios_base::failure</classname> type,
+  and for GCC 5.x and 6.x the library throws the old type.
+  Catch handlers of type <classname>std::ios_base::failure</classname>
+  will only catch the exceptions if using a newer release,
+  or if the handler is compiled with the same ABI as the type thrown by
+  the library.
+  Handlers for <classname>std::exception</classname> will always catch
+  iostreams exceptions, because the old and new type both inherit from
+  <classname>std::exception</classname>.
+</para>
+
 <section xml:id="manual.intro.using.abi.trouble" xreflabel="Dual ABI Troubleshooting"><info><title>Troubleshooting</title></info>
 
 <para> If you get linker errors about undefined references to symbols
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/basic_string.h gcc-7.3.0-msp430/libstdc++-v3/include/bits/basic_string.h
--- gcc-7.3.0/libstdc++-v3/include/bits/basic_string.h	2017-09-20 15:26:19.141800000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/basic_string.h	2019-06-25 02:27:32.293851348 -0700
@@ -1216,7 +1216,7 @@
        *  remainder of @a __str is appended.
        */
       basic_string&
-      append(const basic_string& __str, size_type __pos, size_type __n)
+      append(const basic_string& __str, size_type __pos, size_type __n = npos)
       { return _M_append(__str._M_data()
 			 + __str._M_check(__pos, "basic_string::append"),
 			 __str._M_limit(__pos, __n)); }
@@ -1381,7 +1381,7 @@
        *  __str, the remainder of @a __str is used.
        */
       basic_string&
-      assign(const basic_string& __str, size_type __pos, size_type __n)
+      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
       { return _M_replace(size_type(0), this->size(), __str._M_data()
 			  + __str._M_check(__pos, "basic_string::assign"),
 			  __str._M_limit(__pos, __n)); }
@@ -1633,7 +1633,7 @@
       */
       basic_string&
       insert(size_type __pos1, const basic_string& __str,
-	     size_type __pos2, size_type __n)
+	     size_type __pos2, size_type __n = npos)
       { return this->replace(__pos1, size_type(0), __str._M_data()
 			     + __str._M_check(__pos2, "basic_string::insert"),
 			     __str._M_limit(__pos2, __n)); }
@@ -1881,7 +1881,7 @@
       */
       basic_string&
       replace(size_type __pos1, size_type __n1, const basic_string& __str,
-	      size_type __pos2, size_type __n2)
+	      size_type __pos2, size_type __n2 = npos)
       { return this->replace(__pos1, __n1, __str._M_data()
 			     + __str._M_check(__pos2, "basic_string::replace"),
 			     __str._M_limit(__pos2, __n2)); }
@@ -2941,7 +2941,7 @@
       */
       int
       compare(size_type __pos1, size_type __n1, const basic_string& __str,
-	      size_type __pos2, size_type __n2) const;
+	      size_type __pos2, size_type __n2 = npos) const;
 
       /**
        *  @brief  Compare to a C string.
@@ -4135,7 +4135,7 @@
        *  remainder of @a __str is appended.
        */
       basic_string&
-      append(const basic_string& __str, size_type __pos, size_type __n);
+      append(const basic_string& __str, size_type __pos, size_type __n = npos);
 
       /**
        *  @brief  Append a C substring.
@@ -4280,7 +4280,7 @@
        *  __str, the remainder of @a __str is used.
        */
       basic_string&
-      assign(const basic_string& __str, size_type __pos, size_type __n)
+      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
       { return this->assign(__str._M_data()
 			    + __str._M_check(__pos, "basic_string::assign"),
 			    __str._M_limit(__pos, __n)); }
@@ -4468,7 +4468,7 @@
       */
       basic_string&
       insert(size_type __pos1, const basic_string& __str,
-	     size_type __pos2, size_type __n)
+	     size_type __pos2, size_type __n = npos)
       { return this->insert(__pos1, __str._M_data()
 			    + __str._M_check(__pos2, "basic_string::insert"),
 			    __str._M_limit(__pos2, __n)); }
@@ -4703,7 +4703,7 @@
       */
       basic_string&
       replace(size_type __pos1, size_type __n1, const basic_string& __str,
-	      size_type __pos2, size_type __n2)
+	      size_type __pos2, size_type __n2 = npos)
       { return this->replace(__pos1, __n1, __str._M_data()
 			     + __str._M_check(__pos2, "basic_string::replace"),
 			     __str._M_limit(__pos2, __n2)); }
@@ -5130,7 +5130,10 @@
       */
       _CharT*
       data() noexcept
-      { return _M_data(); }
+      {
+	_M_leak();
+	return _M_data();
+      }
 #endif
 
       /**
@@ -5779,7 +5782,7 @@
       */
       int
       compare(size_type __pos1, size_type __n1, const basic_string& __str,
-	      size_type __pos2, size_type __n2) const;
+	      size_type __pos2, size_type __n2 = npos) const;
 
       /**
        *  @brief  Compare to a C string.
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/basic_string.tcc gcc-7.3.0-msp430/libstdc++-v3/include/bits/basic_string.tcc
--- gcc-7.3.0/libstdc++-v3/include/bits/basic_string.tcc	2017-02-01 03:41:48.369557000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/basic_string.tcc	2019-06-25 02:27:32.293851348 -0700
@@ -1597,8 +1597,21 @@
 
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
-#if _GLIBCXX_EXTERN_TEMPLATE > 0 && __cplusplus <= 201402L
+#if _GLIBCXX_EXTERN_TEMPLATE
+  // The explicit instantiations definitions in src/c++11/string-inst.cc
+  // are compiled as C++14, so the new C++17 members aren't instantiated.
+  // Until those definitions are compiled as C++17 suppress the declaration,
+  // so C++17 code will implicitly instantiate std::string and std::wstring
+  // as needed.
+# if __cplusplus <= 201402L && _GLIBCXX_EXTERN_TEMPLATE > 0
   extern template class basic_string<char>;
+# elif ! _GLIBCXX_USE_CXX11_ABI
+  // Still need to prevent implicit instantiation of the COW empty rep,
+  // to ensure the definition in libstdc++.so is unique (PR 86138).
+  extern template basic_string<char>::size_type
+    basic_string<char>::_Rep::_S_empty_rep_storage[];
+# endif
+
   extern template
     basic_istream<char>&
     operator>>(basic_istream<char>&, string&);
@@ -1613,7 +1626,13 @@
     getline(basic_istream<char>&, string&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
+# if __cplusplus <= 201402L && _GLIBCXX_EXTERN_TEMPLATE > 0
   extern template class basic_string<wchar_t>;
+# elif ! _GLIBCXX_USE_CXX11_ABI
+  extern template basic_string<wchar_t>::size_type
+    basic_string<wchar_t>::_Rep::_S_empty_rep_storage[];
+# endif
+
   extern template
     basic_istream<wchar_t>&
     operator>>(basic_istream<wchar_t>&, wstring&);
@@ -1626,8 +1645,8 @@
   extern template
     basic_istream<wchar_t>&
     getline(basic_istream<wchar_t>&, wstring&);
-#endif
-#endif
+#endif // _GLIBCXX_USE_WCHAR_T
+#endif // _GLIBCXX_EXTERN_TEMPLATE
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/c++config gcc-7.3.0-msp430/libstdc++-v3/include/bits/c++config
--- gcc-7.3.0/libstdc++-v3/include/bits/c++config	2017-03-23 12:40:07.832944000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/c++config	2019-06-25 02:27:32.293851348 -0700
@@ -634,4 +634,9 @@
 # endif
 #endif
 
+/* Define if __float128 is supported on this host. */
+#if defined(__FLOAT128__) || defined(__SIZEOF_FLOAT128__)
+#define _GLIBCXX_USE_FLOAT128
+#endif
+
 // End of prewritten config; the settings discovered at configure time follow.
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/char_traits.h gcc-7.3.0-msp430/libstdc++-v3/include/bits/char_traits.h
--- gcc-7.3.0/libstdc++-v3/include/bits/char_traits.h	2017-09-12 09:27:01.075204000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/char_traits.h	2019-06-25 02:27:32.293851348 -0700
@@ -143,8 +143,6 @@
       { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
     };
 
-#define __cpp_lib_constexpr_char_traits 201611
-
   template<typename _CharT>
     _GLIBCXX14_CONSTEXPR int
     char_traits<_CharT>::
@@ -217,6 +215,8 @@
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #if __cplusplus > 201402
+#define __cpp_lib_constexpr_char_traits 201611
+
   /**
    *  @brief Determine whether the characters of a NULL-terminated
    *  string are known at compile time.
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/forward_list.h gcc-7.3.0-msp430/libstdc++-v3/include/bits/forward_list.h
--- gcc-7.3.0/libstdc++-v3/include/bits/forward_list.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/forward_list.h	2019-06-25 02:27:32.293851348 -0700
@@ -274,7 +274,6 @@
     struct _Fwd_list_base
     {
     protected:
-      typedef __alloc_rebind<_Alloc, _Tp> 		  _Tp_alloc_type;
       typedef __alloc_rebind<_Alloc, _Fwd_list_node<_Tp>> _Node_alloc_type;
       typedef __gnu_cxx::__alloc_traits<_Node_alloc_type> _Node_alloc_traits;
 
@@ -345,11 +344,10 @@
           _Node* __node = this->_M_get_node();
           __try
             {
-	      _Tp_alloc_type __a(_M_get_Node_allocator());
-	      typedef allocator_traits<_Tp_alloc_type> _Alloc_traits;
 	      ::new ((void*)__node) _Node;
-	      _Alloc_traits::construct(__a, __node->_M_valptr(),
-				       std::forward<_Args>(__args)...);
+	      _Node_alloc_traits::construct(_M_get_Node_allocator(),
+					    __node->_M_valptr(),
+					    std::forward<_Args>(__args)...);
             }
           __catch(...)
             {
@@ -412,10 +410,9 @@
       typedef _Fwd_list_base<_Tp, _Alloc>                  _Base;
       typedef _Fwd_list_node<_Tp>                          _Node;
       typedef _Fwd_list_node_base                          _Node_base;
-      typedef typename _Base::_Tp_alloc_type               _Tp_alloc_type;
       typedef typename _Base::_Node_alloc_type             _Node_alloc_type;
       typedef typename _Base::_Node_alloc_traits           _Node_alloc_traits;
-      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>    _Alloc_traits;
+      typedef allocator_traits<__alloc_rebind<_Alloc, _Tp>>    _Alloc_traits;
 
     public:
       // types:
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/forward_list.tcc gcc-7.3.0-msp430/libstdc++-v3/include/bits/forward_list.tcc
--- gcc-7.3.0/libstdc++-v3/include/bits/forward_list.tcc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/forward_list.tcc	2019-06-25 02:27:32.293851348 -0700
@@ -69,8 +69,8 @@
     {
       _Node* __curr = static_cast<_Node*>(__pos->_M_next);
       __pos->_M_next = __curr->_M_next;
-      _Tp_alloc_type __a(_M_get_Node_allocator());
-      allocator_traits<_Tp_alloc_type>::destroy(__a, __curr->_M_valptr());
+      _Node_alloc_traits::destroy(_M_get_Node_allocator(),
+				  __curr->_M_valptr());
       __curr->~_Node();
       _M_put_node(__curr);
       return __pos->_M_next;
@@ -87,8 +87,8 @@
         {
           _Node* __temp = __curr;
           __curr = static_cast<_Node*>(__curr->_M_next);
-	  _Tp_alloc_type __a(_M_get_Node_allocator());
-	  allocator_traits<_Tp_alloc_type>::destroy(__a, __temp->_M_valptr());
+	  _Node_alloc_traits::destroy(_M_get_Node_allocator(),
+				      __temp->_M_valptr());
 	  __temp->~_Node();
           _M_put_node(__temp);
         }
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/node_handle.h gcc-7.3.0-msp430/libstdc++-v3/include/bits/node_handle.h
--- gcc-7.3.0/libstdc++-v3/include/bits/node_handle.h	2017-12-01 09:12:04.345518000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/node_handle.h	2019-06-25 02:27:32.293851348 -0700
@@ -105,7 +105,7 @@
       {
 	using std::swap;
 	swap(_M_ptr, __nh._M_ptr);
-	if (_AllocTraits::propagate_on_container_swap
+	if (_AllocTraits::propagate_on_container_swap::value
 	    || !_M_alloc || !__nh._M_alloc)
 	  _M_alloc.swap(__nh._M_alloc);
 	else
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/parse_numbers.h gcc-7.3.0-msp430/libstdc++-v3/include/bits/parse_numbers.h
--- gcc-7.3.0/libstdc++-v3/include/bits/parse_numbers.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/parse_numbers.h	2019-06-25 02:27:32.293851348 -0700
@@ -197,6 +197,13 @@
 		    "integer literal does not fit in unsigned long long");
     };
 
+  // Skip past digit separators:
+  template<unsigned _Base, unsigned long long _Pow, char _Dig, char..._Digs>
+    struct _Number_help<_Base, _Pow, '\'', _Dig, _Digs...>
+    : _Number_help<_Base, _Pow, _Dig, _Digs...>
+    { };
+
+  // Terminating case for recursion:
   template<unsigned _Base, unsigned long long _Pow, char _Dig>
     struct _Number_help<_Base, _Pow, _Dig>
     {
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/random.h gcc-7.3.0-msp430/libstdc++-v3/include/bits/random.h
--- gcc-7.3.0/libstdc++-v3/include/bits/random.h	2017-01-20 07:28:48.921632000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/random.h	2019-06-25 02:27:32.293851348 -0700
@@ -2643,7 +2643,12 @@
        */
       void
       param(const param_type& __param)
-      { _M_param = __param; }
+      {
+	_M_param = __param;
+	typedef typename std::gamma_distribution<result_type>::param_type
+	  param_type;
+	_M_gd.param(param_type{__param.n() / 2});
+      }
 
       /**
        * @brief Returns the greatest lower bound value of the distribution.
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/random.tcc gcc-7.3.0-msp430/libstdc++-v3/include/bits/random.tcc
--- gcc-7.3.0/libstdc++-v3/include/bits/random.tcc	2017-03-28 09:09:49.962681000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/random.tcc	2019-06-25 02:27:32.293851348 -0700
@@ -2356,7 +2356,7 @@
 	    __v = __v * __v * __v;
 	    __u = __aurng();
 	  }
-	while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
+	while (__u > result_type(1.0) - 0.0331 * __n * __n * __n * __n
 	       && (std::log(__u) > (0.5 * __n * __n + __a1
 				    * (1.0 - __v + std::log(__v)))));
 
@@ -2405,7 +2405,7 @@
 		  __v = __v * __v * __v;
 		  __u = __aurng();
 		}
-	      while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
+	      while (__u > result_type(1.0) - 0.0331 * __n * __n * __n * __n
 		     && (std::log(__u) > (0.5 * __n * __n + __a1
 					  * (1.0 - __v + std::log(__v)))));
 
@@ -2426,7 +2426,7 @@
 		  __v = __v * __v * __v;
 		  __u = __aurng();
 		}
-	      while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
+	      while (__u > result_type(1.0) - 0.0331 * __n * __n * __n * __n
 		     && (std::log(__u) > (0.5 * __n * __n + __a1
 					  * (1.0 - __v + std::log(__v)))));
 
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/regex_automaton.h gcc-7.3.0-msp430/libstdc++-v3/include/bits/regex_automaton.h
--- gcc-7.3.0/libstdc++-v3/include/bits/regex_automaton.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/regex_automaton.h	2019-06-25 02:27:32.293851348 -0700
@@ -333,7 +333,7 @@
 	    "Number of NFA states exceeds limit. Please use shorter regex "
 	    "string, or use smaller brace expression, or make "
 	    "_GLIBCXX_REGEX_STATE_LIMIT larger.");
-	return this->size()-1;
+	return this->size() - 1;
       }
 
       // Eliminate dummy node in this NFA to make it compact.
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/regex.h gcc-7.3.0-msp430/libstdc++-v3/include/bits/regex.h
--- gcc-7.3.0/libstdc++-v3/include/bits/regex.h	2018-01-05 14:22:28.979885000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/regex.h	2019-06-25 02:27:32.293851348 -0700
@@ -785,6 +785,48 @@
       _AutomatonPtr          _M_automaton;
     };
 
+#if __cplusplus < 201703L
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::icase;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::nosubs;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::optimize;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::collate;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::ECMAScript;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::basic;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::extended;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::awk;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::grep;
+
+  template<typename _Ch, typename _Tr>
+    constexpr regex_constants::syntax_option_type
+    basic_regex<_Ch, _Tr>::egrep;
+#endif // ! C++17
+
   /** @brief Standard regular expressions. */
   typedef basic_regex<char>    regex;
 
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/stl_bvector.h gcc-7.3.0-msp430/libstdc++-v3/include/bits/stl_bvector.h
--- gcc-7.3.0/libstdc++-v3/include/bits/stl_bvector.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/stl_bvector.h	2019-06-25 02:27:32.293851348 -0700
@@ -1089,9 +1089,17 @@
     void
     _M_initialize(size_type __n)
     {
-      _Bit_pointer __q = this->_M_allocate(__n);
-      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
-      this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
+      if (__n)
+	{
+	  _Bit_pointer __q = this->_M_allocate(__n);
+	  this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
+	  this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
+	}
+      else
+	{
+	  this->_M_impl._M_end_of_storage = _Bit_pointer();
+	  this->_M_impl._M_start = iterator(0, 0);
+	}
       this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
     }
 
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/stl_iterator.h gcc-7.3.0-msp430/libstdc++-v3/include/bits/stl_iterator.h
--- gcc-7.3.0/libstdc++-v3/include/bits/stl_iterator.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/stl_iterator.h	2019-06-25 02:27:32.293851348 -0700
@@ -122,6 +122,7 @@
       */
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 235 No specification of default ctor for reverse_iterator
+      // 1012. reverse_iterator default ctor should value initialize
       _GLIBCXX17_CONSTEXPR
       reverse_iterator() : current() { }
 
@@ -176,9 +177,11 @@
        *
        *  This requires that @c --current is dereferenceable.
       */
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 2188. Reverse iterator does not fully support targets that overload &
       _GLIBCXX17_CONSTEXPR pointer
       operator->() const
-      { return &(operator*()); }
+      { return std::__addressof(operator*()); }
 
       /**
        *  @return  @c *this
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/stl_vector.h gcc-7.3.0-msp430/libstdc++-v3/include/bits/stl_vector.h
--- gcc-7.3.0/libstdc++-v3/include/bits/stl_vector.h	2017-03-20 13:51:40.822353000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/stl_vector.h	2019-06-25 02:27:32.293851348 -0700
@@ -1302,22 +1302,27 @@
       // Called by the second initialize_dispatch above
       template<typename _InputIterator>
 	void
-	_M_range_initialize(_InputIterator __first,
-			    _InputIterator __last, std::input_iterator_tag)
+	_M_range_initialize(_InputIterator __first, _InputIterator __last,
+			    std::input_iterator_tag)
 	{
-	  for (; __first != __last; ++__first)
+	  __try {
+	    for (; __first != __last; ++__first)
 #if __cplusplus >= 201103L
-	    emplace_back(*__first);
+	      emplace_back(*__first);
 #else
-	    push_back(*__first);
+	      push_back(*__first);
 #endif
+	  } __catch(...) {
+	    clear();
+	    __throw_exception_again;
+	  }
 	}
 
       // Called by the second initialize_dispatch above
       template<typename _ForwardIterator>
 	void
-	_M_range_initialize(_ForwardIterator __first,
-			    _ForwardIterator __last, std::forward_iterator_tag)
+	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
+			    std::forward_iterator_tag)
 	{
 	  const size_type __n = std::distance(__first, __last);
 	  this->_M_impl._M_start = this->_M_allocate(__n);
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/valarray_array.h gcc-7.3.0-msp430/libstdc++-v3/include/bits/valarray_array.h
--- gcc-7.3.0/libstdc++-v3/include/bits/valarray_array.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/valarray_array.h	2019-06-25 02:27:32.293851348 -0700
@@ -152,7 +152,10 @@
     {
       inline static void
       _S_do_it(const _Tp* __b, const _Tp* __e, _Tp* __restrict__ __o)
-      { __builtin_memcpy(__o, __b, (__e - __b) * sizeof(_Tp)); }
+      {
+	if (__b)
+	  __builtin_memcpy(__o, __b, (__e - __b) * sizeof(_Tp));
+      }
     };
 
   template<typename _Tp>
@@ -258,7 +261,10 @@
     {
       inline static void
       _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)
-      { __builtin_memcpy(__b, __a, __n * sizeof (_Tp)); }
+      {
+	if (__n != 0)
+	  __builtin_memcpy(__b, __a, __n * sizeof (_Tp));
+      }
     };
 
   // Copy a plain array __a[<__n>] into a play array __b[<>]
diff -ruN gcc-7.3.0/libstdc++-v3/include/bits/vector.tcc gcc-7.3.0-msp430/libstdc++-v3/include/bits/vector.tcc
--- gcc-7.3.0/libstdc++-v3/include/bits/vector.tcc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/bits/vector.tcc	2019-06-25 02:27:32.293851348 -0700
@@ -567,23 +567,23 @@
 	    {
 	      const size_type __len =
 		_M_check_len(__n, "vector::_M_default_append");
-	      const size_type __old_size = this->size();
+	      const size_type __size = this->size();
 	      pointer __new_start(this->_M_allocate(__len));
-	      pointer __new_finish(__new_start);
+	      pointer __destroy_from = pointer();
 	      __try
 		{
-		  __new_finish
-		    = std::__uninitialized_move_if_noexcept_a
-		    (this->_M_impl._M_start, this->_M_impl._M_finish,
-		     __new_start, _M_get_Tp_allocator());
-		  __new_finish =
-		    std::__uninitialized_default_n_a(__new_finish, __n,
-						     _M_get_Tp_allocator());
+		  std::__uninitialized_default_n_a(__new_start + __size,
+						   __n, _M_get_Tp_allocator());
+		  __destroy_from = __new_start + __size;
+		  std::__uninitialized_move_if_noexcept_a(
+		      this->_M_impl._M_start, this->_M_impl._M_finish,
+		      __new_start, _M_get_Tp_allocator());
 		}
 	      __catch(...)
 		{
-		  std::_Destroy(__new_start, __new_finish,
-				_M_get_Tp_allocator());
+		  if (__destroy_from)
+		    std::_Destroy(__destroy_from, __destroy_from + __n,
+				  _M_get_Tp_allocator());
 		  _M_deallocate(__new_start, __len);
 		  __throw_exception_again;
 		}
@@ -593,7 +593,7 @@
 			    this->_M_impl._M_end_of_storage
 			    - this->_M_impl._M_start);
 	      this->_M_impl._M_start = __new_start;
-	      this->_M_impl._M_finish = __new_finish;
+	      this->_M_impl._M_finish = __new_start + __size + __n;
 	      this->_M_impl._M_end_of_storage = __new_start + __len;
 	    }
 	}
diff -ruN gcc-7.3.0/libstdc++-v3/include/c_global/cstddef gcc-7.3.0-msp430/libstdc++-v3/include/c_global/cstddef
--- gcc-7.3.0/libstdc++-v3/include/c_global/cstddef	2017-10-20 11:19:09.048987000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/include/c_global/cstddef	2019-06-25 02:27:32.293851348 -0700
@@ -65,7 +65,7 @@
   /// std::byte
   enum class byte : unsigned char {};
 
-  template<typename _IntegerType> struct __byte_operand;
+  template<typename _IntegerType> struct __byte_operand { };
   template<> struct __byte_operand<bool> { using __type = byte; };
   template<> struct __byte_operand<char> { using __type = byte; };
   template<> struct __byte_operand<signed char> { using __type = byte; };
diff -ruN gcc-7.3.0/libstdc++-v3/include/c_global/cstdlib gcc-7.3.0-msp430/libstdc++-v3/include/c_global/cstdlib
--- gcc-7.3.0/libstdc++-v3/include/c_global/cstdlib	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/c_global/cstdlib	2019-06-25 02:27:32.293851348 -0700
@@ -78,6 +78,9 @@
 
 // Get rid of those macros defined in <stdlib.h> in lieu of real functions.
 #undef abort
+#if __cplusplus >= 201703L && defined(_GLIBCXX_HAVE_ALIGNED_ALLOC)
+# undef aligned_alloc
+#endif
 #undef atexit
 #if __cplusplus >= 201103L
 # ifdef _GLIBCXX_HAVE_AT_QUICK_EXIT
@@ -125,6 +128,9 @@
   using ::ldiv_t;
 
   using ::abort;
+#if __cplusplus >= 201703L && defined(_GLIBCXX_HAVE_ALIGNED_ALLOC)
+  using ::aligned_alloc;
+#endif
   using ::atexit;
 #if __cplusplus >= 201103L
 # ifdef _GLIBCXX_HAVE_AT_QUICK_EXIT
diff -ruN gcc-7.3.0/libstdc++-v3/include/debug/string gcc-7.3.0-msp430/libstdc++-v3/include/debug/string
--- gcc-7.3.0/libstdc++-v3/include/debug/string	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/debug/string	2019-06-25 02:27:32.293851348 -0700
@@ -565,7 +565,7 @@
       insert(iterator __p, _InputIterator __first, _InputIterator __last)
       {
 	typename __gnu_debug::_Distance_traits<_InputIterator>::__type __dist;
-	__glibcxx_check_insert_range2(__p, __first, __last, __dist);
+	__glibcxx_check_insert_range(__p, __first, __last, __dist);
 
 	if (__dist.second >= __dp_sign)
 	  _Base::insert(__p.base(), __gnu_debug::__unsafe(__first),
diff -ruN gcc-7.3.0/libstdc++-v3/include/experimental/bits/fs_path.h gcc-7.3.0-msp430/libstdc++-v3/include/experimental/bits/fs_path.h
--- gcc-7.3.0/libstdc++-v3/include/experimental/bits/fs_path.h	2017-10-20 08:14:23.114874000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/include/experimental/bits/fs_path.h	2019-06-25 02:27:32.293851348 -0700
@@ -509,7 +509,11 @@
 
   /// Append one path to another
   inline path operator/(const path& __lhs, const path& __rhs)
-  { return path(__lhs) /= __rhs; }
+  {
+    path __result(__lhs);
+    __result /= __rhs;
+    return __result;
+  }
 
   /// Write a path to a stream
   template<typename _CharT, typename _Traits>
diff -ruN gcc-7.3.0/libstdc++-v3/include/Makefile.am gcc-7.3.0-msp430/libstdc++-v3/include/Makefile.am
--- gcc-7.3.0/libstdc++-v3/include/Makefile.am	2017-10-20 08:14:29.733840000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/include/Makefile.am	2019-06-25 02:27:32.293851348 -0700
@@ -1225,6 +1225,14 @@
 	echo 0 > stamp-allocator-new
 endif
 
+if ENABLE_FLOAT128
+stamp-float128:
+	echo 'define _GLIBCXX_USE_FLOAT128 1' > stamp-float128
+else
+stamp-float128:
+	echo 'undef _GLIBCXX_USE_FLOAT128' > stamp-float128
+endif
+
 # NB: The non-empty default ldbl_compat works around an AIX sed
 # oddity, see libstdc++/31957 for details.
 ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
@@ -1236,7 +1244,8 @@
 			      stamp-extern-template \
 			      stamp-dual-abi \
 			      stamp-cxx11-abi \
-			      stamp-allocator-new
+			      stamp-allocator-new \
+			      stamp-float128
 	@date=`cat ${toplevel_srcdir}/gcc/DATESTAMP` ;\
 	release=`sed 's/^\([0-9]*\).*$$/\1/' ${toplevel_srcdir}/gcc/BASE-VER` ;\
 	ns_version=`cat stamp-namespace-version` ;\
@@ -1245,6 +1254,7 @@
 	dualabi=`cat stamp-dual-abi` ;\
 	cxx11abi=`cat stamp-cxx11-abi` ;\
 	allocatornew=`cat stamp-allocator-new` ;\
+	float128=`cat stamp-float128` ;\
 	ldbl_compat='s,g,g,' ;\
 	grep "^[	 ]*#[	 ]*define[	 ][	 ]*_GLIBCXX_LONG_DOUBLE_COMPAT[	 ][	 ]*1[	 ]*$$" \
 	${CONFIG_HEADER} > /dev/null 2>&1 \
@@ -1257,6 +1267,7 @@
 	-e "s,define _GLIBCXX_USE_DUAL_ABI, define _GLIBCXX_USE_DUAL_ABI $$dualabi," \
 	-e "s,define _GLIBCXX_USE_CXX11_ABI, define _GLIBCXX_USE_CXX11_ABI $$cxx11abi," \
 	-e "s,define _GLIBCXX_USE_ALLOCATOR_NEW, define _GLIBCXX_USE_ALLOCATOR_NEW $$allocatornew," \
+	-e "s,define _GLIBCXX_USE_FLOAT128,$$float128," \
 	-e "$$ldbl_compat" \
 	    < ${glibcxx_srcdir}/include/bits/c++config > $@ ;\
 	sed -e 's/HAVE_/_GLIBCXX_HAVE_/g' \
@@ -1474,3 +1485,8 @@
 $(ext_headers): ; @:
 $(experimental_headers): ; @:
 $(experimental_bits_headers): ; @:
+
+if INCLUDE_DIR_NOTPARALLEL
+# See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81797
+.NOTPARALLEL:
+endif
diff -ruN gcc-7.3.0/libstdc++-v3/include/Makefile.in gcc-7.3.0-msp430/libstdc++-v3/include/Makefile.in
--- gcc-7.3.0/libstdc++-v3/include/Makefile.in	2017-10-20 08:14:29.733840000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/include/Makefile.in	2019-06-25 02:27:32.293851348 -0700
@@ -1656,6 +1656,11 @@
 @ENABLE_ALLOCATOR_NEW_FALSE@stamp-allocator-new:
 @ENABLE_ALLOCATOR_NEW_FALSE@	echo 0 > stamp-allocator-new
 
+@ENABLE_FLOAT128_TRUE@stamp-float128:
+@ENABLE_FLOAT128_TRUE@	echo 'define _GLIBCXX_USE_FLOAT128 1' > stamp-float128
+@ENABLE_FLOAT128_FALSE@stamp-float128:
+@ENABLE_FLOAT128_FALSE@	echo 'undef _GLIBCXX_USE_FLOAT128' > stamp-float128
+
 # NB: The non-empty default ldbl_compat works around an AIX sed
 # oddity, see libstdc++/31957 for details.
 ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
@@ -1667,7 +1672,8 @@
 			      stamp-extern-template \
 			      stamp-dual-abi \
 			      stamp-cxx11-abi \
-			      stamp-allocator-new
+			      stamp-allocator-new \
+			      stamp-float128
 	@date=`cat ${toplevel_srcdir}/gcc/DATESTAMP` ;\
 	release=`sed 's/^\([0-9]*\).*$$/\1/' ${toplevel_srcdir}/gcc/BASE-VER` ;\
 	ns_version=`cat stamp-namespace-version` ;\
@@ -1676,6 +1682,7 @@
 	dualabi=`cat stamp-dual-abi` ;\
 	cxx11abi=`cat stamp-cxx11-abi` ;\
 	allocatornew=`cat stamp-allocator-new` ;\
+	float128=`cat stamp-float128` ;\
 	ldbl_compat='s,g,g,' ;\
 	grep "^[	 ]*#[	 ]*define[	 ][	 ]*_GLIBCXX_LONG_DOUBLE_COMPAT[	 ][	 ]*1[	 ]*$$" \
 	${CONFIG_HEADER} > /dev/null 2>&1 \
@@ -1688,6 +1695,7 @@
 	-e "s,define _GLIBCXX_USE_DUAL_ABI, define _GLIBCXX_USE_DUAL_ABI $$dualabi," \
 	-e "s,define _GLIBCXX_USE_CXX11_ABI, define _GLIBCXX_USE_CXX11_ABI $$cxx11abi," \
 	-e "s,define _GLIBCXX_USE_ALLOCATOR_NEW, define _GLIBCXX_USE_ALLOCATOR_NEW $$allocatornew," \
+	-e "s,define _GLIBCXX_USE_FLOAT128,$$float128," \
 	-e "$$ldbl_compat" \
 	    < ${glibcxx_srcdir}/include/bits/c++config > $@ ;\
 	sed -e 's/HAVE_/_GLIBCXX_HAVE_/g' \
@@ -1897,6 +1905,9 @@
 $(experimental_headers): ; @:
 $(experimental_bits_headers): ; @:
 
+# See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81797
+@INCLUDE_DIR_NOTPARALLEL_TRUE@.NOTPARALLEL:
+
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -ruN gcc-7.3.0/libstdc++-v3/include/std/any gcc-7.3.0-msp430/libstdc++-v3/include/std/any
--- gcc-7.3.0/libstdc++-v3/include/std/any	2017-10-20 08:14:29.733840000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/include/std/any	2019-06-25 02:27:32.293851348 -0700
@@ -70,7 +70,7 @@
 
   /**
    *  @brief A type-safe container of any type.
-   * 
+   *
    *  An @c any object's state is either empty or it stores a contained object
    *  of CopyConstructible type.
    */
@@ -114,8 +114,8 @@
       void __do_emplace(_Args&&... __args)
       {
 	reset();
-	_M_manager = &_Mgr::_S_manage;
         _Mgr::_S_create(_M_storage, std::forward<_Args>(__args)...);
+	_M_manager = &_Mgr::_S_manage;
       }
 
     /// Emplace with an object created from @p __il and @p __args as
@@ -125,8 +125,8 @@
       void __do_emplace(initializer_list<_Up> __il, _Args&&... __args)
       {
 	reset();
-	_M_manager = &_Mgr::_S_manage;
         _Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
+	_M_manager = &_Mgr::_S_manage;
       }
 
   public:
@@ -272,8 +272,7 @@
 				   _Decay<_ValueType>, _Args&&...>::type
       emplace(_Args&&... __args)
       {
-	__do_emplace<_Decay<_ValueType>>
-	  (std::forward<_Args>(__args)...);
+	__do_emplace<_Decay<_ValueType>>(std::forward<_Args>(__args)...);
 	any::_Arg __arg;
 	this->_M_manager(any::_Op_access, this, &__arg);
 	return *static_cast<_Decay<_ValueType>*>(__arg._M_obj);
@@ -288,8 +287,8 @@
 				   _Args&&...>::type
       emplace(initializer_list<_Up> __il, _Args&&... __args)
       {
-	__do_emplace<_Decay<_ValueType>, _Up>
-	  (__il, std::forward<_Args>(__args)...);
+	__do_emplace<_Decay<_ValueType>, _Up>(__il,
+					      std::forward<_Args>(__args)...);
 	any::_Arg __arg;
 	this->_M_manager(any::_Op_access, this, &__arg);
 	return *static_cast<_Decay<_ValueType>*>(__arg._M_obj);
@@ -624,7 +623,7 @@
     }
 
   /// @}
-  
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
 
diff -ruN gcc-7.3.0/libstdc++-v3/include/std/chrono gcc-7.3.0-msp430/libstdc++-v3/include/std/chrono
--- gcc-7.3.0/libstdc++-v3/include/std/chrono	2017-10-20 14:06:20.698488000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/include/std/chrono	2019-06-25 02:27:32.293851348 -0700
@@ -318,8 +318,10 @@
 	// constexpr copy constructor will be ill-formed.
 	duration(const duration&) = default;
 
+	// _GLIBCXX_RESOLVE_LIB_DEFECTS
+	// 3050. Conversion specification problem in chrono::duration
 	template<typename _Rep2, typename = typename
-	       enable_if<is_convertible<_Rep2, rep>::value
+	       enable_if<is_convertible<const _Rep2&, rep>::value
 			 && (treat_as_floating_point<rep>::value
 			     || !treat_as_floating_point<_Rep2>::value)>::type>
 	  constexpr explicit duration(const _Rep2& __rep)
@@ -463,8 +465,12 @@
 	return __cd(__cd(__lhs).count() - __cd(__rhs).count());
       }
 
+    // SFINAE helper to obtain common_type<_Rep1, _Rep2> only if _Rep2
+    // is implicitly convertible to it.
+    // _GLIBCXX_RESOLVE_LIB_DEFECTS
+    // 3050. Conversion specification problem in chrono::duration constructor
     template<typename _Rep1, typename _Rep2, bool =
-	     is_convertible<_Rep2,
+	     is_convertible<const _Rep2&,
 			    typename common_type<_Rep1, _Rep2>::type>::value>
       struct __common_rep_type { };
 
diff -ruN gcc-7.3.0/libstdc++-v3/include/std/condition_variable gcc-7.3.0-msp430/libstdc++-v3/include/std/condition_variable
--- gcc-7.3.0/libstdc++-v3/include/std/condition_variable	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/std/condition_variable	2019-06-25 02:27:32.293851348 -0700
@@ -135,14 +135,26 @@
       cv_status
       wait_for(unique_lock<mutex>& __lock,
 	       const chrono::duration<_Rep, _Period>& __rtime)
-      { return wait_until(__lock, __clock_t::now() + __rtime); }
+      {
+	using __dur = typename __clock_t::duration;
+	auto __reltime = chrono::duration_cast<__dur>(__rtime);
+	if (__reltime < __rtime)
+	  ++__reltime;
+	return wait_until(__lock, __clock_t::now() + __reltime);
+      }
 
     template<typename _Rep, typename _Period, typename _Predicate>
       bool
       wait_for(unique_lock<mutex>& __lock,
 	       const chrono::duration<_Rep, _Period>& __rtime,
 	       _Predicate __p)
-      { return wait_until(__lock, __clock_t::now() + __rtime, std::move(__p)); }
+      {
+	using __dur = typename __clock_t::duration;
+	auto __reltime = chrono::duration_cast<__dur>(__rtime);
+	if (__reltime < __rtime)
+	  ++__reltime;
+	return wait_until(__lock, __clock_t::now() + __reltime, std::move(__p));
+      }
 
     native_handle_type
     native_handle()
diff -ruN gcc-7.3.0/libstdc++-v3/include/std/thread gcc-7.3.0-msp430/libstdc++-v3/include/std/thread
--- gcc-7.3.0/libstdc++-v3/include/std/thread	2017-01-03 05:31:26.283951000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/std/thread	2019-06-25 02:27:32.293851348 -0700
@@ -243,21 +243,18 @@
 	{ return _M_invoke(_Indices()); }
       };
 
-    // Alias for _Invoker<tuple<DECAY_COPY(_Tp)...>>
     template<typename... _Tp>
-      using __invoker_type
-	= _Invoker<decltype(std::make_tuple(std::declval<_Tp>()...))>;
+      using __decayed_tuple = tuple<typename std::decay<_Tp>::type...>;
 
   public:
-    // Returns a call wrapper that does
-    // INVOKE(DECAY_COPY(__callable), DECAY_COPY(__args)).
+    // Returns a call wrapper that stores
+    // tuple{DECAY_COPY(__callable), DECAY_COPY(__args)...}.
     template<typename _Callable, typename... _Args>
-      static __invoker_type<_Callable, _Args...>
+      static _Invoker<__decayed_tuple<_Callable, _Args...>>
       __make_invoker(_Callable&& __callable, _Args&&... __args)
       {
-	return { {
-	    std::make_tuple(std::forward<_Callable>(__callable),
-			    std::forward<_Args>(__args)...)
+	return { __decayed_tuple<_Callable, _Args...>{
+	    std::forward<_Callable>(__callable), std::forward<_Args>(__args)...
 	} };
       }
   };
diff -ruN gcc-7.3.0/libstdc++-v3/include/std/type_traits gcc-7.3.0-msp430/libstdc++-v3/include/std/type_traits
--- gcc-7.3.0/libstdc++-v3/include/std/type_traits	2017-12-12 10:07:24.978714000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/std/type_traits	2019-06-25 02:27:32.297851318 -0700
@@ -3069,6 +3069,10 @@
       remove_cv_t<remove_all_extents_t<_Tp>>
       )>
     { };
+
+  template<typename _Tp>
+    inline constexpr bool has_unique_object_representations_v
+      = has_unique_object_representations<_Tp>::value;
 #endif
 #undef _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP
 
diff -ruN gcc-7.3.0/libstdc++-v3/include/std/utility gcc-7.3.0-msp430/libstdc++-v3/include/std/utility
--- gcc-7.3.0/libstdc++-v3/include/std/utility	2017-12-01 09:12:18.664065000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/std/utility	2019-06-25 02:27:32.297851318 -0700
@@ -75,10 +75,6 @@
 #include <bits/move.h>
 #include <initializer_list>
 
-#if __cplusplus > 201402L
-#include <exception>
-#endif
-
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
diff -ruN gcc-7.3.0/libstdc++-v3/include/std/variant gcc-7.3.0-msp430/libstdc++-v3/include/std/variant
--- gcc-7.3.0/libstdc++-v3/include/std/variant	2017-10-20 08:14:29.733840000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/include/std/variant	2019-06-25 02:27:32.297851318 -0700
@@ -229,13 +229,17 @@
 
   template<size_t _Np, typename _Union>
     constexpr decltype(auto) __get(in_place_index_t<_Np>, _Union&& __u)
-    { return __get(in_place_index<_Np-1>, std::forward<_Union>(__u)._M_rest); }
+    {
+      return __variant::__get(in_place_index<_Np-1>,
+			      std::forward<_Union>(__u)._M_rest);
+    }
 
   // Returns the typed storage for __v.
   template<size_t _Np, typename _Variant>
     constexpr decltype(auto) __get(_Variant&& __v)
     {
-      return __get(std::in_place_index<_Np>, std::forward<_Variant>(__v)._M_u);
+      return __variant::__get(std::in_place_index<_Np>,
+			      std::forward<_Variant>(__v)._M_u);
     }
 
   // Various functions as "vtable" entries, where those vtables are used by
@@ -251,7 +255,7 @@
   template<typename _Variant, size_t _Np>
     void
     __erased_dtor(_Variant&& __v)
-    { std::_Destroy(std::__addressof(__get<_Np>(__v))); }
+    { std::_Destroy(std::__addressof(__variant::__get<_Np>(__v))); }
 
   template<typename _Lhs, typename _Rhs>
     void
@@ -274,8 +278,8 @@
     constexpr bool \
     __erased_##__NAME(const _Variant& __lhs, const _Variant& __rhs) \
     { \
-      return __get<_Np>(std::forward<_Variant>(__lhs)) \
-	  __OP __get<_Np>(std::forward<_Variant>(__rhs)); \
+      return __variant::__get<_Np>(std::forward<_Variant>(__lhs)) \
+	  __OP __variant::__get<_Np>(std::forward<_Variant>(__rhs)); \
     }
 
   _VARIANT_RELATION_FUNCTION_TEMPLATE(<, less)
@@ -324,10 +328,9 @@
 
   template <typename... _Types>
   using __select_index =
-    typename __select_int::_Select_int_base<sizeof...(_Types)+1,
+    typename __select_int::_Select_int_base<sizeof...(_Types) + 1,
 					    unsigned char,
-					    unsigned short>
-    ::type::value_type;
+					    unsigned short>::type::value_type;
 
   template<typename... _Types>
     struct _Variant_storage<false, _Types...>
@@ -681,9 +684,8 @@
       decltype(auto)
       static constexpr __visit_invoke(_Visitor&& __visitor, _Variants... __vars)
       {
-	return __invoke(std::forward<_Visitor>(__visitor),
-			std::get<__indices>(
-			    std::forward<_Variants>(__vars))...);
+	return std::__invoke(std::forward<_Visitor>(__visitor),
+	    std::get<__indices>(std::forward<_Variants>(__vars))...);
       }
 
       static constexpr auto
@@ -741,7 +743,7 @@
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
+      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
     }
 
   template<typename _Tp, typename... _Types>
@@ -750,7 +752,7 @@
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
+      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
 	std::move(__v));
     }
 
@@ -760,7 +762,7 @@
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
+      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
     }
 
   template<typename _Tp, typename... _Types>
@@ -769,7 +771,7 @@
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
+      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
 	std::move(__v));
     }
 
@@ -808,7 +810,8 @@
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(__ptr);
+      return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
+	  __ptr);
     }
 
   template<typename _Tp, typename... _Types>
@@ -819,7 +822,8 @@
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(__ptr);
+      return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
+	  __ptr);
     }
 
   struct monostate { };
@@ -1157,6 +1161,12 @@
 
 #undef _VARIANT_RELATION_FUNCTION_TEMPLATE
 
+#ifdef __clang__
+    public:
+      using _Base::_M_u; // See https://bugs.llvm.org/show_bug.cgi?id=31852
+    private:
+#endif
+
       template<size_t _Np, typename _Vp>
 	friend constexpr decltype(auto) __detail::__variant::
 #if _GLIBCXX_INLINE_VERSION
@@ -1240,7 +1250,7 @@
 
       using _Result_type =
 	decltype(std::forward<_Visitor>(__visitor)(
-	    get<0>(std::forward<_Variants>(__variants))...));
+	    std::get<0>(std::forward<_Variants>(__variants))...));
 
       constexpr auto& __vtable = __detail::__variant::__gen_vtable<
 	_Result_type, _Visitor&&, _Variants&&...>::_S_vtable;
diff -ruN gcc-7.3.0/libstdc++-v3/include/tr1/ell_integral.tcc gcc-7.3.0-msp430/libstdc++-v3/include/tr1/ell_integral.tcc
--- gcc-7.3.0/libstdc++-v3/include/tr1/ell_integral.tcc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/tr1/ell_integral.tcc	2019-06-25 02:27:32.297851318 -0700
@@ -685,8 +685,8 @@
           const _Tp __kk = __k * __k;
 
           return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
-               - __nu
-               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) + __nu)
+               + __nu
+               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu)
                / _Tp(3);
         }
     }
@@ -735,9 +735,9 @@
 
           const _Tp __Pi = __s
                          * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
-                         - __nu * __sss
+                         + __nu * __sss
                          * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
-                                       _Tp(1) + __nu * __ss) / _Tp(3);
+                                       _Tp(1) - __nu * __ss) / _Tp(3);
 
           if (__n == 0)
             return __Pi;
diff -ruN gcc-7.3.0/libstdc++-v3/include/tr1/exp_integral.tcc gcc-7.3.0-msp430/libstdc++-v3/include/tr1/exp_integral.tcc
--- gcc-7.3.0/libstdc++-v3/include/tr1/exp_integral.tcc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/include/tr1/exp_integral.tcc	2019-06-25 02:27:32.297851318 -0700
@@ -86,7 +86,7 @@
       _Tp __term = _Tp(1);
       _Tp __esum = _Tp(0);
       _Tp __osum = _Tp(0);
-      const unsigned int __max_iter = 100;
+      const unsigned int __max_iter = 1000;
       for (unsigned int __i = 1; __i < __max_iter; ++__i)
         {
           __term *= - __x / __i;
@@ -156,7 +156,7 @@
     _Tp
     __expint_En_series(unsigned int __n, _Tp __x)
     {
-      const unsigned int __max_iter = 100;
+      const unsigned int __max_iter = 1000;
       const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
       const int __nm1 = __n - 1;
       _Tp __ans = (__nm1 != 0
@@ -202,7 +202,7 @@
     _Tp
     __expint_En_cont_frac(unsigned int __n, _Tp __x)
     {
-      const unsigned int __max_iter = 100;
+      const unsigned int __max_iter = 1000;
       const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
       const _Tp __fp_min = std::numeric_limits<_Tp>::min();
       const int __nm1 = __n - 1;
diff -ruN gcc-7.3.0/libstdc++-v3/libsupc++/cxxabi_init_exception.h gcc-7.3.0-msp430/libstdc++-v3/libsupc++/cxxabi_init_exception.h
--- gcc-7.3.0/libstdc++-v3/libsupc++/cxxabi_init_exception.h	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/libsupc++/cxxabi_init_exception.h	2019-06-25 02:27:32.297851318 -0700
@@ -62,6 +62,9 @@
       void*
       __cxa_allocate_exception(size_t) _GLIBCXX_NOTHROW;
 
+      void
+      __cxa_free_exception(void*) _GLIBCXX_NOTHROW;
+
       // Initialize exception (this is a GNU extension)
       __cxa_refcounted_exception*
       __cxa_init_primary_exception(void *object, std::type_info *tinfo,
diff -ruN gcc-7.3.0/libstdc++-v3/libsupc++/exception_ptr.h gcc-7.3.0-msp430/libstdc++-v3/libsupc++/exception_ptr.h
--- gcc-7.3.0/libstdc++-v3/libsupc++/exception_ptr.h	2017-03-01 19:43:49.462021000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/libsupc++/exception_ptr.h	2019-06-25 02:27:32.297851318 -0700
@@ -178,25 +178,31 @@
     exception_ptr 
     make_exception_ptr(_Ex __ex) _GLIBCXX_USE_NOEXCEPT
     {
-#if __cpp_exceptions
+#if __cpp_exceptions && __cpp_rtti && !_GLIBCXX_HAVE_CDTOR_CALLABI
+      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
+      (void) __cxxabiv1::__cxa_init_primary_exception(
+	  __e, const_cast<std::type_info*>(&typeid(__ex)),
+	  __exception_ptr::__dest_thunk<_Ex>);
       try
 	{
-#if __cpp_rtti && !_GLIBCXX_HAVE_CDTOR_CALLABI
-          void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
-          (void)__cxxabiv1::__cxa_init_primary_exception(
-	      __e, const_cast<std::type_info*>(&typeid(__ex)),
-	      __exception_ptr::__dest_thunk<_Ex>);
           ::new (__e) _Ex(__ex);
           return exception_ptr(__e);
-#else
+	}
+      catch(...)
+	{
+	  __cxxabiv1::__cxa_free_exception(__e);
+	  return current_exception();
+	}
+#elif __cpp_exceptions
+      try
+	{
           throw __ex;
-#endif
 	}
       catch(...)
 	{
 	  return current_exception();
 	}
-#else
+#else // no RTTI and no exceptions
       return exception_ptr();
 #endif
     }
diff -ruN gcc-7.3.0/libstdc++-v3/libsupc++/new_opa.cc gcc-7.3.0-msp430/libstdc++-v3/libsupc++/new_opa.cc
--- gcc-7.3.0/libstdc++-v3/libsupc++/new_opa.cc	2017-01-26 06:30:45.014860000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/libsupc++/new_opa.cc	2019-06-25 02:27:32.297851318 -0700
@@ -25,20 +25,36 @@
 
 #include <bits/c++config.h>
 #include <stdlib.h>
+#include <stdint.h>
 #include <bits/exception_defines.h>
 #include "new"
 
+#if !_GLIBCXX_HAVE_ALIGNED_ALLOC && !_GLIBCXX_HAVE__ALIGNED_MALLOC \
+  && !_GLIBCXX_HAVE_POSIX_MEMALIGN && _GLIBCXX_HAVE_MEMALIGN
+# if _GLIBCXX_HOSTED && __has_include(<malloc.h>)
+// Some C libraries declare memalign in <malloc.h>
+#  include <malloc.h>
+# else
+extern "C" void *memalign(std::size_t boundary, std::size_t size);
+# endif
+#endif
+
 using std::new_handler;
 using std::bad_alloc;
 
-#if !_GLIBCXX_HAVE_ALIGNED_ALLOC
-#if _GLIBCXX_HAVE__ALIGNED_MALLOC
-#define aligned_alloc(al,sz) _aligned_malloc(sz,al)
+namespace __gnu_cxx {
+#if _GLIBCXX_HAVE_ALIGNED_ALLOC
+using ::aligned_alloc;
+#elif _GLIBCXX_HAVE__ALIGNED_MALLOC
+static inline void*
+aligned_alloc (std::size_t al, std::size_t sz)
+{ return _aligned_malloc(sz, al); }
 #elif _GLIBCXX_HAVE_POSIX_MEMALIGN
 static inline void*
 aligned_alloc (std::size_t al, std::size_t sz)
 {
   void *ptr;
+  // posix_memalign has additional requirement, not present on aligned_alloc:
   // The value of alignment shall be a power of two multiple of sizeof(void *).
   if (al < sizeof(void*))
     al = sizeof(void*);
@@ -48,25 +64,23 @@
   return nullptr;
 }
 #elif _GLIBCXX_HAVE_MEMALIGN
-#if _GLIBCXX_HOSTED
-#include <malloc.h>
-#else
-extern "C" void *memalign(std::size_t boundary, std::size_t size);
+static inline void*
+aligned_alloc (std::size_t al, std::size_t sz)
+{
+#ifdef __sun
+  // Solaris 10 memalign requires that alignment is greater than or equal to
+  // the size of a word.
+  if (al < sizeof(int))
+    al = sizeof(int);
 #endif
-#define aligned_alloc memalign
-#else
-#include <stdint.h>
+  return memalign (al, sz);
+}
+#else // !HAVE__ALIGNED_MALLOC && !HAVE_POSIX_MEMALIGN && !HAVE_MEMALIGN
 // The C library doesn't provide any aligned allocation functions, define one.
 // This is a modified version of code from gcc/config/i386/gmm_malloc.h
 static inline void*
 aligned_alloc (std::size_t al, std::size_t sz)
 {
-  // Alignment must be a power of two.
-  if (al & (al - 1))
-    return nullptr;
-  else if (!sz)
-    return nullptr;
-
   // We need extra bytes to store the original value returned by malloc.
   if (al < sizeof(void*))
     al = sizeof(void*);
@@ -82,7 +96,7 @@
   return aligned_ptr;
 }
 #endif
-#endif
+} // namespace __gnu_cxx
 
 _GLIBCXX_WEAK_DEFINITION void *
 operator new (std::size_t sz, std::align_val_t al)
@@ -90,16 +104,28 @@
   void *p;
   std::size_t align = (std::size_t)al;
 
+  /* Alignment must be a power of two.  */
+  /* XXX This should be checked by the compiler (PR 86878).  */
+  if (__builtin_expect (align & (align - 1), false))
+    _GLIBCXX_THROW_OR_ABORT(bad_alloc());
+
   /* malloc (0) is unpredictable; avoid it.  */
-  if (sz == 0)
+  if (__builtin_expect (sz == 0, false))
     sz = 1;
 
 #if _GLIBCXX_HAVE_ALIGNED_ALLOC
+# ifdef _AIX
+  /* AIX 7.2.0.0 aligned_alloc incorrectly has posix_memalign's requirement
+   * that alignment is a multiple of sizeof(void*).  */
+  if (align < sizeof(void*))
+    align = sizeof(void*);
+# endif
   /* C11: the value of size shall be an integral multiple of alignment.  */
   if (std::size_t rem = sz & (align - 1))
     sz += align - rem;
 #endif
 
+  using __gnu_cxx::aligned_alloc;
   while (__builtin_expect ((p = aligned_alloc (align, sz)) == 0, false))
     {
       new_handler handler = std::get_new_handler ();
diff -ruN gcc-7.3.0/libstdc++-v3/src/c++11/codecvt.cc gcc-7.3.0-msp430/libstdc++-v3/src/c++11/codecvt.cc
--- gcc-7.3.0/libstdc++-v3/src/c++11/codecvt.cc	2017-03-17 12:28:05.896614000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/src/c++11/codecvt.cc	2019-06-25 02:27:32.297851318 -0700
@@ -1086,7 +1086,12 @@
     reinterpret_cast<char16_t*>(__to),
     reinterpret_cast<char16_t*>(__to_end)
   };
-  auto res = ucs2_in(from, to, _M_maxcode, _M_mode);
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+  codecvt_mode mode = {};
+#else
+  codecvt_mode mode = little_endian;
+#endif
+  auto res = ucs2_in(from, to, _M_maxcode, mode);
 #elif __SIZEOF_WCHAR_T__ == 4
   range<char32_t> to{
     reinterpret_cast<char32_t*>(__to),
diff -ruN gcc-7.3.0/libstdc++-v3/src/c++11/cxx11-ios_failure.cc gcc-7.3.0-msp430/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
--- gcc-7.3.0/libstdc++-v3/src/c++11/cxx11-ios_failure.cc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/src/c++11/cxx11-ios_failure.cc	2019-06-25 02:27:32.297851318 -0700
@@ -28,6 +28,15 @@
 
 #define _GLIBCXX_USE_CXX11_ABI 1
 #include <ios>
+#include <bits/functexcept.h>
+#include <cxxabi.h>
+
+#ifdef _GLIBCXX_USE_NLS
+# include <libintl.h>
+# define _(msgid)   gettext (msgid)
+#else
+# define _(msgid)   (msgid)
+#endif
 
 #if ! _GLIBCXX_USE_DUAL_ABI
 # error This file should not be compiled for this configuration.
@@ -91,5 +100,66 @@
   ios_base::failure::what() const throw()
   { return runtime_error::what(); }
 
+#if __cpp_rtti
+  // These functions are defined in src/c++98/ios_failure.cc
+  extern void __construct_ios_failure(void*, const char*);
+  extern void __destroy_ios_failure(void*);
+  extern bool __is_ios_failure_handler(const __cxxabiv1::__class_type_info*);
+
+  // The type thrown to report errors during stream buffer operations.
+  // In addition to the ios::failure[abi:cxx11] base class it also has a
+  // member of the gcc4-compatible ios::failure type (in an opaque buffer).
+  struct __ios_failure : std::ios::failure
+  {
+    __ios_failure(const char* s) : failure(s)
+    { __construct_ios_failure(buf, runtime_error::what()); }
+
+    ~__ios_failure()
+    { __destroy_ios_failure(buf); }
+
+    // Use std::runtime_error as a proxy for the gcc4-compatible ios::failure
+    // (which can't be declared here because _GLIBCXX_USE_CXX11_ABI == 1).
+    // There are assertions in src/c++98/ios_failure.cc to ensure the size
+    // and alignment assumptions are valid.
+    alignas(runtime_error) unsigned char buf[sizeof(runtime_error)];
+  };
+
+  // Custom type info for __ios_failure.
+  class __iosfail_type_info : __cxxabiv1::__si_class_type_info
+  {
+    ~__iosfail_type_info();
+
+    bool
+    __do_upcast (const __class_type_info *dst_type,
+		 void **obj_ptr) const override;
+  };
+
+  __iosfail_type_info::~__iosfail_type_info() = default;
+
+  // This function gets called to see if an exception of type
+  // __ios_failure can be upcast to the type in a catch handler.
+  bool
+  __iosfail_type_info::__do_upcast(const __class_type_info *dst_type,
+				   void **obj_ptr) const
+  {
+    // If the handler is for the gcc4-compatible ios::failure type then
+    // catch the object stored in __ios_failure::buf instead of
+    // the __ios_failure exception object itself.
+    if (__is_ios_failure_handler(dst_type))
+      {
+	*obj_ptr = static_cast<__ios_failure*>(*obj_ptr)->buf;
+	return true;
+      }
+    // Otherwise proceed as normal to see if the handler matches.
+    return __class_type_info::__do_upcast(dst_type, obj_ptr);
+  }
+#else // ! __cpp_rtti
+  using __ios_failure = ios::failure;
+#endif
+
+  void
+  __throw_ios_failure(const char* __s __attribute__((unused)))
+  { _GLIBCXX_THROW_OR_ABORT(__ios_failure(_(__s))); }
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff -ruN gcc-7.3.0/libstdc++-v3/src/c++11/ios.cc gcc-7.3.0-msp430/libstdc++-v3/src/c++11/ios.cc
--- gcc-7.3.0/libstdc++-v3/src/c++11/ios.cc	2017-02-03 10:59:05.447038000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/src/c++11/ios.cc	2019-06-25 02:27:32.297851318 -0700
@@ -26,29 +26,13 @@
 // ISO C++ 14882: 27.4  Iostreams base classes
 //
 
-// Determines the version of ios_base::failure thrown by __throw_ios_failure.
-// If !_GLIBCXX_USE_DUAL_ABI this will get undefined automatically.
-#define _GLIBCXX_USE_CXX11_ABI 1
-
 #include <ios>
 #include <limits>
-#include <bits/functexcept.h>
-
-#ifdef _GLIBCXX_USE_NLS
-# include <libintl.h>
-# define _(msgid)   gettext (msgid)
-#else
-# define _(msgid)   (msgid)
-#endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-  void
-  __throw_ios_failure(const char* __s __attribute__((unused)))
-  { _GLIBCXX_THROW_OR_ABORT(ios_base::failure(_(__s))); }
-
   // Definitions for static const members of ios_base.
   const ios_base::fmtflags ios_base::boolalpha;
   const ios_base::fmtflags ios_base::dec;
diff -ruN gcc-7.3.0/libstdc++-v3/src/c++11/Makefile.am gcc-7.3.0-msp430/libstdc++-v3/src/c++11/Makefile.am
--- gcc-7.3.0/libstdc++-v3/src/c++11/Makefile.am	2017-02-03 10:59:05.447038000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/src/c++11/Makefile.am	2019-06-25 02:27:32.297851318 -0700
@@ -126,6 +126,26 @@
 hashtable_c++0x.o: hashtable_c++0x.cc
 	$(CXXCOMPILE) -fimplicit-templates -c $<
 
+if ENABLE_DUAL_ABI
+# Rewrite the type info for __ios_failure.
+rewrite_ios_failure_typeinfo = sed -e '/^_*_ZTISt13__ios_failure:/,/_ZTVN10__cxxabiv120__si_class_type_infoE/s/_ZTVN10__cxxabiv120__si_class_type_infoE/_ZTVSt19__iosfail_type_info/'
+
+cxx11-ios_failure-lt.s: cxx11-ios_failure.cc
+	$(LTCXXCOMPILE) -S $< -o tmp-cxx11-ios_failure-lt.s
+	-test -f tmp-cxx11-ios_failure-lt.o && mv -f tmp-cxx11-ios_failure-lt.o tmp-cxx11-ios_failure-lt.s
+	$(rewrite_ios_failure_typeinfo) tmp-$@ > $@
+	-rm -f tmp-$@
+cxx11-ios_failure.s: cxx11-ios_failure.cc
+	$(CXXCOMPILE) -S $< -o tmp-$@
+	$(rewrite_ios_failure_typeinfo) tmp-$@ > $@
+	-rm -f tmp-$@
+
+cxx11-ios_failure.lo: cxx11-ios_failure-lt.s
+	$(LTCXXCOMPILE) -g0 -c $< -o $@
+cxx11-ios_failure.o: cxx11-ios_failure.s
+	$(CXXCOMPILE) -g0 -c $<
+endif
+
 # AM_CXXFLAGS needs to be in each subdirectory so that it can be
 # modified in a per-library or per-sub-library way.  Need to manually
 # set this option because CONFIG_CXXFLAGS has to be after
diff -ruN gcc-7.3.0/libstdc++-v3/src/c++11/Makefile.in gcc-7.3.0-msp430/libstdc++-v3/src/c++11/Makefile.in
--- gcc-7.3.0/libstdc++-v3/src/c++11/Makefile.in	2017-02-03 10:59:05.447038000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/src/c++11/Makefile.in	2019-06-25 02:27:32.297851318 -0700
@@ -433,6 +433,9 @@
 
 libc__11convenience_la_SOURCES = $(sources)  $(inst_sources)
 
+# Rewrite the type info for __ios_failure.
+@ENABLE_DUAL_ABI_TRUE@rewrite_ios_failure_typeinfo = sed -e '/^_*_ZTISt13__ios_failure:/,/_ZTVN10__cxxabiv120__si_class_type_infoE/s/_ZTVN10__cxxabiv120__si_class_type_infoE/_ZTVSt19__iosfail_type_info/'
+
 # AM_CXXFLAGS needs to be in each subdirectory so that it can be
 # modified in a per-library or per-sub-library way.  Need to manually
 # set this option because CONFIG_CXXFLAGS has to be after
@@ -748,6 +751,21 @@
 hashtable_c++0x.o: hashtable_c++0x.cc
 	$(CXXCOMPILE) -fimplicit-templates -c $<
 
+@ENABLE_DUAL_ABI_TRUE@cxx11-ios_failure-lt.s: cxx11-ios_failure.cc
+@ENABLE_DUAL_ABI_TRUE@	$(LTCXXCOMPILE) -S $< -o tmp-cxx11-ios_failure-lt.s
+@ENABLE_DUAL_ABI_TRUE@	-test -f tmp-cxx11-ios_failure-lt.o && mv -f tmp-cxx11-ios_failure-lt.o tmp-cxx11-ios_failure-lt.s
+@ENABLE_DUAL_ABI_TRUE@	$(rewrite_ios_failure_typeinfo) tmp-$@ > $@
+@ENABLE_DUAL_ABI_TRUE@	-rm -f tmp-$@
+@ENABLE_DUAL_ABI_TRUE@cxx11-ios_failure.s: cxx11-ios_failure.cc
+@ENABLE_DUAL_ABI_TRUE@	$(CXXCOMPILE) -S $< -o tmp-$@
+@ENABLE_DUAL_ABI_TRUE@	$(rewrite_ios_failure_typeinfo) tmp-$@ > $@
+@ENABLE_DUAL_ABI_TRUE@	-rm -f tmp-$@
+
+@ENABLE_DUAL_ABI_TRUE@cxx11-ios_failure.lo: cxx11-ios_failure-lt.s
+@ENABLE_DUAL_ABI_TRUE@	$(LTCXXCOMPILE) -g0 -c $< -o $@
+@ENABLE_DUAL_ABI_TRUE@cxx11-ios_failure.o: cxx11-ios_failure.s
+@ENABLE_DUAL_ABI_TRUE@	$(CXXCOMPILE) -g0 -c $<
+
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -ruN gcc-7.3.0/libstdc++-v3/src/c++11/system_error.cc gcc-7.3.0-msp430/libstdc++-v3/src/c++11/system_error.cc
--- gcc-7.3.0/libstdc++-v3/src/c++11/system_error.cc	2017-02-03 10:59:05.447038000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/src/c++11/system_error.cc	2019-06-25 02:27:32.297851318 -0700
@@ -29,6 +29,7 @@
 #include <system_error>
 #include <bits/functexcept.h>
 #include <limits>
+#include <errno.h>
 #undef __sso_string
 
 namespace
@@ -65,6 +66,261 @@
       // _GLIBCXX_HAVE_STRERROR_L, strerror_l(i, cloc)
       return string(strerror(i));
     }
+
+    virtual std::error_condition
+    default_error_condition(int ev) const noexcept
+    {
+      switch (ev)
+      {
+      // List of errno macros from [cerrno.syn].
+      // C11 only defines EDOM, EILSEQ and ERANGE, the rest are from POSIX.
+      // They expand to integer constant expressions with type int,
+      // and distinct positive values, suitable for use in #if directives.
+      // POSIX adds more macros (but they're not defined on all targets,
+      // see config/os/*/error_constants.h), and POSIX allows
+      // EAGAIN == EWOULDBLOCK and ENOTSUP == EOPNOTSUPP.
+
+#ifdef E2BIG
+      case E2BIG:
+#endif
+#ifdef EACCES
+      case EACCES:
+#endif
+#ifdef EADDRINUSE
+      case EADDRINUSE:
+#endif
+#ifdef EADDRNOTAVAIL
+      case EADDRNOTAVAIL:
+#endif
+#ifdef EAFNOSUPPORT
+      case EAFNOSUPPORT:
+#endif
+#ifdef EAGAIN
+      case EAGAIN:
+#endif
+#ifdef EALREADY
+      case EALREADY:
+#endif
+#ifdef EBADF
+      case EBADF:
+#endif
+#ifdef EBADMSG
+      case EBADMSG:
+#endif
+#ifdef EBUSY
+      case EBUSY:
+#endif
+#ifdef ECANCELED
+      case ECANCELED:
+#endif
+#ifdef ECHILD
+      case ECHILD:
+#endif
+#ifdef ECONNABORTED
+      case ECONNABORTED:
+#endif
+#ifdef ECONNREFUSED
+      case ECONNREFUSED:
+#endif
+#ifdef ECONNRESET
+      case ECONNRESET:
+#endif
+#ifdef EDEADLK
+      case EDEADLK:
+#endif
+#ifdef EDESTADDRREQ
+      case EDESTADDRREQ:
+#endif
+      case EDOM:
+#ifdef EEXIST
+      case EEXIST:
+#endif
+#ifdef EFAULT
+      case EFAULT:
+#endif
+#ifdef EFBIG
+      case EFBIG:
+#endif
+#ifdef EHOSTUNREACH
+      case EHOSTUNREACH:
+#endif
+#ifdef EIDRM
+      case EIDRM:
+#endif
+      case EILSEQ:
+#ifdef EINPROGRESS
+      case EINPROGRESS:
+#endif
+#ifdef EINTR
+      case EINTR:
+#endif
+#ifdef EINVAL
+      case EINVAL:
+#endif
+#ifdef EIO
+      case EIO:
+#endif
+#ifdef EISCONN
+      case EISCONN:
+#endif
+#ifdef EISDIR
+      case EISDIR:
+#endif
+#ifdef ELOOP
+      case ELOOP:
+#endif
+#ifdef EMFILE
+      case EMFILE:
+#endif
+#ifdef EMLINK
+      case EMLINK:
+#endif
+#ifdef EMSGSIZE
+      case EMSGSIZE:
+#endif
+#ifdef ENAMETOOLONG
+      case ENAMETOOLONG:
+#endif
+#ifdef ENETDOWN
+      case ENETDOWN:
+#endif
+#ifdef ENETRESET
+      case ENETRESET:
+#endif
+#ifdef ENETUNREACH
+      case ENETUNREACH:
+#endif
+#ifdef ENFILE
+      case ENFILE:
+#endif
+#ifdef ENOBUFS
+      case ENOBUFS:
+#endif
+#ifdef ENODATA
+      case ENODATA:
+#endif
+#ifdef ENODEV
+      case ENODEV:
+#endif
+#ifdef ENOENT
+      case ENOENT:
+#endif
+#ifdef ENOEXEC
+      case ENOEXEC:
+#endif
+#ifdef ENOLCK
+      case ENOLCK:
+#endif
+#ifdef ENOLINK
+      case ENOLINK:
+#endif
+#ifdef ENOMEM
+      case ENOMEM:
+#endif
+#ifdef ENOMSG
+      case ENOMSG:
+#endif
+#ifdef ENOPROTOOPT
+      case ENOPROTOOPT:
+#endif
+#ifdef ENOSPC
+      case ENOSPC:
+#endif
+#ifdef ENOSR
+      case ENOSR:
+#endif
+#ifdef ENOSTR
+      case ENOSTR:
+#endif
+#ifdef ENOSYS
+      case ENOSYS:
+#endif
+#ifdef ENOTCONN
+      case ENOTCONN:
+#endif
+#ifdef ENOTDIR
+      case ENOTDIR:
+#endif
+#if defined ENOTEMPTY && (!defined EEXIST || ENOTEMPTY != EEXIST)
+      // AIX sometimes uses the same value for EEXIST and ENOTEMPTY
+      case ENOTEMPTY:
+#endif
+#ifdef ENOTRECOVERABLE
+      case ENOTRECOVERABLE:
+#endif
+#ifdef ENOTSOCK
+      case ENOTSOCK:
+#endif
+#ifdef ENOTSUP
+      case ENOTSUP:
+#endif
+#ifdef ENOTTY
+      case ENOTTY:
+#endif
+#ifdef ENXIO
+      case ENXIO:
+#endif
+#if defined EOPNOTSUPP && (!defined ENOTSUP || EOPNOTSUPP != ENOTSUP)
+      case EOPNOTSUPP:
+#endif
+#ifdef EOVERFLOW
+      case EOVERFLOW:
+#endif
+#ifdef EOWNERDEAD
+      case EOWNERDEAD:
+#endif
+#ifdef EPERM
+      case EPERM:
+#endif
+#ifdef EPIPE
+      case EPIPE:
+#endif
+#ifdef EPROTO
+      case EPROTO:
+#endif
+#ifdef EPROTONOSUPPORT
+      case EPROTONOSUPPORT:
+#endif
+#ifdef EPROTOTYPE
+      case EPROTOTYPE:
+#endif
+      case ERANGE:
+#ifdef EROFS
+      case EROFS:
+#endif
+#ifdef ESPIPE
+      case ESPIPE:
+#endif
+#ifdef ESRCH
+      case ESRCH:
+#endif
+#ifdef ETIME
+      case ETIME:
+#endif
+#ifdef ETIMEDOUT
+      case ETIMEDOUT:
+#endif
+#ifdef ETXTBSY
+      case ETXTBSY:
+#endif
+#if defined EWOULDBLOCK && (!defined EAGAIN || EWOULDBLOCK != EAGAIN)
+      case EWOULDBLOCK:
+#endif
+#ifdef EXDEV
+      case EXDEV:
+#endif
+        return std::error_condition(ev, std::generic_category());
+
+      /* Additional system-dependent mappings from non-standard error codes
+       * to one of the POSIX values above would go here, e.g.
+      case EBLAH:
+	return std::error_condition(EINVAL, std::generic_category());
+       */
+
+      default:
+	return std::error_condition(ev, std::system_category());
+      }
+    }
   };
 
   const generic_error_category generic_category_instance{};
diff -ruN gcc-7.3.0/libstdc++-v3/src/c++98/ios_failure.cc gcc-7.3.0-msp430/libstdc++-v3/src/c++98/ios_failure.cc
--- gcc-7.3.0/libstdc++-v3/src/c++98/ios_failure.cc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/src/c++98/ios_failure.cc	2019-06-25 02:27:32.297851318 -0700
@@ -29,6 +29,18 @@
 #define _GLIBCXX_USE_CXX11_ABI 0
 #include <ios>
 
+#if _GLIBCXX_USE_DUAL_ABI && __cpp_rtti
+#include <cxxabi.h>
+#include <typeinfo>
+#endif
+
+#ifdef _GLIBCXX_USE_NLS
+# include <libintl.h>
+# define _(msgid)   gettext (msgid)
+#else
+# define _(msgid)   (msgid)
+#endif
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -43,5 +55,40 @@
   ios_base::failure::what() const throw()
   { return _M_msg.c_str(); }
 
+#if _GLIBCXX_USE_DUAL_ABI
+  // When the dual ABI is enabled __throw_ios_failure() is defined in
+  // src/c++11/cxx11-ios_failure.cc
+#if __cpp_rtti
+  // If RTTI is enabled the exception type thrown will use these functions to
+  // construct/destroy a gcc4-compatible ios::failure object in a buffer,
+  // and to catch that object via a handler of the gcc4-compatible type.
+  void
+  __construct_ios_failure(void* buf, const char* msg)
+  { ::new(buf) ios_base::failure(msg); }
+
+  void
+  __destroy_ios_failure(void* buf)
+  { static_cast<ios_base::failure*>(buf)->~failure(); }
+
+  bool
+  __is_ios_failure_handler(const __cxxabiv1::__class_type_info* type)
+  { return *type == typeid(ios::failure); }
+
+  namespace {
+  // C++98-style static assertions to ensure ios::failure fits in a buffer
+  // with the same size and alignment as runtime_error:
+  typedef char S[1 / (sizeof(ios::failure) <= sizeof(runtime_error))];
+  typedef char A[1 / (__alignof(ios::failure) <= __alignof(runtime_error))];
+  }
+#endif // __cpp_rtti
+
+#else // ! _GLIBCXX_USE_DUAL_ABI
+
+  void
+  __throw_ios_failure(const char* __s __attribute__((unused)))
+  { _GLIBCXX_THROW_OR_ABORT(ios::failure(_(__s))); }
+
+#endif
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
diff -ruN gcc-7.3.0/libstdc++-v3/src/filesystem/ops.cc gcc-7.3.0-msp430/libstdc++-v3/src/filesystem/ops.cc
--- gcc-7.3.0/libstdc++-v3/src/filesystem/ops.cc	2018-01-12 17:53:47.708973000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/src/filesystem/ops.cc	2019-06-25 02:27:32.297851318 -0700
@@ -720,10 +720,8 @@
     if (::mkdir(p.c_str(), mode))
       {
 	const int err = errno;
-	if (err != EEXIST || !is_directory(p))
+	if (err != EEXIST || !is_directory(p, ec))
 	  ec.assign(err, std::generic_category());
-	else
-	  ec.clear();
       }
     else
       {
@@ -1391,10 +1389,11 @@
       ec.assign(errno, std::generic_category());
   else
     {
+      uintmax_t fragment_size = f.f_frsize;
       info = space_info{
-	f.f_blocks * f.f_frsize,
-	f.f_bfree * f.f_frsize,
-	f.f_bavail * f.f_frsize
+	f.f_blocks * fragment_size,
+	f.f_bfree * fragment_size,
+	f.f_bavail * fragment_size
       };
       ec.clear();
     }
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc	2017-03-15 16:13:20.938498000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc	2019-06-25 02:27:32.297851318 -0700
@@ -26,5 +26,5 @@
   using std::any_cast;
 
   const any y(1);
-  any_cast<int&>(y); // { dg-error "invalid static_cast" "" { target { *-*-* } } 461 }
+  any_cast<int&>(y); // { dg-error "invalid static_cast" "" { target { *-*-* } } 460 }
 }
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/20_util/duration/literals/range.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/20_util/duration/literals/range.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/20_util/duration/literals/range.cc	2017-09-13 08:20:21.384351000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/20_util/duration/literals/range.cc	2019-06-25 02:27:32.297851318 -0700
@@ -1,31 +0,0 @@
-// { dg-do compile { target c++14 } }
-
-// Copyright (C) 2014-2017 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 3, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING3.  If not see
-// <http://www.gnu.org/licenses/>.
-
-#include <chrono>
-
-void
-test01()
-{
-  using namespace std::literals::chrono_literals;
-
-  // std::numeric_limits<int64_t>::max() == 9223372036854775807;
-  auto h = 9223372036854775808h;
-  // { dg-error "cannot be represented" "" { target *-*-* } 893 }
-}
-// { dg-prune-output "in constexpr expansion" } // needed for -O0
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc	2019-06-25 02:27:32.297851318 -0700
@@ -108,3 +108,17 @@
   static_assert(test_category<has_unique_object_representations,
 		Aligned[][1]>(false), "");
 }
+
+void
+test02()
+{
+  using std::has_unique_object_representations;
+  using std::has_unique_object_representations_v;
+
+  static_assert(has_unique_object_representations_v<int>
+		== has_unique_object_representations<int>::value);
+  static_assert(has_unique_object_representations_v<void>
+		== has_unique_object_representations<void>::value);
+  static_assert(has_unique_object_representations_v<float>
+		== has_unique_object_representations<float>::value);
+}
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/22_locale/codecvt/codecvt_utf8/69703.cc	2019-06-25 02:27:32.297851318 -0700
@@ -68,7 +68,6 @@
   VERIFY( in[2] == U'c' );
 }
 
-
 void
 test04()
 {
@@ -90,6 +89,6 @@
 {
   test01();
   test02();
-  test01();
-  test02();
+  test03();
+  test04();
 }
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc	2017-09-20 15:26:26.371769000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc	2019-06-25 02:27:32.297851318 -0700
@@ -46,13 +46,6 @@
   }
 
   {
-    // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
     std::ios ios_01(0);
     std::ios ios_02(0);
     ios_01.clear(std::ios_base::eofbit);
@@ -62,7 +55,7 @@
       ios_01.copyfmt(ios_02);
       VERIFY( false );
     }
-    catch(exception_type&) {
+    catch(std::ios_base::failure&) {
       VERIFY( true );
     }
     catch(...) {
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc	2017-09-20 15:26:26.371769000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc	2019-06-25 02:27:32.297851318 -0700
@@ -50,20 +50,13 @@
   }
 
   {
-    // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
     std::ios ios_01(0);
     ios_01.clear(std::ios_base::eofbit);
     try {
       ios_01.exceptions(std::ios_base::eofbit);
       VERIFY( false );
     }
-    catch(exception_type&) {
+    catch(std::ios_base::failure&) {
       iostate02 = ios_01.exceptions();
       VERIFY( static_cast<bool>(iostate02 & std::ios_base::eofbit) );
     }
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc	2017-09-20 15:26:26.371769000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc	2019-06-25 02:27:32.297851318 -0700
@@ -27,20 +27,13 @@
   istringstream stream("jaylib - champion sound");
   stream.exceptions(ios_base::failbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       T i;
       stream >> i;
       VERIFY( false );
     }
-  catch (const exception_type&)
+  catch (const std::ios_base::failure&)
     {
       // stream should set failbit and throw ios_base::failure.
       VERIFY( stream.fail() );
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc	2017-09-20 15:26:26.371769000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc	2019-06-25 02:27:32.297851318 -0700
@@ -27,20 +27,13 @@
   wistringstream stream(L"jaylib - champion sound");
   stream.exceptions(ios_base::failbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       T i;
       stream >> i;
       VERIFY( false );
     }
-  catch (const exception_type&)
+  catch (const std::ios_base::failure&)
     {
       // stream should set failbit and throw ios_base::failure.
       VERIFY( stream.fail() );
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc	2017-09-20 15:26:26.371769000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc	2019-06-25 02:27:32.297851318 -0700
@@ -35,19 +35,12 @@
   istringstream stream;
   stream.exceptions(ios_base::failbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       stream >> static_cast<streambuf*>(0);
       VERIFY(false);
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
     }
 
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc	2017-09-20 15:26:26.371769000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc	2019-06-25 02:27:32.297851318 -0700
@@ -35,19 +35,12 @@
   wistringstream stream;
   stream.exceptions(ios_base::failbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       stream >> static_cast<wstreambuf*>(0);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
     }
 
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc	2017-09-20 15:26:26.371769000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc	2019-06-25 02:27:32.297851318 -0700
@@ -26,19 +26,12 @@
   istringstream stream;
   stream.exceptions(ios_base::eofbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       istream::sentry sentry(stream, false);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
       VERIFY( stream.rdstate() == (ios_base::eofbit | ios_base::failbit) );
     }
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc	2017-09-20 15:26:26.371769000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc	2019-06-25 02:27:32.297851318 -0700
@@ -26,19 +26,12 @@
   wistringstream stream;
   stream.exceptions(ios_base::eofbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       wistream::sentry sentry(stream, false);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
       VERIFY( stream.rdstate() == (ios_base::eofbit | ios_base::failbit) );
     }
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc	2017-09-20 15:26:26.371769000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc	2019-06-25 02:27:32.297851318 -0700
@@ -37,19 +37,12 @@
   ostringstream stream;
   stream.exceptions(ios_base::badbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       stream << static_cast<streambuf*>(0);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
     }
 
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc	2017-09-20 15:26:26.371769000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc	2019-06-25 02:27:32.297851318 -0700
@@ -37,19 +37,12 @@
   wostringstream stream;
   stream.exceptions(ios_base::badbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       stream << static_cast<wstreambuf*>(0);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
     }
 
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc	2017-09-20 15:26:26.371769000 -0700
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc	2019-06-25 02:27:32.297851318 -0700
@@ -50,18 +50,11 @@
   ios.pword(1) = v;
   VERIFY( ios.pword(1) == v );
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       v = ios.pword(max);
     }
-  catch(exception_type&)
+  catch(std::ios_base::failure&)
     {
       // Ok.
       VERIFY( ios.bad() );
@@ -80,7 +73,7 @@
     {
       v = ios.pword(std::numeric_limits<int>::max());
     }
-  catch(exception_type&)
+  catch(std::ios_base::failure&)
     {
       // Ok.
       VERIFY( ios.bad() );
@@ -99,7 +92,7 @@
     {
       l = ios.iword(max);
     }
-  catch(exception_type&)
+  catch(std::ios_base::failure&)
     {
       // Ok.
       VERIFY( ios.bad() );
@@ -118,7 +111,7 @@
     {
       l = ios.iword(std::numeric_limits<int>::max());
     }
-  catch(exception_type&)
+  catch(std::ios_base::failure&)
     {
       // Ok.
       VERIFY( ios.bad() );
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc	2019-06-25 02:27:32.297851318 -0700
@@ -1,4 +1,5 @@
 // { dg-do run { target c++14 } }
+// { dg-xfail-run-if "PR libstdc++/77691" { { i?86-*-solaris2.* x86_64-*-solaris2.* } && ilp32 } }
 
 // Copyright (C) 2016-2017 Free Software Foundation, Inc.
 //
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc	2019-06-25 02:27:32.301851290 -0700
@@ -1,7 +1,7 @@
 // { dg-do run { target c++11 } }
 // { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
 //
-// Copyright (C) 2016-2017 Free Software Foundation, Inc.
+// Copyright (C) 2016-2018 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -37,387 +37,444 @@
 #endif
 #include <specfun_testcase.h>
 
-
 // Test data for k=-0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.6751587294384150e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.2838262090802751e-16
+// mean(f - f_Boost): 4.4408920985006264e-17
+// variance(f - f_Boost): 2.4347558803117648e-34
+// stddev(f - f_Boost): 1.5603704304785339e-17
 const testcase_comp_ellint_3<double>
 data001[10] =
 {
   { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000 },
-  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001 },
-  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001 },
-  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999 },
-  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002 },
-  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000 },
-  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998 },
-  { 1.6600480747670940, -0.90000000000000002, 0.69999999999999996 },
-  { 1.6044591960982202, -0.90000000000000002, 0.80000000000000004 },
-  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002 },
+  { 2.4295011187834885, -0.90000000000000002, 0.10000000000000001 },
+  { 2.6076835743348412, -0.90000000000000002, 0.20000000000000001 },
+  { 2.8256506968858512, -0.90000000000000002, 0.30000000000000004 },
+  { 3.1000689868578619, -0.90000000000000002, 0.40000000000000002 },
+  { 3.4591069002104677, -0.90000000000000002, 0.50000000000000000 },
+  { 3.9549939883570229, -0.90000000000000002, 0.60000000000000009 },
+  { 4.6985482312992435, -0.90000000000000002, 0.70000000000000007 },
+  { 5.9820740813645710, -0.90000000000000002, 0.80000000000000004 },
+  { 8.9942562031858699, -0.90000000000000002, 0.90000000000000002 },
 };
 const double toler001 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.5960830388244336e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1949393471095187e-16
+// mean(f - f_Boost): 9.5479180117763459e-16
+// variance(f - f_Boost): 5.4782007307014711e-34
+// stddev(f - f_Boost): 2.3405556457178006e-17
 const testcase_comp_ellint_3<double>
 data002[10] =
 {
-  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000 },
-  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001 },
-  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001 },
-  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999 },
-  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002 },
-  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000 },
-  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998 },
-  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996 },
-  { 1.4339837018309471, -0.80000000000000004, 0.80000000000000004 },
-  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002 },
+  { 1.9953027776647294, -0.80000000000000004, 0.0000000000000000 },
+  { 2.1172616484005085, -0.80000000000000004, 0.10000000000000001 },
+  { 2.2624789434186798, -0.80000000000000004, 0.20000000000000001 },
+  { 2.4392042002725698, -0.80000000000000004, 0.30000000000000004 },
+  { 2.6604037035529728, -0.80000000000000004, 0.40000000000000002 },
+  { 2.9478781158239751, -0.80000000000000004, 0.50000000000000000 },
+  { 3.3418121892288055, -0.80000000000000004, 0.60000000000000009 },
+  { 3.9268876980046397, -0.80000000000000004, 0.70000000000000007 },
+  { 4.9246422058196071, -0.80000000000000004, 0.80000000000000004 },
+  { 7.2263259298637132, -0.80000000000000004, 0.90000000000000002 },
 };
 const double toler002 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3074070916136724e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 1.9832236886714888e-16
+// mean(f - f_Boost): -1.5543122344752191e-16
+// variance(f - f_Boost): 2.9825759533819119e-33
+// stddev(f - f_Boost): 5.4612965066748680e-17
 const testcase_comp_ellint_3<double>
 data003[10] =
 {
-  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000 },
-  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001 },
-  { 1.6721098780092145, -0.69999999999999996, 0.20000000000000001 },
-  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999 },
-  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002 },
-  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000 },
-  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998 },
-  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996 },
-  { 1.3427110650397531, -0.69999999999999996, 0.80000000000000004 },
-  { 1.3040500499695913, -0.69999999999999996, 0.90000000000000002 },
+  { 1.8456939983747234, -0.69999999999999996, 0.0000000000000000 },
+  { 1.9541347343119564, -0.69999999999999996, 0.10000000000000001 },
+  { 2.0829290325820202, -0.69999999999999996, 0.20000000000000001 },
+  { 2.2392290510988535, -0.69999999999999996, 0.30000000000000004 },
+  { 2.4342502915307880, -0.69999999999999996, 0.40000000000000002 },
+  { 2.6868019968236996, -0.69999999999999996, 0.50000000000000000 },
+  { 3.0314573496746742, -0.69999999999999996, 0.60000000000000009 },
+  { 3.5408408771788564, -0.69999999999999996, 0.70000000000000007 },
+  { 4.4042405729076961, -0.69999999999999996, 0.80000000000000004 },
+  { 6.3796094177887754, -0.69999999999999996, 0.90000000000000002 },
 };
 const double toler003 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1891472451898755e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 2
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -1.9984014443252818e-16
+// variance(f - f_Boost): 4.9303806576313241e-33
+// stddev(f - f_Boost): 7.0216669371534022e-17
 const testcase_comp_ellint_3<double>
 data004[10] =
 {
   { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000 },
-  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001 },
-  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001 },
-  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999 },
-  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002 },
-  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000 },
-  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998 },
-  { 1.3232737468822813, -0.59999999999999998, 0.69999999999999996 },
-  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004 },
-  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002 },
+  { 1.8508766487100685, -0.59999999999999998, 0.10000000000000001 },
+  { 1.9695980282802217, -0.59999999999999998, 0.20000000000000001 },
+  { 2.1134154405060599, -0.59999999999999998, 0.30000000000000004 },
+  { 2.2925036420985130, -0.59999999999999998, 0.40000000000000002 },
+  { 2.5239007084492711, -0.59999999999999998, 0.50000000000000000 },
+  { 2.8388723099514972, -0.59999999999999998, 0.60000000000000009 },
+  { 3.3029735898397159, -0.59999999999999998, 0.70000000000000007 },
+  { 4.0867036409261832, -0.59999999999999998, 0.80000000000000004 },
+  { 5.8709993116265604, -0.59999999999999998, 0.90000000000000002 },
 };
 const double toler004 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.7857620325589816e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 2.1900131385114407e-16
+// mean(f - f_Boost): 2.4424906541753446e-16
+// variance(f - f_Boost): 7.3651365379430888e-33
+// stddev(f - f_Boost): 8.5820373676319358e-17
 const testcase_comp_ellint_3<double>
 data005[10] =
 {
-  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000 },
-  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001 },
-  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001 },
-  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999 },
-  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002 },
-  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000 },
-  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998 },
-  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996 },
-  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004 },
-  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002 },
+  { 1.6857503548125961, -0.50000000000000000, 0.0000000000000000 },
+  { 1.7803034946545482, -0.50000000000000000, 0.10000000000000001 },
+  { 1.8922947612264021, -0.50000000000000000, 0.20000000000000001 },
+  { 2.0277924458111314, -0.50000000000000000, 0.30000000000000004 },
+  { 2.1962905366178065, -0.50000000000000000, 0.40000000000000002 },
+  { 2.4136715042011945, -0.50000000000000000, 0.50000000000000000 },
+  { 2.7090491861753558, -0.50000000000000000, 0.60000000000000009 },
+  { 3.1433945297859229, -0.50000000000000000, 0.70000000000000007 },
+  { 3.8750701888108070, -0.50000000000000000, 0.80000000000000004 },
+  { 5.5355132096026463, -0.50000000000000000, 0.90000000000000002 },
 };
 const double toler005 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.1925080711125793e-16
+// Test data for k=-0.39999999999999991.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1718164615986397e-16
+// mean(f - f_Boost): 6.2172489379008762e-16
+// variance(f - f_Boost): 1.6458949750907531e-31
+// stddev(f - f_Boost): 4.0569631192441877e-16
 const testcase_comp_ellint_3<double>
 data006[10] =
 {
-  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000 },
-  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001 },
-  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001 },
-  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999 },
-  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002 },
-  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000 },
-  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998 },
-  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996 },
-  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004 },
-  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002 },
+  { 1.6399998658645112, -0.39999999999999991, 0.0000000000000000 },
+  { 1.7306968836847190, -0.39999999999999991, 0.10000000000000001 },
+  { 1.8380358826317627, -0.39999999999999991, 0.20000000000000001 },
+  { 1.9677924132520139, -0.39999999999999991, 0.30000000000000004 },
+  { 2.1289968719280026, -0.39999999999999991, 0.40000000000000002 },
+  { 2.3367461373176512, -0.39999999999999991, 0.50000000000000000 },
+  { 2.6186940209850191, -0.39999999999999991, 0.60000000000000009 },
+  { 3.0327078743873246, -0.39999999999999991, 0.70000000000000007 },
+  { 3.7289548002199902, -0.39999999999999991, 0.80000000000000004 },
+  { 5.3055535102872513, -0.39999999999999991, 0.90000000000000002 },
 };
 const double toler006 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8209844149902043e-16
+// Test data for k=-0.29999999999999993.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.9274792319434433e-16
+// mean(f - f_Boost): 6.2172489379008762e-16
+// variance(f - f_Boost): 8.7651211691223537e-33
+// stddev(f - f_Boost): 9.3622225828712025e-17
 const testcase_comp_ellint_3<double>
 data007[10] =
 {
-  { 1.6080486199305128, -0.30000000000000004, 0.0000000000000000 },
-  { 1.5323534693557528, -0.30000000000000004, 0.10000000000000001 },
-  { 1.4663658145259877, -0.30000000000000004, 0.20000000000000001 },
-  { 1.4081767433479091, -0.30000000000000004, 0.29999999999999999 },
-  { 1.3563643538969763, -0.30000000000000004, 0.40000000000000002 },
-  { 1.3098448759814962, -0.30000000000000004, 0.50000000000000000 },
-  { 1.2677758800420669, -0.30000000000000004, 0.59999999999999998 },
-  { 1.2294913236274982, -0.30000000000000004, 0.69999999999999996 },
-  { 1.1944567571590048, -0.30000000000000004, 0.80000000000000004 },
-  { 1.1622376896064914, -0.30000000000000004, 0.90000000000000002 },
+  { 1.6080486199305128, -0.29999999999999993, 0.0000000000000000 },
+  { 1.6960848815118226, -0.29999999999999993, 0.10000000000000001 },
+  { 1.8002173372290500, -0.29999999999999993, 0.20000000000000001 },
+  { 1.9260216862473254, -0.29999999999999993, 0.30000000000000004 },
+  { 2.0822121773175533, -0.29999999999999993, 0.40000000000000002 },
+  { 2.2833505881933971, -0.29999999999999993, 0.50000000000000000 },
+  { 2.5560975528589065, -0.29999999999999993, 0.60000000000000009 },
+  { 2.9562123549913877, -0.29999999999999993, 0.70000000000000007 },
+  { 3.6283050484567170, -0.29999999999999993, 0.80000000000000004 },
+  { 5.1479514944016795, -0.29999999999999993, 0.90000000000000002 },
 };
 const double toler007 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8637687241174905e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.9753938705764407e-16
+// mean(f - f_Boost): 3.1086244689504381e-16
+// variance(f - f_Boost): 4.1147374377268827e-32
+// stddev(f - f_Boost): 2.0284815596220939e-16
 const testcase_comp_ellint_3<double>
 data008[10] =
 {
-  { 1.5868678474541660, -0.19999999999999996, 0.0000000000000000 },
-  { 1.5126513474261087, -0.19999999999999996, 0.10000000000000001 },
-  { 1.4479323932249564, -0.19999999999999996, 0.20000000000000001 },
-  { 1.3908453514752477, -0.19999999999999996, 0.29999999999999999 },
-  { 1.3400002519661005, -0.19999999999999996, 0.40000000000000002 },
-  { 1.2943374404397372, -0.19999999999999996, 0.50000000000000000 },
-  { 1.2530330675914556, -0.19999999999999996, 0.59999999999999998 },
-  { 1.2154356555075863, -0.19999999999999996, 0.69999999999999996 },
-  { 1.1810223448909909, -0.19999999999999996, 0.80000000000000004 },
-  { 1.1493679916141861, -0.19999999999999996, 0.90000000000000002 },
+  { 1.5868678474541662, -0.19999999999999996, 0.0000000000000000 },
+  { 1.6731552050562593, -0.19999999999999996, 0.10000000000000001 },
+  { 1.7751816279738935, -0.19999999999999996, 0.20000000000000001 },
+  { 1.8983924169967101, -0.19999999999999996, 0.30000000000000004 },
+  { 2.0512956926676806, -0.19999999999999996, 0.40000000000000002 },
+  { 2.2481046259421302, -0.19999999999999996, 0.50000000000000000 },
+  { 2.5148333891629315, -0.19999999999999996, 0.60000000000000009 },
+  { 2.9058704854500967, -0.19999999999999996, 0.70000000000000007 },
+  { 3.5622166386422633, -0.19999999999999996, 0.80000000000000004 },
+  { 5.0448269356200370, -0.19999999999999996, 0.90000000000000002 },
 };
 const double toler008 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8887517676790089e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.9932308021417639e-16
+// mean(f - f_Boost): 0.0000000000000000
+// variance(f - f_Boost): 6.8368087769470551e-64
+// stddev(f - f_Boost): 2.6147291976315738e-32
 const testcase_comp_ellint_3<double>
 data009[10] =
 {
-  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000 },
-  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001 },
-  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001 },
-  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999 },
-  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002 },
-  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000 },
-  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998 },
-  { 1.2073745911083185, -0.099999999999999978, 0.69999999999999996 },
-  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004 },
-  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002 },
+  { 1.5747455615173560, -0.099999999999999978, 0.0000000000000000 },
+  { 1.6600374067558428, -0.099999999999999978, 0.10000000000000001 },
+  { 1.7608656115083421, -0.099999999999999978, 0.20000000000000001 },
+  { 1.8826015946315438, -0.099999999999999978, 0.30000000000000004 },
+  { 2.0336367403076760, -0.099999999999999978, 0.40000000000000002 },
+  { 2.2279868912966849, -0.099999999999999978, 0.50000000000000000 },
+  { 2.4913004919173827, -0.099999999999999978, 0.60000000000000009 },
+  { 2.8771910188009744, -0.099999999999999978, 0.70000000000000007 },
+  { 3.5246199613295617, -0.099999999999999978, 0.80000000000000004 },
+  { 4.9862890417305508, -0.099999999999999978, 0.90000000000000002 },
 };
 const double toler009 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.6725702444488137e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.1899085000907084e-16
+// mean(f - f_Boost): -2.2204460492503131e-16
+// variance(f - f_Boost): 5.4782007307014711e-32
+// stddev(f - f_Boost): 2.3405556457178008e-16
 const testcase_comp_ellint_3<double>
 data010[10] =
 {
   { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000 },
-  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001 },
-  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001 },
-  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999 },
-  { 1.3275651989026320, 0.0000000000000000, 0.40000000000000002 },
-  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000 },
-  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998 },
-  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996 },
-  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004 },
-  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002 },
+  { 1.6557647109660170, 0.0000000000000000, 0.10000000000000001 },
+  { 1.7562036827601817, 0.0000000000000000, 0.20000000000000001 },
+  { 1.8774607092226381, 0.0000000000000000, 0.30000000000000004 },
+  { 2.0278893379868062, 0.0000000000000000, 0.40000000000000002 },
+  { 2.2214414690791831, 0.0000000000000000, 0.50000000000000000 },
+  { 2.4836470664490258, 0.0000000000000000, 0.60000000000000009 },
+  { 2.8678686047727386, 0.0000000000000000, 0.70000000000000007 },
+  { 3.5124073655203634, 0.0000000000000000, 0.80000000000000004 },
+  { 4.9672941328980516, 0.0000000000000000, 0.90000000000000002 },
 };
 const double toler010 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8887517676790089e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.9932308021417639e-16
+// mean(f - f_Boost): -2.2204460492503132e-17
+// variance(f - f_Boost): 6.0868897007794120e-35
+// stddev(f - f_Boost): 7.8018521523926693e-18
 const testcase_comp_ellint_3<double>
 data011[10] =
 {
-  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000 },
-  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001 },
-  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001 },
-  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999 },
-  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002 },
-  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000 },
-  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998 },
-  { 1.2073745911083185, 0.10000000000000009, 0.69999999999999996 },
-  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004 },
-  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002 },
+  { 1.5747455615173560, 0.10000000000000009, 0.0000000000000000 },
+  { 1.6600374067558428, 0.10000000000000009, 0.10000000000000001 },
+  { 1.7608656115083421, 0.10000000000000009, 0.20000000000000001 },
+  { 1.8826015946315440, 0.10000000000000009, 0.30000000000000004 },
+  { 2.0336367403076760, 0.10000000000000009, 0.40000000000000002 },
+  { 2.2279868912966849, 0.10000000000000009, 0.50000000000000000 },
+  { 2.4913004919173827, 0.10000000000000009, 0.60000000000000009 },
+  { 2.8771910188009744, 0.10000000000000009, 0.70000000000000007 },
+  { 3.5246199613295617, 0.10000000000000009, 0.80000000000000004 },
+  { 4.9862890417305508, 0.10000000000000009, 0.90000000000000002 },
 };
 const double toler011 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8637687241174905e-16
+// Test data for k=0.20000000000000018.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.9753938705764407e-16
+// mean(f - f_Boost): 3.1086244689504381e-16
+// variance(f - f_Boost): 4.1147374377268827e-32
+// stddev(f - f_Boost): 2.0284815596220939e-16
 const testcase_comp_ellint_3<double>
 data012[10] =
 {
-  { 1.5868678474541660, 0.19999999999999996, 0.0000000000000000 },
-  { 1.5126513474261087, 0.19999999999999996, 0.10000000000000001 },
-  { 1.4479323932249564, 0.19999999999999996, 0.20000000000000001 },
-  { 1.3908453514752477, 0.19999999999999996, 0.29999999999999999 },
-  { 1.3400002519661005, 0.19999999999999996, 0.40000000000000002 },
-  { 1.2943374404397372, 0.19999999999999996, 0.50000000000000000 },
-  { 1.2530330675914556, 0.19999999999999996, 0.59999999999999998 },
-  { 1.2154356555075863, 0.19999999999999996, 0.69999999999999996 },
-  { 1.1810223448909909, 0.19999999999999996, 0.80000000000000004 },
-  { 1.1493679916141861, 0.19999999999999996, 0.90000000000000002 },
+  { 1.5868678474541662, 0.20000000000000018, 0.0000000000000000 },
+  { 1.6731552050562593, 0.20000000000000018, 0.10000000000000001 },
+  { 1.7751816279738935, 0.20000000000000018, 0.20000000000000001 },
+  { 1.8983924169967101, 0.20000000000000018, 0.30000000000000004 },
+  { 2.0512956926676806, 0.20000000000000018, 0.40000000000000002 },
+  { 2.2481046259421302, 0.20000000000000018, 0.50000000000000000 },
+  { 2.5148333891629315, 0.20000000000000018, 0.60000000000000009 },
+  { 2.9058704854500967, 0.20000000000000018, 0.70000000000000007 },
+  { 3.5622166386422633, 0.20000000000000018, 0.80000000000000004 },
+  { 5.0448269356200370, 0.20000000000000018, 0.90000000000000002 },
 };
 const double toler012 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8209844149902043e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.4585997630846713e-16
+// mean(f - f_Boost): 5.1070259132757197e-16
+// variance(f - f_Boost): 1.7591111235252501e-32
+// stddev(f - f_Boost): 1.3263148659067538e-16
 const testcase_comp_ellint_3<double>
 data013[10] =
 {
   { 1.6080486199305128, 0.30000000000000004, 0.0000000000000000 },
-  { 1.5323534693557528, 0.30000000000000004, 0.10000000000000001 },
-  { 1.4663658145259877, 0.30000000000000004, 0.20000000000000001 },
-  { 1.4081767433479091, 0.30000000000000004, 0.29999999999999999 },
-  { 1.3563643538969763, 0.30000000000000004, 0.40000000000000002 },
-  { 1.3098448759814962, 0.30000000000000004, 0.50000000000000000 },
-  { 1.2677758800420669, 0.30000000000000004, 0.59999999999999998 },
-  { 1.2294913236274982, 0.30000000000000004, 0.69999999999999996 },
-  { 1.1944567571590048, 0.30000000000000004, 0.80000000000000004 },
-  { 1.1622376896064914, 0.30000000000000004, 0.90000000000000002 },
+  { 1.6960848815118228, 0.30000000000000004, 0.10000000000000001 },
+  { 1.8002173372290500, 0.30000000000000004, 0.20000000000000001 },
+  { 1.9260216862473254, 0.30000000000000004, 0.30000000000000004 },
+  { 2.0822121773175533, 0.30000000000000004, 0.40000000000000002 },
+  { 2.2833505881933975, 0.30000000000000004, 0.50000000000000000 },
+  { 2.5560975528589065, 0.30000000000000004, 0.60000000000000009 },
+  { 2.9562123549913877, 0.30000000000000004, 0.70000000000000007 },
+  { 3.6283050484567174, 0.30000000000000004, 0.80000000000000004 },
+  { 5.1479514944016795, 0.30000000000000004, 0.90000000000000002 },
 };
 const double toler013 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.1925080711125793e-16
+// Test data for k=0.40000000000000013.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.7696531428672557e-16
+// mean(f - f_Boost): 1.1990408665951691e-15
+// variance(f - f_Boost): 2.6514491536595121e-31
+// stddev(f - f_Boost): 5.1492224205791612e-16
 const testcase_comp_ellint_3<double>
 data014[10] =
 {
-  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000 },
-  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001 },
-  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001 },
-  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999 },
-  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002 },
-  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000 },
-  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998 },
-  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996 },
-  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004 },
-  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002 },
+  { 1.6399998658645112, 0.40000000000000013, 0.0000000000000000 },
+  { 1.7306968836847190, 0.40000000000000013, 0.10000000000000001 },
+  { 1.8380358826317629, 0.40000000000000013, 0.20000000000000001 },
+  { 1.9677924132520141, 0.40000000000000013, 0.30000000000000004 },
+  { 2.1289968719280030, 0.40000000000000013, 0.40000000000000002 },
+  { 2.3367461373176512, 0.40000000000000013, 0.50000000000000000 },
+  { 2.6186940209850196, 0.40000000000000013, 0.60000000000000009 },
+  { 3.0327078743873246, 0.40000000000000013, 0.70000000000000007 },
+  { 3.7289548002199906, 0.40000000000000013, 0.80000000000000004 },
+  { 5.3055535102872522, 0.40000000000000013, 0.90000000000000002 },
 };
 const double toler014 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.7857620325589816e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 2.1900131385114407e-16
+// mean(f - f_Boost): 2.4424906541753446e-16
+// variance(f - f_Boost): 7.3651365379430888e-33
+// stddev(f - f_Boost): 8.5820373676319358e-17
 const testcase_comp_ellint_3<double>
 data015[10] =
 {
-  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000 },
-  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001 },
-  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001 },
-  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999 },
-  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002 },
-  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000 },
-  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998 },
-  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996 },
-  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004 },
-  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002 },
+  { 1.6857503548125961, 0.50000000000000000, 0.0000000000000000 },
+  { 1.7803034946545482, 0.50000000000000000, 0.10000000000000001 },
+  { 1.8922947612264021, 0.50000000000000000, 0.20000000000000001 },
+  { 2.0277924458111314, 0.50000000000000000, 0.30000000000000004 },
+  { 2.1962905366178065, 0.50000000000000000, 0.40000000000000002 },
+  { 2.4136715042011945, 0.50000000000000000, 0.50000000000000000 },
+  { 2.7090491861753558, 0.50000000000000000, 0.60000000000000009 },
+  { 3.1433945297859229, 0.50000000000000000, 0.70000000000000007 },
+  { 3.8750701888108070, 0.50000000000000000, 0.80000000000000004 },
+  { 5.5355132096026463, 0.50000000000000000, 0.90000000000000002 },
 };
 const double toler015 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.7124937590522226e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 2
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -2.2204460492503131e-16
+// variance(f - f_Boost): 6.0868897007794117e-33
+// stddev(f - f_Boost): 7.8018521523926690e-17
 const testcase_comp_ellint_3<double>
 data016[10] =
 {
   { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000 },
-  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001 },
-  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001 },
-  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999 },
-  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002 },
-  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000 },
-  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998 },
-  { 1.3232737468822813, 0.60000000000000009, 0.69999999999999996 },
-  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004 },
-  { 1.2479362973851873, 0.60000000000000009, 0.90000000000000002 },
+  { 1.8508766487100687, 0.60000000000000009, 0.10000000000000001 },
+  { 1.9695980282802217, 0.60000000000000009, 0.20000000000000001 },
+  { 2.1134154405060599, 0.60000000000000009, 0.30000000000000004 },
+  { 2.2925036420985130, 0.60000000000000009, 0.40000000000000002 },
+  { 2.5239007084492711, 0.60000000000000009, 0.50000000000000000 },
+  { 2.8388723099514976, 0.60000000000000009, 0.60000000000000009 },
+  { 3.3029735898397159, 0.60000000000000009, 0.70000000000000007 },
+  { 4.0867036409261832, 0.60000000000000009, 0.80000000000000004 },
+  { 5.8709993116265613, 0.60000000000000009, 0.90000000000000002 },
 };
 const double toler016 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3074070916136724e-16
+// Test data for k=0.70000000000000018.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.9298727220933567e-16
+// mean(f - f_Boost): 4.8849813083506892e-16
+// variance(f - f_Boost): 2.0476296953421943e-31
+// stddev(f - f_Boost): 4.5250742483877478e-16
 const testcase_comp_ellint_3<double>
 data017[10] =
 {
-  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000 },
-  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001 },
-  { 1.6721098780092145, 0.69999999999999996, 0.20000000000000001 },
-  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999 },
-  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002 },
-  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000 },
-  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998 },
-  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996 },
-  { 1.3427110650397531, 0.69999999999999996, 0.80000000000000004 },
-  { 1.3040500499695913, 0.69999999999999996, 0.90000000000000002 },
+  { 1.8456939983747238, 0.70000000000000018, 0.0000000000000000 },
+  { 1.9541347343119566, 0.70000000000000018, 0.10000000000000001 },
+  { 2.0829290325820207, 0.70000000000000018, 0.20000000000000001 },
+  { 2.2392290510988540, 0.70000000000000018, 0.30000000000000004 },
+  { 2.4342502915307880, 0.70000000000000018, 0.40000000000000002 },
+  { 2.6868019968237000, 0.70000000000000018, 0.50000000000000000 },
+  { 3.0314573496746746, 0.70000000000000018, 0.60000000000000009 },
+  { 3.5408408771788569, 0.70000000000000018, 0.70000000000000007 },
+  { 4.4042405729076970, 0.70000000000000018, 0.80000000000000004 },
+  { 6.3796094177887763, 0.70000000000000018, 0.90000000000000002 },
 };
 const double toler017 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.5960830388244336e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1949393471095187e-16
+// mean(f - f_Boost): 9.5479180117763459e-16
+// variance(f - f_Boost): 5.4782007307014711e-34
+// stddev(f - f_Boost): 2.3405556457178006e-17
 const testcase_comp_ellint_3<double>
 data018[10] =
 {
-  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000 },
-  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001 },
-  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001 },
-  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999 },
-  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002 },
-  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000 },
-  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998 },
-  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996 },
-  { 1.4339837018309471, 0.80000000000000004, 0.80000000000000004 },
-  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002 },
+  { 1.9953027776647294, 0.80000000000000004, 0.0000000000000000 },
+  { 2.1172616484005085, 0.80000000000000004, 0.10000000000000001 },
+  { 2.2624789434186798, 0.80000000000000004, 0.20000000000000001 },
+  { 2.4392042002725698, 0.80000000000000004, 0.30000000000000004 },
+  { 2.6604037035529728, 0.80000000000000004, 0.40000000000000002 },
+  { 2.9478781158239751, 0.80000000000000004, 0.50000000000000000 },
+  { 3.3418121892288055, 0.80000000000000004, 0.60000000000000009 },
+  { 3.9268876980046397, 0.80000000000000004, 0.70000000000000007 },
+  { 4.9246422058196071, 0.80000000000000004, 0.80000000000000004 },
+  { 7.2263259298637132, 0.80000000000000004, 0.90000000000000002 },
 };
 const double toler018 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.6751587294384150e-16
+// Test data for k=0.90000000000000013.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 1.5716352001310461e-16
+// mean(f - f_Boost): 4.4408920985006264e-17
+// variance(f - f_Boost): 2.4347558803117648e-34
+// stddev(f - f_Boost): 1.5603704304785339e-17
 const testcase_comp_ellint_3<double>
 data019[10] =
 {
-  { 2.2805491384227703, 0.89999999999999991, 0.0000000000000000 },
-  { 2.1537868513875287, 0.89999999999999991, 0.10000000000000001 },
-  { 2.0443194576468895, 0.89999999999999991, 0.20000000000000001 },
-  { 1.9486280260314426, 0.89999999999999991, 0.29999999999999999 },
-  { 1.8641114227238351, 0.89999999999999991, 0.40000000000000002 },
-  { 1.7888013241937863, 0.89999999999999991, 0.50000000000000000 },
-  { 1.7211781128919525, 0.89999999999999991, 0.59999999999999998 },
-  { 1.6600480747670940, 0.89999999999999991, 0.69999999999999996 },
-  { 1.6044591960982202, 0.89999999999999991, 0.80000000000000004 },
-  { 1.5536420236310948, 0.89999999999999991, 0.90000000000000002 },
+  { 2.2805491384227707, 0.90000000000000013, 0.0000000000000000 },
+  { 2.4295011187834890, 0.90000000000000013, 0.10000000000000001 },
+  { 2.6076835743348421, 0.90000000000000013, 0.20000000000000001 },
+  { 2.8256506968858521, 0.90000000000000013, 0.30000000000000004 },
+  { 3.1000689868578628, 0.90000000000000013, 0.40000000000000002 },
+  { 3.4591069002104686, 0.90000000000000013, 0.50000000000000000 },
+  { 3.9549939883570242, 0.90000000000000013, 0.60000000000000009 },
+  { 4.6985482312992453, 0.90000000000000013, 0.70000000000000007 },
+  { 5.9820740813645727, 0.90000000000000013, 0.80000000000000004 },
+  { 8.9942562031858735, 0.90000000000000013, 0.90000000000000002 },
 };
 const double toler019 = 2.5000000000000020e-13;
 
-template<typename Tp, unsigned int Num>
+template<typename Ret, unsigned int Num>
   void
-  test(const testcase_comp_ellint_3<Tp> (&data)[Num], Tp toler)
+  test(const testcase_comp_ellint_3<Ret> (&data)[Num], Ret toler)
   {
-    const Tp eps = std::numeric_limits<Tp>::epsilon();
-    Tp max_abs_diff = -Tp(1);
-    Tp max_abs_frac = -Tp(1);
+    bool test __attribute__((unused)) = true;
+    const Ret eps = std::numeric_limits<Ret>::epsilon();
+    Ret max_abs_diff = -Ret(1);
+    Ret max_abs_frac = -Ret(1);
     unsigned int num_datum = Num;
     for (unsigned int i = 0; i < num_datum; ++i)
       {
-	const Tp f = std::comp_ellint_3(data[i].k, data[i].nu);
-	const Tp f0 = data[i].f0;
-	const Tp diff = f - f0;
+	const Ret f = std::comp_ellint_3(data[i].k, data[i].nu);
+	const Ret f0 = data[i].f0;
+	const Ret diff = f - f0;
 	if (std::abs(diff) > max_abs_diff)
 	  max_abs_diff = std::abs(diff);
-	if (std::abs(f0) > Tp(10) * eps
-	 && std::abs(f) > Tp(10) * eps)
+	if (std::abs(f0) > Ret(10) * eps
+	 && std::abs(f) > Ret(10) * eps)
 	  {
-	    const Tp frac = diff / f0;
+	    const Ret frac = diff / f0;
 	    if (std::abs(frac) > max_abs_frac)
 	      max_abs_frac = std::abs(frac);
 	  }
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc	2019-06-25 02:27:32.301851290 -0700
@@ -1,7 +1,7 @@
 // { dg-do run { target c++11 } }
 // { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
 //
-// Copyright (C) 2016-2017 Free Software Foundation, Inc.
+// Copyright (C) 2016-2018 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -37,30 +37,32 @@
 #endif
 #include <specfun_testcase.h>
 
-
 // Test data for k=-0.90000000000000002, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.9686139313362077e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 5.7842011620951154e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
 const testcase_ellint_3<double>
 data001[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17525427376115024, -0.90000000000000002, 0.0000000000000000, 
+  { 0.17525427376115027, -0.90000000000000002, 0.0000000000000000, 
 	  0.17453292519943295 },
   { 0.35492464591297446, -0.90000000000000002, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.54388221416157112, -0.90000000000000002, 0.0000000000000000, 
+  { 0.54388221416157123, -0.90000000000000002, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.74797400423532490, -0.90000000000000002, 0.0000000000000000, 
+  { 0.74797400423532512, -0.90000000000000002, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.97463898451966458, -0.90000000000000002, 0.0000000000000000, 
+  { 0.97463898451966446, -0.90000000000000002, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.2334463254523440, -0.90000000000000002, 0.0000000000000000, 
+  { 1.2334463254523438, -0.90000000000000002, 0.0000000000000000, 
 	  1.0471975511965976 },
   { 1.5355247765594913, -0.90000000000000002, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.8882928567775121, -0.90000000000000002, 0.0000000000000000, 
+  { 1.8882928567775126, -0.90000000000000002, 0.0000000000000000, 
 	  1.3962634015954636 },
   { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000, 
 	  1.5707963267948966 },
@@ -68,269 +70,299 @@
 const double toler001 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.0141810743801079e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.1500594295134815e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
 const testcase_ellint_3<double>
 data002[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17507714233254656, -0.90000000000000002, 0.10000000000000001, 
+  { 0.17543204932716244, -0.90000000000000002, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35350932904326521, -0.90000000000000002, 0.10000000000000001, 
+  { 0.35636022898551184, -0.90000000000000002, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53911129989870976, -0.90000000000000002, 0.10000000000000001, 
+  { 0.54880278898382584, -0.90000000000000002, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.73666644254508395, -0.90000000000000002, 0.10000000000000001, 
+  { 0.75988834774529268, -0.90000000000000002, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.95250736612100195, -0.90000000000000002, 0.10000000000000001, 
+  { 0.99853303003568117, -0.90000000000000002, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1950199550905594, -0.90000000000000002, 0.10000000000000001, 
+  { 1.2759958823999022, -0.90000000000000002, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.4741687286340850, -0.90000000000000002, 0.10000000000000001, 
+  { 1.6051187364639401, -0.90000000000000002, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.7968678183506057, -0.90000000000000002, 0.10000000000000001, 
+  { 1.9941406879519472, -0.90000000000000002, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001, 
+  { 2.4295011187834881, -0.90000000000000002, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler002 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.20000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.0588292817405780e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 5.2711357908578066e-16
+// mean(f - f_Boost): 8.0491169285323847e-17
+// variance(f - f_Boost): 7.9985534974304465e-34
+// stddev(f - f_Boost): 2.8281714052423424e-17
 const testcase_ellint_3<double>
 data003[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17490065089140927, -0.90000000000000002, 0.20000000000000001, 
+  { 0.17561047321968409, -0.90000000000000002, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.35211377590661436, -0.90000000000000002, 0.20000000000000001, 
+  { 0.35781659944356109, -0.90000000000000002, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.53448220334204100, -0.90000000000000002, 0.20000000000000001, 
+  { 0.55388150905215283, -0.90000000000000002, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.72591368943179579, -0.90000000000000002, 0.20000000000000001, 
+  { 0.77246874123251441, -0.90000000000000002, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.93192539780038763, -0.90000000000000002, 0.20000000000000001, 
+  { 1.0244466254771925, -0.90000000000000002, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.1600809679692683, -0.90000000000000002, 0.20000000000000001, 
+  { 1.3234824077640801, -0.90000000000000002, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.4195407225882510, -0.90000000000000002, 0.20000000000000001, 
+  { 1.6849848968804237, -0.90000000000000002, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.7168966476424525, -0.90000000000000002, 0.20000000000000001, 
+  { 2.1185749045502273, -0.90000000000000002, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001, 
+  { 2.6076835743348412, -0.90000000000000002, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler003 = 2.5000000000000020e-13;
 
-// Test data for k=-0.90000000000000002, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2403611223075570e-16
+// Test data for k=-0.90000000000000002, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.9955372494296814e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
 const testcase_ellint_3<double>
 data004[10] =
 {
-  { 0.0000000000000000, -0.90000000000000002, 0.29999999999999999, 
+  { 0.0000000000000000, -0.90000000000000002, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17472479532647531, -0.90000000000000002, 0.29999999999999999, 
+  { 0.17578954966746221, -0.90000000000000002, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.35073750187374114, -0.90000000000000002, 0.29999999999999999, 
+  { 0.35929429810867447, -0.90000000000000002, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52998766129466957, -0.90000000000000002, 0.29999999999999999, 
+  { 0.55912757154240811, -0.90000000000000002, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.71566993548699553, -0.90000000000000002, 0.29999999999999999, 
+  { 0.78578314722025389, -0.90000000000000002, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.91271517762560195, -0.90000000000000002, 0.29999999999999999, 
+  { 1.0526941001131365, -0.90000000000000002, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.1281241199843370, -0.90000000000000002, 0.29999999999999999, 
+  { 1.3769682234538601, -0.90000000000000002, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.3704929576917451, -0.90000000000000002, 0.29999999999999999, 
+  { 1.7779437432911238, -0.90000000000000002, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.6461981511487713, -0.90000000000000002, 0.29999999999999999, 
+  { 2.2676509341813631, -0.90000000000000002, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999, 
+  { 2.8256506968858512, -0.90000000000000002, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler004 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3487482375512111e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.7042235432234642e-16
+// mean(f - f_Boost): 2.0261570199409106e-16
+// variance(f - f_Boost): 5.8024227149195491e-32
+// stddev(f - f_Boost): 2.4088218520512364e-16
 const testcase_ellint_3<double>
 data005[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17454957156468837, -0.90000000000000002, 0.40000000000000002, 
+  { 0.17596928293938452, -0.90000000000000002, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34938003933330430, -0.90000000000000002, 0.40000000000000002, 
+  { 0.36079388642472821, -0.90000000000000002, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.52562093533067433, -0.90000000000000002, 0.40000000000000002, 
+  { 0.56455096667115612, -0.90000000000000002, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.70589461324915670, -0.90000000000000002, 0.40000000000000002, 
+  { 0.79990996997869435, -0.90000000000000002, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.89472658511942849, -0.90000000000000002, 0.40000000000000002, 
+  { 1.0836647913872215, -0.90000000000000002, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0987419542323440, -0.90000000000000002, 0.40000000000000002, 
+  { 1.4378726836091849, -0.90000000000000002, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.3261349565496303, -0.90000000000000002, 0.40000000000000002, 
+  { 1.8880446720682853, -0.90000000000000002, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.5831293909853765, -0.90000000000000002, 0.40000000000000002, 
+  { 2.4505848932025227, -0.90000000000000002, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002, 
+  { 3.1000689868578615, -0.90000000000000002, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler005 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4538944656036724e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.8944086593755267e-16
+// mean(f - f_Boost): 6.9388939039072284e-17
+// variance(f - f_Boost): 1.7333369499485123e-32
+// stddev(f - f_Boost): 1.3165625507162629e-16
 const testcase_ellint_3<double>
 data006[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17437497557073334, -0.90000000000000002, 0.50000000000000000, 
+  { 0.17614967734498183, -0.90000000000000002, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34804093691586013, -0.90000000000000002, 0.50000000000000000, 
+  { 0.36231594750319435, -0.90000000000000002, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.52137576320372891, -0.90000000000000002, 0.50000000000000000, 
+  { 0.57016256984349567, -0.90000000000000002, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.69655163996912262, -0.90000000000000002, 0.50000000000000000, 
+  { 0.81494025918293422, -0.90000000000000002, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.87783188683054236, -0.90000000000000002, 0.50000000000000000, 
+  { 1.1178482279283477, -0.90000000000000002, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 1.0716015959755185, -0.90000000000000002, 0.50000000000000000, 
+  { 1.5081455873012106, -0.90000000000000002, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.2857636916026749, -0.90000000000000002, 0.50000000000000000, 
+  { 2.0213599730863998, -0.90000000000000002, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.5264263913252363, -0.90000000000000002, 0.50000000000000000, 
+  { 2.6822467012926827, -0.90000000000000002, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000, 
+  { 3.4591069002104677, -0.90000000000000002, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler006 = 2.5000000000000020e-13;
 
-// Test data for k=-0.90000000000000002, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5560830683344639e-16
+// Test data for k=-0.90000000000000002, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.0602096790645418e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
 const testcase_ellint_3<double>
 data007[10] =
 {
-  { 0.0000000000000000, -0.90000000000000002, 0.59999999999999998, 
+  { 0.0000000000000000, -0.90000000000000002, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17420100334657812, -0.90000000000000002, 0.59999999999999998, 
+  { 0.17633073723493825, -0.90000000000000002, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34671975876122157, -0.90000000000000002, 0.59999999999999998, 
+  { 0.36386108723492810, -0.90000000000000002, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.51724631570707946, -0.90000000000000002, 0.59999999999999998, 
+  { 0.57597424744716241, -0.90000000000000002, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.68760879113743023, -0.90000000000000002, 0.59999999999999998, 
+  { 0.83098051948501150, -0.90000000000000002, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.86192157779698364, -0.90000000000000002, 0.59999999999999998, 
+  { 1.1558706545698916, -0.90000000000000002, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 1.0464279696166354, -0.90000000000000002, 0.59999999999999998, 
+  { 1.5905576379415669, -0.90000000000000002, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.2488156247094007, -0.90000000000000002, 0.59999999999999998, 
+  { 2.1875186010215080, -0.90000000000000002, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.4750988777188472, -0.90000000000000002, 0.59999999999999998, 
+  { 2.9885767771316849, -0.90000000000000002, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998, 
+  { 3.9549939883570224, -0.90000000000000002, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler007 = 2.5000000000000020e-13;
 
-// Test data for k=-0.90000000000000002, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.4833366769839281e-16
+// Test data for k=-0.90000000000000002, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1938610791060186e-16
+// mean(f - f_Boost): 3.0253577421035517e-16
+// variance(f - f_Boost): 4.2342877557562532e-32
+// stddev(f - f_Boost): 2.0577385051935665e-16
 const testcase_ellint_3<double>
 data008[10] =
 {
-  { 0.0000000000000000, -0.90000000000000002, 0.69999999999999996, 
+  { 0.0000000000000000, -0.90000000000000002, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17402765093102207, -0.90000000000000002, 0.69999999999999996, 
+  { 0.17651246700160939, -0.90000000000000002, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34541608382635131, -0.90000000000000002, 0.69999999999999996, 
+  { 0.36542993547358982, -0.90000000000000002, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.51322715827061682, -0.90000000000000002, 0.69999999999999996, 
+  { 0.58199897877674867, -0.90000000000000002, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.67903717872440272, -0.90000000000000002, 0.69999999999999996, 
+  { 0.84815633587352857, -0.90000000000000002, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.84690113601682671, -0.90000000000000002, 0.69999999999999996, 
+  { 1.1985495623872375, -0.90000000000000002, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 1.0229914311548418, -0.90000000000000002, 0.69999999999999996, 
+  { 1.6892158134027688, -0.90000000000000002, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.2148329639709381, -0.90000000000000002, 0.69999999999999996, 
+  { 2.4029722191094236, -0.90000000000000002, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.4283586501307803, -0.90000000000000002, 0.69999999999999996, 
+  { 3.4201084941340052, -0.90000000000000002, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.6600480747670940, -0.90000000000000002, 0.69999999999999996, 
+  { 4.6985482312992435, -0.90000000000000002, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler008 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7525301941362493e-16
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.5091520146032660e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 9.8950000698295322e-33
+// stddev(f - f_Boost): 9.9473614943006532e-17
 const testcase_ellint_3<double>
 data009[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17385491439925146, -0.90000000000000002, 0.80000000000000004, 
+  { 0.17669487107954862, -0.90000000000000002, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34412950523113928, -0.90000000000000002, 0.80000000000000004, 
+  { 0.36702314729628421, -0.90000000000000002, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50931321668729590, -0.90000000000000002, 0.80000000000000004, 
+  { 0.58825099711365492, -0.90000000000000002, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.67081081392296327, -0.90000000000000002, 0.80000000000000004, 
+  { 0.86661711422209031, -0.90000000000000002, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.83268846097293259, -0.90000000000000002, 0.80000000000000004, 
+  { 1.2469779109884802, -0.90000000000000002, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 1.0010985015814027, -0.90000000000000002, 0.80000000000000004, 
+  { 1.8105469760531578, -0.90000000000000002, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.1834394045489680, -0.90000000000000002, 0.80000000000000004, 
+  { 2.6989505165893752, -0.90000000000000002, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.3855695891683186, -0.90000000000000002, 0.80000000000000004, 
+  { 4.0935213267757424, -0.90000000000000002, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.6044591960982202, -0.90000000000000002, 0.80000000000000004, 
+  { 5.9820740813645710, -0.90000000000000002, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler009 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8471853989694167e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.2628580104449673e-16
+// mean(f - f_Boost): 8.5764728652293339e-16
+// variance(f - f_Boost): 8.9671393318321280e-31
+// stddev(f - f_Boost): 9.4694980499666013e-16
 const testcase_ellint_3<double>
 data010[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17368278986240135, -0.90000000000000002, 0.90000000000000002, 
+  { 0.17687795394604169, -0.90000000000000002, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34285962963961397, -0.90000000000000002, 0.90000000000000002, 
+  { 0.36864140434751286, -0.90000000000000002, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.50549974644993312, -0.90000000000000002, 0.90000000000000002, 
+  { 0.59474595366817051, -0.90000000000000002, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.66290623857720876, -0.90000000000000002, 0.90000000000000002, 
+  { 0.88654237226056665, -0.90000000000000002, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.81921183128847175, -0.90000000000000002, 0.90000000000000002, 
+  { 1.3026595810616726, -0.90000000000000002, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.98058481956066390, -0.90000000000000002, 0.90000000000000002, 
+  { 1.9653635459278078, -0.90000000000000002, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.1543223520473569, -0.90000000000000002, 0.90000000000000002, 
+  { 3.1451407527189463, -0.90000000000000002, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.3462119782292938, -0.90000000000000002, 0.90000000000000002, 
+  { 5.3745230680316114, -0.90000000000000002, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002, 
+  { 8.9942562031858682, -0.90000000000000002, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler010 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1175183168766718e-16
+// max(|f - f_Boost|): 1.5543122344752192e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7898565163847540e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.1368406725192426e-31
+// stddev(f - f_Boost): 4.6225974002926564e-16
 const testcase_ellint_3<double>
 data011[10] =
 {
@@ -338,289 +370,319 @@
 	  0.0000000000000000 },
   { 0.17510154241338899, -0.80000000000000004, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35365068839779390, -0.80000000000000004, 0.0000000000000000, 
+  { 0.35365068839779396, -0.80000000000000004, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.53926804409084550, -0.80000000000000004, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.73587926028070361, -0.80000000000000004, 0.0000000000000000, 
+  { 0.73587926028070372, -0.80000000000000004, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.94770942970071170, -0.80000000000000004, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1789022995388236, -0.80000000000000004, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.4323027881876009, -0.80000000000000004, 0.0000000000000000, 
+  { 1.4323027881876012, -0.80000000000000004, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.7069629739121674, -0.80000000000000004, 0.0000000000000000, 
+  { 1.7069629739121677, -0.80000000000000004, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000, 
+  { 1.9953027776647294, -0.80000000000000004, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler011 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1537164503193145e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3898786942190374e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.9190059990693968e-31
+// stddev(f - f_Boost): 5.4027826155319237e-16
 const testcase_ellint_3<double>
 data012[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17492468824017163, -0.80000000000000004, 0.10000000000000001, 
+  { 0.17527903952342144, -0.80000000000000004, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35224443521476911, -0.80000000000000004, 0.10000000000000001, 
+  { 0.35507705313548549, -0.80000000000000004, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53456851853226950, -0.80000000000000004, 0.10000000000000001, 
+  { 0.54411455987643553, -0.80000000000000004, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.72488875602364922, -0.80000000000000004, 0.10000000000000001, 
+  { 0.74745625666804383, -0.80000000000000004, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.92661354274638952, -0.80000000000000004, 0.10000000000000001, 
+  { 0.97046953684238557, -0.80000000000000004, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1432651144499075, -0.80000000000000004, 0.10000000000000001, 
+  { 1.2183080025184605, -0.80000000000000004, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.3774479927211429, -0.80000000000000004, 0.10000000000000001, 
+  { 1.4943711151994405, -0.80000000000000004, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.6287092337196041, -0.80000000000000004, 0.10000000000000001, 
+  { 1.7972401309544201, -0.80000000000000004, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001, 
+  { 2.1172616484005085, -0.80000000000000004, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler012 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1894552974436829e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.8513740186068518e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 2.7528339102381189e-31
+// stddev(f - f_Boost): 5.2467455724840699e-16
 const testcase_ellint_3<double>
 data013[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17474847286224940, -0.80000000000000004, 0.20000000000000001, 
+  { 0.17545718375086419, -0.80000000000000004, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.35085779529084682, -0.80000000000000004, 0.20000000000000001, 
+  { 0.35652404627248163, -0.80000000000000004, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.53000829263059146, -0.80000000000000004, 0.20000000000000001, 
+  { 0.54911638512920913, -0.80000000000000004, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.71443466027453384, -0.80000000000000004, 0.20000000000000001, 
+  { 0.75967684282131176, -0.80000000000000004, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.90698196872715420, -0.80000000000000004, 0.20000000000000001, 
+  { 0.99513526893543769, -0.80000000000000004, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.1108198200558579, -0.80000000000000004, 0.20000000000000001, 
+  { 1.2622192109995993, -0.80000000000000004, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.3284988909963957, -0.80000000000000004, 0.20000000000000001, 
+  { 1.5654106676347741, -0.80000000000000004, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.5600369318140328, -0.80000000000000004, 0.20000000000000001, 
+  { 1.9029531718534984, -0.80000000000000004, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001, 
+  { 2.2624789434186798, -0.80000000000000004, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler013 = 2.5000000000000020e-13;
 
-// Test data for k=-0.80000000000000004, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2247517409029886e-16
+// Test data for k=-0.80000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.2825261583337354e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 2.8249350208968825e-31
+// stddev(f - f_Boost): 5.3150117788175054e-16
 const testcase_ellint_3<double>
 data014[10] =
 {
-  { 0.0000000000000000, -0.80000000000000004, 0.29999999999999999, 
+  { 0.0000000000000000, -0.80000000000000004, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17457289217669889, -0.80000000000000004, 0.29999999999999999, 
+  { 0.17563597931587369, -0.80000000000000004, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34949028801501258, -0.80000000000000004, 0.29999999999999999, 
+  { 0.35799220412005128, -0.80000000000000004, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52558024362769307, -0.80000000000000004, 0.29999999999999999, 
+  { 0.55428253691111318, -0.80000000000000004, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.70447281740094891, -0.80000000000000004, 0.29999999999999999, 
+  { 0.77260647376977365, -0.80000000000000004, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.88864745641528986, -0.80000000000000004, 0.29999999999999999, 
+  { 1.0220015271210958, -0.80000000000000004, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0811075819341462, -0.80000000000000004, 0.29999999999999999, 
+  { 1.3115965312302671, -0.80000000000000004, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.2844589654082377, -0.80000000000000004, 0.29999999999999999, 
+  { 1.6478518468813512, -0.80000000000000004, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.4991461361277847, -0.80000000000000004, 0.29999999999999999, 
+  { 2.0290458414203481, -0.80000000000000004, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999, 
+  { 2.4392042002725693, -0.80000000000000004, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler014 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2596216594752862e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3462748389836647e-16
+// mean(f - f_Boost): 3.3861802251067273e-16
+// variance(f - f_Boost): 4.3719465706454422e-31
+// stddev(f - f_Boost): 6.6120696991527871e-16
 const testcase_ellint_3<double>
 data015[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17439794211872175, -0.80000000000000004, 0.40000000000000002, 
+  { 0.17581543047866136, -0.80000000000000004, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34814144964568972, -0.80000000000000004, 0.40000000000000002, 
+  { 0.35948208343061633, -0.80000000000000004, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.52127776285273064, -0.80000000000000004, 0.40000000000000002, 
+  { 0.55962280893702021, -0.80000000000000004, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.69496411438966588, -0.80000000000000004, 0.40000000000000002, 
+  { 0.78632063889234116, -0.80000000000000004, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.87146878427509589, -0.80000000000000004, 0.40000000000000002, 
+  { 1.0514333069550323, -0.80000000000000004, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0537579024937762, -0.80000000000000004, 0.40000000000000002, 
+  { 1.3677213138838757, -0.80000000000000004, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.2445534387922637, -0.80000000000000004, 0.40000000000000002, 
+  { 1.7451736773665165, -0.80000000000000004, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.4446769766361993, -0.80000000000000004, 0.40000000000000002, 
+  { 2.1830100424586831, -0.80000000000000004, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002, 
+  { 2.6604037035529724, -0.80000000000000004, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler015 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2940800093915668e-16
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0388243828581744e-16
+// mean(f - f_Boost): 3.8580250105724191e-16
+// variance(f - f_Boost): 6.4106456575047741e-31
+// stddev(f - f_Boost): 8.0066507713929764e-16
 const testcase_ellint_3<double>
 data016[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17422361866118044, -0.80000000000000004, 0.50000000000000000, 
+  { 0.17599554153999472, -0.80000000000000004, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34681083254170475, -0.80000000000000004, 0.50000000000000000, 
+  { 0.36099426243351540, -0.80000000000000004, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51709470815494440, -0.80000000000000004, 0.50000000000000000, 
+  { 0.56514786174780673, -0.80000000000000004, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.68587375344080237, -0.80000000000000004, 0.50000000000000000, 
+  { 0.80090697622371010, -0.80000000000000004, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.85532571852810624, -0.80000000000000004, 0.50000000000000000, 
+  { 1.0838891627679339, -0.80000000000000004, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 1.0284677391874903, -0.80000000000000004, 0.50000000000000000, 
+  { 1.4323506654466280, -0.80000000000000004, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.2081693942686225, -0.80000000000000004, 0.50000000000000000, 
+  { 1.8625761085390575, -0.80000000000000004, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.3955803006426311, -0.80000000000000004, 0.50000000000000000, 
+  { 2.3768757305654766, -0.80000000000000004, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000, 
+  { 2.9478781158239746, -0.80000000000000004, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler016 = 2.5000000000000020e-13;
 
-// Test data for k=-0.80000000000000004, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3281408974056389e-16
+// Test data for k=-0.80000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0631099169042069e-15
+// mean(f - f_Boost): 4.8294701571194306e-16
+// variance(f - f_Boost): 1.1633910328160319e-30
+// stddev(f - f_Boost): 1.0786060600682865e-15
 const testcase_ellint_3<double>
 data017[10] =
 {
-  { 0.0000000000000000, -0.80000000000000004, 0.59999999999999998, 
+  { 0.0000000000000000, -0.80000000000000004, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17404991781414089, -0.80000000000000004, 0.59999999999999998, 
+  { 0.17617631684170665, -0.80000000000000004, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34549800443625167, -0.80000000000000004, 0.59999999999999998, 
+  { 0.36252934193666231, -0.80000000000000004, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.51302536167001545, -0.80000000000000004, 0.59999999999999998, 
+  { 0.57086932622945163, -0.80000000000000004, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.67717065003912236, -0.80000000000000004, 0.59999999999999998, 
+  { 0.81646796740150973, -0.80000000000000004, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.84011512421134416, -0.80000000000000004, 0.59999999999999998, 
+  { 1.1199552158519064, -0.80000000000000004, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 1.0049863847088740, -0.80000000000000004, 0.59999999999999998, 
+  { 1.5079766673336394, -0.80000000000000004, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.1748145941898920, -0.80000000000000004, 0.59999999999999998, 
+  { 2.0082747447038165, -0.80000000000000004, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.3510319699755071, -0.80000000000000004, 0.59999999999999998, 
+  { 2.6315146066775523, -0.80000000000000004, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998, 
+  { 3.3418121892288051, -0.80000000000000004, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler017 = 2.5000000000000020e-13;
 
-// Test data for k=-0.80000000000000004, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3618176466061808e-16
+// Test data for k=-0.80000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.6544679145741375e-16
+// mean(f - f_Boost): 3.2751579226442120e-16
+// variance(f - f_Boost): 4.4236851331020672e-31
+// stddev(f - f_Boost): 6.6510789599147505e-16
 const testcase_ellint_3<double>
 data018[10] =
 {
-  { 0.0000000000000000, -0.80000000000000004, 0.69999999999999996, 
+  { 0.0000000000000000, -0.80000000000000004, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17387683562442199, -0.80000000000000004, 0.69999999999999996, 
+  { 0.17635776076721221, -0.80000000000000004, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34420254775101611, -0.80000000000000004, 0.69999999999999996, 
+  { 0.36408794649916976, -0.80000000000000004, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50906439222143673, -0.80000000000000004, 0.69999999999999996, 
+  { 0.57679992290624138, -0.80000000000000004, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.66882693152688422, -0.80000000000000004, 0.69999999999999996, 
+  { 0.83312441418142813, -0.80000000000000004, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.82574792844091316, -0.80000000000000004, 0.69999999999999996, 
+  { 1.1603958891464856, -0.80000000000000004, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.98310431309490931, -0.80000000000000004, 0.69999999999999996, 
+  { 1.5982855143796213, -0.80000000000000004, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.1440884535113258, -0.80000000000000004, 0.69999999999999996, 
+  { 2.1962484408371821, -0.80000000000000004, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.3103743938952537, -0.80000000000000004, 0.69999999999999996, 
+  { 2.9873281786111869, -0.80000000000000004, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996, 
+  { 3.9268876980046397, -0.80000000000000004, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler018 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3951228558314112e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0176949165011079e-16
+// mean(f - f_Boost): 7.0499162063697436e-16
+// variance(f - f_Boost): 1.7230805408026989e-30
+// stddev(f - f_Boost): 1.3126616246400665e-15
 const testcase_ellint_3<double>
 data019[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17370436817515203, -0.80000000000000004, 0.80000000000000004, 
+  { 0.17653987774203392, -0.80000000000000004, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34292405894783395, -0.80000000000000004, 0.80000000000000004, 
+  { 0.36567072568046877, -0.80000000000000004, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50520682176250076, -0.80000000000000004, 0.80000000000000004, 
+  { 0.58295359996558616, -0.80000000000000004, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.66081751679736178, -0.80000000000000004, 0.80000000000000004, 
+  { 0.85101998309176108, -0.80000000000000004, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.81214672249355102, -0.80000000000000004, 0.80000000000000004, 
+  { 1.2062322059736537, -0.80000000000000004, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.96264481387685552, -0.80000000000000004, 0.80000000000000004, 
+  { 1.7090321420917429, -0.80000000000000004, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.1156611352656258, -0.80000000000000004, 0.80000000000000004, 
+  { 2.4529058049405066, -0.80000000000000004, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.2730756225143889, -0.80000000000000004, 0.80000000000000004, 
+  { 3.5368893360106948, -0.80000000000000004, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.4339837018309471, -0.80000000000000004, 0.80000000000000004, 
+  { 4.9246422058196062, -0.80000000000000004, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler019 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.90000000000000002.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4280684534289690e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7782721357365268e-16
+// mean(f - f_Boost): 8.9928064994637676e-16
+// variance(f - f_Boost): 1.5485199571025344e-30
+// stddev(f - f_Boost): 1.2443954183066307e-15
 const testcase_ellint_3<double>
 data020[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17353251158533151, -0.80000000000000004, 0.90000000000000002, 
+  { 0.17672267223433513, -0.80000000000000004, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34166214791545768, -0.80000000000000004, 0.90000000000000002, 
+  { 0.36727835537196063, -0.80000000000000004, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.50144799535130569, -0.80000000000000004, 0.90000000000000002, 
+  { 0.58934569363716649, -0.80000000000000004, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.65311976193814425, -0.80000000000000004, 0.90000000000000002, 
+  { 0.87032723471138851, -0.80000000000000004, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.79924384892320866, -0.80000000000000004, 0.90000000000000002, 
+  { 1.2588676111323349, -0.80000000000000004, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.94345762353365603, -0.80000000000000004, 0.90000000000000002, 
+  { 1.8498731900660019, -0.80000000000000004, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0892582069219161, -0.80000000000000004, 0.90000000000000002, 
+  { 2.8368381299300420, -0.80000000000000004, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.2387000876610268, -0.80000000000000004, 0.90000000000000002, 
+  { 4.5674844191654058, -0.80000000000000004, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002, 
+  { 7.2263259298637115, -0.80000000000000004, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler020 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.0000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5930208052157665e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.5425633303580569e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 7.4564398834547797e-34
+// stddev(f - f_Boost): 2.7306482533374340e-17
 const testcase_ellint_3<double>
 data021[10] =
 {
@@ -628,289 +690,319 @@
 	  0.0000000000000000 },
   { 0.17496737466916723, -0.69999999999999996, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35254687535677925, -0.69999999999999996, 0.0000000000000000, 
+  { 0.35254687535677931, -0.69999999999999996, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.53536740275997119, -0.69999999999999996, 0.0000000000000000, 
+  { 0.53536740275997130, -0.69999999999999996, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.72603797651684454, -0.69999999999999996, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.92698296348313458, -0.69999999999999996, 0.0000000000000000, 
+  { 0.92698296348313447, -0.69999999999999996, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1400447527693316, -0.69999999999999996, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.3657668117194073, -0.69999999999999996, 0.0000000000000000, 
+  { 1.3657668117194071, -0.69999999999999996, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.6024686895959159, -0.69999999999999996, 0.0000000000000000, 
+  { 1.6024686895959162, -0.69999999999999996, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000, 
+  { 1.8456939983747234, -0.69999999999999996, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler021 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.10000000000000001.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6735282577377367e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.2736371663370261e-16
+// mean(f - f_Boost): 8.8817841970012528e-17
+// variance(f - f_Boost): 9.7390235212470591e-34
+// stddev(f - f_Boost): 3.1207408609570677e-17
 const testcase_ellint_3<double>
 data022[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17479076384884684, -0.69999999999999996, 0.10000000000000001, 
+  { 0.17514462737300920, -0.69999999999999996, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35114844900396364, -0.69999999999999996, 0.10000000000000001, 
+  { 0.35396527997470451, -0.69999999999999996, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53072776947527001, -0.69999999999999996, 0.10000000000000001, 
+  { 0.54015179589433981, -0.69999999999999996, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.71530198262386235, -0.69999999999999996, 0.10000000000000001, 
+  { 0.73734430854477728, -0.69999999999999996, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.90666760677828306, -0.69999999999999996, 0.10000000000000001, 
+  { 0.94888950796697047, -0.69999999999999996, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1063366517438080, -0.69999999999999996, 0.10000000000000001, 
+  { 1.1772807959736322, -0.69999999999999996, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.3149477243092149, -0.69999999999999996, 0.10000000000000001, 
+  { 1.4231796401075831, -0.69999999999999996, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.5314886725038925, -0.69999999999999996, 0.10000000000000001, 
+  { 1.6841856799887469, -0.69999999999999996, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001, 
+  { 1.9541347343119562, -0.69999999999999996, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler022 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.20000000000000001.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7517969287516802e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9907249355047774e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
 const testcase_ellint_3<double>
 data023[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17461479077791475, -0.69999999999999996, 0.20000000000000001, 
+  { 0.17532252613350796, -0.69999999999999996, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34976950621407538, -0.69999999999999996, 0.20000000000000001, 
+  { 0.35540417596807522, -0.69999999999999996, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52622533231350177, -0.69999999999999996, 0.20000000000000001, 
+  { 0.54508913033361928, -0.69999999999999996, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.70508774017895215, -0.69999999999999996, 0.20000000000000001, 
+  { 0.74927635777718415, -0.69999999999999996, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.88775302531730294, -0.69999999999999996, 0.20000000000000001, 
+  { 0.97261706337936338, -0.69999999999999996, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0756195476149006, -0.69999999999999996, 0.20000000000000001, 
+  { 1.2187303976209327, -0.69999999999999996, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.2695349716654374, -0.69999999999999996, 0.20000000000000001, 
+  { 1.4887796709222487, -0.69999999999999996, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.4690814617070540, -0.69999999999999996, 0.20000000000000001, 
+  { 1.7796581281839212, -0.69999999999999996, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.6721098780092145, -0.69999999999999996, 0.20000000000000001, 
+  { 2.0829290325820202, -0.69999999999999996, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler023 = 2.5000000000000020e-13;
 
-// Test data for k=-0.69999999999999996, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8280039841080712e-16
+// Test data for k=-0.69999999999999996, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.6912897610535316e-16
+// mean(f - f_Boost): 1.6653345369377347e-17
+// variance(f - f_Boost): 2.6207864467918357e-32
+// stddev(f - f_Boost): 1.6188843216214787e-16
 const testcase_ellint_3<double>
 data024[10] =
 {
-  { 0.0000000000000000, -0.69999999999999996, 0.29999999999999999, 
+  { 0.0000000000000000, -0.69999999999999996, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17443945136076175, -0.69999999999999996, 0.29999999999999999, 
+  { 0.17550107516328570, -0.69999999999999996, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34840956983535287, -0.69999999999999996, 0.29999999999999999, 
+  { 0.35686409576571959, -0.69999999999999996, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52185308551329168, -0.69999999999999996, 0.29999999999999999, 
+  { 0.55018827316513352, -0.69999999999999996, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.69535240431168255, -0.69999999999999996, 0.29999999999999999, 
+  { 0.76189759494390275, -0.69999999999999996, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.87007983473964923, -0.69999999999999996, 0.29999999999999999, 
+  { 0.99844623430885615, -0.69999999999999996, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0474657975577066, -0.69999999999999996, 0.29999999999999999, 
+  { 1.2652862989039833, -0.69999999999999996, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.2286225419931891, -0.69999999999999996, 0.29999999999999999, 
+  { 1.5647666808691361, -0.69999999999999996, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.4136490671013271, -0.69999999999999996, 0.29999999999999999, 
+  { 1.8932499694938163, -0.69999999999999996, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999, 
+  { 2.2392290510988535, -0.69999999999999996, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler024 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3472957053482092e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.5578567644745380e-16
+// mean(f - f_Boost): 1.4710455076283324e-16
+// variance(f - f_Boost): 2.6715739327327140e-33
+// stddev(f - f_Boost): 5.1687270509601433e-17
 const testcase_ellint_3<double>
 data025[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17426474153983229, -0.69999999999999996, 0.40000000000000002, 
+  { 0.17568027871494424, -0.69999999999999996, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34706817945773732, -0.69999999999999996, 0.40000000000000002, 
+  { 0.35834559208180261, -0.69999999999999996, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51760452851738148, -0.69999999999999996, 0.40000000000000002, 
+  { 0.55545885451190613, -0.69999999999999996, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.68605801534722755, -0.69999999999999996, 0.40000000000000002, 
+  { 0.77528120402568101, -0.69999999999999996, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.85351339387296532, -0.69999999999999996, 0.40000000000000002, 
+  { 1.0267241287600319, -0.69999999999999996, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0215297967969539, -0.69999999999999996, 0.40000000000000002, 
+  { 1.3181380338980246, -0.69999999999999996, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1915051074460530, -0.69999999999999996, 0.40000000000000002, 
+  { 1.6542840785132085, -0.69999999999999996, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.3639821911744707, -0.69999999999999996, 0.40000000000000002, 
+  { 2.0315595131131818, -0.69999999999999996, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002, 
+  { 2.4342502915307875, -0.69999999999999996, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler025 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.50000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.9748346743390620e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.0416041815443256e-16
+// mean(f - f_Boost): 1.9151347174783951e-16
+// variance(f - f_Boost): 7.8758646268991113e-33
+// stddev(f - f_Boost): 8.8746068233466605e-17
 const testcase_ellint_3<double>
 data026[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17409065729516096, -0.69999999999999996, 0.50000000000000000, 
+  { 0.17586014108156545, -0.69999999999999996, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34574489064986091, -0.69999999999999996, 0.50000000000000000, 
+  { 0.35984923894341653, -0.69999999999999996, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51347361925579782, -0.69999999999999996, 0.50000000000000000, 
+  { 0.56091135606739995, -0.69999999999999996, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.67717079489579279, -0.69999999999999996, 0.50000000000000000, 
+  { 0.78951212635197054, -0.69999999999999996, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.83793902055292280, -0.69999999999999996, 0.50000000000000000, 
+  { 1.0578865732938729, -0.69999999999999996, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.99752863545289705, -0.69999999999999996, 0.50000000000000000, 
+  { 1.3789149005151722, -0.69999999999999996, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.1576240080401501, -0.69999999999999996, 0.50000000000000000, 
+  { 1.7620212286086225, -0.69999999999999996, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.3191464023923762, -0.69999999999999996, 0.50000000000000000, 
+  { 2.2051554347435585, -0.69999999999999996, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000, 
+  { 2.6868019968236991, -0.69999999999999996, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler026 = 2.5000000000000020e-13;
 
-// Test data for k=-0.69999999999999996, nu=0.59999999999999998.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.0457157538295173e-16
+// Test data for k=-0.69999999999999996, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.6515644573247170e-16
+// mean(f - f_Boost): 9.9920072216264091e-17
+// variance(f - f_Boost): 1.2325951644078310e-33
+// stddev(f - f_Boost): 3.5108334685767011e-17
 const testcase_ellint_3<double>
 data027[10] =
 {
-  { 0.0000000000000000, -0.69999999999999996, 0.59999999999999998, 
+  { 0.0000000000000000, -0.69999999999999996, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17391719464391614, -0.69999999999999996, 0.59999999999999998, 
+  { 0.17604066659721918, -0.69999999999999996, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34443927423869031, -0.69999999999999996, 0.59999999999999998, 
+  { 0.36137563278353424, -0.69999999999999996, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50945473266486063, -0.69999999999999996, 0.59999999999999998, 
+  { 0.56655721272747606, -0.69999999999999996, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.66866056326513812, -0.69999999999999996, 0.59999999999999998, 
+  { 0.80468966552978305, -0.69999999999999996, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.82325830002337352, -0.69999999999999996, 0.59999999999999998, 
+  { 1.0924902943683852, -0.69999999999999996, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.97522808245669368, -0.69999999999999996, 0.59999999999999998, 
+  { 1.4499247992499797, -0.69999999999999996, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.1265300613705285, -0.69999999999999996, 0.59999999999999998, 
+  { 1.8953714382113815, -0.69999999999999996, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.2784066076152001, -0.69999999999999996, 0.59999999999999998, 
+  { 2.4323229949248670, -0.69999999999999996, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998, 
+  { 3.0314573496746742, -0.69999999999999996, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler027 = 2.5000000000000020e-13;
 
-// Test data for k=-0.69999999999999996, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 5.4867405596732161e-16
+// Test data for k=-0.69999999999999996, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.8475278552871384e-16
+// mean(f - f_Boost): 9.9920072216264091e-17
+// variance(f - f_Boost): 1.2325951644078310e-33
+// stddev(f - f_Boost): 3.5108334685767011e-17
 const testcase_ellint_3<double>
 data028[10] =
 {
-  { 0.0000000000000000, -0.69999999999999996, 0.69999999999999996, 
+  { 0.0000000000000000, -0.69999999999999996, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17374434963995031, -0.69999999999999996, 0.69999999999999996, 
+  { 0.17622185963747933, -0.69999999999999996, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34315091562900674, -0.69999999999999996, 0.69999999999999996, 
+  { 0.36292539360435261, -0.69999999999999996, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50554262375653347, -0.69999999999999996, 0.69999999999999996, 
+  { 0.57240892970150015, -0.69999999999999996, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.66050025406305801, -0.69999999999999996, 0.69999999999999996, 
+  { 0.82093084713182629, -0.69999999999999996, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.80938620118847404, -0.69999999999999996, 0.69999999999999996, 
+  { 1.1312609022179871, -0.69999999999999996, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.95443223855852144, -0.69999999999999996, 0.69999999999999996, 
+  { 1.5345768067715795, -0.69999999999999996, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0978573207128304, -0.69999999999999996, 0.69999999999999996, 
+  { 2.0668847445934420, -0.69999999999999996, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.2411754575007123, -0.69999999999999996, 0.69999999999999996, 
+  { 2.7483444537551240, -0.69999999999999996, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996, 
+  { 3.5408408771788560, -0.69999999999999996, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler028 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1829502028913879e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.8664526853112274e-16
+// mean(f - f_Boost): 1.6930901125533636e-16
+// variance(f - f_Boost): 3.5389557150937801e-33
+// stddev(f - f_Boost): 5.9489122661994095e-17
 const testcase_ellint_3<double>
 data029[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17357211837335740, -0.69999999999999996, 0.80000000000000004, 
+  { 0.17640372461994805, -0.69999999999999996, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34187941416012108, -0.69999999999999996, 0.80000000000000004, 
+  { 0.36449916621651091, -0.69999999999999996, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50173239465478259, -0.69999999999999996, 0.80000000000000004, 
+  { 0.57848021800372573, -0.69999999999999996, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.65266550725988315, -0.69999999999999996, 0.80000000000000004, 
+  { 0.83837480968392586, -0.69999999999999996, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.79624879865249298, -0.69999999999999996, 0.80000000000000004, 
+  { 1.1751669030061143, -0.69999999999999996, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.93497577043296920, -0.69999999999999996, 0.80000000000000004, 
+  { 1.6381851899173601, -0.69999999999999996, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0713041566930750, -0.69999999999999996, 0.80000000000000004, 
+  { 2.3002065924302197, -0.69999999999999996, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.2069772023255654, -0.69999999999999996, 0.80000000000000004, 
+  { 3.2337600665337862, -0.69999999999999996, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.3427110650397531, -0.69999999999999996, 0.80000000000000004, 
+  { 4.4042405729076961, -0.69999999999999996, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler029 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.90000000000000002.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2494869624129105e-16
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.5869439826269878e-16
+// mean(f - f_Boost): 6.7723604502134545e-16
+// variance(f - f_Boost): 4.8757508225668289e-31
+// stddev(f - f_Boost): 6.9826576763914390e-16
 const testcase_ellint_3<double>
 data030[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17340049697003637, -0.69999999999999996, 0.90000000000000002, 
+  { 0.17658626600478800, -0.69999999999999996, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34062438249741556, -0.69999999999999996, 0.90000000000000002, 
+  { 0.36609762156017206, -0.69999999999999996, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49801946510076867, -0.69999999999999996, 0.90000000000000002, 
+  { 0.58478615187842409, -0.69999999999999996, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.64513432604750476, -0.69999999999999996, 0.90000000000000002, 
+  { 0.85718862878291846, -0.69999999999999996, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.78378145487573758, -0.69999999999999996, 0.90000000000000002, 
+  { 1.2255385617397643, -0.69999999999999996, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.91671799500854623, -0.69999999999999996, 0.90000000000000002, 
+  { 1.7696521899992939, -0.69999999999999996, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0466193579463123, -0.69999999999999996, 0.90000000000000002, 
+  { 2.6476314987883502, -0.69999999999999996, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1754218079199146, -0.69999999999999996, 0.90000000000000002, 
+  { 4.1373434902898083, -0.69999999999999996, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.3040500499695913, -0.69999999999999996, 0.90000000000000002, 
+  { 6.3796094177887746, -0.69999999999999996, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler030 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.8964816695821429e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.3664899092028927e-16
+// mean(f - f_Boost): 5.2735593669694933e-17
+// variance(f - f_Boost): 3.4333862218458872e-34
+// stddev(f - f_Boost): 1.8529398861932589e-17
 const testcase_ellint_3<double>
 data031[10] =
 {
@@ -918,289 +1010,319 @@
 	  0.0000000000000000 },
   { 0.17485154362988359, -0.59999999999999998, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35160509865544326, -0.59999999999999998, 0.0000000000000000, 
+  { 0.35160509865544320, -0.59999999999999998, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.53210652578446138, -0.59999999999999998, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.71805304664485659, -0.59999999999999998, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.91082759030195970, -0.59999999999999998, 0.0000000000000000, 
+  { 0.91082759030195981, -0.59999999999999998, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1112333229323361, -0.59999999999999998, 0.0000000000000000, 
 	  1.0471975511965976 },
   { 1.3191461190365270, -0.59999999999999998, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.5332022105084773, -0.59999999999999998, 0.0000000000000000, 
+  { 1.5332022105084779, -0.59999999999999998, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000, 
+  { 1.7507538029157523, -0.59999999999999998, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler031 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.6674242225057385e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.2335247010355137e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 2.2835347143080263e-33
+// stddev(f - f_Boost): 4.7786344433405099e-17
 const testcase_ellint_3<double>
 data032[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17467514275022011, -0.59999999999999998, 0.10000000000000001, 
+  { 0.17502858548476194, -0.59999999999999998, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35021333086258255, -0.59999999999999998, 0.10000000000000001, 
+  { 0.35301673150537388, -0.59999999999999998, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52751664092962691, -0.59999999999999998, 0.10000000000000001, 
+  { 0.53683932476326812, -0.59999999999999998, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.70752126971957874, -0.59999999999999998, 0.10000000000000001, 
+  { 0.72914228589586771, -0.59999999999999998, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.89111058756112871, -0.59999999999999998, 0.10000000000000001, 
+  { 0.93208036718354692, -0.59999999999999998, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0789241202877768, -0.59999999999999998, 0.10000000000000001, 
+  { 1.1468984688863377, -0.59999999999999998, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2710800210399946, -0.59999999999999998, 0.10000000000000001, 
+  { 1.3733904977062528, -0.59999999999999998, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.4669060574440276, -0.59999999999999998, 0.10000000000000001, 
+  { 1.6094225663372157, -0.59999999999999998, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001, 
+  { 1.8508766487100685, -0.59999999999999998, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler032 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.20000000000000001.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1891472451898755e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0940560416437693e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
 const testcase_ellint_3<double>
 data033[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17449937871800650, -0.59999999999999998, 0.20000000000000001, 
+  { 0.17520627248155893, -0.59999999999999998, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34884093647346553, -0.59999999999999998, 0.20000000000000001, 
+  { 0.35444873935437748, -0.59999999999999998, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52306221119844087, -0.59999999999999998, 0.20000000000000001, 
+  { 0.54172310557682524, -0.59999999999999998, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.69749955678982223, -0.59999999999999998, 0.20000000000000001, 
+  { 0.74084300280734672, -0.59999999999999998, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.87274610682416853, -0.59999999999999998, 0.20000000000000001, 
+  { 0.95509001527006121, -0.59999999999999998, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0494620540750792, -0.59999999999999998, 0.20000000000000001, 
+  { 1.1865688084431796, -0.59999999999999998, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.2280847305507339, -0.59999999999999998, 0.20000000000000001, 
+  { 1.4352978868932598, -0.59999999999999998, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.4085436279696886, -0.59999999999999998, 0.20000000000000001, 
+  { 1.6983400371331816, -0.59999999999999998, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001, 
+  { 1.9695980282802215, -0.59999999999999998, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler033 = 2.5000000000000020e-13;
 
-// Test data for k=-0.59999999999999998, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.9132420715478757e-16
+// Test data for k=-0.59999999999999998, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.9470074709717020e-16
+// mean(f - f_Boost): 7.4940054162198071e-17
+// variance(f - f_Boost): 1.6823592487044846e-32
+// stddev(f - f_Boost): 1.2970579203352812e-16
 const testcase_ellint_3<double>
 data034[10] =
 {
-  { 0.0000000000000000, -0.59999999999999998, 0.29999999999999999, 
+  { 0.0000000000000000, -0.59999999999999998, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17432424744393932, -0.59999999999999998, 0.29999999999999999, 
+  { 0.17538460882640122, -0.59999999999999998, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34748744127146447, -0.59999999999999998, 0.29999999999999999, 
+  { 0.35590165133735557, -0.59999999999999998, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51873632743924825, -0.59999999999999998, 0.29999999999999999, 
+  { 0.54676661152254535, -0.59999999999999998, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.68794610396313116, -0.59999999999999998, 0.29999999999999999, 
+  { 0.75321709418305305, -0.59999999999999998, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.85558070175468726, -0.59999999999999998, 0.29999999999999999, 
+  { 0.98012637808992920, -0.59999999999999998, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0224416343605653, -0.59999999999999998, 0.29999999999999999, 
+  { 1.2310891277158875, -0.59999999999999998, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1893144457936788, -0.59999999999999998, 0.29999999999999999, 
+  { 1.5069157924585623, -0.59999999999999998, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.3566435377982575, -0.59999999999999998, 0.29999999999999999, 
+  { 1.8039583598337940, -0.59999999999999998, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999, 
+  { 2.1134154405060599, -0.59999999999999998, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler034 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3897581541285558e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.7909659715991921e-16
+// mean(f - f_Boost): -2.7755575615628915e-18
+// variance(f - f_Boost): 2.4044165394594425e-32
+// stddev(f - f_Boost): 1.5506181152880429e-16
 const testcase_ellint_3<double>
 data035[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17414974487670717, -0.59999999999999998, 0.40000000000000002, 
+  { 0.17556359876533037, -0.59999999999999998, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34615238767335027, -0.59999999999999998, 0.40000000000000002, 
+  { 0.35737601674244679, -0.59999999999999998, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51453257838108557, -0.59999999999999998, 0.40000000000000002, 
+  { 0.55197933771320218, -0.59999999999999998, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.67882386787534399, -0.59999999999999998, 0.40000000000000002, 
+  { 0.76633591620002894, -0.59999999999999998, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.83948470233173578, -0.59999999999999998, 0.40000000000000002, 
+  { 1.0075231136019616, -0.59999999999999998, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.99753496200073977, -0.59999999999999998, 0.40000000000000002, 
+  { 1.2815842073813450, -0.59999999999999998, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1541101404388487, -0.59999999999999998, 0.40000000000000002, 
+  { 1.5911666941449827, -0.59999999999999998, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.3100911323398814, -0.59999999999999998, 0.40000000000000002, 
+  { 1.9323227566025762, -0.59999999999999998, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002, 
+  { 2.2925036420985130, -0.59999999999999998, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler035 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5022138270566200e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6240126899196213e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.0357223256482469e-33
+// stddev(f - f_Boost): 3.2182640128619758e-17
 const testcase_ellint_3<double>
 data036[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17397586700252807, -0.59999999999999998, 0.50000000000000000, 
+  { 0.17574324658480217, -0.59999999999999998, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34483533397138516, -0.59999999999999998, 0.50000000000000000, 
+  { 0.35887240603169313, -0.59999999999999998, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51044500461706477, -0.59999999999999998, 0.50000000000000000, 
+  { 0.55737161826345261, -0.59999999999999998, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.67009988034712664, -0.59999999999999998, 0.50000000000000000, 
+  { 0.78028227313077458, -0.59999999999999998, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.82434762375735193, -0.59999999999999998, 0.50000000000000000, 
+  { 1.0376989776486290, -0.59999999999999998, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.97447346702798998, -0.59999999999999998, 0.50000000000000000, 
+  { 1.3395933991042925, -0.59999999999999998, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.1219494000522143, -0.59999999999999998, 0.50000000000000000, 
+  { 1.6924049626591782, -0.59999999999999998, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2680242605954484, -0.59999999999999998, 0.50000000000000000, 
+  { 2.0931011856518920, -0.59999999999999998, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000, 
+  { 2.5239007084492706, -0.59999999999999998, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler036 = 2.5000000000000020e-13;
 
-// Test data for k=-0.59999999999999998, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2504224329684343e-16
+// Test data for k=-0.59999999999999998, nu=0.60000000000000009.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.6651378277398083e-16
+// mean(f - f_Boost): 1.1934897514720432e-16
+// variance(f - f_Boost): 1.7585404776158019e-33
+// stddev(f - f_Boost): 4.1934955319110598e-17
 const testcase_ellint_3<double>
 data037[10] =
 {
-  { 0.0000000000000000, -0.59999999999999998, 0.59999999999999998, 
+  { 0.0000000000000000, -0.59999999999999998, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17380260984469353, -0.59999999999999998, 0.59999999999999998, 
+  { 0.17592355661219386, -0.59999999999999998, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34353585361777839, -0.59999999999999998, 0.59999999999999998, 
+  { 0.36039141192661606, -0.59999999999999998, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50646805774321380, -0.59999999999999998, 0.59999999999999998, 
+  { 0.56295472636903854, -0.59999999999999998, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.66174468108625506, -0.59999999999999998, 0.59999999999999998, 
+  { 0.79515295130165986, -0.59999999999999998, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.81007462280278408, -0.59999999999999998, 0.59999999999999998, 
+  { 1.0711886441942242, -0.59999999999999998, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.95303466945718729, -0.59999999999999998, 0.59999999999999998, 
+  { 1.4072952835139891, -0.59999999999999998, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0924118588677505, -0.59999999999999998, 0.59999999999999998, 
+  { 1.8174863977376825, -0.59999999999999998, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.2297640574847937, -0.59999999999999998, 0.59999999999999998, 
+  { 2.3029921578542232, -0.59999999999999998, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998, 
+  { 2.8388723099514972, -0.59999999999999998, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler037 = 2.5000000000000020e-13;
 
-// Test data for k=-0.59999999999999998, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3559889697529752e-16
+// Test data for k=-0.59999999999999998, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.2451074234797436e-16
+// mean(f - f_Boost): 5.2735593669694933e-17
+// variance(f - f_Boost): 3.4333862218458872e-34
+// stddev(f - f_Boost): 1.8529398861932589e-17
 const testcase_ellint_3<double>
 data038[10] =
 {
-  { 0.0000000000000000, -0.59999999999999998, 0.69999999999999996, 
+  { 0.0000000000000000, -0.59999999999999998, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17362996946312007, -0.59999999999999998, 0.69999999999999996, 
+  { 0.17610453321631936, -0.59999999999999998, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34225353454870588, -0.59999999999999998, 0.69999999999999996, 
+  { 0.36193365056369764, -0.59999999999999998, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50259656397799524, -0.59999999999999998, 0.69999999999999996, 
+  { 0.56874098962268527, -0.59999999999999998, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.65373184496628933, -0.59999999999999998, 0.69999999999999996, 
+  { 0.81106198671477181, -0.59999999999999998, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.79658372884056439, -0.59999999999999998, 0.69999999999999996, 
+  { 1.1086886419010082, -0.59999999999999998, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.93303240100245421, -0.59999999999999998, 0.69999999999999996, 
+  { 1.4879048567239257, -0.59999999999999998, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0651547944716557, -0.59999999999999998, 0.69999999999999996, 
+  { 1.9780310073615923, -0.59999999999999998, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1947676204853441, -0.59999999999999998, 0.69999999999999996, 
+  { 2.5941545586772712, -0.59999999999999998, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.3232737468822813, -0.59999999999999998, 0.69999999999999996, 
+  { 3.3029735898397155, -0.59999999999999998, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler038 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.80000000000000004.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.1879494682720725e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.3826960061025914e-16
+// mean(f - f_Boost): 2.7478019859472625e-16
+// variance(f - f_Boost): 4.6451528105588637e-32
+// stddev(f - f_Boost): 2.1552616570984749e-16
 const testcase_ellint_3<double>
 data039[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17345794195390685, -0.59999999999999998, 0.80000000000000004, 
+  { 0.17628618080795252, -0.59999999999999998, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34098797854531027, -0.59999999999999998, 0.80000000000000004, 
+  { 0.36349976272521012, -0.59999999999999998, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49882569168826213, -0.59999999999999998, 0.80000000000000004, 
+  { 0.57474392342151914, -0.59999999999999998, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.64603758566475511, -0.59999999999999998, 0.80000000000000004, 
+  { 0.82814493499158159, -0.59999999999999998, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.78380365594769730, -0.59999999999999998, 0.80000000000000004, 
+  { 1.1511281795998280, -0.59999999999999998, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.91430946255611190, -0.59999999999999998, 0.80000000000000004, 
+  { 1.5864286332503075, -0.59999999999999998, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0398955217270607, -0.59999999999999998, 0.80000000000000004, 
+  { 2.1958944866494527, -0.59999999999999998, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1625948314277679, -0.59999999999999998, 0.80000000000000004, 
+  { 3.0398358172574604, -0.59999999999999998, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004, 
+  { 4.0867036409261832, -0.59999999999999998, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler039 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.90000000000000002.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4768329326726447e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.7440178400898422e-16
+// mean(f - f_Boost): 5.0792703376600914e-16
+// variance(f - f_Boost): 1.9863137923719990e-31
+// stddev(f - f_Boost): 4.4568080420543122e-16
 const testcase_ellint_3<double>
 data040[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17328652344890030, -0.59999999999999998, 0.90000000000000002, 
+  { 0.17646850384035848, -0.59999999999999998, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33973880062929018, -0.59999999999999998, 0.90000000000000002, 
+  { 0.36509041515134105, -0.59999999999999998, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49515092233122743, -0.59999999999999998, 0.90000000000000002, 
+  { 0.58097838596260631, -0.59999999999999998, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.63864042139737043, -0.59999999999999998, 0.90000000000000002, 
+  { 0.84656453396163722, -0.59999999999999998, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.77167205646538850, -0.59999999999999998, 0.90000000000000002, 
+  { 1.1997828426963724, -0.59999999999999998, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.89673202848034383, -0.59999999999999998, 0.90000000000000002, 
+  { 1.7112436789225605, -0.59999999999999998, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0163984492661304, -0.59999999999999998, 0.90000000000000002, 
+  { 2.5193168553672312, -0.59999999999999998, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1328845785162431, -0.59999999999999998, 0.90000000000000002, 
+  { 3.8656670488606686, -0.59999999999999998, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002, 
+  { 5.8709993116265595, -0.59999999999999998, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler040 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.0000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1201497220602069e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.4551389361831220e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.5893058141206173e-32
+// stddev(f - f_Boost): 1.6091320064309879e-16
 const testcase_ellint_3<double>
 data041[10] =
 {
@@ -1208,1469 +1330,1619 @@
 	  0.0000000000000000 },
   { 0.17475385514035785, -0.50000000000000000, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35081868470101585, -0.50000000000000000, 0.0000000000000000, 
+  { 0.35081868470101579, -0.50000000000000000, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.52942862705190574, -0.50000000000000000, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.71164727562630314, -0.50000000000000000, 0.0000000000000000, 
+  { 0.71164727562630326, -0.50000000000000000, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.89824523594227768, -0.50000000000000000, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0895506700518851, -0.50000000000000000, 0.0000000000000000, 
+  { 1.0895506700518853, -0.50000000000000000, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2853005857432931, -0.50000000000000000, 0.0000000000000000, 
+  { 1.2853005857432933, -0.50000000000000000, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4845545520549484, -0.50000000000000000, 0.0000000000000000, 
+  { 1.4845545520549488, -0.50000000000000000, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000, 
+  { 1.6857503548125961, -0.50000000000000000, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler041 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.10000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1662857256911530e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7416868347177582e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
 const testcase_ellint_3<double>
 data042[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17457763120814676, -0.50000000000000000, 0.10000000000000001, 
+  { 0.17493071928248824, -0.50000000000000000, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34943246340849154, -0.50000000000000000, 0.10000000000000001, 
+  { 0.35222467688034798, -0.50000000000000000, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52487937869610790, -0.50000000000000000, 0.10000000000000001, 
+  { 0.53411928652008112, -0.50000000000000000, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.70127785096388384, -0.50000000000000000, 0.10000000000000001, 
+  { 0.72256398117177589, -0.50000000000000000, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.87898815988624479, -0.50000000000000000, 0.10000000000000001, 
+  { 0.91899583232771009, -0.50000000000000000, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0582764576094172, -0.50000000000000000, 0.10000000000000001, 
+  { 1.1240549163055360, -0.50000000000000000, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2391936844060205, -0.50000000000000000, 0.10000000000000001, 
+  { 1.3372938086286021, -0.50000000000000000, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.4214793542995841, -0.50000000000000000, 0.10000000000000001, 
+  { 1.5570024469132429, -0.50000000000000000, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001, 
+  { 1.7803034946545480, -0.50000000000000000, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler042 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.20000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2114786773102175e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1198767993730867e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 5.0311947683004831e-32
+// stddev(f - f_Boost): 2.2430324938128922e-16
 const testcase_ellint_3<double>
 data043[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17440204336345433, -0.50000000000000000, 0.20000000000000001, 
+  { 0.17510822779582402, -0.50000000000000000, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34806552388338824, -0.50000000000000000, 0.20000000000000001, 
+  { 0.35365094725531487, -0.50000000000000000, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52046416757129810, -0.50000000000000000, 0.20000000000000001, 
+  { 0.53895933237328697, -0.50000000000000000, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.69140924550993865, -0.50000000000000000, 0.20000000000000001, 
+  { 0.73408090840070794, -0.50000000000000000, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.86104678636125520, -0.50000000000000000, 0.20000000000000001, 
+  { 0.94145442818535396, -0.50000000000000000, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0297439459053981, -0.50000000000000000, 0.20000000000000001, 
+  { 1.1624120186296487, -0.50000000000000000, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1979214112912033, -0.50000000000000000, 0.20000000000000001, 
+  { 1.3965823372867114, -0.50000000000000000, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3659033858648930, -0.50000000000000000, 0.20000000000000001, 
+  { 1.6414308440430099, -0.50000000000000000, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001, 
+  { 1.8922947612264018, -0.50000000000000000, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler043 = 2.5000000000000020e-13;
 
-// Test data for k=-0.50000000000000000, nu=0.29999999999999999.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2557837230041312e-16
+// Test data for k=-0.50000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3800262770228813e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 8.5027191584278157e-32
+// stddev(f - f_Boost): 2.9159422419567599e-16
 const testcase_ellint_3<double>
 data044[10] =
 {
-  { 0.0000000000000000, -0.50000000000000000, 0.29999999999999999, 
+  { 0.0000000000000000, -0.50000000000000000, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17422708752228896, -0.50000000000000000, 0.29999999999999999, 
+  { 0.17528638488102041, -0.50000000000000000, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34671739434855858, -0.50000000000000000, 0.29999999999999999, 
+  { 0.35509802222332720, -0.50000000000000000, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51617616305641878, -0.50000000000000000, 0.29999999999999999, 
+  { 0.54395740731866193, -0.50000000000000000, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.68200047612545167, -0.50000000000000000, 0.29999999999999999, 
+  { 0.74625871438752667, -0.50000000000000000, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.84427217869498372, -0.50000000000000000, 0.29999999999999999, 
+  { 0.96588271186092023, -0.50000000000000000, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0035637821389782, -0.50000000000000000, 0.29999999999999999, 
+  { 1.2054319584357329, -0.50000000000000000, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1606800483933111, -0.50000000000000000, 0.29999999999999999, 
+  { 1.4651077994832871, -0.50000000000000000, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.3164407134643459, -0.50000000000000000, 0.29999999999999999, 
+  { 1.7416018368052644, -0.50000000000000000, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999, 
+  { 2.0277924458111314, -0.50000000000000000, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler044 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.40000000000000002.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2992508582900068e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.0439932918341581e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 9.0809736800018602e-32
+// stddev(f - f_Boost): 3.0134653938616686e-16
 const testcase_ellint_3<double>
 data045[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17405275963859917, -0.50000000000000000, 0.40000000000000002, 
+  { 0.17546519477859268, -0.50000000000000000, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34538761957029329, -0.50000000000000000, 0.40000000000000002, 
+  { 0.35656644822531680, -0.50000000000000000, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51200902646603907, -0.50000000000000000, 0.40000000000000002, 
+  { 0.54912289677411319, -0.50000000000000000, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.67301522212868792, -0.50000000000000000, 0.40000000000000002, 
+  { 0.75916731611690047, -0.50000000000000000, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.82853844466313320, -0.50000000000000000, 0.40000000000000002, 
+  { 0.99260415631328214, -0.50000000000000000, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.97942097862681488, -0.50000000000000000, 0.40000000000000002, 
+  { 1.2541925856918670, -0.50000000000000000, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1268429801220614, -0.50000000000000000, 0.40000000000000002, 
+  { 1.5456393705347609, -0.50000000000000000, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2720406704533922, -0.50000000000000000, 0.40000000000000002, 
+  { 1.8631904972952076, -0.50000000000000000, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002, 
+  { 2.1962905366178065, -0.50000000000000000, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler045 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.50000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3419255755184137e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6797816859260978e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
 const testcase_ellint_3<double>
 data046[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17387905570381157, -0.50000000000000000, 0.50000000000000000, 
+  { 0.17564466176941509, -0.50000000000000000, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34407576010465207, -0.50000000000000000, 0.50000000000000000, 
+  { 0.35805679276065394, -0.50000000000000000, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50795686560160824, -0.50000000000000000, 0.50000000000000000, 
+  { 0.55446601496200032, -0.50000000000000000, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.66442115453330164, -0.50000000000000000, 0.50000000000000000, 
+  { 0.77288783578259013, -0.50000000000000000, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.81373829119355345, -0.50000000000000000, 0.50000000000000000, 
+  { 1.0220246013918972, -0.50000000000000000, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.95705743313235825, -0.50000000000000000, 0.50000000000000000, 
+  { 1.3101681612463965, -0.50000000000000000, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0959131991362554, -0.50000000000000000, 0.50000000000000000, 
+  { 1.6422994881851025, -0.50000000000000000, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2318900529754597, -0.50000000000000000, 0.50000000000000000, 
+  { 2.0152636030998816, -0.50000000000000000, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000, 
+  { 2.4136715042011945, -0.50000000000000000, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler046 = 2.5000000000000020e-13;
 
-// Test data for k=-0.50000000000000000, nu=0.59999999999999998.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3838494104749599e-16
+// Test data for k=-0.50000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9178421578645735e-16
+// mean(f - f_Boost): 1.3322676295501878e-16
+// variance(f - f_Boost): 1.7749370367472766e-31
+// stddev(f - f_Boost): 4.2130001622920411e-16
 const testcase_ellint_3<double>
 data047[10] =
 {
-  { 0.0000000000000000, -0.50000000000000000, 0.59999999999999998, 
+  { 0.0000000000000000, -0.50000000000000000, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17370597174637581, -0.50000000000000000, 0.59999999999999998, 
+  { 0.17582479017522740, -0.50000000000000000, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34278139158591414, -0.50000000000000000, 0.59999999999999998, 
+  { 0.35956964546660036, -0.50000000000000000, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50401419439302708, -0.50000000000000000, 0.59999999999999998, 
+  { 0.55999790372984193, -0.50000000000000000, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.65618938076167210, -0.50000000000000000, 0.59999999999999998, 
+  { 0.78751507911209895, -0.50000000000000000, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.79977959248855424, -0.50000000000000000, 0.59999999999999998, 
+  { 1.0546620505035220, -0.50000000000000000, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.93625925190753545, -0.50000000000000000, 0.59999999999999998, 
+  { 1.3754438357425935, -0.50000000000000000, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0674905658379708, -0.50000000000000000, 0.59999999999999998, 
+  { 1.7615727400820127, -0.50000000000000000, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1953481298023050, -0.50000000000000000, 0.59999999999999998, 
+  { 2.2134638067565242, -0.50000000000000000, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998, 
+  { 2.7090491861753558, -0.50000000000000000, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler047 = 2.5000000000000020e-13;
 
-// Test data for k=-0.50000000000000000, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4250604066951477e-16
+// Test data for k=-0.50000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0745105182189226e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 1.9996383743576116e-32
+// stddev(f - f_Boost): 1.4140857026211713e-16
 const testcase_ellint_3<double>
 data048[10] =
 {
-  { 0.0000000000000000, -0.50000000000000000, 0.69999999999999996, 
+  { 0.0000000000000000, -0.50000000000000000, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17353350383131641, -0.50000000000000000, 0.69999999999999996, 
+  { 0.17600558435914915, -0.50000000000000000, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34150410405436771, -0.50000000000000000, 0.69999999999999996, 
+  { 0.36110561926726259, -0.50000000000000000, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50017589696443487, -0.50000000000000000, 0.69999999999999996, 
+  { 0.56573074641137111, -0.50000000000000000, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64829398188419951, -0.50000000000000000, 0.69999999999999996, 
+  { 0.80316073084237205, -0.50000000000000000, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.78658270782402073, -0.50000000000000000, 0.69999999999999996, 
+  { 1.0911910688131461, -0.50000000000000000, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.91684738336675053, -0.50000000000000000, 0.69999999999999996, 
+  { 1.4530946406380640, -0.50000000000000000, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0412486789555935, -0.50000000000000000, 0.69999999999999996, 
+  { 1.9144386536785372, -0.50000000000000000, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1619021847612001, -0.50000000000000000, 0.69999999999999996, 
+  { 2.4878788958234970, -0.50000000000000000, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996, 
+  { 3.1433945297859225, -0.50000000000000000, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler048 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5715240651179632e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.4380477375534667e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
 const testcase_ellint_3<double>
 data049[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17336164805979126, -0.50000000000000000, 0.80000000000000004, 
+  { 0.17618704872620228, -0.50000000000000000, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34024350132086773, -0.50000000000000000, 0.80000000000000004, 
+  { 0.36266535159745827, -0.50000000000000000, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49643719555734073, -0.50000000000000000, 0.80000000000000004, 
+  { 0.57167789954529158, -0.50000000000000000, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.64071162456976150, -0.50000000000000000, 0.80000000000000004, 
+  { 0.81995752984315018, -0.50000000000000000, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.77407836177211908, -0.50000000000000000, 0.80000000000000004, 
+  { 1.1325112162158122, -0.50000000000000000, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.89867058251905652, -0.50000000000000000, 0.80000000000000004, 
+  { 1.5479055930718042, -0.50000000000000000, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0169181822134910, -0.50000000000000000, 0.80000000000000004, 
+  { 2.1215243941010486, -0.50000000000000000, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1311363312779448, -0.50000000000000000, 0.80000000000000004, 
+  { 2.9069405767650132, -0.50000000000000000, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004, 
+  { 3.8750701888108066, -0.50000000000000000, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler049 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4664649039489274e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6192315188521289e-16
+// mean(f - f_Boost): 3.5249581031848718e-16
+// variance(f - f_Boost): 2.5029385557256515e-31
+// stddev(f - f_Boost): 5.0029376927217987e-16
 const testcase_ellint_3<double>
 data050[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17319040056865681, -0.50000000000000000, 0.90000000000000002, 
+  { 0.17636918772384180, -0.50000000000000000, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33899920036578557, -0.50000000000000000, 0.90000000000000002, 
+  { 0.36424950570740700, -0.50000000000000000, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49279362182695174, -0.50000000000000000, 0.90000000000000002, 
+  { 0.57785404590231426, -0.50000000000000000, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.63342123379746151, -0.50000000000000000, 0.90000000000000002, 
+  { 0.83806480521716531, -0.50000000000000000, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.76220595179550321, -0.50000000000000000, 0.90000000000000002, 
+  { 1.1798568683069752, -0.50000000000000000, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.88160004743532294, -0.50000000000000000, 0.90000000000000002, 
+  { 1.6678766243739607, -0.50000000000000000, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.99427448642310123, -0.50000000000000000, 0.90000000000000002, 
+  { 2.4282976450693483, -0.50000000000000000, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1027091512470095, -0.50000000000000000, 0.90000000000000002, 
+  { 3.6810787666126656, -0.50000000000000000, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002, 
+  { 5.5355132096026454, -0.50000000000000000, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler050 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.0000000000000000.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.0617918857203532e-16
+// Test data for k=-0.39999999999999991, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.1423314994346225e-16
+// mean(f - f_Boost): 1.9428902930940238e-17
+// variance(f - f_Boost): 2.2263750157116445e-32
+// stddev(f - f_Boost): 1.4921042241450980e-16
 const testcase_ellint_3<double>
 data051[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.0000000000000000, 
+  { 0.0000000000000000, -0.39999999999999991, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17467414669441528, -0.40000000000000002, 0.0000000000000000, 
+  { 0.17467414669441528, -0.39999999999999991, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35018222772483443, -0.40000000000000002, 0.0000000000000000, 
+  { 0.35018222772483443, -0.39999999999999991, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52729015917508737, -0.40000000000000002, 0.0000000000000000, 
+  { 0.52729015917508748, -0.39999999999999991, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70662374407341244, -0.40000000000000002, 0.0000000000000000, 
+  { 0.70662374407341244, -0.39999999999999991, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.88859210497602170, -0.40000000000000002, 0.0000000000000000, 
+  { 0.88859210497602159, -0.39999999999999991, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0733136290471379, -0.40000000000000002, 0.0000000000000000, 
+  { 1.0733136290471381, -0.39999999999999991, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2605612170157061, -0.40000000000000002, 0.0000000000000000, 
+  { 1.2605612170157066, -0.39999999999999991, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4497513956433439, -0.40000000000000002, 0.0000000000000000, 
+  { 1.4497513956433439, -0.39999999999999991, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000, 
+  { 1.6399998658645112, -0.39999999999999991, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler051 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.10000000000000001.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2644663257577874e-16
+// Test data for k=-0.39999999999999991, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.8489340395463703e-16
+// mean(f - f_Boost): 6.3837823915946496e-17
+// variance(f - f_Boost): 4.4785242050000272e-32
+// stddev(f - f_Boost): 2.1162523963365114e-16
 const testcase_ellint_3<double>
 data052[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.10000000000000001, 
+  { 0.0000000000000000, -0.39999999999999991, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17449806706684670, -0.40000000000000002, 0.10000000000000001, 
+  { 0.17485086590796767, -0.39999999999999991, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34880048623856075, -0.40000000000000002, 0.10000000000000001, 
+  { 0.35158366412506992, -0.39999999999999991, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52277322065757392, -0.40000000000000002, 0.10000000000000001, 
+  { 0.53194731675711726, -0.39999999999999991, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69638072056918365, -0.40000000000000002, 0.10000000000000001, 
+  { 0.71740615528010931, -0.39999999999999991, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.86968426619831540, -0.40000000000000002, 0.10000000000000001, 
+  { 0.90896157773487030, -0.39999999999999991, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0428044206578095, -0.40000000000000002, 0.10000000000000001, 
+  { 1.1069605483834348, -0.39999999999999991, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2158651158274378, -0.40000000000000002, 0.10000000000000001, 
+  { 1.3109353428823001, -0.39999999999999991, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3889447129893324, -0.40000000000000002, 0.10000000000000001, 
+  { 1.5195460789903448, -0.39999999999999991, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001, 
+  { 1.7306968836847187, -0.39999999999999991, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler052 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.20000000000000001.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4583049464169287e-16
+// Test data for k=-0.39999999999999991, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.0467985583872730e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 1.5826864298542218e-32
+// stddev(f - f_Boost): 1.2580486595733180e-16
 const testcase_ellint_3<double>
 data053[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.20000000000000001, 
+  { 0.0000000000000000, -0.39999999999999991, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17432262290723397, -0.40000000000000002, 0.20000000000000001, 
+  { 0.17502822886437389, -0.39999999999999991, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34743795258968596, -0.40000000000000002, 0.20000000000000001, 
+  { 0.35300530062530805, -0.39999999999999991, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51838919472805101, -0.40000000000000002, 0.20000000000000001, 
+  { 0.53675259548210896, -0.39999999999999991, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68663134739057907, -0.40000000000000002, 0.20000000000000001, 
+  { 0.72878006428676934, -0.39999999999999991, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.85206432981833979, -0.40000000000000002, 0.20000000000000001, 
+  { 0.93100219010583563, -0.39999999999999991, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0149595349004430, -0.40000000000000002, 0.20000000000000001, 
+  { 1.1443487271187609, -0.39999999999999991, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1758349405464676, -0.40000000000000002, 0.20000000000000001, 
+  { 1.3683427764108813, -0.39999999999999991, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3353337673882637, -0.40000000000000002, 0.20000000000000001, 
+  { 1.6008221459300933, -0.39999999999999991, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001, 
+  { 1.8380358826317627, -0.39999999999999991, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler053 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.29999999999999999.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.1925080711125793e-16
+// Test data for k=-0.39999999999999991, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.9973414591826100e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 1.5826864298542218e-32
+// stddev(f - f_Boost): 1.2580486595733180e-16
 const testcase_ellint_3<double>
 data054[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.29999999999999999, 
+  { 0.0000000000000000, -0.39999999999999991, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17414781013591540, -0.40000000000000002, 0.29999999999999999, 
+  { 0.17520623975982899, -0.39999999999999991, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34609415696777285, -0.40000000000000002, 0.29999999999999999, 
+  { 0.35444766141612105, -0.39999999999999991, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51413131295862535, -0.40000000000000002, 0.29999999999999999, 
+  { 0.54171455841536009, -0.39999999999999991, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67733527622935630, -0.40000000000000002, 0.29999999999999999, 
+  { 0.74080517001084012, -0.39999999999999991, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.83558675182733266, -0.40000000000000002, 0.29999999999999999, 
+  { 0.95496950509296563, -0.39999999999999991, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.98940140808865906, -0.40000000000000002, 0.29999999999999999, 
+  { 1.1862627879844718, -0.39999999999999991, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1396968797728058, -0.40000000000000002, 0.29999999999999999, 
+  { 1.4346501803799458, -0.39999999999999991, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2875920037865090, -0.40000000000000002, 0.29999999999999999, 
+  { 1.6971744798077697, -0.39999999999999991, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999, 
+  { 1.9677924132520139, -0.39999999999999991, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler054 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.40000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.8235661108581362e-16
+// Test data for k=-0.39999999999999991, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2577246923979600e-16
+// mean(f - f_Boost): 1.8596235662471373e-16
+// variance(f - f_Boost): 1.6222417021441306e-31
+// stddev(f - f_Boost): 4.0277061736727151e-16
 const testcase_ellint_3<double>
 data055[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.40000000000000002, 
+  { 0.0000000000000000, -0.39999999999999991, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17397362471112707, -0.40000000000000002, 0.40000000000000002, 
+  { 0.17538490283034375, -0.39999999999999991, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34476864603333196, -0.40000000000000002, 0.40000000000000002, 
+  { 0.35591129064319948, -0.39999999999999991, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50999329415379346, -0.40000000000000002, 0.40000000000000002, 
+  { 0.54684250413264535, -0.39999999999999991, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66845674551396006, -0.40000000000000002, 0.40000000000000002, 
+  { 0.75355027742668290, -0.39999999999999991, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.82012848346231748, -0.40000000000000002, 0.40000000000000002, 
+  { 0.98117935026780634, -0.39999999999999991, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.96582449258349057, -0.40000000000000002, 0.40000000000000002, 
+  { 1.2337464222030734, -0.39999999999999991, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1068473749476286, -0.40000000000000002, 0.40000000000000002, 
+  { 1.5125183419289221, -0.39999999999999991, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2447132729159989, -0.40000000000000002, 0.40000000000000002, 
+  { 1.8140224451130311, -0.39999999999999991, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002, 
+  { 2.1289968719280026, -0.39999999999999991, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler055 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.50000000000000000.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.9965792755639576e-16
+// Test data for k=-0.39999999999999991, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.8009196014748294e-16
+// mean(f - f_Boost): 1.6375789613221060e-16
+// variance(f - f_Boost): 6.4788283329186610e-32
+// stddev(f - f_Boost): 2.5453542647181080e-16
 const testcase_ellint_3<double>
 data056[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.50000000000000000, 
+  { 0.0000000000000000, -0.39999999999999991, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17380006262854136, -0.40000000000000002, 0.50000000000000000, 
+  { 0.17556422235224273, -0.39999999999999991, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34346098216756610, -0.40000000000000002, 0.50000000000000000, 
+  { 0.35739675341763921, -0.39999999999999991, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50596929935059420, -0.40000000000000002, 0.50000000000000000, 
+  { 0.55214655195037188, -0.39999999999999991, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65996392089131251, -0.40000000000000002, 0.50000000000000000, 
+  { 0.76709520942047438, -0.39999999999999991, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.80558463511364786, -0.40000000000000002, 0.50000000000000000, 
+  { 1.0100278761577499, -0.39999999999999991, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.94397834522857704, -0.40000000000000002, 0.50000000000000000, 
+  { 1.2882265661384342, -0.39999999999999991, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0768075114108115, -0.40000000000000002, 0.50000000000000000, 
+  { 1.6059059780051874, -0.39999999999999991, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2059184624251333, -0.40000000000000002, 0.50000000000000000, 
+  { 1.9600182740224081, -0.39999999999999991, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000, 
+  { 2.3367461373176508, -0.39999999999999991, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler056 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.59999999999999998.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.1640223038298069e-16
+// Test data for k=-0.39999999999999991, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.8411408870840790e-16
+// mean(f - f_Boost): 9.7144514654701197e-17
+// variance(f - f_Boost): 1.4860570558543486e-32
+// stddev(f - f_Boost): 1.2190393988113545e-16
 const testcase_ellint_3<double>
 data057[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.59999999999999998, 
+  { 0.0000000000000000, -0.39999999999999991, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17362711992081245, -0.40000000000000002, 0.59999999999999998, 
+  { 0.17574420264267029, -0.39999999999999991, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34217074276403953, -0.40000000000000002, 0.59999999999999998, 
+  { 0.35890463689046265, -0.39999999999999991, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50205389185761606, -0.40000000000000002, 0.59999999999999998, 
+  { 0.55763773975194486, -0.39999999999999991, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.65182834920372734, -0.40000000000000002, 0.59999999999999998, 
+  { 0.78153324227761267, -0.39999999999999991, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.79186512820565136, -0.40000000000000002, 0.59999999999999998, 
+  { 1.0420205885765887, -0.39999999999999991, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.92365535916287134, -0.40000000000000002, 0.59999999999999998, 
+  { 1.3517205230381770, -0.39999999999999991, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0491915663957907, -0.40000000000000002, 0.59999999999999998, 
+  { 1.7210360970313896, -0.39999999999999991, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1705934291745106, -0.40000000000000002, 0.59999999999999998, 
+  { 2.1500780510169242, -0.39999999999999991, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998, 
+  { 2.6186940209850191, -0.39999999999999991, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler057 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.3264047918332349e-16
+// Test data for k=-0.39999999999999991, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.1553900340611668e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.3242789405258207e-32
+// stddev(f - f_Boost): 1.1507731924779187e-16
 const testcase_ellint_3<double>
 data058[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.69999999999999996, 
+  { 0.0000000000000000, -0.39999999999999991, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17345479265712868, -0.40000000000000002, 0.69999999999999996, 
+  { 0.17592484806010436, -0.39999999999999991, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34089751955950354, -0.40000000000000002, 0.69999999999999996, 
+  { 0.36043555139631439, -0.39999999999999991, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49824200167361332, -0.40000000000000002, 0.69999999999999996, 
+  { 0.56332813669944881, -0.39999999999999991, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64402450341199402, -0.40000000000000002, 0.69999999999999996, 
+  { 0.79697424562157548, -0.39999999999999991, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.77889207804122873, -0.40000000000000002, 0.69999999999999996, 
+  { 1.0778155987523672, -0.39999999999999991, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.90468169720957992, -0.40000000000000002, 0.69999999999999996, 
+  { 1.4272018169896268, -0.39999999999999991, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0236847823692916, -0.40000000000000002, 0.69999999999999996, 
+  { 1.8684377907453380, -0.39999999999999991, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1382465247425166, -0.40000000000000002, 0.69999999999999996, 
+  { 2.4128677409207469, -0.39999999999999991, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996, 
+  { 3.0327078743873241, -0.39999999999999991, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler058 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.80000000000000004.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 6.6611561645571024e-16
+// Test data for k=-0.39999999999999991, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5727642219519274e-16
+// mean(f - f_Boost): 2.1926904736346843e-16
+// variance(f - f_Boost): 1.5293405480859847e-31
+// stddev(f - f_Boost): 3.9106783913868252e-16
 const testcase_ellint_3<double>
 data059[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.80000000000000004, 
+  { 0.0000000000000000, -0.39999999999999991, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17328307694277154, -0.40000000000000002, 0.80000000000000004, 
+  { 0.17610616300487833, -0.39999999999999991, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33964091800132007, -0.40000000000000002, 0.80000000000000004, 
+  { 0.36199013167171978, -0.39999999999999991, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49452889372467440, -0.40000000000000002, 0.80000000000000004, 
+  { 0.56923097361842423, -0.39999999999999991, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63652940095937316, -0.40000000000000002, 0.80000000000000004, 
+  { 0.81354878456624347, -0.39999999999999991, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.76659772511159097, -0.40000000000000002, 0.80000000000000004, 
+  { 1.1182902719261825, -0.39999999999999991, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.88691047977338111, -0.40000000000000002, 0.80000000000000004, 
+  { 1.5192950589409022, -0.39999999999999991, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0000273200611638, -0.40000000000000002, 0.80000000000000004, 
+  { 2.0678761710223981, -0.39999999999999991, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1084787902188009, -0.40000000000000002, 0.80000000000000004, 
+  { 2.8135222249879783, -0.39999999999999991, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004, 
+  { 3.7289548002199902, -0.39999999999999991, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler059 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.90000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.6376730823308004e-16
+// Test data for k=-0.39999999999999991, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.0221626338023938e-16
+// mean(f - f_Boost): 4.1910919179599658e-16
+// variance(f - f_Boost): 6.2246150910247033e-31
+// stddev(f - f_Boost): 7.8896229891070860e-16
 const testcase_ellint_3<double>
 data060[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.90000000000000002, 
+  { 0.0000000000000000, -0.39999999999999991, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17311196891868127, -0.40000000000000002, 0.90000000000000002, 
+  { 0.17628815191971123, -0.39999999999999991, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33840055664911906, -0.40000000000000002, 0.90000000000000002, 
+  { 0.36356903815378772, -0.39999999999999991, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49091013944075329, -0.40000000000000002, 0.90000000000000002, 
+  { 0.57536079447000310, -0.39999999999999991, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62932228186809580, -0.40000000000000002, 0.90000000000000002, 
+  { 0.83141355850172571, -0.39999999999999991, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.75492278323019801, -0.40000000000000002, 0.90000000000000002, 
+  { 1.1646481598721361, -0.39999999999999991, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.87021659043854294, -0.40000000000000002, 0.90000000000000002, 
+  { 1.6357275034001995, -0.39999999999999991, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.97800245228239246, -0.40000000000000002, 0.90000000000000002, 
+  { 2.3628787566572398, -0.39999999999999991, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0809625773173697, -0.40000000000000002, 0.90000000000000002, 
+  { 3.5521010369134958, -0.39999999999999991, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002, 
+  { 5.3055535102872513, -0.39999999999999991, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler060 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.0000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.3361874537309281e-16
+// Test data for k=-0.29999999999999993, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2241249691539529e-16
+// mean(f - f_Boost): 4.9960036108132046e-17
+// variance(f - f_Boost): 4.6872855002064458e-32
+// stddev(f - f_Boost): 2.1650139722889657e-16
 const testcase_ellint_3<double>
 data061[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.0000000000000000, 
+  { 0.0000000000000000, -0.29999999999999993, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17461228653000099, -0.30000000000000004, 0.0000000000000000, 
+  { 0.17461228653000099, -0.29999999999999993, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34969146102798415, -0.30000000000000004, 0.0000000000000000, 
+  { 0.34969146102798421, -0.29999999999999993, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52565822873726320, -0.30000000000000004, 0.0000000000000000, 
+  { 0.52565822873726309, -0.29999999999999993, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70284226512408532, -0.30000000000000004, 0.0000000000000000, 
+  { 0.70284226512408543, -0.29999999999999993, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.88144139195111182, -0.30000000000000004, 0.0000000000000000, 
+  { 0.88144139195111171, -0.29999999999999993, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0614897067260520, -0.30000000000000004, 0.0000000000000000, 
+  { 1.0614897067260520, -0.29999999999999993, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2428416824174218, -0.30000000000000004, 0.0000000000000000, 
+  { 1.2428416824174220, -0.29999999999999993, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4251795877015927, -0.30000000000000004, 0.0000000000000000, 
+  { 1.4251795877015929, -0.29999999999999993, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6080486199305128, -0.30000000000000004, 0.0000000000000000, 
+  { 1.6080486199305126, -0.29999999999999993, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler061 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.10000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.3908043711907203e-16
+// Test data for k=-0.29999999999999993, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1872304407982844e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 4.0359883022230488e-32
+// stddev(f - f_Boost): 2.0089769292411121e-16
 const testcase_ellint_3<double>
 data062[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.10000000000000001, 
+  { 0.0000000000000000, -0.29999999999999993, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17443631884814376, -0.30000000000000004, 0.10000000000000001, 
+  { 0.17478889331392972, -0.29999999999999993, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34831316835124926, -0.30000000000000004, 0.10000000000000001, 
+  { 0.35108939018329183, -0.29999999999999993, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52116586276523857, -0.30000000000000004, 0.10000000000000001, 
+  { 0.53028990896115835, -0.29999999999999993, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69269385837910036, -0.30000000000000004, 0.10000000000000001, 
+  { 0.71352417052371409, -0.29999999999999993, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.86279023163070856, -0.30000000000000004, 0.10000000000000001, 
+  { 0.90153086032405894, -0.29999999999999993, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0315321461438263, -0.30000000000000004, 0.10000000000000001, 
+  { 1.0945187977283313, -0.29999999999999993, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1991449111869024, -0.30000000000000004, 0.10000000000000001, 
+  { 1.2920699268385680, -0.29999999999999993, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3659561780923213, -0.30000000000000004, 0.10000000000000001, 
+  { 1.4931243665896394, -0.29999999999999993, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5323534693557528, -0.30000000000000004, 0.10000000000000001, 
+  { 1.6960848815118226, -0.29999999999999993, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler062 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.20000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4447238179454079e-16
+// Test data for k=-0.29999999999999993, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2247497610332889e-16
+// mean(f - f_Boost): 1.1102230246251565e-16
+// variance(f - f_Boost): 3.8043060629871325e-32
+// stddev(f - f_Boost): 1.9504630380981672e-16
 const testcase_ellint_3<double>
 data063[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.20000000000000001, 
+  { 0.0000000000000000, -0.29999999999999993, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17426098615372088, -0.30000000000000004, 0.20000000000000001, 
+  { 0.17496614335337535, -0.29999999999999993, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34695402664689923, -0.30000000000000004, 0.20000000000000001, 
+  { 0.35250745937139372, -0.29999999999999993, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51680555567038933, -0.30000000000000004, 0.20000000000000001, 
+  { 0.53506875002836884, -0.29999999999999993, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68303375225260210, -0.30000000000000004, 0.20000000000000001, 
+  { 0.72479106622248191, -0.29999999999999993, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.84540662891295026, -0.30000000000000004, 0.20000000000000001, 
+  { 0.92326451535891607, -0.29999999999999993, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0041834051646927, -0.30000000000000004, 0.20000000000000001, 
+  { 1.1312092060698349, -0.29999999999999993, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1599952702345711, -0.30000000000000004, 0.20000000000000001, 
+  { 1.3481473154592321, -0.29999999999999993, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3137179520499165, -0.30000000000000004, 0.20000000000000001, 
+  { 1.5722049569662748, -0.29999999999999993, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4663658145259877, -0.30000000000000004, 0.20000000000000001, 
+  { 1.8002173372290498, -0.29999999999999993, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler063 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.29999999999999999.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4979715256503266e-16
+// Test data for k=-0.29999999999999993, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1678685180047551e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
 const testcase_ellint_3<double>
 data064[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.29999999999999999, 
+  { 0.0000000000000000, -0.29999999999999993, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17408628437042842, -0.30000000000000004, 0.29999999999999999, 
+  { 0.17514404084107435, -0.29999999999999993, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34561356761638401, -0.30000000000000004, 0.29999999999999999, 
+  { 0.35394619108645647, -0.29999999999999993, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51257058617875850, -0.30000000000000004, 0.29999999999999999, 
+  { 0.54000325463372689, -0.29999999999999993, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67382207124602878, -0.30000000000000004, 0.29999999999999999, 
+  { 0.73670193794067651, -0.29999999999999993, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82914751587825131, -0.30000000000000004, 0.29999999999999999, 
+  { 0.94689345491722177, -0.29999999999999993, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.97907434814374938, -0.30000000000000004, 0.29999999999999999, 
+  { 1.1723274608389140, -0.29999999999999993, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1246399297351584, -0.30000000000000004, 0.29999999999999999, 
+  { 1.4128880552936287, -0.29999999999999993, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2671793970398149, -0.30000000000000004, 0.29999999999999999, 
+  { 1.6659010047449661, -0.29999999999999993, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4081767433479091, -0.30000000000000004, 0.29999999999999999, 
+  { 1.9260216862473254, -0.29999999999999993, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler064 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.5505716921759864e-16
+// Test data for k=-0.29999999999999993, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.3983279132797385e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.8245832308692586e-31
+// stddev(f - f_Boost): 4.2715140534349863e-16
 const testcase_ellint_3<double>
 data065[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.40000000000000002, 
+  { 0.0000000000000000, -0.29999999999999993, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17391220945982727, -0.30000000000000004, 0.40000000000000002, 
+  { 0.17532259000954434, -0.29999999999999993, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34429133937639689, -0.30000000000000004, 0.40000000000000002, 
+  { 0.35540612770983693, -0.29999999999999993, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50845471668581632, -0.30000000000000004, 0.40000000000000002, 
+  { 0.54510265552938919, -0.29999999999999993, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66502347027873854, -0.30000000000000004, 0.40000000000000002, 
+  { 0.74932476310965057, -0.29999999999999993, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.81389191978012254, -0.30000000000000004, 0.40000000000000002, 
+  { 0.97272793583093109, -0.29999999999999993, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.95590618002140570, -0.30000000000000004, 0.40000000000000002, 
+  { 1.2188928987074241, -0.29999999999999993, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0924915195213121, -0.30000000000000004, 0.40000000000000002, 
+  { 1.4888771674085941, -0.29999999999999993, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2253651604038061, -0.30000000000000004, 0.40000000000000002, 
+  { 1.7794558498219191, -0.29999999999999993, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3563643538969763, -0.30000000000000004, 0.40000000000000002, 
+  { 2.0822121773175528, -0.29999999999999993, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler065 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.50000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.7807908859023716e-16
+// Test data for k=-0.29999999999999993, nu=0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0516138451673425e-16
+// mean(f - f_Boost): 4.7184478546569152e-17
+// variance(f - f_Boost): 1.9448563670505968e-32
+// stddev(f - f_Boost): 1.3945810722401896e-16
 const testcase_ellint_3<double>
 data066[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.50000000000000000, 
+  { 0.0000000000000000, -0.29999999999999993, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17373875742088232, -0.30000000000000004, 0.50000000000000000, 
+  { 0.17550179513158179, -0.29999999999999993, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34298690571124157, -0.30000000000000004, 0.50000000000000000, 
+  { 0.35688783251681200, -0.29999999999999993, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50445214859646936, -0.30000000000000004, 0.50000000000000000, 
+  { 0.55037700010142798, -0.29999999999999993, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65660648352418516, -0.30000000000000004, 0.50000000000000000, 
+  { 0.76273839789895992, -0.29999999999999993, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79953670639287289, -0.30000000000000004, 0.50000000000000000, 
+  { 1.0011570518830419, -0.29999999999999993, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.93443393926588536, -0.30000000000000004, 0.50000000000000000, 
+  { 1.2722987414055109, -0.29999999999999993, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0630838369016911, -0.30000000000000004, 0.50000000000000000, 
+  { 1.5799590511080066, -0.29999999999999993, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1875197325653029, -0.30000000000000004, 0.50000000000000000, 
+  { 1.9212367220124293, -0.29999999999999993, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3098448759814962, -0.30000000000000004, 0.50000000000000000, 
+  { 2.2833505881933971, -0.29999999999999993, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler066 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.59999999999999998.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.0057999499931649e-16
+// Test data for k=-0.29999999999999993, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2121157428443725e-16
+// mean(f - f_Boost): 1.9428902930940239e-16
+// variance(f - f_Boost): 1.5987596229703424e-31
+// stddev(f - f_Boost): 3.9984492281012430e-16
 const testcase_ellint_3<double>
 data067[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.59999999999999998, 
+  { 0.0000000000000000, -0.29999999999999993, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17356592428950823, -0.30000000000000004, 0.59999999999999998, 
+  { 0.17568166052076745, -0.29999999999999993, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34169984536697379, -0.30000000000000004, 0.59999999999999998, 
+  { 0.35839189074731181, -0.29999999999999993, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50055748266498457, -0.30000000000000004, 0.59999999999999998, 
+  { 0.55583724744367558, -0.29999999999999993, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64854298527106768, -0.30000000000000004, 0.59999999999999998, 
+  { 0.77703498090888223, -0.29999999999999993, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.78599329284207431, -0.30000000000000004, 0.59999999999999998, 
+  { 1.0326772113675962, -0.29999999999999993, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.91445452089128199, -0.30000000000000004, 0.59999999999999998, 
+  { 1.3345139983717369, -0.29999999999999993, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0360412952290587, -0.30000000000000004, 0.59999999999999998, 
+  { 1.6921742922838403, -0.29999999999999993, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1530473919778641, -0.30000000000000004, 0.59999999999999998, 
+  { 2.1056608968472186, -0.29999999999999993, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2677758800420669, -0.30000000000000004, 0.59999999999999998, 
+  { 2.5560975528589061, -0.29999999999999993, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler067 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.69999999999999996.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.2239502844122443e-16
+// Test data for k=-0.29999999999999993, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0088945789059381e-16
+// mean(f - f_Boost): 1.6653345369377348e-16
+// variance(f - f_Boost): 3.1994213989721786e-31
+// stddev(f - f_Boost): 5.6563428104846852e-16
 const testcase_ellint_3<double>
 data068[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.69999999999999996, 
+  { 0.0000000000000000, -0.29999999999999993, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17339370613812224, -0.30000000000000004, 0.69999999999999996, 
+  { 0.17586219053197988, -0.29999999999999993, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34042975138455933, -0.30000000000000004, 0.69999999999999996, 
+  { 0.35991891074557669, -0.29999999999999993, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49676568368075985, -0.30000000000000004, 0.69999999999999996, 
+  { 0.56149538019961731, -0.29999999999999993, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64080774055753720, -0.30000000000000004, 0.69999999999999996, 
+  { 0.79232303189667685, -0.29999999999999993, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.77318507779667278, -0.30000000000000004, 0.69999999999999996, 
+  { 1.0679345542878826, -0.29999999999999993, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.89579782346548609, -0.30000000000000004, 0.69999999999999996, 
+  { 1.4084400085913955, -0.29999999999999993, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0110573286052202, -0.30000000000000004, 0.69999999999999996, 
+  { 1.8357382859296454, -0.29999999999999993, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1214710972949635, -0.30000000000000004, 0.69999999999999996, 
+  { 2.3604197996171519, -0.29999999999999993, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2294913236274982, -0.30000000000000004, 0.69999999999999996, 
+  { 2.9562123549913872, -0.29999999999999993, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler068 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.80000000000000004.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.4358357000101250e-16
+// Test data for k=-0.29999999999999993, nu=0.80000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1197887707781618e-16
+// mean(f - f_Boost): 3.4416913763379854e-16
+// variance(f - f_Boost): 4.3461914185990199e-31
+// stddev(f - f_Boost): 6.5925650687718054e-16
 const testcase_ellint_3<double>
 data069[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.80000000000000004, 
+  { 0.0000000000000000, -0.29999999999999993, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17322209907520358, -0.30000000000000004, 0.80000000000000004, 
+  { 0.17604338956191670, -0.29999999999999993, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33917623046949996, -0.30000000000000004, 0.80000000000000004, 
+  { 0.36146952517410791, -0.29999999999999993, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49307204894329176, -0.30000000000000004, 0.80000000000000004, 
+  { 0.56736453393774644, -0.29999999999999993, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63337802830291734, -0.30000000000000004, 0.80000000000000004, 
+  { 0.80873149979001091, -0.29999999999999993, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.76104540997689407, -0.30000000000000004, 0.80000000000000004, 
+  { 1.1077903069860620, -0.29999999999999993, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.87832009635450714, -0.30000000000000004, 0.80000000000000004, 
+  { 1.4985874311132998, -0.29999999999999993, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.98787879723171790, -0.30000000000000004, 0.80000000000000004, 
+  { 2.0298167266724954, -0.29999999999999993, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0924036340069339, -0.30000000000000004, 0.80000000000000004, 
+  { 2.7483929054985432, -0.29999999999999993, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1944567571590048, -0.30000000000000004, 0.80000000000000004, 
+  { 3.6283050484567170, -0.29999999999999993, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler069 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.90000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.6419688299804087e-16
+// Test data for k=-0.29999999999999993, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1301806687926828e-16
+// mean(f - f_Boost): 4.1633363423443370e-16
+// variance(f - f_Boost): 2.2835347143080263e-31
+// stddev(f - f_Boost): 4.7786344433405093e-16
 const testcase_ellint_3<double>
 data070[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.90000000000000002, 
+  { 0.0000000000000000, -0.29999999999999993, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17305109924485945, -0.30000000000000004, 0.90000000000000002, 
+  { 0.17622526204962433, -0.29999999999999993, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33793890239556984, -0.30000000000000004, 0.90000000000000002, 
+  { 0.36304439230777141, -0.29999999999999993, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48947218005089738, -0.30000000000000004, 0.90000000000000002, 
+  { 0.57345914744719195, -0.29999999999999993, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62623332340775151, -0.30000000000000004, 0.90000000000000002, 
+  { 0.82641512928845162, -0.29999999999999993, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74951596581511148, -0.30000000000000004, 0.90000000000000002, 
+  { 1.1534256210757743, -0.29999999999999993, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.86189886597755994, -0.30000000000000004, 0.90000000000000002, 
+  { 1.6124900353411677, -0.29999999999999993, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.96629451153092005, -0.30000000000000004, 0.90000000000000002, 
+  { 2.3165905514845089, -0.29999999999999993, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0655269133492682, -0.30000000000000004, 0.90000000000000002, 
+  { 3.4625619526539824, -0.29999999999999993, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1622376896064914, -0.30000000000000004, 0.90000000000000002, 
+  { 5.1479514944016787, -0.29999999999999993, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler070 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2156475739151676e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.2156475739151676e-16
+// mean(f - f_Boost): -5.2735593669694933e-17
+// variance(f - f_Boost): 3.0473442641042680e-32
+// stddev(f - f_Boost): 1.7456644190978597e-16
 const testcase_ellint_3<double>
 data071[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17456817290292809, -0.19999999999999996, 0.0000000000000000, 
+  { 0.17456817290292806, -0.19999999999999996, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34934315932086801, -0.19999999999999996, 0.0000000000000000, 
+  { 0.34934315932086796, -0.19999999999999996, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.52450880529443988, -0.19999999999999996, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70020491009844876, -0.19999999999999996, 0.0000000000000000, 
+  { 0.70020491009844887, -0.19999999999999996, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.87651006649967955, -0.19999999999999996, 0.0000000000000000, 
+  { 0.87651006649967977, -0.19999999999999996, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.0534305870298994, -0.19999999999999996, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2308975521670784, -0.19999999999999996, 0.0000000000000000, 
+  { 1.2308975521670789, -0.19999999999999996, 0.0000000000000000, 
 	  1.2217304763960306 },
   { 1.4087733584990738, -0.19999999999999996, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.5868678474541660, -0.19999999999999996, 0.0000000000000000, 
+  { 1.5868678474541662, -0.19999999999999996, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler071 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3374593253183472e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.0890622182605400e-16
+// mean(f - f_Boost): -3.8857805861880476e-17
+// variance(f - f_Boost): 2.8794792590749608e-32
+// stddev(f - f_Boost): 1.6969028431454054e-16
 const testcase_ellint_3<double>
 data072[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17439228502691748, -0.19999999999999996, 0.10000000000000001, 
+  { 0.17474469953608965, -0.19999999999999996, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34796731137565740, -0.19999999999999996, 0.10000000000000001, 
+  { 0.35073860234984255, -0.19999999999999996, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52003370294544848, -0.19999999999999996, 0.10000000000000001, 
+  { 0.52912258712951521, -0.19999999999999996, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69012222258631462, -0.19999999999999996, 0.10000000000000001, 
+  { 0.71081701558898069, -0.19999999999999996, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85803491465566772, -0.19999999999999996, 0.10000000000000001, 
+  { 0.89640758521169384, -0.19999999999999996, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0238463961099364, -0.19999999999999996, 0.10000000000000001, 
+  { 1.0860417038089853, -0.19999999999999996, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1878691059202153, -0.19999999999999996, 0.10000000000000001, 
+  { 1.2793599255528623, -0.19999999999999996, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3505985031831940, -0.19999999999999996, 0.10000000000000001, 
+  { 1.4754938544089076, -0.19999999999999996, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5126513474261087, -0.19999999999999996, 0.10000000000000001, 
+  { 1.6731552050562593, -0.19999999999999996, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler072 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4549984059502760e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.9570963716579749e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 3.1158217732380362e-32
+// stddev(f - f_Boost): 1.7651690494788412e-16
 const testcase_ellint_3<double>
 data073[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17421703179583747, -0.19999999999999996, 0.20000000000000001, 
+  { 0.17492186907740698, -0.19999999999999996, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34661057411998791, -0.19999999999999996, 0.20000000000000001, 
+  { 0.35215414286134267, -0.19999999999999996, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51569006052647393, -0.19999999999999996, 0.20000000000000001, 
+  { 0.53388285615182440, -0.19999999999999996, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68052412821107244, -0.19999999999999996, 0.20000000000000001, 
+  { 0.72200960282688265, -0.19999999999999996, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.84081341263313825, -0.19999999999999996, 0.20000000000000001, 
+  { 0.91793087614428526, -0.19999999999999996, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99683359988842890, -0.19999999999999996, 0.20000000000000001, 
+  { 1.1222602841587976, -0.19999999999999996, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1493086715118852, -0.19999999999999996, 0.20000000000000001, 
+  { 1.3345489407496247, -0.19999999999999996, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2992699693957541, -0.19999999999999996, 0.20000000000000001, 
+  { 1.5531225705475502, -0.19999999999999996, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4479323932249564, -0.19999999999999996, 0.20000000000000001, 
+  { 1.7751816279738935, -0.19999999999999996, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler073 = 2.5000000000000020e-13;
 
-// Test data for k=-0.19999999999999996, nu=0.29999999999999999.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.3140668101543467e-16
+// Test data for k=-0.19999999999999996, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.6785817924053817e-16
+// mean(f - f_Boost): -1.1102230246251566e-17
+// variance(f - f_Boost): 9.9840208317034302e-32
+// stddev(f - f_Boost): 3.1597501217190311e-16
 const testcase_ellint_3<double>
 data074[10] =
 {
-  { 0.0000000000000000, -0.19999999999999996, 0.29999999999999999, 
+  { 0.0000000000000000, -0.19999999999999996, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17404240913577704, -0.19999999999999996, 0.29999999999999999, 
+  { 0.17509968571715159, -0.19999999999999996, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34527248032587193, -0.19999999999999996, 0.29999999999999999, 
+  { 0.35359030214835629, -0.19999999999999996, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51147118981668416, -0.19999999999999996, 0.29999999999999999, 
+  { 0.53879807274537084, -0.19999999999999996, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67137107867777601, -0.19999999999999996, 0.29999999999999999, 
+  { 0.73384116418059731, -0.19999999999999996, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82470418188668893, -0.19999999999999996, 0.29999999999999999, 
+  { 0.94132799329524031, -0.19999999999999996, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.97202873223594299, -0.19999999999999996, 0.29999999999999999, 
+  { 1.1628407021801439, -0.19999999999999996, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1144773569375266, -0.19999999999999996, 0.29999999999999999, 
+  { 1.3982440216739438, -0.19999999999999996, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2535292433701000, -0.19999999999999996, 0.29999999999999999, 
+  { 1.6450634983653640, -0.19999999999999996, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3908453514752477, -0.19999999999999996, 0.29999999999999999, 
+  { 1.8983924169967099, -0.19999999999999996, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler074 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.6788709752760483e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3298410018355870e-16
+// mean(f - f_Boost): 1.3877787807814457e-17
+// variance(f - f_Boost): 9.4370567274974557e-32
+// stddev(f - f_Boost): 3.0719792850046133e-16
 const testcase_ellint_3<double>
 data075[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17386841301066674, -0.19999999999999996, 0.40000000000000002, 
+  { 0.17527815368535152, -0.19999999999999996, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34395257914113253, -0.19999999999999996, 0.40000000000000002, 
+  { 0.35504762134297801, -0.19999999999999996, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50737088376869466, -0.19999999999999996, 0.40000000000000002, 
+  { 0.54387742353211344, -0.19999999999999996, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66262801717277631, -0.19999999999999996, 0.40000000000000002, 
+  { 0.74637910471804259, -0.19999999999999996, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80958766645079094, -0.19999999999999996, 0.40000000000000002, 
+  { 0.96690539714174639, -0.19999999999999996, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94913754236162040, -0.19999999999999996, 0.40000000000000002, 
+  { 1.2087859420184757, -0.19999999999999996, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0827985514222997, -0.19999999999999996, 0.40000000000000002, 
+  { 1.4729799844168852, -0.19999999999999996, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2124212429050478, -0.19999999999999996, 0.40000000000000002, 
+  { 1.7564445064596661, -0.19999999999999996, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3400002519661005, -0.19999999999999996, 0.40000000000000002, 
+  { 2.0512956926676802, -0.19999999999999996, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler075 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7788201301356829e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3841806057292116e-16
+// mean(f - f_Boost): 8.0491169285323847e-17
+// variance(f - f_Boost): 8.0538110429953348e-32
+// stddev(f - f_Boost): 2.8379237204328335e-16
 const testcase_ellint_3<double>
 data076[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17369503942181799, -0.19999999999999996, 0.50000000000000000, 
+  { 0.17545727725228877, -0.19999999999999996, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34265043534362660, -0.19999999999999996, 0.50000000000000000, 
+  { 0.35652666242062175, -0.19999999999999996, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50338337208655415, -0.19999999999999996, 0.50000000000000000, 
+  { 0.54913090549102406, -0.19999999999999996, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65426373297163609, -0.19999999999999996, 0.50000000000000000, 
+  { 0.75970161209211551, -0.19999999999999996, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79536193036145808, -0.19999999999999996, 0.50000000000000000, 
+  { 0.99504737401590326, -0.19999999999999996, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92791875910061605, -0.19999999999999996, 0.50000000000000000, 
+  { 1.2614666007124373, -0.19999999999999996, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0538145052725829, -0.19999999999999996, 0.50000000000000000, 
+  { 1.5625255355205496, -0.19999999999999996, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1752060022875899, -0.19999999999999996, 0.50000000000000000, 
+  { 1.8954460255613343, -0.19999999999999996, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2943374404397372, -0.19999999999999996, 0.50000000000000000, 
+  { 2.2481046259421302, -0.19999999999999996, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler076 = 2.5000000000000020e-13;
 
-// Test data for k=-0.19999999999999996, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.8899223779598256e-16
+// Test data for k=-0.19999999999999996, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5317584994994743e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 1.0045745697575397e-31
+// stddev(f - f_Boost): 3.1695024369095219e-16
 const testcase_ellint_3<double>
 data077[10] =
 {
-  { 0.0000000000000000, -0.19999999999999996, 0.59999999999999998, 
+  { 0.0000000000000000, -0.19999999999999996, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17352228440746925, -0.19999999999999996, 0.59999999999999998, 
+  { 0.17563706072900442, -0.19999999999999996, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34136562863713626, -0.19999999999999996, 0.59999999999999998, 
+  { 0.35802800926807238, -0.19999999999999996, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49950328177638481, -0.19999999999999996, 0.59999999999999998, 
+  { 0.55456942250515051, -0.19999999999999996, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64625032705690799, -0.19999999999999996, 0.59999999999999998, 
+  { 0.77390003828438203, -0.19999999999999996, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.78193941198403083, -0.19999999999999996, 0.59999999999999998, 
+  { 1.0262441366366397, -0.19999999999999996, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90817230934317128, -0.19999999999999996, 0.59999999999999998, 
+  { 1.3228192988439669, -0.19999999999999996, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0271563751276462, -0.19999999999999996, 0.59999999999999998, 
+  { 1.6728005754680795, -0.19999999999999996, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1412999379040518, -0.19999999999999996, 0.59999999999999998, 
+  { 2.0761587107468511, -0.19999999999999996, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2530330675914556, -0.19999999999999996, 0.59999999999999998, 
+  { 2.5148333891629315, -0.19999999999999996, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler077 = 2.5000000000000020e-13;
 
-// Test data for k=-0.19999999999999996, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.9999318361775115e-16
+// Test data for k=-0.19999999999999996, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.1818454249546518e-16
+// mean(f - f_Boost): 3.6082248300317589e-17
+// variance(f - f_Boost): 8.9638010532618564e-32
+// stddev(f - f_Boost): 2.9939607634806868e-16
 const testcase_ellint_3<double>
 data078[10] =
 {
-  { 0.0000000000000000, -0.19999999999999996, 0.69999999999999996, 
+  { 0.0000000000000000, -0.19999999999999996, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17335014404233895, -0.19999999999999996, 0.69999999999999996, 
+  { 0.17581750846781172, -0.19999999999999996, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34009775298617811, -0.19999999999999996, 0.69999999999999996, 
+  { 0.35955226882028513, -0.19999999999999996, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49572560201923810, -0.19999999999999996, 0.69999999999999996, 
+  { 0.56020489659466499, -0.19999999999999996, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63856276669886503, -0.19999999999999996, 0.69999999999999996, 
+  { 0.78908196988531487, -0.19999999999999996, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76924438644867565, -0.19999999999999996, 0.69999999999999996, 
+  { 1.0611336754143517, -0.19999999999999996, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88973060843856466, -0.19999999999999996, 0.69999999999999996, 
+  { 1.3956969951058884, -0.19999999999999996, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0025230471636377, -0.19999999999999996, 0.69999999999999996, 
+  { 1.8138131612209609, -0.19999999999999996, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1102356376093103, -0.19999999999999996, 0.69999999999999996, 
+  { 2.3256365528879561, -0.19999999999999996, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2154356555075863, -0.19999999999999996, 0.69999999999999996, 
+  { 2.9058704854500963, -0.19999999999999996, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler078 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 5.0901276230707249e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9866614515542431e-16
+// mean(f - f_Boost): 1.8318679906315082e-16
+// variance(f - f_Boost): 3.1335688610218711e-31
+// stddev(f - f_Boost): 5.5978289193417400e-16
 const testcase_ellint_3<double>
 data079[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17317861443718538, -0.19999999999999996, 0.80000000000000004, 
+  { 0.17599862486281712, -0.19999999999999996, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33884641598718701, -0.19999999999999996, 0.80000000000000004, 
+  { 0.36110007227128776, -0.19999999999999996, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49204565281259494, -0.19999999999999996, 0.80000000000000004, 
+  { 0.56605039658567224, -0.19999999999999996, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63117851188220320, -0.19999999999999996, 0.80000000000000004, 
+  { 0.80537523874517691, -0.19999999999999996, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75721095949544170, -0.19999999999999996, 0.80000000000000004, 
+  { 1.1005662342414086, -0.19999999999999996, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.87245201443919118, -0.19999999999999996, 0.80000000000000004, 
+  { 1.4845340298105778, -0.19999999999999996, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97966584238831089, -0.19999999999999996, 0.80000000000000004, 
+  { 2.0043332244969392, -0.19999999999999996, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0816336325174360, -0.19999999999999996, 0.80000000000000004, 
+  { 2.7052856676744761, -0.19999999999999996, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1810223448909909, -0.19999999999999996, 0.80000000000000004, 
+  { 3.5622166386422629, -0.19999999999999996, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler079 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.90000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4833128442756722e-16
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2817178727913890e-16
+// mean(f - f_Boost): 3.4694469519536142e-16
+// variance(f - f_Boost): 6.6311432369155086e-31
+// stddev(f - f_Boost): 8.1431831840598485e-16
 const testcase_ellint_3<double>
 data080[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17300769173837277, -0.19999999999999996, 0.90000000000000002, 
+  { 0.17618041435044951, -0.19999999999999996, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33761123827372508, -0.19999999999999996, 0.90000000000000002, 
+  { 0.36267207636502929, -0.19999999999999996, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48845905690769426, -0.19999999999999996, 0.90000000000000002, 
+  { 0.57212028758237743, -0.19999999999999996, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62407720017324952, -0.19999999999999996, 0.90000000000000002, 
+  { 0.82293323876704483, -0.19999999999999996, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74578146525124289, -0.19999999999999996, 0.90000000000000002, 
+  { 1.1457077279880385, -0.19999999999999996, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85621583540073076, -0.19999999999999996, 0.90000000000000002, 
+  { 1.5967346899325681, -0.19999999999999996, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95837725988001199, -0.19999999999999996, 0.90000000000000002, 
+  { 2.2856537353421724, -0.19999999999999996, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0551821412633928, -0.19999999999999996, 0.90000000000000002, 
+  { 3.4034714304613902, -0.19999999999999996, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1493679916141861, -0.19999999999999996, 0.90000000000000002, 
+  { 5.0448269356200361, -0.19999999999999996, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler080 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1735566504509650e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.1735566504509645e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 8.2258607846939269e-33
+// stddev(f - f_Boost): 9.0696531271564778e-17
 const testcase_ellint_3<double>
 data081[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17454173353063659, -0.099999999999999978, 0.0000000000000000, 
+  { 0.17454173353063662, -0.099999999999999978, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34913506721468091, -0.099999999999999978, 0.0000000000000000, 
+  { 0.34913506721468096, -0.099999999999999978, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52382550016538942, -0.099999999999999978, 0.0000000000000000, 
+  { 0.52382550016538953, -0.099999999999999978, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.69864700854177020, -0.099999999999999978, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.87361792586964870, -0.099999999999999978, 0.0000000000000000, 
+  { 0.87361792586964859, -0.099999999999999978, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0487386319621683, -0.099999999999999978, 0.0000000000000000, 
+  { 1.0487386319621685, -0.099999999999999978, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2239913752078757, -0.099999999999999978, 0.0000000000000000, 
+  { 1.2239913752078759, -0.099999999999999978, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.3993423113684049, -0.099999999999999978, 0.0000000000000000, 
+  { 1.3993423113684051, -0.099999999999999978, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000, 
+  { 1.5747455615173558, -0.099999999999999978, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler081 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3097339877269682e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.0305747373482148e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
 const testcase_ellint_3<double>
 data082[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17436589347616613, -0.099999999999999978, 0.10000000000000001, 
+  { 0.17471821213559732, -0.099999999999999978, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34776067871237359, -0.099999999999999978, 0.10000000000000001, 
+  { 0.35052902610011138, -0.099999999999999978, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.51936064354727796, -0.099999999999999978, 0.10000000000000001, 
+  { 0.52842865990255727, -0.099999999999999978, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.68860303749364349, -0.099999999999999978, 0.10000000000000001, 
+  { 0.70921799731166713, -0.099999999999999978, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85524561882332051, -0.099999999999999978, 0.10000000000000001, 
+  { 0.89340330535868662, -0.099999999999999978, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0193708301908335, -0.099999999999999978, 0.10000000000000001, 
+  { 1.0811075784236857, -0.099999999999999978, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1813474067123044, -0.099999999999999978, 0.10000000000000001, 
+  { 1.2720133232666426, -0.099999999999999978, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3417670770424983, -0.099999999999999978, 0.10000000000000001, 
+  { 1.4653630031861395, -0.099999999999999978, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001, 
+  { 1.6600374067558428, -0.099999999999999978, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler082 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4399947764827574e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 1.6736714959992433e-16
+// mean(f - f_Boost): 5.5511151231257830e-18
+// variance(f - f_Boost): 3.8043060629871325e-36
+// stddev(f - f_Boost): 1.9504630380981673e-18
 const testcase_ellint_3<double>
 data083[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17419068786141340, -0.099999999999999978, 0.20000000000000001, 
+  { 0.17489533344059083, -0.099999999999999978, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34640537686230133, -0.099999999999999978, 0.20000000000000001, 
+  { 0.35194305707815038, -0.099999999999999978, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51502689171753946, -0.099999999999999978, 0.20000000000000001, 
+  { 0.53317790741512527, -0.099999999999999978, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.67904147863672715, -0.099999999999999978, 0.20000000000000001, 
+  { 0.72036681615081222, -0.099999999999999978, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.83811885126105179, -0.099999999999999978, 0.20000000000000001, 
+  { 0.91480372268244303, -0.099999999999999978, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99255278555742787, -0.099999999999999978, 0.20000000000000001, 
+  { 1.1170528708071514, -0.099999999999999978, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1431260546194930, -0.099999999999999978, 0.20000000000000001, 
+  { 1.3266916802718358, -0.099999999999999978, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2909589656532101, -0.099999999999999978, 0.20000000000000001, 
+  { 1.5421622241831547, -0.099999999999999978, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001, 
+  { 1.7608656115083421, -0.099999999999999978, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler083 = 2.5000000000000020e-13;
 
-// Test data for k=-0.099999999999999978, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5650492137236872e-16
+// Test data for k=-0.099999999999999978, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 1.9186071760326645e-16
+// mean(f - f_Boost): -1.6653345369377347e-17
+// variance(f - f_Boost): 3.4238754566884194e-35
+// stddev(f - f_Boost): 5.8513891142945016e-18
 const testcase_ellint_3<double>
 data084[10] =
 {
-  { 0.0000000000000000, -0.099999999999999978, 0.29999999999999999, 
+  { 0.0000000000000000, -0.099999999999999978, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17401611261390104, -0.099999999999999978, 0.29999999999999999, 
+  { 0.17507310163441189, -0.099999999999999978, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34506869507511773, -0.099999999999999978, 0.29999999999999999, 
+  { 0.35337768072524217, -0.099999999999999978, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51081757604259859, -0.099999999999999978, 0.29999999999999999, 
+  { 0.53808167801629170, -0.099999999999999978, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.66992297597712303, -0.099999999999999978, 0.29999999999999999, 
+  { 0.73215166755955019, -0.099999999999999978, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82209722856174228, -0.099999999999999978, 0.29999999999999999, 
+  { 0.93806546000201219, -0.099999999999999978, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.96792430487669590, -0.099999999999999978, 0.29999999999999999, 
+  { 1.1573218723395986, -0.099999999999999978, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1085964108954092, -0.099999999999999978, 0.29999999999999999, 
+  { 1.3897859679542097, -0.099999999999999978, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2456748370836999, -0.099999999999999978, 0.29999999999999999, 
+  { 1.6331009404328622, -0.099999999999999978, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999, 
+  { 1.8826015946315438, -0.099999999999999978, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler084 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6854758534459740e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0338059536914377e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 9.5107651574678308e-35
+// stddev(f - f_Boost): 9.7523151904908362e-18
 const testcase_ellint_3<double>
 data085[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17384216369897931, -0.099999999999999978, 0.40000000000000002, 
+  { 0.17525152094559704, -0.099999999999999978, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34375018311376787, -0.099999999999999978, 0.40000000000000002, 
+  { 0.35483343742825979, -0.099999999999999978, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50672650758380455, -0.099999999999999978, 0.40000000000000002, 
+  { 0.54314913099505446, -0.099999999999999978, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66121264213337616, -0.099999999999999978, 0.40000000000000002, 
+  { 0.74463962034766862, -0.099999999999999978, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80706202005774441, -0.099999999999999978, 0.40000000000000002, 
+  { 0.96349276837570441, -0.099999999999999978, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94519376138245870, -0.099999999999999978, 0.40000000000000002, 
+  { 1.2029081382746343, -0.099999999999999978, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0771880300759584, -0.099999999999999978, 0.40000000000000002, 
+  { 1.4638022887050806, -0.099999999999999978, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2049711557188272, -0.099999999999999978, 0.40000000000000002, 
+  { 1.7432413830105224, -0.099999999999999978, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002, 
+  { 2.0336367403076760, -0.099999999999999978, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler085 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8017534281650347e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.9864616042835278e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
 const testcase_ellint_3<double>
 data086[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17366883711936548, -0.099999999999999978, 0.50000000000000000, 
+  { 0.17543059564292182, -0.099999999999999978, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34244940634881882, -0.099999999999999978, 0.50000000000000000, 
+  { 0.35631088838721664, -0.099999999999999978, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50274793281634367, -0.099999999999999978, 0.50000000000000000, 
+  { 0.54839023346436444, -0.099999999999999978, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65287941633275082, -0.099999999999999978, 0.50000000000000000, 
+  { 0.75790846946088830, -0.099999999999999978, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79291198790315398, -0.099999999999999978, 0.50000000000000000, 
+  { 0.99146713686720678, -0.099999999999999978, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92412201537880323, -0.099999999999999978, 0.50000000000000000, 
+  { 1.2551692247937198, -0.099999999999999978, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0484480076799372, -0.099999999999999978, 0.50000000000000000, 
+  { 1.5524660788146873, -0.099999999999999978, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1681168130475206, -0.099999999999999978, 0.50000000000000000, 
+  { 1.8806578570830670, -0.099999999999999978, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000, 
+  { 2.2279868912966849, -0.099999999999999978, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler086 = 2.5000000000000020e-13;
 
-// Test data for k=-0.099999999999999978, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.9142834151672032e-16
+// Test data for k=-0.099999999999999978, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6726146516228014e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 1.6073193116120635e-34
+// stddev(f - f_Boost): 1.2678009747638087e-17
 const testcase_ellint_3<double>
 data087[10] =
 {
-  { 0.0000000000000000, -0.099999999999999978, 0.59999999999999998, 
+  { 0.0000000000000000, -0.099999999999999978, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17349612891469013, -0.099999999999999978, 0.59999999999999998, 
+  { 0.17561033003590576, -0.099999999999999978, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34116594505539444, -0.099999999999999978, 0.59999999999999998, 
+  { 0.35781061668171932, -0.099999999999999978, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49887649430466674, -0.099999999999999978, 0.59999999999999998, 
+  { 0.55381585659629196, -0.099999999999999978, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64489553282165146, -0.099999999999999978, 0.59999999999999998, 
+  { 0.77204910484575640, -0.099999999999999978, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.77956016553782437, -0.099999999999999978, 0.59999999999999998, 
+  { 1.0224751740393108, -0.099999999999999978, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90451074530096287, -0.099999999999999978, 0.59999999999999998, 
+  { 1.3160230906351114, -0.099999999999999978, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0220113666961632, -0.099999999999999978, 0.59999999999999998, 
+  { 1.6616282844233206, -0.099999999999999978, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1345351441065563, -0.099999999999999978, 0.59999999999999998, 
+  { 2.0592555664850392, -0.099999999999999978, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998, 
+  { 2.4913004919173822, -0.099999999999999978, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler087 = 2.5000000000000020e-13;
 
-// Test data for k=-0.099999999999999978, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.5172091551439012e-16
+// Test data for k=-0.099999999999999978, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 2.1004074871280821e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
 const testcase_ellint_3<double>
 data088[10] =
 {
-  { 0.0000000000000000, -0.099999999999999978, 0.69999999999999996, 
+  { 0.0000000000000000, -0.099999999999999978, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17332403516105047, -0.099999999999999978, 0.69999999999999996, 
+  { 0.17579072847532518, -0.099999999999999978, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.33989939374896883, -0.099999999999999978, 0.69999999999999996, 
+  { 0.35933322840606297, -0.099999999999999978, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49510719568614070, -0.099999999999999978, 0.69999999999999996, 
+  { 0.55943788649460324, -0.099999999999999978, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63723607776354974, -0.099999999999999978, 0.69999999999999996, 
+  { 0.78716856504031707, -0.099999999999999978, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76693133887935327, -0.099999999999999978, 0.69999999999999996, 
+  { 1.0571501305617423, -0.099999999999999978, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88619382078823805, -0.099999999999999978, 0.69999999999999996, 
+  { 1.3882948301743525, -0.099999999999999978, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 0.99758012018676490, -0.099999999999999978, 0.69999999999999996, 
+  { 1.8011785680114223, -0.099999999999999978, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1037642270814410, -0.099999999999999978, 0.69999999999999996, 
+  { 2.3057268183616464, -0.099999999999999978, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2073745911083185, -0.099999999999999978, 0.69999999999999996, 
+  { 2.8771910188009739, -0.099999999999999978, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler088 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1294144515772258e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.3133043868392355e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 6.1843750436434569e-32
+// stddev(f - f_Boost): 2.4868403735751633e-16
 const testcase_ellint_3<double>
 data089[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17315255197057014, -0.099999999999999978, 0.80000000000000004, 
+  { 0.17597179535373417, -0.099999999999999978, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33864936055747991, -0.099999999999999978, 0.80000000000000004, 
+  { 0.36087935387831499, -0.099999999999999978, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49143537041117613, -0.099999999999999978, 0.80000000000000004, 
+  { 0.56526935244526444, -0.099999999999999978, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.62987861760047492, -0.099999999999999978, 0.80000000000000004, 
+  { 0.80339402590612397, -0.099999999999999978, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75496005490917517, -0.099999999999999978, 0.80000000000000004, 
+  { 1.0963358646374459, -0.099999999999999978, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.86903081862701881, -0.099999999999999978, 0.80000000000000004, 
+  { 1.4763748483246868, -0.099999999999999978, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97490814820725591, -0.099999999999999978, 0.80000000000000004, 
+  { 1.9896610222794102, -0.099999999999999978, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0754290107171083, -0.099999999999999978, 0.80000000000000004, 
+  { 2.6806423920122024, -0.099999999999999978, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004, 
+  { 3.5246199613295612, -0.099999999999999978, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler089 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2325599449457852e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5624826890976725e-16
+// mean(f - f_Boost): 2.3314683517128288e-16
+// variance(f - f_Boost): 2.9401198977189756e-31
+// stddev(f - f_Boost): 5.4222872459129045e-16
 const testcase_ellint_3<double>
 data090[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17298167549096563, -0.099999999999999978, 0.90000000000000002, 
+  { 0.17615353510599349, -0.099999999999999978, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33741546662741589, -0.099999999999999978, 0.90000000000000002, 
+  { 0.36244964892922371, -0.099999999999999978, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48785665376856868, -0.099999999999999978, 0.90000000000000002, 
+  { 0.57132457590110530, -0.099999999999999978, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62280288554518959, -0.099999999999999978, 0.90000000000000002, 
+  { 0.82087808820385000, -0.099999999999999978, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74358903115455188, -0.099999999999999978, 0.90000000000000002, 
+  { 1.1411894342144451, -0.099999999999999978, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85290207679298335, -0.099999999999999978, 0.90000000000000002, 
+  { 1.5875929286844597, -0.099999999999999978, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95379006645397379, -0.099999999999999978, 0.90000000000000002, 
+  { 2.2678622986596659, -0.099999999999999978, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0492213119872327, -0.099999999999999978, 0.90000000000000002, 
+  { 3.3697528941897903, -0.099999999999999978, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002, 
+  { 4.9862890417305499, -0.099999999999999978, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler090 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.0000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.1203697876423452e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.1203697876423447e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data091[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17453292519943292, 0.0000000000000000, 0.0000000000000000, 
+  { 0.17453292519943295, 0.0000000000000000, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34906585039886584, 0.0000000000000000, 0.0000000000000000, 
+  { 0.34906585039886590, 0.0000000000000000, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52359877559829870, 0.0000000000000000, 0.0000000000000000, 
+  { 0.52359877559829882, 0.0000000000000000, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.69813170079773168, 0.0000000000000000, 0.0000000000000000, 
+  { 0.69813170079773179, 0.0000000000000000, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.87266462599716477, 0.0000000000000000, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0471975511965974, 0.0000000000000000, 0.0000000000000000, 
+  { 1.0471975511965976, 0.0000000000000000, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2217304763960304, 0.0000000000000000, 0.0000000000000000, 
+  { 1.2217304763960306, 0.0000000000000000, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.3962634015954631, 0.0000000000000000, 0.0000000000000000, 
+  { 1.3962634015954636, 0.0000000000000000, 0.0000000000000000, 
 	  1.3962634015954636 },
   { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000, 
 	  1.5707963267948966 },
@@ -2678,849 +2950,939 @@
 const double toler091 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.10000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.1813975824747021e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.1019052604815601e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 9.5107651574678312e-37
+// stddev(f - f_Boost): 9.7523151904908366e-19
 const testcase_ellint_3<double>
 data092[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17435710107516605, 0.0000000000000000, 0.10000000000000001, 
+  { 0.17470938780535167, 0.0000000000000000, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34769194715329604, 0.0000000000000000, 0.10000000000000001, 
+  { 0.35045931581655582, 0.0000000000000000, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.51913731575866107, 0.0000000000000000, 0.10000000000000001, 
+  { 0.52819841383849875, 0.0000000000000000, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.68810051897078450, 0.0000000000000000, 0.10000000000000001, 
+  { 0.70868910807992958, 0.0000000000000000, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85432615661706823, 0.0000000000000000, 0.10000000000000001, 
+  { 0.89241311307249638, 0.0000000000000000, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0179006647340794, 0.0000000000000000, 0.10000000000000001, 
+  { 1.0794871444666669, 0.0000000000000000, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1792120640746322, 0.0000000000000000, 0.10000000000000001, 
+  { 1.2696086247356864, 0.0000000000000000, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3388834245070498, 0.0000000000000000, 0.10000000000000001, 
+  { 1.4620562617494721, 0.0000000000000000, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001, 
+  { 1.6557647109660167, 0.0000000000000000, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler092 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.20000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.2402804784409065e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0831888697465320e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data093[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17418191132226074, 0.0000000000000000, 0.20000000000000001, 
+  { 0.17488649304197776, 0.0000000000000000, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34633712256943405, 0.0000000000000000, 0.20000000000000001, 
+  { 0.35187284488675424, 0.0000000000000000, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51480684302043700, 0.0000000000000000, 0.20000000000000001, 
+  { 0.53294400750146131, 0.0000000000000000, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.67855102942481937, 0.0000000000000000, 0.20000000000000001, 
+  { 0.71982347021822823, 0.0000000000000000, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.83723056090326253, 0.0000000000000000, 0.20000000000000001, 
+  { 0.91377311030258745, 0.0000000000000000, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99114645269578161, 0.0000000000000000, 0.20000000000000001, 
+  { 1.1153429007215137, 0.0000000000000000, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1411014627915537, 0.0000000000000000, 0.20000000000000001, 
+  { 1.3241202847784086, 0.0000000000000000, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2882448138013969, 0.0000000000000000, 0.20000000000000001, 
+  { 1.5385854914338242, 0.0000000000000000, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001, 
+  { 1.7562036827601815, 0.0000000000000000, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler093 = 2.5000000000000020e-13;
 
-// Test data for k=0.0000000000000000, nu=0.29999999999999999.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.2972291118632678e-16
+// Test data for k=0.0000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0642101770923591e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data094[10] =
 {
-  { 0.0000000000000000, 0.0000000000000000, 0.29999999999999999, 
+  { 0.0000000000000000, 0.0000000000000000, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17400735186871724, 0.0000000000000000, 0.29999999999999999, 
+  { 0.17506424509761404, 0.0000000000000000, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34500091027020219, 0.0000000000000000, 0.29999999999999999, 
+  { 0.35330695794774630, 0.0000000000000000, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51060069523901530, 0.0000000000000000, 0.29999999999999999, 
+  { 0.53784398359522367, 0.0000000000000000, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.66944393961375448, 0.0000000000000000, 0.29999999999999999, 
+  { 0.73159289408687844, 0.0000000000000000, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82123776744538157, 0.0000000000000000, 0.29999999999999999, 
+  { 0.93699031797084975, 0.0000000000000000, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.96657579245516501, 0.0000000000000000, 0.29999999999999999, 
+  { 1.1555098909390267, 0.0000000000000000, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1066703663542414, 0.0000000000000000, 0.29999999999999999, 
+  { 1.3870184960144325, 0.0000000000000000, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2431094251944901, 0.0000000000000000, 0.29999999999999999, 
+  { 1.6291980835772994, 0.0000000000000000, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999, 
+  { 1.8774607092226381, 0.0000000000000000, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler094 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.40000000000000002.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.3524218164111537e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0449580089795878e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data095[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17383341868035862, 0.0000000000000000, 0.40000000000000002, 
+  { 0.17524264820030025, 0.0000000000000000, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34368286022299821, 0.0000000000000000, 0.40000000000000002, 
+  { 0.35476219513871499, 0.0000000000000000, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50651268947499395, 0.0000000000000000, 0.40000000000000002, 
+  { 0.54290749235440094, 0.0000000000000000, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66074441806097539, 0.0000000000000000, 0.40000000000000002, 
+  { 0.74406433757109913, 0.0000000000000000, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80622931670113474, 0.0000000000000000, 0.40000000000000002, 
+  { 0.96236826162553313, 0.0000000000000000, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94389791565435210, 0.0000000000000000, 0.40000000000000002, 
+  { 1.2009785880262487, 0.0000000000000000, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0753503387899728, 0.0000000000000000, 0.40000000000000002, 
+  { 1.4608000106167567, 0.0000000000000000, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2025374759127518, 0.0000000000000000, 0.40000000000000002, 
+  { 1.7389349574753439, 0.0000000000000000, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3275651989026320, 0.0000000000000000, 0.40000000000000002, 
+  { 2.0278893379868057, 0.0000000000000000, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler095 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.50000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6090167266677240e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0254203825026289e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data096[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17366010776037044, 0.0000000000000000, 0.50000000000000000, 
+  { 0.17542170661831016, 0.0000000000000000, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34238253799539309, 0.0000000000000000, 0.50000000000000000, 
+  { 0.35623911740195419, 0.0000000000000000, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50253707775976397, 0.0000000000000000, 0.50000000000000000, 
+  { 0.54814449099863127, 0.0000000000000000, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65242145347295766, 0.0000000000000000, 0.50000000000000000, 
+  { 0.75731546607718081, 0.0000000000000000, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79210420018698058, 0.0000000000000000, 0.50000000000000000, 
+  { 0.99028751188233310, 0.0000000000000000, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92287437995632171, 0.0000000000000000, 0.50000000000000000, 
+  { 1.2531022857760581, 0.0000000000000000, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0466900550798659, 0.0000000000000000, 0.50000000000000000, 
+  { 1.5491761777615785, 0.0000000000000000, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1658007366618623, 0.0000000000000000, 0.50000000000000000, 
+  { 1.8758359693666533, 0.0000000000000000, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000, 
+  { 2.2214414690791831, 0.0000000000000000, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler096 = 2.5000000000000020e-13;
 
-// Test data for k=0.0000000000000000, nu=0.59999999999999998.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.4581288258006758e-16
+// Test data for k=0.0000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.1742785192400269e-16
+// mean(f - f_Boost): 1.3877787807814457e-17
+// variance(f - f_Boost): 2.3776912893669577e-35
+// stddev(f - f_Boost): 4.8761575952454181e-18
 const testcase_ellint_3<double>
 data097[10] =
 {
-  { 0.0000000000000000, 0.0000000000000000, 0.59999999999999998, 
+  { 0.0000000000000000, 0.0000000000000000, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17348741514884700, 0.0000000000000000, 0.59999999999999998, 
+  { 0.17560142466065651, 0.0000000000000000, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34109952405241289, 0.0000000000000000, 0.59999999999999998, 
+  { 0.35773830754879005, 0.0000000000000000, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49866850781226285, 0.0000000000000000, 0.59999999999999998, 
+  { 0.55356583986445973, 0.0000000000000000, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64444732407062499, 0.0000000000000000, 0.59999999999999998, 
+  { 0.77143701715151514, 0.0000000000000000, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.77877564686544720, 0.0000000000000000, 0.59999999999999998, 
+  { 1.0212334940541210, 0.0000000000000000, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90330743691883475, 0.0000000000000000, 0.59999999999999998, 
+  { 1.3137928444460387, 0.0000000000000000, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0203257987604104, 0.0000000000000000, 0.59999999999999998, 
+  { 1.6579755004159076, 0.0000000000000000, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1323247918768629, 0.0000000000000000, 0.59999999999999998, 
+  { 2.0537461418295506, 0.0000000000000000, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998, 
+  { 2.4836470664490253, 0.0000000000000000, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler097 = 2.5000000000000020e-13;
 
-// Test data for k=0.0000000000000000, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.5088894797856263e-16
+// Test data for k=0.0000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 4
+// max(|f - f_Boost| / |f_Boost|): 3.0903019454022601e-16
+// mean(f - f_Boost): -6.9388939039072284e-17
+// variance(f - f_Boost): 5.9442282234173945e-34
+// stddev(f - f_Boost): 2.4380787976227090e-17
 const testcase_ellint_3<double>
 data098[10] =
 {
-  { 0.0000000000000000, 0.0000000000000000, 0.69999999999999996, 
+  { 0.0000000000000000, 0.0000000000000000, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17331533692234474, 0.0000000000000000, 0.69999999999999996, 
+  { 0.17578180667760368, 0.0000000000000000, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.33983341309265935, 0.0000000000000000, 0.69999999999999996, 
+  { 0.35926037139410999, 0.0000000000000000, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49490198805931979, 0.0000000000000000, 0.69999999999999996, 
+  { 0.55918341315855080, 0.0000000000000000, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63679715525145297, 0.0000000000000000, 0.69999999999999996, 
+  { 0.78653584856932546, 0.0000000000000000, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76616861049481944, 0.0000000000000000, 0.69999999999999996, 
+  { 1.0558379029273324, 0.0000000000000000, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88503143209004198, 0.0000000000000000, 0.69999999999999996, 
+  { 1.3858662544850615, 0.0000000000000000, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 0.99596060249112173, 0.0000000000000000, 0.69999999999999996, 
+  { 1.7970491170359040, 0.0000000000000000, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1016495050260424, 0.0000000000000000, 0.69999999999999996, 
+  { 2.2992404490153917, 0.0000000000000000, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996, 
+  { 2.8678686047727382, 0.0000000000000000, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler098 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.80000000000000004.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8375904358197891e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.2373744057922657e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
 const testcase_ellint_3<double>
 data099[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17314386919344210, 0.0000000000000000, 0.80000000000000004, 
+  { 0.17596285706118869, 0.0000000000000000, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33858381342073240, 0.0000000000000000, 0.80000000000000004, 
+  { 0.36080593896484231, 0.0000000000000000, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49123285640844727, 0.0000000000000000, 0.80000000000000004, 
+  { 0.56501022706967863, 0.0000000000000000, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.62944854858904509, 0.0000000000000000, 0.80000000000000004, 
+  { 0.80273891984116930, 0.0000000000000000, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75421778305499343, 0.0000000000000000, 0.80000000000000004, 
+  { 1.0949425007763358, 0.0000000000000000, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.86790634112156617, 0.0000000000000000, 0.80000000000000004, 
+  { 1.4736985692253419, 0.0000000000000000, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97334918087427558, 0.0000000000000000, 0.80000000000000004, 
+  { 1.9848676587180696, 0.0000000000000000, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0734012615283985, 0.0000000000000000, 0.80000000000000004, 
+  { 2.6726187823193546, 0.0000000000000000, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004, 
+  { 3.5124073655203634, 0.0000000000000000, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler099 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.90000000000000002.
-// max(|f - f_GSL|): 1.1102230246251565e-16
-// max(|f - f_GSL| / |f_GSL|): 1.7838310376154469e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.6108624815885066e-16
+// mean(f - f_Boost): 2.1371793224034264e-16
+// variance(f - f_Boost): 5.6389326618626776e-33
+// stddev(f - f_Boost): 7.5092826966779442e-17
 const testcase_ellint_3<double>
 data100[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17297300811030597, 0.0000000000000000, 0.90000000000000002, 
+  { 0.17614458024574997, 0.0000000000000000, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33735034635360817, 0.0000000000000000, 0.90000000000000002, 
+  { 0.36237566578821978, 0.0000000000000000, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48765675230233130, 0.0000000000000000, 0.90000000000000002, 
+  { 0.57106058859196640, 0.0000000000000000, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62238126886123568, 0.0000000000000000, 0.90000000000000002, 
+  { 0.82019857015755915, 0.0000000000000000, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74286600807269243, 0.0000000000000000, 0.90000000000000002, 
+  { 1.1397014388908147, 0.0000000000000000, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85181283909264949, 0.0000000000000000, 0.90000000000000002, 
+  { 1.5845952415154960, 0.0000000000000000, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95228683995371133, 0.0000000000000000, 0.90000000000000002, 
+  { 2.2620531413370775, 0.0000000000000000, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0472730487412552, 0.0000000000000000, 0.90000000000000002, 
+  { 3.3587842061975066, 0.0000000000000000, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002, 
+  { 4.9672941328980507, 0.0000000000000000, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler100 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1735566504509650e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.1735566504509645e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
 const testcase_ellint_3<double>
 data101[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17454173353063659, 0.10000000000000009, 0.0000000000000000, 
+  { 0.17454173353063662, 0.10000000000000009, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34913506721468091, 0.10000000000000009, 0.0000000000000000, 
+  { 0.34913506721468096, 0.10000000000000009, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52382550016538942, 0.10000000000000009, 0.0000000000000000, 
+  { 0.52382550016538953, 0.10000000000000009, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.69864700854177020, 0.10000000000000009, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.87361792586964870, 0.10000000000000009, 0.0000000000000000, 
+  { 0.87361792586964859, 0.10000000000000009, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0487386319621683, 0.10000000000000009, 0.0000000000000000, 
+  { 1.0487386319621685, 0.10000000000000009, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2239913752078757, 0.10000000000000009, 0.0000000000000000, 
+  { 1.2239913752078759, 0.10000000000000009, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.3993423113684049, 0.10000000000000009, 0.0000000000000000, 
+  { 1.3993423113684051, 0.10000000000000009, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000, 
+  { 1.5747455615173560, 0.10000000000000009, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler101 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3097339877269682e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.0305747373482148e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
 const testcase_ellint_3<double>
 data102[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17436589347616613, 0.10000000000000009, 0.10000000000000001, 
+  { 0.17471821213559732, 0.10000000000000009, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34776067871237359, 0.10000000000000009, 0.10000000000000001, 
+  { 0.35052902610011138, 0.10000000000000009, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.51936064354727796, 0.10000000000000009, 0.10000000000000001, 
+  { 0.52842865990255727, 0.10000000000000009, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.68860303749364349, 0.10000000000000009, 0.10000000000000001, 
+  { 0.70921799731166713, 0.10000000000000009, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85524561882332051, 0.10000000000000009, 0.10000000000000001, 
+  { 0.89340330535868662, 0.10000000000000009, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0193708301908335, 0.10000000000000009, 0.10000000000000001, 
+  { 1.0811075784236857, 0.10000000000000009, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1813474067123044, 0.10000000000000009, 0.10000000000000001, 
+  { 1.2720133232666426, 0.10000000000000009, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3417670770424983, 0.10000000000000009, 0.10000000000000001, 
+  { 1.4653630031861395, 0.10000000000000009, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001, 
+  { 1.6600374067558428, 0.10000000000000009, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler102 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4399947764827574e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 1.6736714959992433e-16
+// mean(f - f_Boost): 5.5511151231257830e-18
+// variance(f - f_Boost): 3.8043060629871325e-36
+// stddev(f - f_Boost): 1.9504630380981673e-18
 const testcase_ellint_3<double>
 data103[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17419068786141340, 0.10000000000000009, 0.20000000000000001, 
+  { 0.17489533344059083, 0.10000000000000009, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34640537686230133, 0.10000000000000009, 0.20000000000000001, 
+  { 0.35194305707815038, 0.10000000000000009, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51502689171753946, 0.10000000000000009, 0.20000000000000001, 
+  { 0.53317790741512527, 0.10000000000000009, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.67904147863672715, 0.10000000000000009, 0.20000000000000001, 
+  { 0.72036681615081222, 0.10000000000000009, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.83811885126105179, 0.10000000000000009, 0.20000000000000001, 
+  { 0.91480372268244303, 0.10000000000000009, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99255278555742787, 0.10000000000000009, 0.20000000000000001, 
+  { 1.1170528708071514, 0.10000000000000009, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1431260546194930, 0.10000000000000009, 0.20000000000000001, 
+  { 1.3266916802718358, 0.10000000000000009, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2909589656532101, 0.10000000000000009, 0.20000000000000001, 
+  { 1.5421622241831547, 0.10000000000000009, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001, 
+  { 1.7608656115083421, 0.10000000000000009, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler103 = 2.5000000000000020e-13;
 
-// Test data for k=0.10000000000000009, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5650492137236872e-16
+// Test data for k=0.10000000000000009, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 1.9186071760326645e-16
+// mean(f - f_Boost): -1.6653345369377347e-17
+// variance(f - f_Boost): 3.4238754566884194e-35
+// stddev(f - f_Boost): 5.8513891142945016e-18
 const testcase_ellint_3<double>
 data104[10] =
 {
-  { 0.0000000000000000, 0.10000000000000009, 0.29999999999999999, 
+  { 0.0000000000000000, 0.10000000000000009, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17401611261390104, 0.10000000000000009, 0.29999999999999999, 
+  { 0.17507310163441189, 0.10000000000000009, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34506869507511773, 0.10000000000000009, 0.29999999999999999, 
+  { 0.35337768072524217, 0.10000000000000009, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51081757604259859, 0.10000000000000009, 0.29999999999999999, 
+  { 0.53808167801629170, 0.10000000000000009, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.66992297597712303, 0.10000000000000009, 0.29999999999999999, 
+  { 0.73215166755955019, 0.10000000000000009, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82209722856174228, 0.10000000000000009, 0.29999999999999999, 
+  { 0.93806546000201219, 0.10000000000000009, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.96792430487669590, 0.10000000000000009, 0.29999999999999999, 
+  { 1.1573218723395986, 0.10000000000000009, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1085964108954092, 0.10000000000000009, 0.29999999999999999, 
+  { 1.3897859679542097, 0.10000000000000009, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2456748370836999, 0.10000000000000009, 0.29999999999999999, 
+  { 1.6331009404328622, 0.10000000000000009, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999, 
+  { 1.8826015946315438, 0.10000000000000009, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler104 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6854758534459740e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0338059536914377e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 9.5107651574678308e-35
+// stddev(f - f_Boost): 9.7523151904908362e-18
 const testcase_ellint_3<double>
 data105[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17384216369897931, 0.10000000000000009, 0.40000000000000002, 
+  { 0.17525152094559704, 0.10000000000000009, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34375018311376787, 0.10000000000000009, 0.40000000000000002, 
+  { 0.35483343742825979, 0.10000000000000009, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50672650758380455, 0.10000000000000009, 0.40000000000000002, 
+  { 0.54314913099505446, 0.10000000000000009, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66121264213337616, 0.10000000000000009, 0.40000000000000002, 
+  { 0.74463962034766862, 0.10000000000000009, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80706202005774441, 0.10000000000000009, 0.40000000000000002, 
+  { 0.96349276837570441, 0.10000000000000009, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94519376138245870, 0.10000000000000009, 0.40000000000000002, 
+  { 1.2029081382746343, 0.10000000000000009, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0771880300759584, 0.10000000000000009, 0.40000000000000002, 
+  { 1.4638022887050806, 0.10000000000000009, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2049711557188272, 0.10000000000000009, 0.40000000000000002, 
+  { 1.7432413830105224, 0.10000000000000009, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002, 
+  { 2.0336367403076760, 0.10000000000000009, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler105 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8017534281650347e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.9864616042835278e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
 const testcase_ellint_3<double>
 data106[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17366883711936548, 0.10000000000000009, 0.50000000000000000, 
+  { 0.17543059564292182, 0.10000000000000009, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34244940634881882, 0.10000000000000009, 0.50000000000000000, 
+  { 0.35631088838721664, 0.10000000000000009, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50274793281634367, 0.10000000000000009, 0.50000000000000000, 
+  { 0.54839023346436455, 0.10000000000000009, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65287941633275082, 0.10000000000000009, 0.50000000000000000, 
+  { 0.75790846946088830, 0.10000000000000009, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79291198790315398, 0.10000000000000009, 0.50000000000000000, 
+  { 0.99146713686720678, 0.10000000000000009, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92412201537880323, 0.10000000000000009, 0.50000000000000000, 
+  { 1.2551692247937198, 0.10000000000000009, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0484480076799372, 0.10000000000000009, 0.50000000000000000, 
+  { 1.5524660788146873, 0.10000000000000009, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1681168130475206, 0.10000000000000009, 0.50000000000000000, 
+  { 1.8806578570830670, 0.10000000000000009, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000, 
+  { 2.2279868912966849, 0.10000000000000009, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler106 = 2.5000000000000020e-13;
 
-// Test data for k=0.10000000000000009, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.9142834151672032e-16
+// Test data for k=0.10000000000000009, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6726146516228014e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 1.6073193116120635e-34
+// stddev(f - f_Boost): 1.2678009747638087e-17
 const testcase_ellint_3<double>
 data107[10] =
 {
-  { 0.0000000000000000, 0.10000000000000009, 0.59999999999999998, 
+  { 0.0000000000000000, 0.10000000000000009, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17349612891469013, 0.10000000000000009, 0.59999999999999998, 
+  { 0.17561033003590576, 0.10000000000000009, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34116594505539444, 0.10000000000000009, 0.59999999999999998, 
+  { 0.35781061668171932, 0.10000000000000009, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49887649430466674, 0.10000000000000009, 0.59999999999999998, 
+  { 0.55381585659629196, 0.10000000000000009, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64489553282165146, 0.10000000000000009, 0.59999999999999998, 
+  { 0.77204910484575640, 0.10000000000000009, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.77956016553782437, 0.10000000000000009, 0.59999999999999998, 
+  { 1.0224751740393108, 0.10000000000000009, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90451074530096287, 0.10000000000000009, 0.59999999999999998, 
+  { 1.3160230906351114, 0.10000000000000009, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0220113666961632, 0.10000000000000009, 0.59999999999999998, 
+  { 1.6616282844233206, 0.10000000000000009, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1345351441065563, 0.10000000000000009, 0.59999999999999998, 
+  { 2.0592555664850392, 0.10000000000000009, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998, 
+  { 2.4913004919173822, 0.10000000000000009, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler107 = 2.5000000000000020e-13;
 
-// Test data for k=0.10000000000000009, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.5172091551439012e-16
+// Test data for k=0.10000000000000009, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 2.1004074871280821e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
 const testcase_ellint_3<double>
 data108[10] =
 {
-  { 0.0000000000000000, 0.10000000000000009, 0.69999999999999996, 
+  { 0.0000000000000000, 0.10000000000000009, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17332403516105047, 0.10000000000000009, 0.69999999999999996, 
+  { 0.17579072847532518, 0.10000000000000009, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.33989939374896883, 0.10000000000000009, 0.69999999999999996, 
+  { 0.35933322840606297, 0.10000000000000009, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49510719568614070, 0.10000000000000009, 0.69999999999999996, 
+  { 0.55943788649460324, 0.10000000000000009, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63723607776354974, 0.10000000000000009, 0.69999999999999996, 
+  { 0.78716856504031707, 0.10000000000000009, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76693133887935327, 0.10000000000000009, 0.69999999999999996, 
+  { 1.0571501305617423, 0.10000000000000009, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88619382078823805, 0.10000000000000009, 0.69999999999999996, 
+  { 1.3882948301743525, 0.10000000000000009, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 0.99758012018676490, 0.10000000000000009, 0.69999999999999996, 
+  { 1.8011785680114223, 0.10000000000000009, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1037642270814410, 0.10000000000000009, 0.69999999999999996, 
+  { 2.3057268183616464, 0.10000000000000009, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2073745911083185, 0.10000000000000009, 0.69999999999999996, 
+  { 2.8771910188009739, 0.10000000000000009, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler108 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1294144515772258e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.3133043868392355e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 6.1843750436434569e-32
+// stddev(f - f_Boost): 2.4868403735751633e-16
 const testcase_ellint_3<double>
 data109[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17315255197057014, 0.10000000000000009, 0.80000000000000004, 
+  { 0.17597179535373417, 0.10000000000000009, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33864936055747991, 0.10000000000000009, 0.80000000000000004, 
+  { 0.36087935387831499, 0.10000000000000009, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49143537041117613, 0.10000000000000009, 0.80000000000000004, 
+  { 0.56526935244526444, 0.10000000000000009, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.62987861760047492, 0.10000000000000009, 0.80000000000000004, 
+  { 0.80339402590612397, 0.10000000000000009, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75496005490917517, 0.10000000000000009, 0.80000000000000004, 
+  { 1.0963358646374459, 0.10000000000000009, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.86903081862701881, 0.10000000000000009, 0.80000000000000004, 
+  { 1.4763748483246868, 0.10000000000000009, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97490814820725591, 0.10000000000000009, 0.80000000000000004, 
+  { 1.9896610222794102, 0.10000000000000009, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0754290107171083, 0.10000000000000009, 0.80000000000000004, 
+  { 2.6806423920122024, 0.10000000000000009, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004, 
+  { 3.5246199613295612, 0.10000000000000009, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler109 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2325599449457852e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5624826890976725e-16
+// mean(f - f_Boost): 2.3314683517128288e-16
+// variance(f - f_Boost): 2.9401198977189756e-31
+// stddev(f - f_Boost): 5.4222872459129045e-16
 const testcase_ellint_3<double>
 data110[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17298167549096563, 0.10000000000000009, 0.90000000000000002, 
+  { 0.17615353510599349, 0.10000000000000009, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33741546662741589, 0.10000000000000009, 0.90000000000000002, 
+  { 0.36244964892922371, 0.10000000000000009, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48785665376856868, 0.10000000000000009, 0.90000000000000002, 
+  { 0.57132457590110530, 0.10000000000000009, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62280288554518959, 0.10000000000000009, 0.90000000000000002, 
+  { 0.82087808820385000, 0.10000000000000009, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74358903115455188, 0.10000000000000009, 0.90000000000000002, 
+  { 1.1411894342144451, 0.10000000000000009, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85290207679298335, 0.10000000000000009, 0.90000000000000002, 
+  { 1.5875929286844597, 0.10000000000000009, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95379006645397379, 0.10000000000000009, 0.90000000000000002, 
+  { 2.2678622986596659, 0.10000000000000009, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0492213119872327, 0.10000000000000009, 0.90000000000000002, 
+  { 3.3697528941897903, 0.10000000000000009, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002, 
+  { 4.9862890417305499, 0.10000000000000009, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler110 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2156475739151676e-16
+// Test data for k=0.20000000000000018, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.2156475739151676e-16
+// mean(f - f_Boost): -5.2735593669694933e-17
+// variance(f - f_Boost): 3.0473442641042680e-32
+// stddev(f - f_Boost): 1.7456644190978597e-16
 const testcase_ellint_3<double>
 data111[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.0000000000000000, 
+  { 0.0000000000000000, 0.20000000000000018, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17456817290292809, 0.19999999999999996, 0.0000000000000000, 
+  { 0.17456817290292806, 0.20000000000000018, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34934315932086801, 0.19999999999999996, 0.0000000000000000, 
+  { 0.34934315932086796, 0.20000000000000018, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52450880529443988, 0.19999999999999996, 0.0000000000000000, 
+  { 0.52450880529443988, 0.20000000000000018, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70020491009844876, 0.19999999999999996, 0.0000000000000000, 
+  { 0.70020491009844887, 0.20000000000000018, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.87651006649967955, 0.19999999999999996, 0.0000000000000000, 
+  { 0.87651006649967977, 0.20000000000000018, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0534305870298994, 0.19999999999999996, 0.0000000000000000, 
+  { 1.0534305870298994, 0.20000000000000018, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2308975521670784, 0.19999999999999996, 0.0000000000000000, 
+  { 1.2308975521670789, 0.20000000000000018, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4087733584990738, 0.19999999999999996, 0.0000000000000000, 
+  { 1.4087733584990738, 0.20000000000000018, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.5868678474541660, 0.19999999999999996, 0.0000000000000000, 
+  { 1.5868678474541662, 0.20000000000000018, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler111 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3374593253183472e-16
+// Test data for k=0.20000000000000018, nu=0.10000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.0890622182605400e-16
+// mean(f - f_Boost): -3.8857805861880476e-17
+// variance(f - f_Boost): 2.8794792590749608e-32
+// stddev(f - f_Boost): 1.6969028431454054e-16
 const testcase_ellint_3<double>
 data112[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.10000000000000001, 
+  { 0.0000000000000000, 0.20000000000000018, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17439228502691748, 0.19999999999999996, 0.10000000000000001, 
+  { 0.17474469953608965, 0.20000000000000018, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34796731137565740, 0.19999999999999996, 0.10000000000000001, 
+  { 0.35073860234984255, 0.20000000000000018, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52003370294544848, 0.19999999999999996, 0.10000000000000001, 
+  { 0.52912258712951521, 0.20000000000000018, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69012222258631462, 0.19999999999999996, 0.10000000000000001, 
+  { 0.71081701558898069, 0.20000000000000018, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85803491465566772, 0.19999999999999996, 0.10000000000000001, 
+  { 0.89640758521169384, 0.20000000000000018, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0238463961099364, 0.19999999999999996, 0.10000000000000001, 
+  { 1.0860417038089853, 0.20000000000000018, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1878691059202153, 0.19999999999999996, 0.10000000000000001, 
+  { 1.2793599255528623, 0.20000000000000018, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3505985031831940, 0.19999999999999996, 0.10000000000000001, 
+  { 1.4754938544089076, 0.20000000000000018, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5126513474261087, 0.19999999999999996, 0.10000000000000001, 
+  { 1.6731552050562593, 0.20000000000000018, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler112 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4549984059502760e-16
+// Test data for k=0.20000000000000018, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.9570963716579749e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 3.1158217732380362e-32
+// stddev(f - f_Boost): 1.7651690494788412e-16
 const testcase_ellint_3<double>
 data113[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.20000000000000001, 
+  { 0.0000000000000000, 0.20000000000000018, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17421703179583747, 0.19999999999999996, 0.20000000000000001, 
+  { 0.17492186907740698, 0.20000000000000018, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34661057411998791, 0.19999999999999996, 0.20000000000000001, 
+  { 0.35215414286134267, 0.20000000000000018, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51569006052647393, 0.19999999999999996, 0.20000000000000001, 
+  { 0.53388285615182440, 0.20000000000000018, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68052412821107244, 0.19999999999999996, 0.20000000000000001, 
+  { 0.72200960282688265, 0.20000000000000018, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.84081341263313825, 0.19999999999999996, 0.20000000000000001, 
+  { 0.91793087614428526, 0.20000000000000018, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99683359988842890, 0.19999999999999996, 0.20000000000000001, 
+  { 1.1222602841587976, 0.20000000000000018, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1493086715118852, 0.19999999999999996, 0.20000000000000001, 
+  { 1.3345489407496247, 0.20000000000000018, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2992699693957541, 0.19999999999999996, 0.20000000000000001, 
+  { 1.5531225705475502, 0.20000000000000018, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4479323932249564, 0.19999999999999996, 0.20000000000000001, 
+  { 1.7751816279738935, 0.20000000000000018, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler113 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.29999999999999999.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.3140668101543467e-16
+// Test data for k=0.20000000000000018, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.6785817924053817e-16
+// mean(f - f_Boost): -1.1102230246251566e-17
+// variance(f - f_Boost): 9.9840208317034302e-32
+// stddev(f - f_Boost): 3.1597501217190311e-16
 const testcase_ellint_3<double>
 data114[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.29999999999999999, 
+  { 0.0000000000000000, 0.20000000000000018, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17404240913577704, 0.19999999999999996, 0.29999999999999999, 
+  { 0.17509968571715159, 0.20000000000000018, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34527248032587193, 0.19999999999999996, 0.29999999999999999, 
+  { 0.35359030214835629, 0.20000000000000018, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51147118981668416, 0.19999999999999996, 0.29999999999999999, 
+  { 0.53879807274537084, 0.20000000000000018, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67137107867777601, 0.19999999999999996, 0.29999999999999999, 
+  { 0.73384116418059731, 0.20000000000000018, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82470418188668893, 0.19999999999999996, 0.29999999999999999, 
+  { 0.94132799329524031, 0.20000000000000018, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.97202873223594299, 0.19999999999999996, 0.29999999999999999, 
+  { 1.1628407021801439, 0.20000000000000018, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1144773569375266, 0.19999999999999996, 0.29999999999999999, 
+  { 1.3982440216739438, 0.20000000000000018, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2535292433701000, 0.19999999999999996, 0.29999999999999999, 
+  { 1.6450634983653640, 0.20000000000000018, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3908453514752477, 0.19999999999999996, 0.29999999999999999, 
+  { 1.8983924169967099, 0.20000000000000018, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler114 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.6788709752760483e-16
+// Test data for k=0.20000000000000018, nu=0.40000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.6738449250038925e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 2.7810428396951687e-32
+// stddev(f - f_Boost): 1.6676458975739331e-16
 const testcase_ellint_3<double>
 data115[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.40000000000000002, 
+  { 0.0000000000000000, 0.20000000000000018, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17386841301066674, 0.19999999999999996, 0.40000000000000002, 
+  { 0.17527815368535152, 0.20000000000000018, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34395257914113253, 0.19999999999999996, 0.40000000000000002, 
+  { 0.35504762134297801, 0.20000000000000018, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50737088376869466, 0.19999999999999996, 0.40000000000000002, 
+  { 0.54387742353211344, 0.20000000000000018, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66262801717277631, 0.19999999999999996, 0.40000000000000002, 
+  { 0.74637910471804259, 0.20000000000000018, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80958766645079094, 0.19999999999999996, 0.40000000000000002, 
+  { 0.96690539714174639, 0.20000000000000018, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94913754236162040, 0.19999999999999996, 0.40000000000000002, 
+  { 1.2087859420184757, 0.20000000000000018, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0827985514222997, 0.19999999999999996, 0.40000000000000002, 
+  { 1.4729799844168852, 0.20000000000000018, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2124212429050478, 0.19999999999999996, 0.40000000000000002, 
+  { 1.7564445064596661, 0.20000000000000018, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3400002519661005, 0.19999999999999996, 0.40000000000000002, 
+  { 2.0512956926676806, 0.20000000000000018, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler115 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7788201301356829e-16
+// Test data for k=0.20000000000000018, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3841806057292116e-16
+// mean(f - f_Boost): 3.6082248300317589e-17
+// variance(f - f_Boost): 8.9638010532618564e-32
+// stddev(f - f_Boost): 2.9939607634806868e-16
 const testcase_ellint_3<double>
 data116[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.50000000000000000, 
+  { 0.0000000000000000, 0.20000000000000018, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17369503942181799, 0.19999999999999996, 0.50000000000000000, 
+  { 0.17545727725228877, 0.20000000000000018, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34265043534362660, 0.19999999999999996, 0.50000000000000000, 
+  { 0.35652666242062175, 0.20000000000000018, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50338337208655415, 0.19999999999999996, 0.50000000000000000, 
+  { 0.54913090549102406, 0.20000000000000018, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65426373297163609, 0.19999999999999996, 0.50000000000000000, 
+  { 0.75970161209211551, 0.20000000000000018, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79536193036145808, 0.19999999999999996, 0.50000000000000000, 
+  { 0.99504737401590326, 0.20000000000000018, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92791875910061605, 0.19999999999999996, 0.50000000000000000, 
+  { 1.2614666007124373, 0.20000000000000018, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0538145052725829, 0.19999999999999996, 0.50000000000000000, 
+  { 1.5625255355205498, 0.20000000000000018, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1752060022875899, 0.19999999999999996, 0.50000000000000000, 
+  { 1.8954460255613346, 0.20000000000000018, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2943374404397372, 0.19999999999999996, 0.50000000000000000, 
+  { 2.2481046259421302, 0.20000000000000018, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler116 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.8899223779598256e-16
+// Test data for k=0.20000000000000018, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5317584994994743e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 1.0045745697575397e-31
+// stddev(f - f_Boost): 3.1695024369095219e-16
 const testcase_ellint_3<double>
 data117[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.59999999999999998, 
+  { 0.0000000000000000, 0.20000000000000018, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17352228440746925, 0.19999999999999996, 0.59999999999999998, 
+  { 0.17563706072900442, 0.20000000000000018, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34136562863713626, 0.19999999999999996, 0.59999999999999998, 
+  { 0.35802800926807238, 0.20000000000000018, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49950328177638481, 0.19999999999999996, 0.59999999999999998, 
+  { 0.55456942250515051, 0.20000000000000018, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64625032705690799, 0.19999999999999996, 0.59999999999999998, 
+  { 0.77390003828438203, 0.20000000000000018, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.78193941198403083, 0.19999999999999996, 0.59999999999999998, 
+  { 1.0262441366366397, 0.20000000000000018, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90817230934317128, 0.19999999999999996, 0.59999999999999998, 
+  { 1.3228192988439669, 0.20000000000000018, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0271563751276462, 0.19999999999999996, 0.59999999999999998, 
+  { 1.6728005754680795, 0.20000000000000018, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1412999379040518, 0.19999999999999996, 0.59999999999999998, 
+  { 2.0761587107468511, 0.20000000000000018, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2530330675914556, 0.19999999999999996, 0.59999999999999998, 
+  { 2.5148333891629315, 0.20000000000000018, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler117 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.9999318361775115e-16
+// Test data for k=0.20000000000000018, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2209418045118284e-16
+// mean(f - f_Boost): 2.4980018054066023e-17
+// variance(f - f_Boost): 9.1989071679544611e-32
+// stddev(f - f_Boost): 3.0329700242426498e-16
 const testcase_ellint_3<double>
 data118[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.69999999999999996, 
+  { 0.0000000000000000, 0.20000000000000018, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17335014404233895, 0.19999999999999996, 0.69999999999999996, 
+  { 0.17581750846781172, 0.20000000000000018, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34009775298617811, 0.19999999999999996, 0.69999999999999996, 
+  { 0.35955226882028513, 0.20000000000000018, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49572560201923810, 0.19999999999999996, 0.69999999999999996, 
+  { 0.56020489659466499, 0.20000000000000018, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63856276669886503, 0.19999999999999996, 0.69999999999999996, 
+  { 0.78908196988531498, 0.20000000000000018, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76924438644867565, 0.19999999999999996, 0.69999999999999996, 
+  { 1.0611336754143517, 0.20000000000000018, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88973060843856466, 0.19999999999999996, 0.69999999999999996, 
+  { 1.3956969951058884, 0.20000000000000018, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0025230471636377, 0.19999999999999996, 0.69999999999999996, 
+  { 1.8138131612209609, 0.20000000000000018, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1102356376093103, 0.19999999999999996, 0.69999999999999996, 
+  { 2.3256365528879561, 0.20000000000000018, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2154356555075863, 0.19999999999999996, 0.69999999999999996, 
+  { 2.9058704854500963, 0.20000000000000018, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler118 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 5.0901276230707249e-16
+// Test data for k=0.20000000000000018, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7399960886656824e-16
+// mean(f - f_Boost): 1.3877787807814457e-16
+// variance(f - f_Boost): 1.7585404776158019e-31
+// stddev(f - f_Boost): 4.1934955319110593e-16
 const testcase_ellint_3<double>
 data119[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.80000000000000004, 
+  { 0.0000000000000000, 0.20000000000000018, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17317861443718538, 0.19999999999999996, 0.80000000000000004, 
+  { 0.17599862486281712, 0.20000000000000018, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33884641598718701, 0.19999999999999996, 0.80000000000000004, 
+  { 0.36110007227128776, 0.20000000000000018, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49204565281259494, 0.19999999999999996, 0.80000000000000004, 
+  { 0.56605039658567224, 0.20000000000000018, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63117851188220320, 0.19999999999999996, 0.80000000000000004, 
+  { 0.80537523874517691, 0.20000000000000018, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75721095949544170, 0.19999999999999996, 0.80000000000000004, 
+  { 1.1005662342414086, 0.20000000000000018, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.87245201443919118, 0.19999999999999996, 0.80000000000000004, 
+  { 1.4845340298105778, 0.20000000000000018, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97966584238831089, 0.19999999999999996, 0.80000000000000004, 
+  { 2.0043332244969392, 0.20000000000000018, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0816336325174360, 0.19999999999999996, 0.80000000000000004, 
+  { 2.7052856676744761, 0.20000000000000018, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1810223448909909, 0.19999999999999996, 0.80000000000000004, 
+  { 3.5622166386422633, 0.20000000000000018, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler119 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.90000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4833128442756722e-16
+// Test data for k=0.20000000000000018, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1718503329017390e-16
+// mean(f - f_Boost): 2.3592239273284576e-16
+// variance(f - f_Boost): 2.9295534376290287e-31
+// stddev(f - f_Boost): 5.4125349307224141e-16
 const testcase_ellint_3<double>
 data120[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.90000000000000002, 
+  { 0.0000000000000000, 0.20000000000000018, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17300769173837277, 0.19999999999999996, 0.90000000000000002, 
+  { 0.17618041435044951, 0.20000000000000018, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33761123827372508, 0.19999999999999996, 0.90000000000000002, 
+  { 0.36267207636502929, 0.20000000000000018, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48845905690769426, 0.19999999999999996, 0.90000000000000002, 
+  { 0.57212028758237743, 0.20000000000000018, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62407720017324952, 0.19999999999999996, 0.90000000000000002, 
+  { 0.82293323876704483, 0.20000000000000018, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74578146525124289, 0.19999999999999996, 0.90000000000000002, 
+  { 1.1457077279880388, 0.20000000000000018, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85621583540073076, 0.19999999999999996, 0.90000000000000002, 
+  { 1.5967346899325681, 0.20000000000000018, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95837725988001199, 0.19999999999999996, 0.90000000000000002, 
+  { 2.2856537353421724, 0.20000000000000018, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0551821412633928, 0.19999999999999996, 0.90000000000000002, 
+  { 3.4034714304613902, 0.20000000000000018, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1493679916141861, 0.19999999999999996, 0.90000000000000002, 
+  { 5.0448269356200370, 0.20000000000000018, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler120 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.0000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.3361874537309281e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2241249691539529e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 2.1399221604302621e-32
+// stddev(f - f_Boost): 1.4628472785736254e-16
 const testcase_ellint_3<double>
 data121[10] =
 {
@@ -3528,19 +3890,19 @@
 	  0.0000000000000000 },
   { 0.17461228653000099, 0.30000000000000004, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34969146102798415, 0.30000000000000004, 0.0000000000000000, 
+  { 0.34969146102798421, 0.30000000000000004, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52565822873726320, 0.30000000000000004, 0.0000000000000000, 
+  { 0.52565822873726309, 0.30000000000000004, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70284226512408532, 0.30000000000000004, 0.0000000000000000, 
+  { 0.70284226512408543, 0.30000000000000004, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.88144139195111182, 0.30000000000000004, 0.0000000000000000, 
+  { 0.88144139195111171, 0.30000000000000004, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.0614897067260520, 0.30000000000000004, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2428416824174218, 0.30000000000000004, 0.0000000000000000, 
+  { 1.2428416824174220, 0.30000000000000004, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4251795877015927, 0.30000000000000004, 0.0000000000000000, 
+  { 1.4251795877015929, 0.30000000000000004, 0.0000000000000000, 
 	  1.3962634015954636 },
   { 1.6080486199305128, 0.30000000000000004, 0.0000000000000000, 
 	  1.5707963267948966 },
@@ -3548,559 +3910,619 @@
 const double toler121 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.10000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.3908043711907203e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1872304407982844e-16
+// mean(f - f_Boost): 7.2164496600635178e-17
+// variance(f - f_Boost): 4.3555500115139682e-32
+// stddev(f - f_Boost): 2.0869954507650391e-16
 const testcase_ellint_3<double>
 data122[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17443631884814376, 0.30000000000000004, 0.10000000000000001, 
+  { 0.17478889331392972, 0.30000000000000004, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34831316835124926, 0.30000000000000004, 0.10000000000000001, 
+  { 0.35108939018329183, 0.30000000000000004, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52116586276523857, 0.30000000000000004, 0.10000000000000001, 
+  { 0.53028990896115835, 0.30000000000000004, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69269385837910036, 0.30000000000000004, 0.10000000000000001, 
+  { 0.71352417052371409, 0.30000000000000004, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.86279023163070856, 0.30000000000000004, 0.10000000000000001, 
+  { 0.90153086032405894, 0.30000000000000004, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0315321461438263, 0.30000000000000004, 0.10000000000000001, 
+  { 1.0945187977283313, 0.30000000000000004, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1991449111869024, 0.30000000000000004, 0.10000000000000001, 
+  { 1.2920699268385683, 0.30000000000000004, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3659561780923213, 0.30000000000000004, 0.10000000000000001, 
+  { 1.4931243665896394, 0.30000000000000004, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5323534693557528, 0.30000000000000004, 0.10000000000000001, 
+  { 1.6960848815118226, 0.30000000000000004, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler122 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.20000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4447238179454079e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2247497610332889e-16
+// mean(f - f_Boost): 6.6613381477509390e-17
+// variance(f - f_Boost): 1.7591111235252501e-32
+// stddev(f - f_Boost): 1.3263148659067538e-16
 const testcase_ellint_3<double>
 data123[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17426098615372088, 0.30000000000000004, 0.20000000000000001, 
+  { 0.17496614335337535, 0.30000000000000004, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34695402664689923, 0.30000000000000004, 0.20000000000000001, 
+  { 0.35250745937139372, 0.30000000000000004, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51680555567038933, 0.30000000000000004, 0.20000000000000001, 
+  { 0.53506875002836884, 0.30000000000000004, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68303375225260210, 0.30000000000000004, 0.20000000000000001, 
+  { 0.72479106622248191, 0.30000000000000004, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.84540662891295026, 0.30000000000000004, 0.20000000000000001, 
+  { 0.92326451535891607, 0.30000000000000004, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0041834051646927, 0.30000000000000004, 0.20000000000000001, 
+  { 1.1312092060698349, 0.30000000000000004, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1599952702345711, 0.30000000000000004, 0.20000000000000001, 
+  { 1.3481473154592321, 0.30000000000000004, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3137179520499165, 0.30000000000000004, 0.20000000000000001, 
+  { 1.5722049569662750, 0.30000000000000004, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4663658145259877, 0.30000000000000004, 0.20000000000000001, 
+  { 1.8002173372290500, 0.30000000000000004, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler123 = 2.5000000000000020e-13;
 
-// Test data for k=0.30000000000000004, nu=0.29999999999999999.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4979715256503266e-16
+// Test data for k=0.30000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1678685180047551e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
 const testcase_ellint_3<double>
 data124[10] =
 {
-  { 0.0000000000000000, 0.30000000000000004, 0.29999999999999999, 
+  { 0.0000000000000000, 0.30000000000000004, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17408628437042842, 0.30000000000000004, 0.29999999999999999, 
+  { 0.17514404084107435, 0.30000000000000004, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34561356761638401, 0.30000000000000004, 0.29999999999999999, 
+  { 0.35394619108645647, 0.30000000000000004, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51257058617875850, 0.30000000000000004, 0.29999999999999999, 
+  { 0.54000325463372689, 0.30000000000000004, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67382207124602878, 0.30000000000000004, 0.29999999999999999, 
+  { 0.73670193794067651, 0.30000000000000004, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82914751587825131, 0.30000000000000004, 0.29999999999999999, 
+  { 0.94689345491722177, 0.30000000000000004, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.97907434814374938, 0.30000000000000004, 0.29999999999999999, 
+  { 1.1723274608389140, 0.30000000000000004, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1246399297351584, 0.30000000000000004, 0.29999999999999999, 
+  { 1.4128880552936287, 0.30000000000000004, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2671793970398149, 0.30000000000000004, 0.29999999999999999, 
+  { 1.6659010047449661, 0.30000000000000004, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4081767433479091, 0.30000000000000004, 0.29999999999999999, 
+  { 1.9260216862473254, 0.30000000000000004, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler124 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.5505716921759864e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.3983279132797385e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.8245832308692586e-31
+// stddev(f - f_Boost): 4.2715140534349863e-16
 const testcase_ellint_3<double>
 data125[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17391220945982727, 0.30000000000000004, 0.40000000000000002, 
+  { 0.17532259000954434, 0.30000000000000004, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34429133937639689, 0.30000000000000004, 0.40000000000000002, 
+  { 0.35540612770983693, 0.30000000000000004, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50845471668581632, 0.30000000000000004, 0.40000000000000002, 
+  { 0.54510265552938919, 0.30000000000000004, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66502347027873854, 0.30000000000000004, 0.40000000000000002, 
+  { 0.74932476310965057, 0.30000000000000004, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.81389191978012254, 0.30000000000000004, 0.40000000000000002, 
+  { 0.97272793583093109, 0.30000000000000004, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.95590618002140570, 0.30000000000000004, 0.40000000000000002, 
+  { 1.2188928987074241, 0.30000000000000004, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0924915195213121, 0.30000000000000004, 0.40000000000000002, 
+  { 1.4888771674085941, 0.30000000000000004, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2253651604038061, 0.30000000000000004, 0.40000000000000002, 
+  { 1.7794558498219191, 0.30000000000000004, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3563643538969763, 0.30000000000000004, 0.40000000000000002, 
+  { 2.0822121773175528, 0.30000000000000004, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler125 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.50000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.7807908859023716e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0516138451673425e-16
+// mean(f - f_Boost): 4.7184478546569152e-17
+// variance(f - f_Boost): 1.9448563670505968e-32
+// stddev(f - f_Boost): 1.3945810722401896e-16
 const testcase_ellint_3<double>
 data126[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17373875742088232, 0.30000000000000004, 0.50000000000000000, 
+  { 0.17550179513158179, 0.30000000000000004, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34298690571124157, 0.30000000000000004, 0.50000000000000000, 
+  { 0.35688783251681200, 0.30000000000000004, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50445214859646936, 0.30000000000000004, 0.50000000000000000, 
+  { 0.55037700010142798, 0.30000000000000004, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65660648352418516, 0.30000000000000004, 0.50000000000000000, 
+  { 0.76273839789895992, 0.30000000000000004, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79953670639287289, 0.30000000000000004, 0.50000000000000000, 
+  { 1.0011570518830419, 0.30000000000000004, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.93443393926588536, 0.30000000000000004, 0.50000000000000000, 
+  { 1.2722987414055109, 0.30000000000000004, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0630838369016911, 0.30000000000000004, 0.50000000000000000, 
+  { 1.5799590511080066, 0.30000000000000004, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1875197325653029, 0.30000000000000004, 0.50000000000000000, 
+  { 1.9212367220124293, 0.30000000000000004, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3098448759814962, 0.30000000000000004, 0.50000000000000000, 
+  { 2.2833505881933971, 0.30000000000000004, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler126 = 2.5000000000000020e-13;
 
-// Test data for k=0.30000000000000004, nu=0.59999999999999998.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.0057999499931649e-16
+// Test data for k=0.30000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2121157428443725e-16
+// mean(f - f_Boost): 1.9428902930940239e-16
+// variance(f - f_Boost): 1.5987596229703424e-31
+// stddev(f - f_Boost): 3.9984492281012430e-16
 const testcase_ellint_3<double>
 data127[10] =
 {
-  { 0.0000000000000000, 0.30000000000000004, 0.59999999999999998, 
+  { 0.0000000000000000, 0.30000000000000004, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17356592428950823, 0.30000000000000004, 0.59999999999999998, 
+  { 0.17568166052076745, 0.30000000000000004, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34169984536697379, 0.30000000000000004, 0.59999999999999998, 
+  { 0.35839189074731181, 0.30000000000000004, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50055748266498457, 0.30000000000000004, 0.59999999999999998, 
+  { 0.55583724744367558, 0.30000000000000004, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64854298527106768, 0.30000000000000004, 0.59999999999999998, 
+  { 0.77703498090888223, 0.30000000000000004, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.78599329284207431, 0.30000000000000004, 0.59999999999999998, 
+  { 1.0326772113675962, 0.30000000000000004, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.91445452089128199, 0.30000000000000004, 0.59999999999999998, 
+  { 1.3345139983717369, 0.30000000000000004, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0360412952290587, 0.30000000000000004, 0.59999999999999998, 
+  { 1.6921742922838403, 0.30000000000000004, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1530473919778641, 0.30000000000000004, 0.59999999999999998, 
+  { 2.1056608968472186, 0.30000000000000004, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2677758800420669, 0.30000000000000004, 0.59999999999999998, 
+  { 2.5560975528589061, 0.30000000000000004, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler127 = 2.5000000000000020e-13;
 
-// Test data for k=0.30000000000000004, nu=0.69999999999999996.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.2239502844122443e-16
+// Test data for k=0.30000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0088945789059381e-16
+// mean(f - f_Boost): 2.1094237467877973e-16
+// variance(f - f_Boost): 3.0253363535298873e-31
+// stddev(f - f_Boost): 5.5003057674368314e-16
 const testcase_ellint_3<double>
 data128[10] =
 {
-  { 0.0000000000000000, 0.30000000000000004, 0.69999999999999996, 
+  { 0.0000000000000000, 0.30000000000000004, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17339370613812224, 0.30000000000000004, 0.69999999999999996, 
+  { 0.17586219053197988, 0.30000000000000004, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34042975138455933, 0.30000000000000004, 0.69999999999999996, 
+  { 0.35991891074557669, 0.30000000000000004, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49676568368075985, 0.30000000000000004, 0.69999999999999996, 
+  { 0.56149538019961731, 0.30000000000000004, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64080774055753720, 0.30000000000000004, 0.69999999999999996, 
+  { 0.79232303189667685, 0.30000000000000004, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.77318507779667278, 0.30000000000000004, 0.69999999999999996, 
+  { 1.0679345542878826, 0.30000000000000004, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.89579782346548609, 0.30000000000000004, 0.69999999999999996, 
+  { 1.4084400085913955, 0.30000000000000004, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0110573286052202, 0.30000000000000004, 0.69999999999999996, 
+  { 1.8357382859296454, 0.30000000000000004, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1214710972949635, 0.30000000000000004, 0.69999999999999996, 
+  { 2.3604197996171519, 0.30000000000000004, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2294913236274982, 0.30000000000000004, 0.69999999999999996, 
+  { 2.9562123549913872, 0.30000000000000004, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler128 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.80000000000000004.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.4358357000101250e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1197887707781618e-16
+// mean(f - f_Boost): 3.4416913763379854e-16
+// variance(f - f_Boost): 4.3461914185990199e-31
+// stddev(f - f_Boost): 6.5925650687718054e-16
 const testcase_ellint_3<double>
 data129[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17322209907520358, 0.30000000000000004, 0.80000000000000004, 
+  { 0.17604338956191670, 0.30000000000000004, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33917623046949996, 0.30000000000000004, 0.80000000000000004, 
+  { 0.36146952517410791, 0.30000000000000004, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49307204894329176, 0.30000000000000004, 0.80000000000000004, 
+  { 0.56736453393774644, 0.30000000000000004, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63337802830291734, 0.30000000000000004, 0.80000000000000004, 
+  { 0.80873149979001091, 0.30000000000000004, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.76104540997689407, 0.30000000000000004, 0.80000000000000004, 
+  { 1.1077903069860620, 0.30000000000000004, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.87832009635450714, 0.30000000000000004, 0.80000000000000004, 
+  { 1.4985874311132998, 0.30000000000000004, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.98787879723171790, 0.30000000000000004, 0.80000000000000004, 
+  { 2.0298167266724954, 0.30000000000000004, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0924036340069339, 0.30000000000000004, 0.80000000000000004, 
+  { 2.7483929054985432, 0.30000000000000004, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1944567571590048, 0.30000000000000004, 0.80000000000000004, 
+  { 3.6283050484567170, 0.30000000000000004, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler129 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.90000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.6419688299804087e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1301806687926828e-16
+// mean(f - f_Boost): 4.1633363423443370e-16
+// variance(f - f_Boost): 2.2835347143080263e-31
+// stddev(f - f_Boost): 4.7786344433405093e-16
 const testcase_ellint_3<double>
 data130[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17305109924485945, 0.30000000000000004, 0.90000000000000002, 
+  { 0.17622526204962433, 0.30000000000000004, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33793890239556984, 0.30000000000000004, 0.90000000000000002, 
+  { 0.36304439230777141, 0.30000000000000004, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48947218005089738, 0.30000000000000004, 0.90000000000000002, 
+  { 0.57345914744719195, 0.30000000000000004, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62623332340775151, 0.30000000000000004, 0.90000000000000002, 
+  { 0.82641512928845162, 0.30000000000000004, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74951596581511148, 0.30000000000000004, 0.90000000000000002, 
+  { 1.1534256210757743, 0.30000000000000004, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.86189886597755994, 0.30000000000000004, 0.90000000000000002, 
+  { 1.6124900353411677, 0.30000000000000004, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.96629451153092005, 0.30000000000000004, 0.90000000000000002, 
+  { 2.3165905514845089, 0.30000000000000004, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0655269133492682, 0.30000000000000004, 0.90000000000000002, 
+  { 3.4625619526539824, 0.30000000000000004, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1622376896064914, 0.30000000000000004, 0.90000000000000002, 
+  { 5.1479514944016787, 0.30000000000000004, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler130 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.0000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 5.4157225142938039e-16
+// Test data for k=0.40000000000000013, nu=0.0000000000000000.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0831445028587608e-15
+// mean(f - f_Boost): 1.7486012637846215e-16
+// variance(f - f_Boost): 3.1664095331106078e-31
+// stddev(f - f_Boost): 5.6270858649132121e-16
 const testcase_ellint_3<double>
 data131[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.0000000000000000, 
+  { 0.0000000000000000, 0.40000000000000013, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17467414669441528, 0.39999999999999991, 0.0000000000000000, 
+  { 0.17467414669441528, 0.40000000000000013, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35018222772483443, 0.39999999999999991, 0.0000000000000000, 
+  { 0.35018222772483443, 0.40000000000000013, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52729015917508737, 0.39999999999999991, 0.0000000000000000, 
+  { 0.52729015917508748, 0.40000000000000013, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70662374407341244, 0.39999999999999991, 0.0000000000000000, 
+  { 0.70662374407341244, 0.40000000000000013, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.88859210497602170, 0.39999999999999991, 0.0000000000000000, 
+  { 0.88859210497602159, 0.40000000000000013, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0733136290471379, 0.39999999999999991, 0.0000000000000000, 
+  { 1.0733136290471381, 0.40000000000000013, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2605612170157061, 0.39999999999999991, 0.0000000000000000, 
+  { 1.2605612170157066, 0.40000000000000013, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4497513956433439, 0.39999999999999991, 0.0000000000000000, 
+  { 1.4497513956433439, 0.40000000000000013, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000, 
+  { 1.6399998658645112, 0.40000000000000013, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler131 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.10000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 5.6859551010103832e-16
+// Test data for k=0.40000000000000013, nu=0.10000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0263824105456986e-15
+// mean(f - f_Boost): 1.7486012637846215e-16
+// variance(f - f_Boost): 3.1664095331106078e-31
+// stddev(f - f_Boost): 5.6270858649132121e-16
 const testcase_ellint_3<double>
 data132[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.10000000000000001, 
+  { 0.0000000000000000, 0.40000000000000013, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17449806706684670, 0.39999999999999991, 0.10000000000000001, 
+  { 0.17485086590796767, 0.40000000000000013, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34880048623856075, 0.39999999999999991, 0.10000000000000001, 
+  { 0.35158366412506992, 0.40000000000000013, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52277322065757392, 0.39999999999999991, 0.10000000000000001, 
+  { 0.53194731675711726, 0.40000000000000013, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69638072056918365, 0.39999999999999991, 0.10000000000000001, 
+  { 0.71740615528010931, 0.40000000000000013, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.86968426619831540, 0.39999999999999991, 0.10000000000000001, 
+  { 0.90896157773487030, 0.40000000000000013, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0428044206578095, 0.39999999999999991, 0.10000000000000001, 
+  { 1.1069605483834348, 0.40000000000000013, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2158651158274378, 0.39999999999999991, 0.10000000000000001, 
+  { 1.3109353428823001, 0.40000000000000013, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3889447129893324, 0.39999999999999991, 0.10000000000000001, 
+  { 1.5195460789903450, 0.40000000000000013, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001, 
+  { 1.7306968836847190, 0.40000000000000013, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler132 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.20000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 5.9444065952225719e-16
+// Test data for k=0.40000000000000013, nu=0.20000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.6644296021947179e-16
+// mean(f - f_Boost): 2.0816681711721685e-16
+// variance(f - f_Boost): 3.0360740073926687e-31
+// stddev(f - f_Boost): 5.5100580826273227e-16
 const testcase_ellint_3<double>
 data133[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.20000000000000001, 
+  { 0.0000000000000000, 0.40000000000000013, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17432262290723397, 0.39999999999999991, 0.20000000000000001, 
+  { 0.17502822886437389, 0.40000000000000013, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34743795258968596, 0.39999999999999991, 0.20000000000000001, 
+  { 0.35300530062530805, 0.40000000000000013, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51838919472805112, 0.39999999999999991, 0.20000000000000001, 
+  { 0.53675259548210896, 0.40000000000000013, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68663134739057907, 0.39999999999999991, 0.20000000000000001, 
+  { 0.72878006428676934, 0.40000000000000013, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.85206432981833979, 0.39999999999999991, 0.20000000000000001, 
+  { 0.93100219010583574, 0.40000000000000013, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0149595349004430, 0.39999999999999991, 0.20000000000000001, 
+  { 1.1443487271187611, 0.40000000000000013, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1758349405464676, 0.39999999999999991, 0.20000000000000001, 
+  { 1.3683427764108813, 0.40000000000000013, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3353337673882637, 0.39999999999999991, 0.20000000000000001, 
+  { 1.6008221459300933, 0.40000000000000013, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001, 
+  { 1.8380358826317627, 0.40000000000000013, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler133 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.29999999999999999.
-// max(|f - f_GSL|): 1.1102230246251565e-15
-// max(|f - f_GSL| / |f_GSL|): 7.7406350888907249e-16
+// Test data for k=0.40000000000000013, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0271556462838835e-16
+// mean(f - f_Boost): 2.0816681711721685e-16
+// variance(f - f_Boost): 3.0360740073926687e-31
+// stddev(f - f_Boost): 5.5100580826273227e-16
 const testcase_ellint_3<double>
 data134[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.29999999999999999, 
+  { 0.0000000000000000, 0.40000000000000013, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17414781013591540, 0.39999999999999991, 0.29999999999999999, 
+  { 0.17520623975982899, 0.40000000000000013, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34609415696777285, 0.39999999999999991, 0.29999999999999999, 
+  { 0.35444766141612105, 0.40000000000000013, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51413131295862535, 0.39999999999999991, 0.29999999999999999, 
+  { 0.54171455841536009, 0.40000000000000013, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67733527622935630, 0.39999999999999991, 0.29999999999999999, 
+  { 0.74080517001084012, 0.40000000000000013, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.83558675182733266, 0.39999999999999991, 0.29999999999999999, 
+  { 0.95496950509296574, 0.40000000000000013, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.98940140808865906, 0.39999999999999991, 0.29999999999999999, 
+  { 1.1862627879844718, 0.40000000000000013, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1396968797728058, 0.39999999999999991, 0.29999999999999999, 
+  { 1.4346501803799458, 0.40000000000000013, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2875920037865090, 0.39999999999999991, 0.29999999999999999, 
+  { 1.6971744798077699, 0.40000000000000013, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999, 
+  { 1.9677924132520139, 0.40000000000000013, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler134 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4314214811441816e-16
+// Test data for k=0.40000000000000013, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3436329231972794e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 2.9507053793392374e-31
+// stddev(f - f_Boost): 5.4320395611033958e-16
 const testcase_ellint_3<double>
 data135[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.40000000000000002, 
+  { 0.0000000000000000, 0.40000000000000013, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17397362471112707, 0.39999999999999991, 0.40000000000000002, 
+  { 0.17538490283034375, 0.40000000000000013, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34476864603333196, 0.39999999999999991, 0.40000000000000002, 
+  { 0.35591129064319948, 0.40000000000000013, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50999329415379346, 0.39999999999999991, 0.40000000000000002, 
+  { 0.54684250413264535, 0.40000000000000013, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66845674551396006, 0.39999999999999991, 0.40000000000000002, 
+  { 0.75355027742668290, 0.40000000000000013, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.82012848346231748, 0.39999999999999991, 0.40000000000000002, 
+  { 0.98117935026780634, 0.40000000000000013, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.96582449258349057, 0.39999999999999991, 0.40000000000000002, 
+  { 1.2337464222030736, 0.40000000000000013, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1068473749476286, 0.39999999999999991, 0.40000000000000002, 
+  { 1.5125183419289221, 0.40000000000000013, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2447132729159989, 0.39999999999999991, 0.40000000000000002, 
+  { 1.8140224451130313, 0.40000000000000013, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002, 
+  { 2.1289968719280026, 0.40000000000000013, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler135 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.50000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.6621057007519435e-16
+// Test data for k=0.40000000000000013, nu=0.50000000000000000.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.7013794022122431e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
 const testcase_ellint_3<double>
 data136[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.50000000000000000, 
+  { 0.0000000000000000, 0.40000000000000013, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17380006262854136, 0.39999999999999991, 0.50000000000000000, 
+  { 0.17556422235224273, 0.40000000000000013, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34346098216756610, 0.39999999999999991, 0.50000000000000000, 
+  { 0.35739675341763921, 0.40000000000000013, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50596929935059420, 0.39999999999999991, 0.50000000000000000, 
+  { 0.55214655195037188, 0.40000000000000013, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65996392089131251, 0.39999999999999991, 0.50000000000000000, 
+  { 0.76709520942047438, 0.40000000000000013, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.80558463511364786, 0.39999999999999991, 0.50000000000000000, 
+  { 1.0100278761577499, 0.40000000000000013, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.94397834522857704, 0.39999999999999991, 0.50000000000000000, 
+  { 1.2882265661384342, 0.40000000000000013, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0768075114108115, 0.39999999999999991, 0.50000000000000000, 
+  { 1.6059059780051876, 0.40000000000000013, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2059184624251333, 0.39999999999999991, 0.50000000000000000, 
+  { 1.9600182740224081, 0.40000000000000013, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000, 
+  { 2.3367461373176512, 0.40000000000000013, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler136 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.59999999999999998.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.8853630717730749e-16
+// Test data for k=0.40000000000000013, nu=0.60000000000000009.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.4792115132836117e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 4.8893797490374802e-31
+// stddev(f - f_Boost): 6.9924099915819294e-16
 const testcase_ellint_3<double>
 data137[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.59999999999999998, 
+  { 0.0000000000000000, 0.40000000000000013, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17362711992081245, 0.39999999999999991, 0.59999999999999998, 
+  { 0.17574420264267029, 0.40000000000000013, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34217074276403953, 0.39999999999999991, 0.59999999999999998, 
+  { 0.35890463689046265, 0.40000000000000013, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50205389185761606, 0.39999999999999991, 0.59999999999999998, 
+  { 0.55763773975194486, 0.40000000000000013, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.65182834920372734, 0.39999999999999991, 0.59999999999999998, 
+  { 0.78153324227761267, 0.40000000000000013, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.79186512820565136, 0.39999999999999991, 0.59999999999999998, 
+  { 1.0420205885765887, 0.40000000000000013, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.92365535916287134, 0.39999999999999991, 0.59999999999999998, 
+  { 1.3517205230381770, 0.40000000000000013, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0491915663957907, 0.39999999999999991, 0.59999999999999998, 
+  { 1.7210360970313896, 0.40000000000000013, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1705934291745106, 0.39999999999999991, 0.59999999999999998, 
+  { 2.1500780510169246, 0.40000000000000013, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998, 
+  { 2.6186940209850191, 0.40000000000000013, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler137 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.69999999999999996.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.1018730557776469e-16
+// Test data for k=0.40000000000000013, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.8573292020719759e-16
+// mean(f - f_Boost): 2.2759572004815707e-16
+// variance(f - f_Boost): 2.9613098824898137e-31
+// stddev(f - f_Boost): 5.4417918762938862e-16
 const testcase_ellint_3<double>
 data138[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.69999999999999996, 
+  { 0.0000000000000000, 0.40000000000000013, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17345479265712868, 0.39999999999999991, 0.69999999999999996, 
+  { 0.17592484806010436, 0.40000000000000013, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34089751955950354, 0.39999999999999991, 0.69999999999999996, 
+  { 0.36043555139631439, 0.40000000000000013, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49824200167361332, 0.39999999999999991, 0.69999999999999996, 
+  { 0.56332813669944881, 0.40000000000000013, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64402450341199402, 0.39999999999999991, 0.69999999999999996, 
+  { 0.79697424562157548, 0.40000000000000013, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.77889207804122873, 0.39999999999999991, 0.69999999999999996, 
+  { 1.0778155987523672, 0.40000000000000013, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.90468169720957992, 0.39999999999999991, 0.69999999999999996, 
+  { 1.4272018169896268, 0.40000000000000013, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0236847823692916, 0.39999999999999991, 0.69999999999999996, 
+  { 1.8684377907453382, 0.40000000000000013, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1382465247425166, 0.39999999999999991, 0.69999999999999996, 
+  { 2.4128677409207473, 0.40000000000000013, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996, 
+  { 3.0327078743873246, 0.40000000000000013, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler138 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.80000000000000004.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.3122171115555478e-16
+// Test data for k=0.40000000000000013, nu=0.80000000000000004.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.5273712585384737e-16
+// mean(f - f_Boost): 4.5241588253475131e-16
+// variance(f - f_Boost): 1.1866477068555882e-30
+// stddev(f - f_Boost): 1.0893336067778265e-15
 const testcase_ellint_3<double>
 data139[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.80000000000000004, 
+  { 0.0000000000000000, 0.40000000000000013, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17328307694277154, 0.39999999999999991, 0.80000000000000004, 
+  { 0.17610616300487833, 0.40000000000000013, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33964091800132007, 0.39999999999999991, 0.80000000000000004, 
+  { 0.36199013167171978, 0.40000000000000013, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49452889372467440, 0.39999999999999991, 0.80000000000000004, 
+  { 0.56923097361842434, 0.40000000000000013, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63652940095937316, 0.39999999999999991, 0.80000000000000004, 
+  { 0.81354878456624347, 0.40000000000000013, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.76659772511159097, 0.39999999999999991, 0.80000000000000004, 
+  { 1.1182902719261825, 0.40000000000000013, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.88691047977338111, 0.39999999999999991, 0.80000000000000004, 
+  { 1.5192950589409022, 0.40000000000000013, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0000273200611638, 0.39999999999999991, 0.80000000000000004, 
+  { 2.0678761710223981, 0.40000000000000013, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1084787902188009, 0.39999999999999991, 0.80000000000000004, 
+  { 2.8135222249879788, 0.40000000000000013, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004, 
+  { 3.7289548002199902, 0.40000000000000013, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler139 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.90000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.5168974431077345e-16
+// Test data for k=0.40000000000000013, nu=0.90000000000000002.
+// max(|f - f_Boost|): 6.2172489379008766e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.1718379478872251e-15
+// mean(f - f_Boost): 8.4099394115355610e-16
+// variance(f - f_Boost): 3.5684096037099424e-30
+// stddev(f - f_Boost): 1.8890234523980751e-15
 const testcase_ellint_3<double>
 data140[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.90000000000000002, 
+  { 0.0000000000000000, 0.40000000000000013, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17311196891868127, 0.39999999999999991, 0.90000000000000002, 
+  { 0.17628815191971123, 0.40000000000000013, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33840055664911906, 0.39999999999999991, 0.90000000000000002, 
+  { 0.36356903815378772, 0.40000000000000013, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49091013944075329, 0.39999999999999991, 0.90000000000000002, 
+  { 0.57536079447000310, 0.40000000000000013, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62932228186809580, 0.39999999999999991, 0.90000000000000002, 
+  { 0.83141355850172571, 0.40000000000000013, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.75492278323019801, 0.39999999999999991, 0.90000000000000002, 
+  { 1.1646481598721361, 0.40000000000000013, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.87021659043854294, 0.39999999999999991, 0.90000000000000002, 
+  { 1.6357275034001995, 0.40000000000000013, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.97800245228239246, 0.39999999999999991, 0.90000000000000002, 
+  { 2.3628787566572402, 0.40000000000000013, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0809625773173697, 0.39999999999999991, 0.90000000000000002, 
+  { 3.5521010369134962, 0.40000000000000013, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002, 
+  { 5.3055535102872513, 0.40000000000000013, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler140 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.0000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1201497220602069e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.4551389361831220e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.5893058141206173e-32
+// stddev(f - f_Boost): 1.6091320064309879e-16
 const testcase_ellint_3<double>
 data141[10] =
 {
@@ -4108,289 +4530,319 @@
 	  0.0000000000000000 },
   { 0.17475385514035785, 0.50000000000000000, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35081868470101585, 0.50000000000000000, 0.0000000000000000, 
+  { 0.35081868470101579, 0.50000000000000000, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.52942862705190574, 0.50000000000000000, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.71164727562630314, 0.50000000000000000, 0.0000000000000000, 
+  { 0.71164727562630326, 0.50000000000000000, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.89824523594227768, 0.50000000000000000, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0895506700518851, 0.50000000000000000, 0.0000000000000000, 
+  { 1.0895506700518853, 0.50000000000000000, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2853005857432931, 0.50000000000000000, 0.0000000000000000, 
+  { 1.2853005857432933, 0.50000000000000000, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4845545520549484, 0.50000000000000000, 0.0000000000000000, 
+  { 1.4845545520549488, 0.50000000000000000, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000, 
+  { 1.6857503548125961, 0.50000000000000000, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler141 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.10000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1662857256911530e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7416868347177582e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
 const testcase_ellint_3<double>
 data142[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17457763120814676, 0.50000000000000000, 0.10000000000000001, 
+  { 0.17493071928248824, 0.50000000000000000, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34943246340849154, 0.50000000000000000, 0.10000000000000001, 
+  { 0.35222467688034798, 0.50000000000000000, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52487937869610790, 0.50000000000000000, 0.10000000000000001, 
+  { 0.53411928652008112, 0.50000000000000000, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.70127785096388384, 0.50000000000000000, 0.10000000000000001, 
+  { 0.72256398117177589, 0.50000000000000000, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.87898815988624479, 0.50000000000000000, 0.10000000000000001, 
+  { 0.91899583232771009, 0.50000000000000000, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0582764576094172, 0.50000000000000000, 0.10000000000000001, 
+  { 1.1240549163055360, 0.50000000000000000, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2391936844060205, 0.50000000000000000, 0.10000000000000001, 
+  { 1.3372938086286021, 0.50000000000000000, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.4214793542995841, 0.50000000000000000, 0.10000000000000001, 
+  { 1.5570024469132429, 0.50000000000000000, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001, 
+  { 1.7803034946545480, 0.50000000000000000, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler142 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.20000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2114786773102175e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1198767993730867e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 5.0311947683004831e-32
+// stddev(f - f_Boost): 2.2430324938128922e-16
 const testcase_ellint_3<double>
 data143[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17440204336345433, 0.50000000000000000, 0.20000000000000001, 
+  { 0.17510822779582402, 0.50000000000000000, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34806552388338824, 0.50000000000000000, 0.20000000000000001, 
+  { 0.35365094725531487, 0.50000000000000000, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52046416757129810, 0.50000000000000000, 0.20000000000000001, 
+  { 0.53895933237328697, 0.50000000000000000, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.69140924550993865, 0.50000000000000000, 0.20000000000000001, 
+  { 0.73408090840070794, 0.50000000000000000, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.86104678636125520, 0.50000000000000000, 0.20000000000000001, 
+  { 0.94145442818535396, 0.50000000000000000, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0297439459053981, 0.50000000000000000, 0.20000000000000001, 
+  { 1.1624120186296487, 0.50000000000000000, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1979214112912033, 0.50000000000000000, 0.20000000000000001, 
+  { 1.3965823372867114, 0.50000000000000000, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3659033858648930, 0.50000000000000000, 0.20000000000000001, 
+  { 1.6414308440430099, 0.50000000000000000, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001, 
+  { 1.8922947612264018, 0.50000000000000000, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler143 = 2.5000000000000020e-13;
 
-// Test data for k=0.50000000000000000, nu=0.29999999999999999.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2557837230041312e-16
+// Test data for k=0.50000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3800262770228813e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 8.5027191584278157e-32
+// stddev(f - f_Boost): 2.9159422419567599e-16
 const testcase_ellint_3<double>
 data144[10] =
 {
-  { 0.0000000000000000, 0.50000000000000000, 0.29999999999999999, 
+  { 0.0000000000000000, 0.50000000000000000, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17422708752228896, 0.50000000000000000, 0.29999999999999999, 
+  { 0.17528638488102041, 0.50000000000000000, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34671739434855858, 0.50000000000000000, 0.29999999999999999, 
+  { 0.35509802222332720, 0.50000000000000000, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51617616305641878, 0.50000000000000000, 0.29999999999999999, 
+  { 0.54395740731866193, 0.50000000000000000, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.68200047612545167, 0.50000000000000000, 0.29999999999999999, 
+  { 0.74625871438752667, 0.50000000000000000, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.84427217869498372, 0.50000000000000000, 0.29999999999999999, 
+  { 0.96588271186092023, 0.50000000000000000, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0035637821389782, 0.50000000000000000, 0.29999999999999999, 
+  { 1.2054319584357329, 0.50000000000000000, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1606800483933111, 0.50000000000000000, 0.29999999999999999, 
+  { 1.4651077994832871, 0.50000000000000000, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.3164407134643459, 0.50000000000000000, 0.29999999999999999, 
+  { 1.7416018368052644, 0.50000000000000000, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999, 
+  { 2.0277924458111314, 0.50000000000000000, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler144 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.40000000000000002.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2992508582900068e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.0439932918341581e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 9.0809736800018602e-32
+// stddev(f - f_Boost): 3.0134653938616686e-16
 const testcase_ellint_3<double>
 data145[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17405275963859917, 0.50000000000000000, 0.40000000000000002, 
+  { 0.17546519477859268, 0.50000000000000000, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34538761957029329, 0.50000000000000000, 0.40000000000000002, 
+  { 0.35656644822531680, 0.50000000000000000, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51200902646603907, 0.50000000000000000, 0.40000000000000002, 
+  { 0.54912289677411319, 0.50000000000000000, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.67301522212868792, 0.50000000000000000, 0.40000000000000002, 
+  { 0.75916731611690047, 0.50000000000000000, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.82853844466313320, 0.50000000000000000, 0.40000000000000002, 
+  { 0.99260415631328214, 0.50000000000000000, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.97942097862681488, 0.50000000000000000, 0.40000000000000002, 
+  { 1.2541925856918670, 0.50000000000000000, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1268429801220614, 0.50000000000000000, 0.40000000000000002, 
+  { 1.5456393705347609, 0.50000000000000000, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2720406704533922, 0.50000000000000000, 0.40000000000000002, 
+  { 1.8631904972952076, 0.50000000000000000, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002, 
+  { 2.1962905366178065, 0.50000000000000000, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler145 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.50000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3419255755184137e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6797816859260978e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
 const testcase_ellint_3<double>
 data146[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17387905570381157, 0.50000000000000000, 0.50000000000000000, 
+  { 0.17564466176941509, 0.50000000000000000, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34407576010465207, 0.50000000000000000, 0.50000000000000000, 
+  { 0.35805679276065394, 0.50000000000000000, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50795686560160824, 0.50000000000000000, 0.50000000000000000, 
+  { 0.55446601496200032, 0.50000000000000000, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.66442115453330164, 0.50000000000000000, 0.50000000000000000, 
+  { 0.77288783578259013, 0.50000000000000000, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.81373829119355345, 0.50000000000000000, 0.50000000000000000, 
+  { 1.0220246013918972, 0.50000000000000000, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.95705743313235825, 0.50000000000000000, 0.50000000000000000, 
+  { 1.3101681612463965, 0.50000000000000000, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0959131991362554, 0.50000000000000000, 0.50000000000000000, 
+  { 1.6422994881851025, 0.50000000000000000, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2318900529754597, 0.50000000000000000, 0.50000000000000000, 
+  { 2.0152636030998816, 0.50000000000000000, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000, 
+  { 2.4136715042011945, 0.50000000000000000, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler146 = 2.5000000000000020e-13;
 
-// Test data for k=0.50000000000000000, nu=0.59999999999999998.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3838494104749599e-16
+// Test data for k=0.50000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9178421578645735e-16
+// mean(f - f_Boost): 1.3322676295501878e-16
+// variance(f - f_Boost): 1.7749370367472766e-31
+// stddev(f - f_Boost): 4.2130001622920411e-16
 const testcase_ellint_3<double>
 data147[10] =
 {
-  { 0.0000000000000000, 0.50000000000000000, 0.59999999999999998, 
+  { 0.0000000000000000, 0.50000000000000000, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17370597174637581, 0.50000000000000000, 0.59999999999999998, 
+  { 0.17582479017522740, 0.50000000000000000, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34278139158591414, 0.50000000000000000, 0.59999999999999998, 
+  { 0.35956964546660036, 0.50000000000000000, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50401419439302708, 0.50000000000000000, 0.59999999999999998, 
+  { 0.55999790372984193, 0.50000000000000000, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.65618938076167210, 0.50000000000000000, 0.59999999999999998, 
+  { 0.78751507911209895, 0.50000000000000000, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.79977959248855424, 0.50000000000000000, 0.59999999999999998, 
+  { 1.0546620505035220, 0.50000000000000000, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.93625925190753545, 0.50000000000000000, 0.59999999999999998, 
+  { 1.3754438357425935, 0.50000000000000000, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0674905658379708, 0.50000000000000000, 0.59999999999999998, 
+  { 1.7615727400820127, 0.50000000000000000, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1953481298023050, 0.50000000000000000, 0.59999999999999998, 
+  { 2.2134638067565242, 0.50000000000000000, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998, 
+  { 2.7090491861753558, 0.50000000000000000, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler147 = 2.5000000000000020e-13;
 
-// Test data for k=0.50000000000000000, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4250604066951477e-16
+// Test data for k=0.50000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0745105182189226e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 1.9996383743576116e-32
+// stddev(f - f_Boost): 1.4140857026211713e-16
 const testcase_ellint_3<double>
 data148[10] =
 {
-  { 0.0000000000000000, 0.50000000000000000, 0.69999999999999996, 
+  { 0.0000000000000000, 0.50000000000000000, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17353350383131641, 0.50000000000000000, 0.69999999999999996, 
+  { 0.17600558435914915, 0.50000000000000000, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34150410405436771, 0.50000000000000000, 0.69999999999999996, 
+  { 0.36110561926726259, 0.50000000000000000, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50017589696443487, 0.50000000000000000, 0.69999999999999996, 
+  { 0.56573074641137111, 0.50000000000000000, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64829398188419951, 0.50000000000000000, 0.69999999999999996, 
+  { 0.80316073084237205, 0.50000000000000000, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.78658270782402073, 0.50000000000000000, 0.69999999999999996, 
+  { 1.0911910688131461, 0.50000000000000000, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.91684738336675053, 0.50000000000000000, 0.69999999999999996, 
+  { 1.4530946406380640, 0.50000000000000000, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0412486789555935, 0.50000000000000000, 0.69999999999999996, 
+  { 1.9144386536785372, 0.50000000000000000, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1619021847612001, 0.50000000000000000, 0.69999999999999996, 
+  { 2.4878788958234970, 0.50000000000000000, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996, 
+  { 3.1433945297859225, 0.50000000000000000, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler148 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5715240651179632e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.4380477375534667e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
 const testcase_ellint_3<double>
 data149[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17336164805979126, 0.50000000000000000, 0.80000000000000004, 
+  { 0.17618704872620228, 0.50000000000000000, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34024350132086773, 0.50000000000000000, 0.80000000000000004, 
+  { 0.36266535159745827, 0.50000000000000000, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49643719555734073, 0.50000000000000000, 0.80000000000000004, 
+  { 0.57167789954529158, 0.50000000000000000, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.64071162456976150, 0.50000000000000000, 0.80000000000000004, 
+  { 0.81995752984315018, 0.50000000000000000, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.77407836177211908, 0.50000000000000000, 0.80000000000000004, 
+  { 1.1325112162158122, 0.50000000000000000, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.89867058251905652, 0.50000000000000000, 0.80000000000000004, 
+  { 1.5479055930718042, 0.50000000000000000, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0169181822134910, 0.50000000000000000, 0.80000000000000004, 
+  { 2.1215243941010486, 0.50000000000000000, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1311363312779448, 0.50000000000000000, 0.80000000000000004, 
+  { 2.9069405767650132, 0.50000000000000000, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004, 
+  { 3.8750701888108066, 0.50000000000000000, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler149 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4664649039489274e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6192315188521289e-16
+// mean(f - f_Boost): 3.5249581031848718e-16
+// variance(f - f_Boost): 2.5029385557256515e-31
+// stddev(f - f_Boost): 5.0029376927217987e-16
 const testcase_ellint_3<double>
 data150[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17319040056865681, 0.50000000000000000, 0.90000000000000002, 
+  { 0.17636918772384180, 0.50000000000000000, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33899920036578557, 0.50000000000000000, 0.90000000000000002, 
+  { 0.36424950570740700, 0.50000000000000000, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49279362182695174, 0.50000000000000000, 0.90000000000000002, 
+  { 0.57785404590231426, 0.50000000000000000, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.63342123379746151, 0.50000000000000000, 0.90000000000000002, 
+  { 0.83806480521716531, 0.50000000000000000, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.76220595179550321, 0.50000000000000000, 0.90000000000000002, 
+  { 1.1798568683069752, 0.50000000000000000, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.88160004743532294, 0.50000000000000000, 0.90000000000000002, 
+  { 1.6678766243739607, 0.50000000000000000, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.99427448642310123, 0.50000000000000000, 0.90000000000000002, 
+  { 2.4282976450693483, 0.50000000000000000, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1027091512470095, 0.50000000000000000, 0.90000000000000002, 
+  { 3.6810787666126656, 0.50000000000000000, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002, 
+  { 5.5355132096026454, 0.50000000000000000, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler150 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3664899092028927e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.3664899092028927e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 7.8758646268991113e-33
+// stddev(f - f_Boost): 8.8746068233466605e-17
 const testcase_ellint_3<double>
 data151[10] =
 {
@@ -4398,19 +4850,19 @@
 	  0.0000000000000000 },
   { 0.17485154362988359, 0.60000000000000009, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35160509865544326, 0.60000000000000009, 0.0000000000000000, 
+  { 0.35160509865544320, 0.60000000000000009, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.53210652578446138, 0.60000000000000009, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.71805304664485659, 0.60000000000000009, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.91082759030195970, 0.60000000000000009, 0.0000000000000000, 
+  { 0.91082759030195981, 0.60000000000000009, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1112333229323361, 0.60000000000000009, 0.0000000000000000, 
 	  1.0471975511965976 },
   { 1.3191461190365270, 0.60000000000000009, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.5332022105084775, 0.60000000000000009, 0.0000000000000000, 
+  { 1.5332022105084779, 0.60000000000000009, 0.0000000000000000, 
 	  1.3962634015954636 },
   { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000, 
 	  1.5707963267948966 },
@@ -4418,559 +4870,619 @@
 const double toler151 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4937942733669112e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.2335247010355137e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 2.2835347143080263e-33
+// stddev(f - f_Boost): 4.7786344433405099e-17
 const testcase_ellint_3<double>
 data152[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17467514275022011, 0.60000000000000009, 0.10000000000000001, 
+  { 0.17502858548476194, 0.60000000000000009, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35021333086258255, 0.60000000000000009, 0.10000000000000001, 
+  { 0.35301673150537388, 0.60000000000000009, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52751664092962691, 0.60000000000000009, 0.10000000000000001, 
+  { 0.53683932476326812, 0.60000000000000009, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.70752126971957874, 0.60000000000000009, 0.10000000000000001, 
+  { 0.72914228589586771, 0.60000000000000009, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.89111058756112871, 0.60000000000000009, 0.10000000000000001, 
+  { 0.93208036718354692, 0.60000000000000009, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0789241202877768, 0.60000000000000009, 0.10000000000000001, 
+  { 1.1468984688863377, 0.60000000000000009, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2710800210399946, 0.60000000000000009, 0.10000000000000001, 
+  { 1.3733904977062528, 0.60000000000000009, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.4669060574440276, 0.60000000000000009, 0.10000000000000001, 
+  { 1.6094225663372157, 0.60000000000000009, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001, 
+  { 1.8508766487100685, 0.60000000000000009, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler152 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.20000000000000001.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1891472451898755e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -2.4980018054066023e-17
+// variance(f - f_Boost): 2.1685495635542404e-32
+// stddev(f - f_Boost): 1.4725995937641163e-16
 const testcase_ellint_3<double>
 data153[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17449937871800650, 0.60000000000000009, 0.20000000000000001, 
+  { 0.17520627248155893, 0.60000000000000009, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34884093647346553, 0.60000000000000009, 0.20000000000000001, 
+  { 0.35444873935437748, 0.60000000000000009, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52306221119844087, 0.60000000000000009, 0.20000000000000001, 
+  { 0.54172310557682524, 0.60000000000000009, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.69749955678982223, 0.60000000000000009, 0.20000000000000001, 
+  { 0.74084300280734672, 0.60000000000000009, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.87274610682416853, 0.60000000000000009, 0.20000000000000001, 
+  { 0.95509001527006121, 0.60000000000000009, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0494620540750792, 0.60000000000000009, 0.20000000000000001, 
+  { 1.1865688084431796, 0.60000000000000009, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.2280847305507339, 0.60000000000000009, 0.20000000000000001, 
+  { 1.4352978868932600, 0.60000000000000009, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.4085436279696888, 0.60000000000000009, 0.20000000000000001, 
+  { 1.6983400371331818, 0.60000000000000009, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001, 
+  { 1.9695980282802217, 0.60000000000000009, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler153 = 2.5000000000000020e-13;
 
-// Test data for k=0.60000000000000009, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7339932380431439e-16
+// Test data for k=0.60000000000000009, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.9470074709717020e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
 const testcase_ellint_3<double>
 data154[10] =
 {
-  { 0.0000000000000000, 0.60000000000000009, 0.29999999999999999, 
+  { 0.0000000000000000, 0.60000000000000009, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17432424744393932, 0.60000000000000009, 0.29999999999999999, 
+  { 0.17538460882640122, 0.60000000000000009, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34748744127146447, 0.60000000000000009, 0.29999999999999999, 
+  { 0.35590165133735557, 0.60000000000000009, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51873632743924825, 0.60000000000000009, 0.29999999999999999, 
+  { 0.54676661152254535, 0.60000000000000009, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.68794610396313116, 0.60000000000000009, 0.29999999999999999, 
+  { 0.75321709418305305, 0.60000000000000009, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.85558070175468726, 0.60000000000000009, 0.29999999999999999, 
+  { 0.98012637808992920, 0.60000000000000009, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0224416343605653, 0.60000000000000009, 0.29999999999999999, 
+  { 1.2310891277158875, 0.60000000000000009, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1893144457936788, 0.60000000000000009, 0.29999999999999999, 
+  { 1.5069157924585623, 0.60000000000000009, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.3566435377982575, 0.60000000000000009, 0.29999999999999999, 
+  { 1.8039583598337940, 0.60000000000000009, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999, 
+  { 2.1134154405060599, 0.60000000000000009, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler154 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.40000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.5440898085101625e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.8974839914337670e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.2849613290816465e-32
+// stddev(f - f_Boost): 1.5116088545260797e-16
 const testcase_ellint_3<double>
 data155[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17414974487670717, 0.60000000000000009, 0.40000000000000002, 
+  { 0.17556359876533037, 0.60000000000000009, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34615238767335027, 0.60000000000000009, 0.40000000000000002, 
+  { 0.35737601674244679, 0.60000000000000009, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51453257838108557, 0.60000000000000009, 0.40000000000000002, 
+  { 0.55197933771320218, 0.60000000000000009, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.67882386787534399, 0.60000000000000009, 0.40000000000000002, 
+  { 0.76633591620002905, 0.60000000000000009, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.83948470233173578, 0.60000000000000009, 0.40000000000000002, 
+  { 1.0075231136019616, 0.60000000000000009, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.99753496200073977, 0.60000000000000009, 0.40000000000000002, 
+  { 1.2815842073813450, 0.60000000000000009, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1541101404388487, 0.60000000000000009, 0.40000000000000002, 
+  { 1.5911666941449827, 0.60000000000000009, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.3100911323398816, 0.60000000000000009, 0.40000000000000002, 
+  { 1.9323227566025762, 0.60000000000000009, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002, 
+  { 2.2925036420985130, 0.60000000000000009, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler155 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.50000000000000000.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.7124937590522226e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.1397785842303966e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.5339913122479866e-32
+// stddev(f - f_Boost): 1.2385440291923362e-16
 const testcase_ellint_3<double>
 data156[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17397586700252807, 0.60000000000000009, 0.50000000000000000, 
+  { 0.17574324658480217, 0.60000000000000009, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34483533397138516, 0.60000000000000009, 0.50000000000000000, 
+  { 0.35887240603169313, 0.60000000000000009, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51044500461706477, 0.60000000000000009, 0.50000000000000000, 
+  { 0.55737161826345261, 0.60000000000000009, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.67009988034712664, 0.60000000000000009, 0.50000000000000000, 
+  { 0.78028227313077458, 0.60000000000000009, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.82434762375735193, 0.60000000000000009, 0.50000000000000000, 
+  { 1.0376989776486290, 0.60000000000000009, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.97447346702798998, 0.60000000000000009, 0.50000000000000000, 
+  { 1.3395933991042928, 0.60000000000000009, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.1219494000522143, 0.60000000000000009, 0.50000000000000000, 
+  { 1.6924049626591784, 0.60000000000000009, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2680242605954486, 0.60000000000000009, 0.50000000000000000, 
+  { 2.0931011856518920, 0.60000000000000009, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000, 
+  { 2.5239007084492711, 0.60000000000000009, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler156 = 2.5000000000000020e-13;
 
-// Test data for k=0.60000000000000009, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.0652177678695900e-16
+// Test data for k=0.60000000000000009, nu=0.60000000000000009.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.6651378277398083e-16
+// mean(f - f_Boost): 1.1934897514720432e-16
+// variance(f - f_Boost): 1.7585404776158019e-33
+// stddev(f - f_Boost): 4.1934955319110598e-17
 const testcase_ellint_3<double>
 data157[10] =
 {
-  { 0.0000000000000000, 0.60000000000000009, 0.59999999999999998, 
+  { 0.0000000000000000, 0.60000000000000009, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17380260984469353, 0.60000000000000009, 0.59999999999999998, 
+  { 0.17592355661219386, 0.60000000000000009, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34353585361777839, 0.60000000000000009, 0.59999999999999998, 
+  { 0.36039141192661606, 0.60000000000000009, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50646805774321380, 0.60000000000000009, 0.59999999999999998, 
+  { 0.56295472636903854, 0.60000000000000009, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.66174468108625506, 0.60000000000000009, 0.59999999999999998, 
+  { 0.79515295130165986, 0.60000000000000009, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.81007462280278408, 0.60000000000000009, 0.59999999999999998, 
+  { 1.0711886441942242, 0.60000000000000009, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.95303466945718729, 0.60000000000000009, 0.59999999999999998, 
+  { 1.4072952835139891, 0.60000000000000009, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0924118588677505, 0.60000000000000009, 0.59999999999999998, 
+  { 1.8174863977376825, 0.60000000000000009, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.2297640574847937, 0.60000000000000009, 0.59999999999999998, 
+  { 2.3029921578542232, 0.60000000000000009, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998, 
+  { 2.8388723099514972, 0.60000000000000009, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler157 = 2.5000000000000020e-13;
 
-// Test data for k=0.60000000000000009, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1692457486457856e-16
+// Test data for k=0.60000000000000009, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.0027679235921772e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.2849613290816465e-32
+// stddev(f - f_Boost): 1.5116088545260797e-16
 const testcase_ellint_3<double>
 data158[10] =
 {
-  { 0.0000000000000000, 0.60000000000000009, 0.69999999999999996, 
+  { 0.0000000000000000, 0.60000000000000009, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17362996946312007, 0.60000000000000009, 0.69999999999999996, 
+  { 0.17610453321631936, 0.60000000000000009, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34225353454870588, 0.60000000000000009, 0.69999999999999996, 
+  { 0.36193365056369764, 0.60000000000000009, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50259656397799524, 0.60000000000000009, 0.69999999999999996, 
+  { 0.56874098962268527, 0.60000000000000009, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.65373184496628933, 0.60000000000000009, 0.69999999999999996, 
+  { 0.81106198671477181, 0.60000000000000009, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.79658372884056439, 0.60000000000000009, 0.69999999999999996, 
+  { 1.1086886419010082, 0.60000000000000009, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.93303240100245421, 0.60000000000000009, 0.69999999999999996, 
+  { 1.4879048567239257, 0.60000000000000009, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0651547944716557, 0.60000000000000009, 0.69999999999999996, 
+  { 1.9780310073615925, 0.60000000000000009, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1947676204853441, 0.60000000000000009, 0.69999999999999996, 
+  { 2.5941545586772712, 0.60000000000000009, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.3232737468822813, 0.60000000000000009, 0.69999999999999996, 
+  { 3.3029735898397159, 0.60000000000000009, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler158 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2705175719241326e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 7.3044933435043190e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
 const testcase_ellint_3<double>
 data159[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17345794195390685, 0.60000000000000009, 0.80000000000000004, 
+  { 0.17628618080795252, 0.60000000000000009, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34098797854531027, 0.60000000000000009, 0.80000000000000004, 
+  { 0.36349976272521012, 0.60000000000000009, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49882569168826213, 0.60000000000000009, 0.80000000000000004, 
+  { 0.57474392342151914, 0.60000000000000009, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.64603758566475511, 0.60000000000000009, 0.80000000000000004, 
+  { 0.82814493499158170, 0.60000000000000009, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.78380365594769730, 0.60000000000000009, 0.80000000000000004, 
+  { 1.1511281795998280, 0.60000000000000009, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.91430946255611190, 0.60000000000000009, 0.80000000000000004, 
+  { 1.5864286332503075, 0.60000000000000009, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0398955217270607, 0.60000000000000009, 0.80000000000000004, 
+  { 2.1958944866494527, 0.60000000000000009, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1625948314277679, 0.60000000000000009, 0.80000000000000004, 
+  { 3.0398358172574604, 0.60000000000000009, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004, 
+  { 4.0867036409261832, 0.60000000000000009, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler159 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5585887739668036e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.5952142720718732e-16
+// mean(f - f_Boost): 4.6351811278100284e-16
+// variance(f - f_Boost): 2.1278339779151204e-31
+// stddev(f - f_Boost): 4.6128450851021651e-16
 const testcase_ellint_3<double>
 data160[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17328652344890030, 0.60000000000000009, 0.90000000000000002, 
+  { 0.17646850384035848, 0.60000000000000009, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33973880062929018, 0.60000000000000009, 0.90000000000000002, 
+  { 0.36509041515134105, 0.60000000000000009, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49515092233122743, 0.60000000000000009, 0.90000000000000002, 
+  { 0.58097838596260631, 0.60000000000000009, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.63864042139737043, 0.60000000000000009, 0.90000000000000002, 
+  { 0.84656453396163722, 0.60000000000000009, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.77167205646538850, 0.60000000000000009, 0.90000000000000002, 
+  { 1.1997828426963724, 0.60000000000000009, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.89673202848034383, 0.60000000000000009, 0.90000000000000002, 
+  { 1.7112436789225605, 0.60000000000000009, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0163984492661304, 0.60000000000000009, 0.90000000000000002, 
+  { 2.5193168553672312, 0.60000000000000009, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1328845785162431, 0.60000000000000009, 0.90000000000000002, 
+  { 3.8656670488606690, 0.60000000000000009, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.2479362973851873, 0.60000000000000009, 0.90000000000000002, 
+  { 5.8709993116265604, 0.60000000000000009, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler160 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.0000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5930208052157665e-16
+// Test data for k=0.70000000000000018, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1569224977685422e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 1.6571557210371951e-32
+// stddev(f - f_Boost): 1.2873056051447903e-16
 const testcase_ellint_3<double>
 data161[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.0000000000000000, 
+  { 0.0000000000000000, 0.70000000000000018, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17496737466916723, 0.69999999999999996, 0.0000000000000000, 
+  { 0.17496737466916723, 0.70000000000000018, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35254687535677925, 0.69999999999999996, 0.0000000000000000, 
+  { 0.35254687535677931, 0.70000000000000018, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.53536740275997119, 0.69999999999999996, 0.0000000000000000, 
+  { 0.53536740275997130, 0.70000000000000018, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.72603797651684454, 0.69999999999999996, 0.0000000000000000, 
+  { 0.72603797651684454, 0.70000000000000018, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.92698296348313458, 0.69999999999999996, 0.0000000000000000, 
+  { 0.92698296348313447, 0.70000000000000018, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.1400447527693316, 0.69999999999999996, 0.0000000000000000, 
+  { 1.1400447527693318, 0.70000000000000018, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.3657668117194073, 0.69999999999999996, 0.0000000000000000, 
+  { 1.3657668117194073, 0.70000000000000018, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.6024686895959159, 0.69999999999999996, 0.0000000000000000, 
+  { 1.6024686895959164, 0.70000000000000018, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000, 
+  { 1.8456939983747236, 0.70000000000000018, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler161 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.10000000000000001.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6735282577377367e-16
+// Test data for k=0.70000000000000018, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.9552278747527691e-16
+// mean(f - f_Boost): 1.1102230246251565e-16
+// variance(f - f_Boost): 1.3695501826753678e-32
+// stddev(f - f_Boost): 1.1702778228589004e-16
 const testcase_ellint_3<double>
 data162[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.10000000000000001, 
+  { 0.0000000000000000, 0.70000000000000018, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17479076384884684, 0.69999999999999996, 0.10000000000000001, 
+  { 0.17514462737300920, 0.70000000000000018, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35114844900396364, 0.69999999999999996, 0.10000000000000001, 
+  { 0.35396527997470451, 0.70000000000000018, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53072776947527001, 0.69999999999999996, 0.10000000000000001, 
+  { 0.54015179589433981, 0.70000000000000018, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.71530198262386235, 0.69999999999999996, 0.10000000000000001, 
+  { 0.73734430854477728, 0.70000000000000018, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.90666760677828306, 0.69999999999999996, 0.10000000000000001, 
+  { 0.94888950796697047, 0.70000000000000018, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1063366517438080, 0.69999999999999996, 0.10000000000000001, 
+  { 1.1772807959736322, 0.70000000000000018, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.3149477243092149, 0.69999999999999996, 0.10000000000000001, 
+  { 1.4231796401075834, 0.70000000000000018, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.5314886725038925, 0.69999999999999996, 0.10000000000000001, 
+  { 1.6841856799887471, 0.70000000000000018, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001, 
+  { 1.9541347343119564, 0.70000000000000018, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler162 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.20000000000000001.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7517969287516802e-16
+// Test data for k=0.70000000000000018, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.7430437016285820e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
 const testcase_ellint_3<double>
 data163[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.20000000000000001, 
+  { 0.0000000000000000, 0.70000000000000018, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17461479077791475, 0.69999999999999996, 0.20000000000000001, 
+  { 0.17532252613350796, 0.70000000000000018, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34976950621407538, 0.69999999999999996, 0.20000000000000001, 
+  { 0.35540417596807522, 0.70000000000000018, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52622533231350177, 0.69999999999999996, 0.20000000000000001, 
+  { 0.54508913033361928, 0.70000000000000018, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.70508774017895215, 0.69999999999999996, 0.20000000000000001, 
+  { 0.74927635777718415, 0.70000000000000018, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.88775302531730294, 0.69999999999999996, 0.20000000000000001, 
+  { 0.97261706337936338, 0.70000000000000018, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0756195476149006, 0.69999999999999996, 0.20000000000000001, 
+  { 1.2187303976209327, 0.70000000000000018, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.2695349716654374, 0.69999999999999996, 0.20000000000000001, 
+  { 1.4887796709222487, 0.70000000000000018, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.4690814617070540, 0.69999999999999996, 0.20000000000000001, 
+  { 1.7796581281839214, 0.70000000000000018, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.6721098780092145, 0.69999999999999996, 0.20000000000000001, 
+  { 2.0829290325820207, 0.70000000000000018, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler163 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8280039841080712e-16
+// Test data for k=0.70000000000000018, nu=0.30000000000000004.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.2570807706941696e-16
+// mean(f - f_Boost): 8.8817841970012528e-17
+// variance(f - f_Boost): 1.5582437633995295e-32
+// stddev(f - f_Boost): 1.2482963443828271e-16
 const testcase_ellint_3<double>
 data164[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.29999999999999999, 
+  { 0.0000000000000000, 0.70000000000000018, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17443945136076175, 0.69999999999999996, 0.29999999999999999, 
+  { 0.17550107516328570, 0.70000000000000018, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34840956983535287, 0.69999999999999996, 0.29999999999999999, 
+  { 0.35686409576571965, 0.70000000000000018, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52185308551329168, 0.69999999999999996, 0.29999999999999999, 
+  { 0.55018827316513352, 0.70000000000000018, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.69535240431168255, 0.69999999999999996, 0.29999999999999999, 
+  { 0.76189759494390275, 0.70000000000000018, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.87007983473964923, 0.69999999999999996, 0.29999999999999999, 
+  { 0.99844623430885626, 0.70000000000000018, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0474657975577066, 0.69999999999999996, 0.29999999999999999, 
+  { 1.2652862989039833, 0.70000000000000018, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.2286225419931891, 0.69999999999999996, 0.29999999999999999, 
+  { 1.5647666808691361, 0.70000000000000018, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.4136490671013271, 0.69999999999999996, 0.29999999999999999, 
+  { 1.8932499694938165, 0.70000000000000018, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999, 
+  { 2.2392290510988535, 0.70000000000000018, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler164 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3472957053482092e-16
+// Test data for k=0.70000000000000018, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.3719045096496910e-16
+// mean(f - f_Boost): 1.3600232051658169e-16
+// variance(f - f_Boost): 1.1718213750516114e-32
+// stddev(f - f_Boost): 1.0825069861444829e-16
 const testcase_ellint_3<double>
 data165[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.40000000000000002, 
+  { 0.0000000000000000, 0.70000000000000018, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17426474153983229, 0.69999999999999996, 0.40000000000000002, 
+  { 0.17568027871494424, 0.70000000000000018, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34706817945773732, 0.69999999999999996, 0.40000000000000002, 
+  { 0.35834559208180261, 0.70000000000000018, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51760452851738148, 0.69999999999999996, 0.40000000000000002, 
+  { 0.55545885451190613, 0.70000000000000018, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.68605801534722755, 0.69999999999999996, 0.40000000000000002, 
+  { 0.77528120402568113, 0.70000000000000018, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.85351339387296532, 0.69999999999999996, 0.40000000000000002, 
+  { 1.0267241287600322, 0.70000000000000018, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0215297967969539, 0.69999999999999996, 0.40000000000000002, 
+  { 1.3181380338980246, 0.70000000000000018, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1915051074460530, 0.69999999999999996, 0.40000000000000002, 
+  { 1.6542840785132087, 0.70000000000000018, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.3639821911744707, 0.69999999999999996, 0.40000000000000002, 
+  { 2.0315595131131823, 0.70000000000000018, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002, 
+  { 2.4342502915307880, 0.70000000000000018, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler165 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.50000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.9748346743390620e-16
+// Test data for k=0.70000000000000018, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.0277361210295499e-16
+// mean(f - f_Boost): 1.6930901125533636e-16
+// variance(f - f_Boost): 6.3799163752809956e-32
+// stddev(f - f_Boost): 2.5258496343371268e-16
 const testcase_ellint_3<double>
 data166[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.50000000000000000, 
+  { 0.0000000000000000, 0.70000000000000018, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17409065729516096, 0.69999999999999996, 0.50000000000000000, 
+  { 0.17586014108156545, 0.70000000000000018, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34574489064986091, 0.69999999999999996, 0.50000000000000000, 
+  { 0.35984923894341653, 0.70000000000000018, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51347361925579782, 0.69999999999999996, 0.50000000000000000, 
+  { 0.56091135606739995, 0.70000000000000018, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.67717079489579279, 0.69999999999999996, 0.50000000000000000, 
+  { 0.78951212635197054, 0.70000000000000018, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.83793902055292280, 0.69999999999999996, 0.50000000000000000, 
+  { 1.0578865732938731, 0.70000000000000018, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.99752863545289705, 0.69999999999999996, 0.50000000000000000, 
+  { 1.3789149005151722, 0.70000000000000018, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.1576240080401501, 0.69999999999999996, 0.50000000000000000, 
+  { 1.7620212286086228, 0.70000000000000018, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.3191464023923762, 0.69999999999999996, 0.50000000000000000, 
+  { 2.2051554347435589, 0.70000000000000018, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000, 
+  { 2.6868019968236996, 0.70000000000000018, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler166 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.59999999999999998.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.0457157538295173e-16
+// Test data for k=0.70000000000000018, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.8597454441867134e-16
+// mean(f - f_Boost): 2.5535129566378598e-16
+// variance(f - f_Boost): 2.8561208198482198e-31
+// stddev(f - f_Boost): 5.3442687243889785e-16
 const testcase_ellint_3<double>
 data167[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.59999999999999998, 
+  { 0.0000000000000000, 0.70000000000000018, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17391719464391614, 0.69999999999999996, 0.59999999999999998, 
+  { 0.17604066659721918, 0.70000000000000018, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34443927423869031, 0.69999999999999996, 0.59999999999999998, 
+  { 0.36137563278353424, 0.70000000000000018, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50945473266486063, 0.69999999999999996, 0.59999999999999998, 
+  { 0.56655721272747606, 0.70000000000000018, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.66866056326513812, 0.69999999999999996, 0.59999999999999998, 
+  { 0.80468966552978305, 0.70000000000000018, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.82325830002337352, 0.69999999999999996, 0.59999999999999998, 
+  { 1.0924902943683852, 0.70000000000000018, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.97522808245669368, 0.69999999999999996, 0.59999999999999998, 
+  { 1.4499247992499800, 0.70000000000000018, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.1265300613705285, 0.69999999999999996, 0.59999999999999998, 
+  { 1.8953714382113818, 0.70000000000000018, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.2784066076152001, 0.69999999999999996, 0.59999999999999998, 
+  { 2.4323229949248670, 0.70000000000000018, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998, 
+  { 3.0314573496746746, 0.70000000000000018, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler167 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 5.4867405596732161e-16
+// Test data for k=0.70000000000000018, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.2316852368580916e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 7.4564398834547797e-34
+// stddev(f - f_Boost): 2.7306482533374340e-17
 const testcase_ellint_3<double>
 data168[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.69999999999999996, 
+  { 0.0000000000000000, 0.70000000000000018, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17374434963995031, 0.69999999999999996, 0.69999999999999996, 
+  { 0.17622185963747933, 0.70000000000000018, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34315091562900674, 0.69999999999999996, 0.69999999999999996, 
+  { 0.36292539360435261, 0.70000000000000018, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50554262375653347, 0.69999999999999996, 0.69999999999999996, 
+  { 0.57240892970150015, 0.70000000000000018, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.66050025406305801, 0.69999999999999996, 0.69999999999999996, 
+  { 0.82093084713182629, 0.70000000000000018, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.80938620118847404, 0.69999999999999996, 0.69999999999999996, 
+  { 1.1312609022179871, 0.70000000000000018, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.95443223855852144, 0.69999999999999996, 0.69999999999999996, 
+  { 1.5345768067715795, 0.70000000000000018, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0978573207128304, 0.69999999999999996, 0.69999999999999996, 
+  { 2.0668847445934424, 0.70000000000000018, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.2411754575007123, 0.69999999999999996, 0.69999999999999996, 
+  { 2.7483444537551245, 0.70000000000000018, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996, 
+  { 3.5408408771788569, 0.70000000000000018, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler168 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1829502028913879e-16
+// Test data for k=0.70000000000000018, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1198716111867353e-16
+// mean(f - f_Boost): 2.2482016248659419e-16
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
 const testcase_ellint_3<double>
 data169[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.80000000000000004, 
+  { 0.0000000000000000, 0.70000000000000018, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17357211837335740, 0.69999999999999996, 0.80000000000000004, 
+  { 0.17640372461994805, 0.70000000000000018, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34187941416012108, 0.69999999999999996, 0.80000000000000004, 
+  { 0.36449916621651091, 0.70000000000000018, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50173239465478259, 0.69999999999999996, 0.80000000000000004, 
+  { 0.57848021800372584, 0.70000000000000018, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.65266550725988315, 0.69999999999999996, 0.80000000000000004, 
+  { 0.83837480968392586, 0.70000000000000018, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.79624879865249298, 0.69999999999999996, 0.80000000000000004, 
+  { 1.1751669030061143, 0.70000000000000018, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.93497577043296920, 0.69999999999999996, 0.80000000000000004, 
+  { 1.6381851899173603, 0.70000000000000018, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0713041566930750, 0.69999999999999996, 0.80000000000000004, 
+  { 2.3002065924302197, 0.70000000000000018, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.2069772023255654, 0.69999999999999996, 0.80000000000000004, 
+  { 3.2337600665337871, 0.70000000000000018, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.3427110650397531, 0.69999999999999996, 0.80000000000000004, 
+  { 4.4042405729076970, 0.70000000000000018, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler169 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.90000000000000002.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2494869624129105e-16
+// Test data for k=0.70000000000000018, nu=0.90000000000000002.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.5869439826269878e-16
+// mean(f - f_Boost): 7.4384942649885490e-16
+// variance(f - f_Boost): 9.7403930714297352e-31
+// stddev(f - f_Boost): 9.8693429727767263e-16
 const testcase_ellint_3<double>
 data170[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.90000000000000002, 
+  { 0.0000000000000000, 0.70000000000000018, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17340049697003637, 0.69999999999999996, 0.90000000000000002, 
+  { 0.17658626600478800, 0.70000000000000018, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34062438249741556, 0.69999999999999996, 0.90000000000000002, 
+  { 0.36609762156017206, 0.70000000000000018, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49801946510076867, 0.69999999999999996, 0.90000000000000002, 
+  { 0.58478615187842409, 0.70000000000000018, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.64513432604750476, 0.69999999999999996, 0.90000000000000002, 
+  { 0.85718862878291846, 0.70000000000000018, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.78378145487573758, 0.69999999999999996, 0.90000000000000002, 
+  { 1.2255385617397643, 0.70000000000000018, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.91671799500854623, 0.69999999999999996, 0.90000000000000002, 
+  { 1.7696521899992941, 0.70000000000000018, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0466193579463123, 0.69999999999999996, 0.90000000000000002, 
+  { 2.6476314987883507, 0.70000000000000018, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1754218079199146, 0.69999999999999996, 0.90000000000000002, 
+  { 4.1373434902898083, 0.70000000000000018, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.3040500499695913, 0.69999999999999996, 0.90000000000000002, 
+  { 6.3796094177887763, 0.70000000000000018, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler170 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1175183168766718e-16
+// max(|f - f_Boost|): 1.5543122344752192e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7898565163847540e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.1368406725192426e-31
+// stddev(f - f_Boost): 4.6225974002926564e-16
 const testcase_ellint_3<double>
 data171[10] =
 {
@@ -4978,596 +5490,654 @@
 	  0.0000000000000000 },
   { 0.17510154241338899, 0.80000000000000004, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35365068839779390, 0.80000000000000004, 0.0000000000000000, 
+  { 0.35365068839779396, 0.80000000000000004, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.53926804409084550, 0.80000000000000004, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.73587926028070361, 0.80000000000000004, 0.0000000000000000, 
+  { 0.73587926028070372, 0.80000000000000004, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.94770942970071170, 0.80000000000000004, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1789022995388236, 0.80000000000000004, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.4323027881876009, 0.80000000000000004, 0.0000000000000000, 
+  { 1.4323027881876012, 0.80000000000000004, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.7069629739121674, 0.80000000000000004, 0.0000000000000000, 
+  { 1.7069629739121677, 0.80000000000000004, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000, 
+  { 1.9953027776647294, 0.80000000000000004, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler171 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1537164503193145e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3898786942190374e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.9190059990693968e-31
+// stddev(f - f_Boost): 5.4027826155319237e-16
 const testcase_ellint_3<double>
 data172[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17492468824017163, 0.80000000000000004, 0.10000000000000001, 
+  { 0.17527903952342144, 0.80000000000000004, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35224443521476911, 0.80000000000000004, 0.10000000000000001, 
+  { 0.35507705313548549, 0.80000000000000004, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53456851853226950, 0.80000000000000004, 0.10000000000000001, 
+  { 0.54411455987643553, 0.80000000000000004, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.72488875602364922, 0.80000000000000004, 0.10000000000000001, 
+  { 0.74745625666804383, 0.80000000000000004, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.92661354274638952, 0.80000000000000004, 0.10000000000000001, 
+  { 0.97046953684238557, 0.80000000000000004, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1432651144499075, 0.80000000000000004, 0.10000000000000001, 
+  { 1.2183080025184605, 0.80000000000000004, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.3774479927211429, 0.80000000000000004, 0.10000000000000001, 
+  { 1.4943711151994405, 0.80000000000000004, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.6287092337196041, 0.80000000000000004, 0.10000000000000001, 
+  { 1.7972401309544201, 0.80000000000000004, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001, 
+  { 2.1172616484005085, 0.80000000000000004, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler172 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1894552974436829e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.8513740186068518e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 2.7528339102381189e-31
+// stddev(f - f_Boost): 5.2467455724840699e-16
 const testcase_ellint_3<double>
 data173[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17474847286224940, 0.80000000000000004, 0.20000000000000001, 
+  { 0.17545718375086419, 0.80000000000000004, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.35085779529084682, 0.80000000000000004, 0.20000000000000001, 
+  { 0.35652404627248163, 0.80000000000000004, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.53000829263059146, 0.80000000000000004, 0.20000000000000001, 
+  { 0.54911638512920913, 0.80000000000000004, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.71443466027453384, 0.80000000000000004, 0.20000000000000001, 
+  { 0.75967684282131176, 0.80000000000000004, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.90698196872715420, 0.80000000000000004, 0.20000000000000001, 
+  { 0.99513526893543769, 0.80000000000000004, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.1108198200558579, 0.80000000000000004, 0.20000000000000001, 
+  { 1.2622192109995993, 0.80000000000000004, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.3284988909963957, 0.80000000000000004, 0.20000000000000001, 
+  { 1.5654106676347741, 0.80000000000000004, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.5600369318140328, 0.80000000000000004, 0.20000000000000001, 
+  { 1.9029531718534984, 0.80000000000000004, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001, 
+  { 2.2624789434186798, 0.80000000000000004, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler173 = 2.5000000000000020e-13;
 
-// Test data for k=0.80000000000000004, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2247517409029886e-16
+// Test data for k=0.80000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.2825261583337354e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 2.8249350208968825e-31
+// stddev(f - f_Boost): 5.3150117788175054e-16
 const testcase_ellint_3<double>
 data174[10] =
 {
-  { 0.0000000000000000, 0.80000000000000004, 0.29999999999999999, 
+  { 0.0000000000000000, 0.80000000000000004, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17457289217669889, 0.80000000000000004, 0.29999999999999999, 
+  { 0.17563597931587369, 0.80000000000000004, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34949028801501258, 0.80000000000000004, 0.29999999999999999, 
+  { 0.35799220412005128, 0.80000000000000004, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52558024362769307, 0.80000000000000004, 0.29999999999999999, 
+  { 0.55428253691111318, 0.80000000000000004, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.70447281740094891, 0.80000000000000004, 0.29999999999999999, 
+  { 0.77260647376977365, 0.80000000000000004, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.88864745641528986, 0.80000000000000004, 0.29999999999999999, 
+  { 1.0220015271210958, 0.80000000000000004, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0811075819341462, 0.80000000000000004, 0.29999999999999999, 
+  { 1.3115965312302671, 0.80000000000000004, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.2844589654082377, 0.80000000000000004, 0.29999999999999999, 
+  { 1.6478518468813512, 0.80000000000000004, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.4991461361277847, 0.80000000000000004, 0.29999999999999999, 
+  { 2.0290458414203481, 0.80000000000000004, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999, 
+  { 2.4392042002725693, 0.80000000000000004, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler174 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2596216594752862e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3462748389836647e-16
+// mean(f - f_Boost): 3.3861802251067273e-16
+// variance(f - f_Boost): 4.3719465706454422e-31
+// stddev(f - f_Boost): 6.6120696991527871e-16
 const testcase_ellint_3<double>
 data175[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17439794211872175, 0.80000000000000004, 0.40000000000000002, 
+  { 0.17581543047866136, 0.80000000000000004, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34814144964568972, 0.80000000000000004, 0.40000000000000002, 
+  { 0.35948208343061633, 0.80000000000000004, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.52127776285273064, 0.80000000000000004, 0.40000000000000002, 
+  { 0.55962280893702021, 0.80000000000000004, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.69496411438966588, 0.80000000000000004, 0.40000000000000002, 
+  { 0.78632063889234116, 0.80000000000000004, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.87146878427509589, 0.80000000000000004, 0.40000000000000002, 
+  { 1.0514333069550323, 0.80000000000000004, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0537579024937762, 0.80000000000000004, 0.40000000000000002, 
+  { 1.3677213138838757, 0.80000000000000004, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.2445534387922637, 0.80000000000000004, 0.40000000000000002, 
+  { 1.7451736773665165, 0.80000000000000004, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.4446769766361993, 0.80000000000000004, 0.40000000000000002, 
+  { 2.1830100424586831, 0.80000000000000004, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002, 
+  { 2.6604037035529724, 0.80000000000000004, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler175 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2940800093915668e-16
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0388243828581744e-16
+// mean(f - f_Boost): 3.8580250105724191e-16
+// variance(f - f_Boost): 6.4106456575047741e-31
+// stddev(f - f_Boost): 8.0066507713929764e-16
 const testcase_ellint_3<double>
 data176[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17422361866118044, 0.80000000000000004, 0.50000000000000000, 
+  { 0.17599554153999472, 0.80000000000000004, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34681083254170475, 0.80000000000000004, 0.50000000000000000, 
+  { 0.36099426243351540, 0.80000000000000004, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51709470815494440, 0.80000000000000004, 0.50000000000000000, 
+  { 0.56514786174780673, 0.80000000000000004, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.68587375344080237, 0.80000000000000004, 0.50000000000000000, 
+  { 0.80090697622371010, 0.80000000000000004, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.85532571852810624, 0.80000000000000004, 0.50000000000000000, 
+  { 1.0838891627679339, 0.80000000000000004, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 1.0284677391874903, 0.80000000000000004, 0.50000000000000000, 
+  { 1.4323506654466280, 0.80000000000000004, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.2081693942686225, 0.80000000000000004, 0.50000000000000000, 
+  { 1.8625761085390575, 0.80000000000000004, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.3955803006426311, 0.80000000000000004, 0.50000000000000000, 
+  { 2.3768757305654766, 0.80000000000000004, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000, 
+  { 2.9478781158239746, 0.80000000000000004, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler176 = 2.5000000000000020e-13;
 
-// Test data for k=0.80000000000000004, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3281408974056389e-16
+// Test data for k=0.80000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0631099169042069e-15
+// mean(f - f_Boost): 4.8294701571194306e-16
+// variance(f - f_Boost): 1.1633910328160319e-30
+// stddev(f - f_Boost): 1.0786060600682865e-15
 const testcase_ellint_3<double>
 data177[10] =
 {
-  { 0.0000000000000000, 0.80000000000000004, 0.59999999999999998, 
+  { 0.0000000000000000, 0.80000000000000004, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17404991781414089, 0.80000000000000004, 0.59999999999999998, 
+  { 0.17617631684170665, 0.80000000000000004, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34549800443625167, 0.80000000000000004, 0.59999999999999998, 
+  { 0.36252934193666231, 0.80000000000000004, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.51302536167001545, 0.80000000000000004, 0.59999999999999998, 
+  { 0.57086932622945163, 0.80000000000000004, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.67717065003912236, 0.80000000000000004, 0.59999999999999998, 
+  { 0.81646796740150973, 0.80000000000000004, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.84011512421134416, 0.80000000000000004, 0.59999999999999998, 
+  { 1.1199552158519064, 0.80000000000000004, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 1.0049863847088740, 0.80000000000000004, 0.59999999999999998, 
+  { 1.5079766673336394, 0.80000000000000004, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.1748145941898920, 0.80000000000000004, 0.59999999999999998, 
+  { 2.0082747447038165, 0.80000000000000004, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.3510319699755071, 0.80000000000000004, 0.59999999999999998, 
+  { 2.6315146066775523, 0.80000000000000004, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998, 
+  { 3.3418121892288051, 0.80000000000000004, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler177 = 2.5000000000000020e-13;
 
-// Test data for k=0.80000000000000004, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3618176466061808e-16
+// Test data for k=0.80000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.6544679145741375e-16
+// mean(f - f_Boost): 3.2751579226442120e-16
+// variance(f - f_Boost): 4.4236851331020672e-31
+// stddev(f - f_Boost): 6.6510789599147505e-16
 const testcase_ellint_3<double>
 data178[10] =
 {
-  { 0.0000000000000000, 0.80000000000000004, 0.69999999999999996, 
+  { 0.0000000000000000, 0.80000000000000004, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17387683562442199, 0.80000000000000004, 0.69999999999999996, 
+  { 0.17635776076721221, 0.80000000000000004, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34420254775101611, 0.80000000000000004, 0.69999999999999996, 
+  { 0.36408794649916976, 0.80000000000000004, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50906439222143673, 0.80000000000000004, 0.69999999999999996, 
+  { 0.57679992290624138, 0.80000000000000004, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.66882693152688422, 0.80000000000000004, 0.69999999999999996, 
+  { 0.83312441418142813, 0.80000000000000004, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.82574792844091316, 0.80000000000000004, 0.69999999999999996, 
+  { 1.1603958891464856, 0.80000000000000004, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.98310431309490931, 0.80000000000000004, 0.69999999999999996, 
+  { 1.5982855143796213, 0.80000000000000004, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.1440884535113258, 0.80000000000000004, 0.69999999999999996, 
+  { 2.1962484408371821, 0.80000000000000004, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.3103743938952537, 0.80000000000000004, 0.69999999999999996, 
+  { 2.9873281786111869, 0.80000000000000004, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996, 
+  { 3.9268876980046397, 0.80000000000000004, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler178 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3951228558314112e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0176949165011079e-16
+// mean(f - f_Boost): 7.0499162063697436e-16
+// variance(f - f_Boost): 1.7230805408026989e-30
+// stddev(f - f_Boost): 1.3126616246400665e-15
 const testcase_ellint_3<double>
 data179[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17370436817515203, 0.80000000000000004, 0.80000000000000004, 
+  { 0.17653987774203392, 0.80000000000000004, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34292405894783395, 0.80000000000000004, 0.80000000000000004, 
+  { 0.36567072568046877, 0.80000000000000004, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50520682176250076, 0.80000000000000004, 0.80000000000000004, 
+  { 0.58295359996558616, 0.80000000000000004, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.66081751679736178, 0.80000000000000004, 0.80000000000000004, 
+  { 0.85101998309176108, 0.80000000000000004, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.81214672249355102, 0.80000000000000004, 0.80000000000000004, 
+  { 1.2062322059736537, 0.80000000000000004, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.96264481387685552, 0.80000000000000004, 0.80000000000000004, 
+  { 1.7090321420917429, 0.80000000000000004, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.1156611352656258, 0.80000000000000004, 0.80000000000000004, 
+  { 2.4529058049405066, 0.80000000000000004, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.2730756225143889, 0.80000000000000004, 0.80000000000000004, 
+  { 3.5368893360106948, 0.80000000000000004, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.4339837018309471, 0.80000000000000004, 0.80000000000000004, 
+  { 4.9246422058196062, 0.80000000000000004, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler179 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.90000000000000002.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4280684534289690e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7782721357365268e-16
+// mean(f - f_Boost): 8.9928064994637676e-16
+// variance(f - f_Boost): 1.5485199571025344e-30
+// stddev(f - f_Boost): 1.2443954183066307e-15
 const testcase_ellint_3<double>
 data180[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17353251158533151, 0.80000000000000004, 0.90000000000000002, 
+  { 0.17672267223433513, 0.80000000000000004, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34166214791545768, 0.80000000000000004, 0.90000000000000002, 
+  { 0.36727835537196063, 0.80000000000000004, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.50144799535130569, 0.80000000000000004, 0.90000000000000002, 
+  { 0.58934569363716649, 0.80000000000000004, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.65311976193814425, 0.80000000000000004, 0.90000000000000002, 
+  { 0.87032723471138851, 0.80000000000000004, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.79924384892320866, 0.80000000000000004, 0.90000000000000002, 
+  { 1.2588676111323349, 0.80000000000000004, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.94345762353365603, 0.80000000000000004, 0.90000000000000002, 
+  { 1.8498731900660019, 0.80000000000000004, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0892582069219161, 0.80000000000000004, 0.90000000000000002, 
+  { 2.8368381299300420, 0.80000000000000004, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.2387000876610268, 0.80000000000000004, 0.90000000000000002, 
+  { 4.5674844191654058, 0.80000000000000004, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002, 
+  { 7.2263259298637115, 0.80000000000000004, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler180 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.0000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8945813740035884e-16
+// Test data for k=0.90000000000000013, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.3381508715713360e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
 const testcase_ellint_3<double>
 data181[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.0000000000000000, 
+  { 0.0000000000000000, 0.90000000000000013, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17525427376115024, 0.89999999999999991, 0.0000000000000000, 
+  { 0.17525427376115027, 0.90000000000000013, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35492464591297446, 0.89999999999999991, 0.0000000000000000, 
+  { 0.35492464591297446, 0.90000000000000013, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.54388221416157112, 0.89999999999999991, 0.0000000000000000, 
+  { 0.54388221416157123, 0.90000000000000013, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.74797400423532490, 0.89999999999999991, 0.0000000000000000, 
+  { 0.74797400423532512, 0.90000000000000013, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.97463898451966458, 0.89999999999999991, 0.0000000000000000, 
+  { 0.97463898451966446, 0.90000000000000013, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.2334463254523440, 0.89999999999999991, 0.0000000000000000, 
+  { 1.2334463254523440, 0.90000000000000013, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.5355247765594910, 0.89999999999999991, 0.0000000000000000, 
+  { 1.5355247765594915, 0.90000000000000013, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.8882928567775117, 0.89999999999999991, 0.0000000000000000, 
+  { 1.8882928567775128, 0.90000000000000013, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 2.2805491384227703, 0.89999999999999991, 0.0000000000000000, 
+  { 2.2805491384227707, 0.90000000000000013, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler181 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.10000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1237990617685137e-16
+// Test data for k=0.90000000000000013, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.1500594295134815e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.0357223256482469e-33
+// stddev(f - f_Boost): 3.2182640128619758e-17
 const testcase_ellint_3<double>
 data182[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.10000000000000001, 
+  { 0.0000000000000000, 0.90000000000000013, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17507714233254656, 0.89999999999999991, 0.10000000000000001, 
+  { 0.17543204932716244, 0.90000000000000013, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35350932904326521, 0.89999999999999991, 0.10000000000000001, 
+  { 0.35636022898551184, 0.90000000000000013, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53911129989870976, 0.89999999999999991, 0.10000000000000001, 
+  { 0.54880278898382595, 0.90000000000000013, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.73666644254508395, 0.89999999999999991, 0.10000000000000001, 
+  { 0.75988834774529268, 0.90000000000000013, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.95250736612100195, 0.89999999999999991, 0.10000000000000001, 
+  { 0.99853303003568117, 0.90000000000000013, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1950199550905594, 0.89999999999999991, 0.10000000000000001, 
+  { 1.2759958823999022, 0.90000000000000013, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.4741687286340848, 0.89999999999999991, 0.10000000000000001, 
+  { 1.6051187364639401, 0.90000000000000013, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.7968678183506053, 0.89999999999999991, 0.10000000000000001, 
+  { 1.9941406879519474, 0.90000000000000013, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 2.1537868513875287, 0.89999999999999991, 0.10000000000000001, 
+  { 2.4295011187834890, 0.90000000000000013, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler182 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.20000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3446165733924066e-16
+// Test data for k=0.90000000000000013, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.9533518431433547e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
 const testcase_ellint_3<double>
 data183[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.20000000000000001, 
+  { 0.0000000000000000, 0.90000000000000013, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17490065089140927, 0.89999999999999991, 0.20000000000000001, 
+  { 0.17561047321968409, 0.90000000000000013, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.35211377590661436, 0.89999999999999991, 0.20000000000000001, 
+  { 0.35781659944356109, 0.90000000000000013, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.53448220334204100, 0.89999999999999991, 0.20000000000000001, 
+  { 0.55388150905215283, 0.90000000000000013, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.72591368943179579, 0.89999999999999991, 0.20000000000000001, 
+  { 0.77246874123251441, 0.90000000000000013, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.93192539780038763, 0.89999999999999991, 0.20000000000000001, 
+  { 1.0244466254771925, 0.90000000000000013, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.1600809679692683, 0.89999999999999991, 0.20000000000000001, 
+  { 1.3234824077640801, 0.90000000000000013, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.4195407225882508, 0.89999999999999991, 0.20000000000000001, 
+  { 1.6849848968804240, 0.90000000000000013, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.7168966476424521, 0.89999999999999991, 0.20000000000000001, 
+  { 2.1185749045502278, 0.90000000000000013, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 2.0443194576468895, 0.89999999999999991, 0.20000000000000001, 
+  { 2.6076835743348417, 0.90000000000000013, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler183 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.29999999999999999.
-// max(|f - f_GSL|): 1.1102230246251565e-15
-// max(|f - f_GSL| / |f_GSL|): 5.6974600067013622e-16
+// Test data for k=0.90000000000000013, nu=0.30000000000000004.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.9712691025502371e-16
+// mean(f - f_Boost): 6.9388939039072284e-17
+// variance(f - f_Boost): 5.9442282234173945e-34
+// stddev(f - f_Boost): 2.4380787976227090e-17
 const testcase_ellint_3<double>
 data184[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.29999999999999999, 
+  { 0.0000000000000000, 0.90000000000000013, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17472479532647531, 0.89999999999999991, 0.29999999999999999, 
+  { 0.17578954966746221, 0.90000000000000013, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.35073750187374114, 0.89999999999999991, 0.29999999999999999, 
+  { 0.35929429810867447, 0.90000000000000013, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52998766129466957, 0.89999999999999991, 0.29999999999999999, 
+  { 0.55912757154240822, 0.90000000000000013, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.71566993548699553, 0.89999999999999991, 0.29999999999999999, 
+  { 0.78578314722025389, 0.90000000000000013, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.91271517762560195, 0.89999999999999991, 0.29999999999999999, 
+  { 1.0526941001131365, 0.90000000000000013, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.1281241199843370, 0.89999999999999991, 0.29999999999999999, 
+  { 1.3769682234538601, 0.90000000000000013, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.3704929576917448, 0.89999999999999991, 0.29999999999999999, 
+  { 1.7779437432911240, 0.90000000000000013, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.6461981511487711, 0.89999999999999991, 0.29999999999999999, 
+  { 2.2676509341813635, 0.90000000000000013, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.9486280260314426, 0.89999999999999991, 0.29999999999999999, 
+  { 2.8256506968858517, 0.90000000000000013, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler184 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 4.7646208744449464e-16
+// Test data for k=0.90000000000000013, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.7042235432234642e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
 const testcase_ellint_3<double>
 data185[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.40000000000000002, 
+  { 0.0000000000000000, 0.90000000000000013, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17454957156468837, 0.89999999999999991, 0.40000000000000002, 
+  { 0.17596928293938452, 0.90000000000000013, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34938003933330430, 0.89999999999999991, 0.40000000000000002, 
+  { 0.36079388642472821, 0.90000000000000013, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.52562093533067433, 0.89999999999999991, 0.40000000000000002, 
+  { 0.56455096667115612, 0.90000000000000013, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.70589461324915670, 0.89999999999999991, 0.40000000000000002, 
+  { 0.79990996997869435, 0.90000000000000013, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.89472658511942849, 0.89999999999999991, 0.40000000000000002, 
+  { 1.0836647913872215, 0.90000000000000013, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0987419542323440, 0.89999999999999991, 0.40000000000000002, 
+  { 1.4378726836091849, 0.90000000000000013, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.3261349565496301, 0.89999999999999991, 0.40000000000000002, 
+  { 1.8880446720682853, 0.90000000000000013, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.5831293909853763, 0.89999999999999991, 0.40000000000000002, 
+  { 2.4505848932025232, 0.90000000000000013, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.8641114227238351, 0.89999999999999991, 0.40000000000000002, 
+  { 3.1000689868578624, 0.90000000000000013, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler185 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.50000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 4.9652155758573562e-16
+// Test data for k=0.90000000000000013, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.3939646155354115e-16
+// mean(f - f_Boost): 1.5820678100908481e-16
+// variance(f - f_Boost): 1.0089970755557622e-32
+// stddev(f - f_Boost): 1.0044884646205561e-16
 const testcase_ellint_3<double>
 data186[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.50000000000000000, 
+  { 0.0000000000000000, 0.90000000000000013, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17437497557073334, 0.89999999999999991, 0.50000000000000000, 
+  { 0.17614967734498183, 0.90000000000000013, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34804093691586013, 0.89999999999999991, 0.50000000000000000, 
+  { 0.36231594750319435, 0.90000000000000013, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.52137576320372891, 0.89999999999999991, 0.50000000000000000, 
+  { 0.57016256984349567, 0.90000000000000013, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.69655163996912262, 0.89999999999999991, 0.50000000000000000, 
+  { 0.81494025918293422, 0.90000000000000013, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.87783188683054236, 0.89999999999999991, 0.50000000000000000, 
+  { 1.1178482279283477, 0.90000000000000013, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 1.0716015959755185, 0.89999999999999991, 0.50000000000000000, 
+  { 1.5081455873012106, 0.90000000000000013, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.2857636916026749, 0.89999999999999991, 0.50000000000000000, 
+  { 2.0213599730863998, 0.90000000000000013, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.5264263913252358, 0.89999999999999991, 0.50000000000000000, 
+  { 2.6822467012926832, 0.90000000000000013, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.7888013241937863, 0.89999999999999991, 0.50000000000000000, 
+  { 3.4591069002104686, 0.90000000000000013, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler186 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.59999999999999998.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8702201113622378e-16
+// Test data for k=0.90000000000000013, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.4914274070443813e-16
+// mean(f - f_Boost): 3.4694469519536142e-16
+// variance(f - f_Boost): 2.5224926888894056e-31
+// stddev(f - f_Boost): 5.0224423231027804e-16
 const testcase_ellint_3<double>
 data187[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.59999999999999998, 
+  { 0.0000000000000000, 0.90000000000000013, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17420100334657812, 0.89999999999999991, 0.59999999999999998, 
+  { 0.17633073723493825, 0.90000000000000013, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34671975876122157, 0.89999999999999991, 0.59999999999999998, 
+  { 0.36386108723492810, 0.90000000000000013, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.51724631570707946, 0.89999999999999991, 0.59999999999999998, 
+  { 0.57597424744716241, 0.90000000000000013, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.68760879113743023, 0.89999999999999991, 0.59999999999999998, 
+  { 0.83098051948501150, 0.90000000000000013, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.86192157779698364, 0.89999999999999991, 0.59999999999999998, 
+  { 1.1558706545698916, 0.90000000000000013, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 1.0464279696166354, 0.89999999999999991, 0.59999999999999998, 
+  { 1.5905576379415669, 0.90000000000000013, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.2488156247094004, 0.89999999999999991, 0.59999999999999998, 
+  { 2.1875186010215084, 0.90000000000000013, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.4750988777188470, 0.89999999999999991, 0.59999999999999998, 
+  { 2.9885767771316853, 0.90000000000000013, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.7211781128919525, 0.89999999999999991, 0.59999999999999998, 
+  { 3.9549939883570238, 0.90000000000000013, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler187 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3410843563834748e-16
+// Test data for k=0.90000000000000013, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.5442489886293633e-16
+// mean(f - f_Boost): 4.3576253716537392e-16
+// variance(f - f_Boost): 2.2187568928205130e-31
+// stddev(f - f_Boost): 4.7103682370070737e-16
 const testcase_ellint_3<double>
 data188[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.69999999999999996, 
+  { 0.0000000000000000, 0.90000000000000013, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17402765093102207, 0.89999999999999991, 0.69999999999999996, 
+  { 0.17651246700160939, 0.90000000000000013, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34541608382635131, 0.89999999999999991, 0.69999999999999996, 
+  { 0.36542993547358982, 0.90000000000000013, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.51322715827061682, 0.89999999999999991, 0.69999999999999996, 
+  { 0.58199897877674867, 0.90000000000000013, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.67903717872440272, 0.89999999999999991, 0.69999999999999996, 
+  { 0.84815633587352857, 0.90000000000000013, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.84690113601682671, 0.89999999999999991, 0.69999999999999996, 
+  { 1.1985495623872375, 0.90000000000000013, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 1.0229914311548418, 0.89999999999999991, 0.69999999999999996, 
+  { 1.6892158134027691, 0.90000000000000013, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.2148329639709381, 0.89999999999999991, 0.69999999999999996, 
+  { 2.4029722191094236, 0.90000000000000013, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.4283586501307799, 0.89999999999999991, 0.69999999999999996, 
+  { 3.4201084941340061, 0.90000000000000013, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.6600480747670940, 0.89999999999999991, 0.69999999999999996, 
+  { 4.6985482312992444, 0.90000000000000013, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler188 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3100928058463168e-16
+// Test data for k=0.90000000000000013, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9362432595976420e-16
+// mean(f - f_Boost): 3.0531133177191805e-16
+// variance(f - f_Boost): 1.1508025840536076e-32
+// stddev(f - f_Boost): 1.0727546709539920e-16
 const testcase_ellint_3<double>
 data189[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.80000000000000004, 
+  { 0.0000000000000000, 0.90000000000000013, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17385491439925146, 0.89999999999999991, 0.80000000000000004, 
+  { 0.17669487107954862, 0.90000000000000013, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34412950523113928, 0.89999999999999991, 0.80000000000000004, 
+  { 0.36702314729628421, 0.90000000000000013, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50931321668729590, 0.89999999999999991, 0.80000000000000004, 
+  { 0.58825099711365492, 0.90000000000000013, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.67081081392296327, 0.89999999999999991, 0.80000000000000004, 
+  { 0.86661711422209031, 0.90000000000000013, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.83268846097293259, 0.89999999999999991, 0.80000000000000004, 
+  { 1.2469779109884802, 0.90000000000000013, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 1.0010985015814027, 0.89999999999999991, 0.80000000000000004, 
+  { 1.8105469760531578, 0.90000000000000013, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.1834394045489678, 0.89999999999999991, 0.80000000000000004, 
+  { 2.6989505165893752, 0.90000000000000013, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.3855695891683182, 0.89999999999999991, 0.80000000000000004, 
+  { 4.0935213267757433, 0.90000000000000013, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.6044591960982202, 0.89999999999999991, 0.80000000000000004, 
+  { 5.9820740813645727, 0.90000000000000013, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler189 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.90000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 5.7167507456081732e-16
+// Test data for k=0.90000000000000013, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9577148062669782e-16
+// mean(f - f_Boost): 5.9119376061289588e-16
+// variance(f - f_Boost): 1.7340883003959522e-31
+// stddev(f - f_Boost): 4.1642385863395872e-16
 const testcase_ellint_3<double>
 data190[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.90000000000000002, 
+  { 0.0000000000000000, 0.90000000000000013, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17368278986240135, 0.89999999999999991, 0.90000000000000002, 
+  { 0.17687795394604169, 0.90000000000000013, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34285962963961397, 0.89999999999999991, 0.90000000000000002, 
+  { 0.36864140434751286, 0.90000000000000013, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.50549974644993312, 0.89999999999999991, 0.90000000000000002, 
+  { 0.59474595366817051, 0.90000000000000013, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.66290623857720876, 0.89999999999999991, 0.90000000000000002, 
+  { 0.88654237226056665, 0.90000000000000013, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.81921183128847175, 0.89999999999999991, 0.90000000000000002, 
+  { 1.3026595810616726, 0.90000000000000013, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.98058481956066390, 0.89999999999999991, 0.90000000000000002, 
+  { 1.9653635459278080, 0.90000000000000013, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.1543223520473569, 0.89999999999999991, 0.90000000000000002, 
+  { 3.1451407527189468, 0.90000000000000013, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.3462119782292934, 0.89999999999999991, 0.90000000000000002, 
+  { 5.3745230680316132, 0.90000000000000013, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.5536420236310948, 0.89999999999999991, 0.90000000000000002, 
+  { 8.9942562031858717, 0.90000000000000013, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler190 = 2.5000000000000020e-13;
 
-template<typename Tp, unsigned int Num>
+template<typename Ret, unsigned int Num>
   void
-  test(const testcase_ellint_3<Tp> (&data)[Num], Tp toler)
+  test(const testcase_ellint_3<Ret> (&data)[Num], Ret toler)
   {
-    const Tp eps = std::numeric_limits<Tp>::epsilon();
-    Tp max_abs_diff = -Tp(1);
-    Tp max_abs_frac = -Tp(1);
+    bool test __attribute__((unused)) = true;
+    const Ret eps = std::numeric_limits<Ret>::epsilon();
+    Ret max_abs_diff = -Ret(1);
+    Ret max_abs_frac = -Ret(1);
     unsigned int num_datum = Num;
     for (unsigned int i = 0; i < num_datum; ++i)
   	 {
-	const Tp f = std::ellint_3(data[i].k, data[i].nu,
+	const Ret f = std::ellint_3(data[i].k, data[i].nu,
 		     data[i].phi);
-	const Tp f0 = data[i].f0;
-	const Tp diff = f - f0;
+	const Ret f0 = data[i].f0;
+	const Ret diff = f - f0;
 	if (std::abs(diff) > max_abs_diff)
 	  max_abs_diff = std::abs(diff);
-	if (std::abs(f0) > Tp(10) * eps
-	 && std::abs(f) > Tp(10) * eps)
+	if (std::abs(f0) > Ret(10) * eps
+	 && std::abs(f) > Ret(10) * eps)
 	  {
-	    const Tp frac = diff / f0;
+	    const Ret frac = diff / f0;
 	    if (std::abs(frac) > max_abs_frac)
 	      max_abs_frac = std::abs(frac);
 	  }
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc	2019-06-25 02:27:32.301851290 -0700
@@ -1,6 +1,7 @@
-// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>
+// { dg-do run { target c++11 } }
+// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
 //
-// Copyright (C) 2007-2017 Free Software Foundation, Inc.
+// Copyright (C) 2016-2018 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -18,826 +19,490 @@
 // <http://www.gnu.org/licenses/>.
 
 //  comp_ellint_3
-
-
 //  Compare against values generated by the GNU Scientific Library.
 //  The GSL can be found on the web: http://www.gnu.org/software/gsl/
-
+#include <limits>
 #include <tr1/cmath>
 #if defined(__TEST_DEBUG)
-#include <iostream>
-#define VERIFY(A) \
-if (!(A)) \
-  { \
-    std::cout << "line " << __LINE__ \
-      << "  max_abs_frac = " << max_abs_frac \
-      << std::endl; \
-  }
+#  include <iostream>
+#  define VERIFY(A) \
+  if (!(A)) \
+    { \
+      std::cout << "line " << __LINE__ \
+	<< "  max_abs_frac = " << max_abs_frac \
+	<< std::endl; \
+    }
 #else
-#include <testsuite_hooks.h>
+#  include <testsuite_hooks.h>
 #endif
-#include "../testcase.h"
-
+#include <specfun_testcase.h>
 
 // Test data for k=-0.90000000000000002.
-testcase_comp_ellint_3<double> data001[] = {
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.2838262090802751e-16
+// mean(f - f_Boost): 4.4408920985006264e-17
+// variance(f - f_Boost): 2.4347558803117648e-34
+// stddev(f - f_Boost): 1.5603704304785339e-17
+const testcase_comp_ellint_3<double>
+data001[10] =
+{
   { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000 },
-  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001 },
-  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001 },
-  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999 },
-  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002 },
-  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000 },
-  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998 },
-  { 1.6600480747670938, -0.90000000000000002, 0.69999999999999996 },
-  { 1.6044591960982204, -0.90000000000000002, 0.80000000000000004 },
-  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002 },
-};
-
-// Test function for k=-0.90000000000000002.
-template <typename Tp>
-void test001()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data001)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data001[i].k), Tp(data001[i].nu));
-      const Tp f0 = data001[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+  { 2.4295011187834885, -0.90000000000000002, 0.10000000000000001 },
+  { 2.6076835743348412, -0.90000000000000002, 0.20000000000000001 },
+  { 2.8256506968858512, -0.90000000000000002, 0.30000000000000004 },
+  { 3.1000689868578619, -0.90000000000000002, 0.40000000000000002 },
+  { 3.4591069002104677, -0.90000000000000002, 0.50000000000000000 },
+  { 3.9549939883570229, -0.90000000000000002, 0.60000000000000009 },
+  { 4.6985482312992435, -0.90000000000000002, 0.70000000000000007 },
+  { 5.9820740813645710, -0.90000000000000002, 0.80000000000000004 },
+  { 8.9942562031858699, -0.90000000000000002, 0.90000000000000002 },
+};
+const double toler001 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004.
-testcase_comp_ellint_3<double> data002[] = {
-  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000 },
-  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001 },
-  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001 },
-  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999 },
-  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002 },
-  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000 },
-  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998 },
-  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996 },
-  { 1.4339837018309474, -0.80000000000000004, 0.80000000000000004 },
-  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002 },
-};
-
-// Test function for k=-0.80000000000000004.
-template <typename Tp>
-void test002()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data002)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data002[i].k), Tp(data002[i].nu));
-      const Tp f0 = data002[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1949393471095187e-16
+// mean(f - f_Boost): 9.5479180117763459e-16
+// variance(f - f_Boost): 5.4782007307014711e-34
+// stddev(f - f_Boost): 2.3405556457178006e-17
+const testcase_comp_ellint_3<double>
+data002[10] =
+{
+  { 1.9953027776647294, -0.80000000000000004, 0.0000000000000000 },
+  { 2.1172616484005085, -0.80000000000000004, 0.10000000000000001 },
+  { 2.2624789434186798, -0.80000000000000004, 0.20000000000000001 },
+  { 2.4392042002725698, -0.80000000000000004, 0.30000000000000004 },
+  { 2.6604037035529728, -0.80000000000000004, 0.40000000000000002 },
+  { 2.9478781158239751, -0.80000000000000004, 0.50000000000000000 },
+  { 3.3418121892288055, -0.80000000000000004, 0.60000000000000009 },
+  { 3.9268876980046397, -0.80000000000000004, 0.70000000000000007 },
+  { 4.9246422058196071, -0.80000000000000004, 0.80000000000000004 },
+  { 7.2263259298637132, -0.80000000000000004, 0.90000000000000002 },
+};
+const double toler002 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996.
-testcase_comp_ellint_3<double> data003[] = {
-  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000 },
-  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001 },
-  { 1.6721098780092147, -0.69999999999999996, 0.20000000000000001 },
-  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999 },
-  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002 },
-  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000 },
-  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998 },
-  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996 },
-  { 1.3427110650397533, -0.69999999999999996, 0.80000000000000004 },
-  { 1.3040500499695911, -0.69999999999999996, 0.90000000000000002 },
-};
-
-// Test function for k=-0.69999999999999996.
-template <typename Tp>
-void test003()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data003)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data003[i].k), Tp(data003[i].nu));
-      const Tp f0 = data003[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 1.9832236886714888e-16
+// mean(f - f_Boost): -1.5543122344752191e-16
+// variance(f - f_Boost): 2.9825759533819119e-33
+// stddev(f - f_Boost): 5.4612965066748680e-17
+const testcase_comp_ellint_3<double>
+data003[10] =
+{
+  { 1.8456939983747234, -0.69999999999999996, 0.0000000000000000 },
+  { 1.9541347343119564, -0.69999999999999996, 0.10000000000000001 },
+  { 2.0829290325820202, -0.69999999999999996, 0.20000000000000001 },
+  { 2.2392290510988535, -0.69999999999999996, 0.30000000000000004 },
+  { 2.4342502915307880, -0.69999999999999996, 0.40000000000000002 },
+  { 2.6868019968236996, -0.69999999999999996, 0.50000000000000000 },
+  { 3.0314573496746742, -0.69999999999999996, 0.60000000000000009 },
+  { 3.5408408771788564, -0.69999999999999996, 0.70000000000000007 },
+  { 4.4042405729076961, -0.69999999999999996, 0.80000000000000004 },
+  { 6.3796094177887754, -0.69999999999999996, 0.90000000000000002 },
+};
+const double toler003 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998.
-testcase_comp_ellint_3<double> data004[] = {
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 2
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -1.9984014443252818e-16
+// variance(f - f_Boost): 4.9303806576313241e-33
+// stddev(f - f_Boost): 7.0216669371534022e-17
+const testcase_comp_ellint_3<double>
+data004[10] =
+{
   { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000 },
-  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001 },
-  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001 },
-  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999 },
-  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002 },
-  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000 },
-  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998 },
-  { 1.3232737468822811, -0.59999999999999998, 0.69999999999999996 },
-  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004 },
-  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002 },
-};
-
-// Test function for k=-0.59999999999999998.
-template <typename Tp>
-void test004()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data004)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data004[i].k), Tp(data004[i].nu));
-      const Tp f0 = data004[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+  { 1.8508766487100685, -0.59999999999999998, 0.10000000000000001 },
+  { 1.9695980282802217, -0.59999999999999998, 0.20000000000000001 },
+  { 2.1134154405060599, -0.59999999999999998, 0.30000000000000004 },
+  { 2.2925036420985130, -0.59999999999999998, 0.40000000000000002 },
+  { 2.5239007084492711, -0.59999999999999998, 0.50000000000000000 },
+  { 2.8388723099514972, -0.59999999999999998, 0.60000000000000009 },
+  { 3.3029735898397159, -0.59999999999999998, 0.70000000000000007 },
+  { 4.0867036409261832, -0.59999999999999998, 0.80000000000000004 },
+  { 5.8709993116265604, -0.59999999999999998, 0.90000000000000002 },
+};
+const double toler004 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000.
-testcase_comp_ellint_3<double> data005[] = {
-  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000 },
-  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001 },
-  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001 },
-  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999 },
-  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002 },
-  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000 },
-  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998 },
-  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996 },
-  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004 },
-  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002 },
-};
-
-// Test function for k=-0.50000000000000000.
-template <typename Tp>
-void test005()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data005)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data005[i].k), Tp(data005[i].nu));
-      const Tp f0 = data005[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002.
-testcase_comp_ellint_3<double> data006[] = {
-  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000 },
-  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001 },
-  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001 },
-  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999 },
-  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002 },
-  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000 },
-  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998 },
-  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996 },
-  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004 },
-  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002 },
-};
-
-// Test function for k=-0.40000000000000002.
-template <typename Tp>
-void test006()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data006)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data006[i].k), Tp(data006[i].nu));
-      const Tp f0 = data006[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004.
-testcase_comp_ellint_3<double> data007[] = {
-  { 1.6080486199305126, -0.30000000000000004, 0.0000000000000000 },
-  { 1.5323534693557526, -0.30000000000000004, 0.10000000000000001 },
-  { 1.4663658145259875, -0.30000000000000004, 0.20000000000000001 },
-  { 1.4081767433479089, -0.30000000000000004, 0.29999999999999999 },
-  { 1.3563643538969761, -0.30000000000000004, 0.40000000000000002 },
-  { 1.3098448759814960, -0.30000000000000004, 0.50000000000000000 },
-  { 1.2677758800420666, -0.30000000000000004, 0.59999999999999998 },
-  { 1.2294913236274980, -0.30000000000000004, 0.69999999999999996 },
-  { 1.1944567571590046, -0.30000000000000004, 0.80000000000000004 },
-  { 1.1622376896064912, -0.30000000000000004, 0.90000000000000002 },
-};
-
-// Test function for k=-0.30000000000000004.
-template <typename Tp>
-void test007()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data007)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data007[i].k), Tp(data007[i].nu));
-      const Tp f0 = data007[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 2.1900131385114407e-16
+// mean(f - f_Boost): 2.4424906541753446e-16
+// variance(f - f_Boost): 7.3651365379430888e-33
+// stddev(f - f_Boost): 8.5820373676319358e-17
+const testcase_comp_ellint_3<double>
+data005[10] =
+{
+  { 1.6857503548125961, -0.50000000000000000, 0.0000000000000000 },
+  { 1.7803034946545482, -0.50000000000000000, 0.10000000000000001 },
+  { 1.8922947612264021, -0.50000000000000000, 0.20000000000000001 },
+  { 2.0277924458111314, -0.50000000000000000, 0.30000000000000004 },
+  { 2.1962905366178065, -0.50000000000000000, 0.40000000000000002 },
+  { 2.4136715042011945, -0.50000000000000000, 0.50000000000000000 },
+  { 2.7090491861753558, -0.50000000000000000, 0.60000000000000009 },
+  { 3.1433945297859229, -0.50000000000000000, 0.70000000000000007 },
+  { 3.8750701888108070, -0.50000000000000000, 0.80000000000000004 },
+  { 5.5355132096026463, -0.50000000000000000, 0.90000000000000002 },
+};
+const double toler005 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1718164615986397e-16
+// mean(f - f_Boost): 6.2172489379008762e-16
+// variance(f - f_Boost): 1.6458949750907531e-31
+// stddev(f - f_Boost): 4.0569631192441877e-16
+const testcase_comp_ellint_3<double>
+data006[10] =
+{
+  { 1.6399998658645112, -0.39999999999999991, 0.0000000000000000 },
+  { 1.7306968836847190, -0.39999999999999991, 0.10000000000000001 },
+  { 1.8380358826317627, -0.39999999999999991, 0.20000000000000001 },
+  { 1.9677924132520139, -0.39999999999999991, 0.30000000000000004 },
+  { 2.1289968719280026, -0.39999999999999991, 0.40000000000000002 },
+  { 2.3367461373176512, -0.39999999999999991, 0.50000000000000000 },
+  { 2.6186940209850191, -0.39999999999999991, 0.60000000000000009 },
+  { 3.0327078743873246, -0.39999999999999991, 0.70000000000000007 },
+  { 3.7289548002199902, -0.39999999999999991, 0.80000000000000004 },
+  { 5.3055535102872513, -0.39999999999999991, 0.90000000000000002 },
+};
+const double toler006 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.9274792319434433e-16
+// mean(f - f_Boost): 6.2172489379008762e-16
+// variance(f - f_Boost): 8.7651211691223537e-33
+// stddev(f - f_Boost): 9.3622225828712025e-17
+const testcase_comp_ellint_3<double>
+data007[10] =
+{
+  { 1.6080486199305128, -0.29999999999999993, 0.0000000000000000 },
+  { 1.6960848815118226, -0.29999999999999993, 0.10000000000000001 },
+  { 1.8002173372290500, -0.29999999999999993, 0.20000000000000001 },
+  { 1.9260216862473254, -0.29999999999999993, 0.30000000000000004 },
+  { 2.0822121773175533, -0.29999999999999993, 0.40000000000000002 },
+  { 2.2833505881933971, -0.29999999999999993, 0.50000000000000000 },
+  { 2.5560975528589065, -0.29999999999999993, 0.60000000000000009 },
+  { 2.9562123549913877, -0.29999999999999993, 0.70000000000000007 },
+  { 3.6283050484567170, -0.29999999999999993, 0.80000000000000004 },
+  { 5.1479514944016795, -0.29999999999999993, 0.90000000000000002 },
+};
+const double toler007 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996.
-testcase_comp_ellint_3<double> data008[] = {
-  { 1.5868678474541664, -0.19999999999999996, 0.0000000000000000 },
-  { 1.5126513474261092, -0.19999999999999996, 0.10000000000000001 },
-  { 1.4479323932249568, -0.19999999999999996, 0.20000000000000001 },
-  { 1.3908453514752481, -0.19999999999999996, 0.29999999999999999 },
-  { 1.3400002519661010, -0.19999999999999996, 0.40000000000000002 },
-  { 1.2943374404397376, -0.19999999999999996, 0.50000000000000000 },
-  { 1.2530330675914561, -0.19999999999999996, 0.59999999999999998 },
-  { 1.2154356555075867, -0.19999999999999996, 0.69999999999999996 },
-  { 1.1810223448909913, -0.19999999999999996, 0.80000000000000004 },
-  { 1.1493679916141863, -0.19999999999999996, 0.90000000000000002 },
-};
-
-// Test function for k=-0.19999999999999996.
-template <typename Tp>
-void test008()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data008)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data008[i].k), Tp(data008[i].nu));
-      const Tp f0 = data008[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.9753938705764407e-16
+// mean(f - f_Boost): 3.1086244689504381e-16
+// variance(f - f_Boost): 4.1147374377268827e-32
+// stddev(f - f_Boost): 2.0284815596220939e-16
+const testcase_comp_ellint_3<double>
+data008[10] =
+{
+  { 1.5868678474541662, -0.19999999999999996, 0.0000000000000000 },
+  { 1.6731552050562593, -0.19999999999999996, 0.10000000000000001 },
+  { 1.7751816279738935, -0.19999999999999996, 0.20000000000000001 },
+  { 1.8983924169967101, -0.19999999999999996, 0.30000000000000004 },
+  { 2.0512956926676806, -0.19999999999999996, 0.40000000000000002 },
+  { 2.2481046259421302, -0.19999999999999996, 0.50000000000000000 },
+  { 2.5148333891629315, -0.19999999999999996, 0.60000000000000009 },
+  { 2.9058704854500967, -0.19999999999999996, 0.70000000000000007 },
+  { 3.5622166386422633, -0.19999999999999996, 0.80000000000000004 },
+  { 5.0448269356200370, -0.19999999999999996, 0.90000000000000002 },
+};
+const double toler008 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978.
-testcase_comp_ellint_3<double> data009[] = {
-  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000 },
-  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001 },
-  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001 },
-  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999 },
-  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002 },
-  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000 },
-  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998 },
-  { 1.2073745911083187, -0.099999999999999978, 0.69999999999999996 },
-  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004 },
-  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002 },
-};
-
-// Test function for k=-0.099999999999999978.
-template <typename Tp>
-void test009()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data009)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data009[i].k), Tp(data009[i].nu));
-      const Tp f0 = data009[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.9932308021417639e-16
+// mean(f - f_Boost): 0.0000000000000000
+// variance(f - f_Boost): 6.8368087769470551e-64
+// stddev(f - f_Boost): 2.6147291976315738e-32
+const testcase_comp_ellint_3<double>
+data009[10] =
+{
+  { 1.5747455615173560, -0.099999999999999978, 0.0000000000000000 },
+  { 1.6600374067558428, -0.099999999999999978, 0.10000000000000001 },
+  { 1.7608656115083421, -0.099999999999999978, 0.20000000000000001 },
+  { 1.8826015946315438, -0.099999999999999978, 0.30000000000000004 },
+  { 2.0336367403076760, -0.099999999999999978, 0.40000000000000002 },
+  { 2.2279868912966849, -0.099999999999999978, 0.50000000000000000 },
+  { 2.4913004919173827, -0.099999999999999978, 0.60000000000000009 },
+  { 2.8771910188009744, -0.099999999999999978, 0.70000000000000007 },
+  { 3.5246199613295617, -0.099999999999999978, 0.80000000000000004 },
+  { 4.9862890417305508, -0.099999999999999978, 0.90000000000000002 },
+};
+const double toler009 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000.
-testcase_comp_ellint_3<double> data010[] = {
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.1899085000907084e-16
+// mean(f - f_Boost): -2.2204460492503131e-16
+// variance(f - f_Boost): 5.4782007307014711e-32
+// stddev(f - f_Boost): 2.3405556457178008e-16
+const testcase_comp_ellint_3<double>
+data010[10] =
+{
   { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000 },
-  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001 },
-  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001 },
-  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999 },
-  { 1.3275651989026322, 0.0000000000000000, 0.40000000000000002 },
-  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000 },
-  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998 },
-  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996 },
-  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004 },
-  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002 },
-};
-
-// Test function for k=0.0000000000000000.
-template <typename Tp>
-void test010()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data010)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data010[i].k), Tp(data010[i].nu));
-      const Tp f0 = data010[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+  { 1.6557647109660170, 0.0000000000000000, 0.10000000000000001 },
+  { 1.7562036827601817, 0.0000000000000000, 0.20000000000000001 },
+  { 1.8774607092226381, 0.0000000000000000, 0.30000000000000004 },
+  { 2.0278893379868062, 0.0000000000000000, 0.40000000000000002 },
+  { 2.2214414690791831, 0.0000000000000000, 0.50000000000000000 },
+  { 2.4836470664490258, 0.0000000000000000, 0.60000000000000009 },
+  { 2.8678686047727386, 0.0000000000000000, 0.70000000000000007 },
+  { 3.5124073655203634, 0.0000000000000000, 0.80000000000000004 },
+  { 4.9672941328980516, 0.0000000000000000, 0.90000000000000002 },
+};
+const double toler010 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009.
-testcase_comp_ellint_3<double> data011[] = {
-  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000 },
-  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001 },
-  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001 },
-  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999 },
-  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002 },
-  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000 },
-  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998 },
-  { 1.2073745911083187, 0.10000000000000009, 0.69999999999999996 },
-  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004 },
-  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002 },
-};
-
-// Test function for k=0.10000000000000009.
-template <typename Tp>
-void test011()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data011)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data011[i].k), Tp(data011[i].nu));
-      const Tp f0 = data011[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996.
-testcase_comp_ellint_3<double> data012[] = {
-  { 1.5868678474541664, 0.19999999999999996, 0.0000000000000000 },
-  { 1.5126513474261092, 0.19999999999999996, 0.10000000000000001 },
-  { 1.4479323932249568, 0.19999999999999996, 0.20000000000000001 },
-  { 1.3908453514752481, 0.19999999999999996, 0.29999999999999999 },
-  { 1.3400002519661010, 0.19999999999999996, 0.40000000000000002 },
-  { 1.2943374404397376, 0.19999999999999996, 0.50000000000000000 },
-  { 1.2530330675914561, 0.19999999999999996, 0.59999999999999998 },
-  { 1.2154356555075867, 0.19999999999999996, 0.69999999999999996 },
-  { 1.1810223448909913, 0.19999999999999996, 0.80000000000000004 },
-  { 1.1493679916141863, 0.19999999999999996, 0.90000000000000002 },
-};
-
-// Test function for k=0.19999999999999996.
-template <typename Tp>
-void test012()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data012)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data012[i].k), Tp(data012[i].nu));
-      const Tp f0 = data012[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.9932308021417639e-16
+// mean(f - f_Boost): -2.2204460492503132e-17
+// variance(f - f_Boost): 6.0868897007794120e-35
+// stddev(f - f_Boost): 7.8018521523926693e-18
+const testcase_comp_ellint_3<double>
+data011[10] =
+{
+  { 1.5747455615173560, 0.10000000000000009, 0.0000000000000000 },
+  { 1.6600374067558428, 0.10000000000000009, 0.10000000000000001 },
+  { 1.7608656115083421, 0.10000000000000009, 0.20000000000000001 },
+  { 1.8826015946315440, 0.10000000000000009, 0.30000000000000004 },
+  { 2.0336367403076760, 0.10000000000000009, 0.40000000000000002 },
+  { 2.2279868912966849, 0.10000000000000009, 0.50000000000000000 },
+  { 2.4913004919173827, 0.10000000000000009, 0.60000000000000009 },
+  { 2.8771910188009744, 0.10000000000000009, 0.70000000000000007 },
+  { 3.5246199613295617, 0.10000000000000009, 0.80000000000000004 },
+  { 4.9862890417305508, 0.10000000000000009, 0.90000000000000002 },
+};
+const double toler011 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.9753938705764407e-16
+// mean(f - f_Boost): 3.1086244689504381e-16
+// variance(f - f_Boost): 4.1147374377268827e-32
+// stddev(f - f_Boost): 2.0284815596220939e-16
+const testcase_comp_ellint_3<double>
+data012[10] =
+{
+  { 1.5868678474541662, 0.20000000000000018, 0.0000000000000000 },
+  { 1.6731552050562593, 0.20000000000000018, 0.10000000000000001 },
+  { 1.7751816279738935, 0.20000000000000018, 0.20000000000000001 },
+  { 1.8983924169967101, 0.20000000000000018, 0.30000000000000004 },
+  { 2.0512956926676806, 0.20000000000000018, 0.40000000000000002 },
+  { 2.2481046259421302, 0.20000000000000018, 0.50000000000000000 },
+  { 2.5148333891629315, 0.20000000000000018, 0.60000000000000009 },
+  { 2.9058704854500967, 0.20000000000000018, 0.70000000000000007 },
+  { 3.5622166386422633, 0.20000000000000018, 0.80000000000000004 },
+  { 5.0448269356200370, 0.20000000000000018, 0.90000000000000002 },
+};
+const double toler012 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004.
-testcase_comp_ellint_3<double> data013[] = {
-  { 1.6080486199305126, 0.30000000000000004, 0.0000000000000000 },
-  { 1.5323534693557526, 0.30000000000000004, 0.10000000000000001 },
-  { 1.4663658145259875, 0.30000000000000004, 0.20000000000000001 },
-  { 1.4081767433479089, 0.30000000000000004, 0.29999999999999999 },
-  { 1.3563643538969761, 0.30000000000000004, 0.40000000000000002 },
-  { 1.3098448759814960, 0.30000000000000004, 0.50000000000000000 },
-  { 1.2677758800420666, 0.30000000000000004, 0.59999999999999998 },
-  { 1.2294913236274980, 0.30000000000000004, 0.69999999999999996 },
-  { 1.1944567571590046, 0.30000000000000004, 0.80000000000000004 },
-  { 1.1622376896064912, 0.30000000000000004, 0.90000000000000002 },
-};
-
-// Test function for k=0.30000000000000004.
-template <typename Tp>
-void test013()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data013)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data013[i].k), Tp(data013[i].nu));
-      const Tp f0 = data013[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991.
-testcase_comp_ellint_3<double> data014[] = {
-  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000 },
-  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001 },
-  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001 },
-  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999 },
-  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002 },
-  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000 },
-  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998 },
-  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996 },
-  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004 },
-  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002 },
-};
-
-// Test function for k=0.39999999999999991.
-template <typename Tp>
-void test014()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data014)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data014[i].k), Tp(data014[i].nu));
-      const Tp f0 = data014[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.4585997630846713e-16
+// mean(f - f_Boost): 5.1070259132757197e-16
+// variance(f - f_Boost): 1.7591111235252501e-32
+// stddev(f - f_Boost): 1.3263148659067538e-16
+const testcase_comp_ellint_3<double>
+data013[10] =
+{
+  { 1.6080486199305128, 0.30000000000000004, 0.0000000000000000 },
+  { 1.6960848815118228, 0.30000000000000004, 0.10000000000000001 },
+  { 1.8002173372290500, 0.30000000000000004, 0.20000000000000001 },
+  { 1.9260216862473254, 0.30000000000000004, 0.30000000000000004 },
+  { 2.0822121773175533, 0.30000000000000004, 0.40000000000000002 },
+  { 2.2833505881933975, 0.30000000000000004, 0.50000000000000000 },
+  { 2.5560975528589065, 0.30000000000000004, 0.60000000000000009 },
+  { 2.9562123549913877, 0.30000000000000004, 0.70000000000000007 },
+  { 3.6283050484567174, 0.30000000000000004, 0.80000000000000004 },
+  { 5.1479514944016795, 0.30000000000000004, 0.90000000000000002 },
+};
+const double toler013 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.7696531428672557e-16
+// mean(f - f_Boost): 1.1990408665951691e-15
+// variance(f - f_Boost): 2.6514491536595121e-31
+// stddev(f - f_Boost): 5.1492224205791612e-16
+const testcase_comp_ellint_3<double>
+data014[10] =
+{
+  { 1.6399998658645112, 0.40000000000000013, 0.0000000000000000 },
+  { 1.7306968836847190, 0.40000000000000013, 0.10000000000000001 },
+  { 1.8380358826317629, 0.40000000000000013, 0.20000000000000001 },
+  { 1.9677924132520141, 0.40000000000000013, 0.30000000000000004 },
+  { 2.1289968719280030, 0.40000000000000013, 0.40000000000000002 },
+  { 2.3367461373176512, 0.40000000000000013, 0.50000000000000000 },
+  { 2.6186940209850196, 0.40000000000000013, 0.60000000000000009 },
+  { 3.0327078743873246, 0.40000000000000013, 0.70000000000000007 },
+  { 3.7289548002199906, 0.40000000000000013, 0.80000000000000004 },
+  { 5.3055535102872522, 0.40000000000000013, 0.90000000000000002 },
+};
+const double toler014 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000.
-testcase_comp_ellint_3<double> data015[] = {
-  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000 },
-  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001 },
-  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001 },
-  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999 },
-  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002 },
-  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000 },
-  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998 },
-  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996 },
-  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004 },
-  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002 },
-};
-
-// Test function for k=0.50000000000000000.
-template <typename Tp>
-void test015()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data015)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data015[i].k), Tp(data015[i].nu));
-      const Tp f0 = data015[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 2.1900131385114407e-16
+// mean(f - f_Boost): 2.4424906541753446e-16
+// variance(f - f_Boost): 7.3651365379430888e-33
+// stddev(f - f_Boost): 8.5820373676319358e-17
+const testcase_comp_ellint_3<double>
+data015[10] =
+{
+  { 1.6857503548125961, 0.50000000000000000, 0.0000000000000000 },
+  { 1.7803034946545482, 0.50000000000000000, 0.10000000000000001 },
+  { 1.8922947612264021, 0.50000000000000000, 0.20000000000000001 },
+  { 2.0277924458111314, 0.50000000000000000, 0.30000000000000004 },
+  { 2.1962905366178065, 0.50000000000000000, 0.40000000000000002 },
+  { 2.4136715042011945, 0.50000000000000000, 0.50000000000000000 },
+  { 2.7090491861753558, 0.50000000000000000, 0.60000000000000009 },
+  { 3.1433945297859229, 0.50000000000000000, 0.70000000000000007 },
+  { 3.8750701888108070, 0.50000000000000000, 0.80000000000000004 },
+  { 5.5355132096026463, 0.50000000000000000, 0.90000000000000002 },
+};
+const double toler015 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009.
-testcase_comp_ellint_3<double> data016[] = {
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 2
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -2.2204460492503131e-16
+// variance(f - f_Boost): 6.0868897007794117e-33
+// stddev(f - f_Boost): 7.8018521523926690e-17
+const testcase_comp_ellint_3<double>
+data016[10] =
+{
   { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000 },
-  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001 },
-  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001 },
-  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999 },
-  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002 },
-  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000 },
-  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998 },
-  { 1.3232737468822811, 0.60000000000000009, 0.69999999999999996 },
-  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004 },
-  { 1.2479362973851875, 0.60000000000000009, 0.90000000000000002 },
-};
-
-// Test function for k=0.60000000000000009.
-template <typename Tp>
-void test016()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data016)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data016[i].k), Tp(data016[i].nu));
-      const Tp f0 = data016[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996.
-testcase_comp_ellint_3<double> data017[] = {
-  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000 },
-  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001 },
-  { 1.6721098780092147, 0.69999999999999996, 0.20000000000000001 },
-  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999 },
-  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002 },
-  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000 },
-  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998 },
-  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996 },
-  { 1.3427110650397533, 0.69999999999999996, 0.80000000000000004 },
-  { 1.3040500499695911, 0.69999999999999996, 0.90000000000000002 },
-};
-
-// Test function for k=0.69999999999999996.
-template <typename Tp>
-void test017()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data017)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data017[i].k), Tp(data017[i].nu));
-      const Tp f0 = data017[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+  { 1.8508766487100687, 0.60000000000000009, 0.10000000000000001 },
+  { 1.9695980282802217, 0.60000000000000009, 0.20000000000000001 },
+  { 2.1134154405060599, 0.60000000000000009, 0.30000000000000004 },
+  { 2.2925036420985130, 0.60000000000000009, 0.40000000000000002 },
+  { 2.5239007084492711, 0.60000000000000009, 0.50000000000000000 },
+  { 2.8388723099514976, 0.60000000000000009, 0.60000000000000009 },
+  { 3.3029735898397159, 0.60000000000000009, 0.70000000000000007 },
+  { 4.0867036409261832, 0.60000000000000009, 0.80000000000000004 },
+  { 5.8709993116265613, 0.60000000000000009, 0.90000000000000002 },
+};
+const double toler016 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.9298727220933567e-16
+// mean(f - f_Boost): 4.8849813083506892e-16
+// variance(f - f_Boost): 2.0476296953421943e-31
+// stddev(f - f_Boost): 4.5250742483877478e-16
+const testcase_comp_ellint_3<double>
+data017[10] =
+{
+  { 1.8456939983747238, 0.70000000000000018, 0.0000000000000000 },
+  { 1.9541347343119566, 0.70000000000000018, 0.10000000000000001 },
+  { 2.0829290325820207, 0.70000000000000018, 0.20000000000000001 },
+  { 2.2392290510988540, 0.70000000000000018, 0.30000000000000004 },
+  { 2.4342502915307880, 0.70000000000000018, 0.40000000000000002 },
+  { 2.6868019968237000, 0.70000000000000018, 0.50000000000000000 },
+  { 3.0314573496746746, 0.70000000000000018, 0.60000000000000009 },
+  { 3.5408408771788569, 0.70000000000000018, 0.70000000000000007 },
+  { 4.4042405729076970, 0.70000000000000018, 0.80000000000000004 },
+  { 6.3796094177887763, 0.70000000000000018, 0.90000000000000002 },
+};
+const double toler017 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004.
-testcase_comp_ellint_3<double> data018[] = {
-  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000 },
-  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001 },
-  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001 },
-  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999 },
-  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002 },
-  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000 },
-  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998 },
-  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996 },
-  { 1.4339837018309474, 0.80000000000000004, 0.80000000000000004 },
-  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002 },
-};
-
-// Test function for k=0.80000000000000004.
-template <typename Tp>
-void test018()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data018)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data018[i].k), Tp(data018[i].nu));
-      const Tp f0 = data018[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991.
-testcase_comp_ellint_3<double> data019[] = {
-  { 2.2805491384227699, 0.89999999999999991, 0.0000000000000000 },
-  { 2.1537868513875282, 0.89999999999999991, 0.10000000000000001 },
-  { 2.0443194576468890, 0.89999999999999991, 0.20000000000000001 },
-  { 1.9486280260314424, 0.89999999999999991, 0.29999999999999999 },
-  { 1.8641114227238347, 0.89999999999999991, 0.40000000000000002 },
-  { 1.7888013241937859, 0.89999999999999991, 0.50000000000000000 },
-  { 1.7211781128919521, 0.89999999999999991, 0.59999999999999998 },
-  { 1.6600480747670936, 0.89999999999999991, 0.69999999999999996 },
-  { 1.6044591960982200, 0.89999999999999991, 0.80000000000000004 },
-  { 1.5536420236310944, 0.89999999999999991, 0.90000000000000002 },
-};
-
-// Test function for k=0.89999999999999991.
-template <typename Tp>
-void test019()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data019)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data019[i].k), Tp(data019[i].nu));
-      const Tp f0 = data019[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1949393471095187e-16
+// mean(f - f_Boost): 9.5479180117763459e-16
+// variance(f - f_Boost): 5.4782007307014711e-34
+// stddev(f - f_Boost): 2.3405556457178006e-17
+const testcase_comp_ellint_3<double>
+data018[10] =
+{
+  { 1.9953027776647294, 0.80000000000000004, 0.0000000000000000 },
+  { 2.1172616484005085, 0.80000000000000004, 0.10000000000000001 },
+  { 2.2624789434186798, 0.80000000000000004, 0.20000000000000001 },
+  { 2.4392042002725698, 0.80000000000000004, 0.30000000000000004 },
+  { 2.6604037035529728, 0.80000000000000004, 0.40000000000000002 },
+  { 2.9478781158239751, 0.80000000000000004, 0.50000000000000000 },
+  { 3.3418121892288055, 0.80000000000000004, 0.60000000000000009 },
+  { 3.9268876980046397, 0.80000000000000004, 0.70000000000000007 },
+  { 4.9246422058196071, 0.80000000000000004, 0.80000000000000004 },
+  { 7.2263259298637132, 0.80000000000000004, 0.90000000000000002 },
+};
+const double toler018 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 1.5716352001310461e-16
+// mean(f - f_Boost): 4.4408920985006264e-17
+// variance(f - f_Boost): 2.4347558803117648e-34
+// stddev(f - f_Boost): 1.5603704304785339e-17
+const testcase_comp_ellint_3<double>
+data019[10] =
+{
+  { 2.2805491384227707, 0.90000000000000013, 0.0000000000000000 },
+  { 2.4295011187834890, 0.90000000000000013, 0.10000000000000001 },
+  { 2.6076835743348421, 0.90000000000000013, 0.20000000000000001 },
+  { 2.8256506968858521, 0.90000000000000013, 0.30000000000000004 },
+  { 3.1000689868578628, 0.90000000000000013, 0.40000000000000002 },
+  { 3.4591069002104686, 0.90000000000000013, 0.50000000000000000 },
+  { 3.9549939883570242, 0.90000000000000013, 0.60000000000000009 },
+  { 4.6985482312992453, 0.90000000000000013, 0.70000000000000007 },
+  { 5.9820740813645727, 0.90000000000000013, 0.80000000000000004 },
+  { 8.9942562031858735, 0.90000000000000013, 0.90000000000000002 },
+};
+const double toler019 = 2.5000000000000020e-13;
+
+template<typename Ret, unsigned int Num>
+  void
+  test(const testcase_comp_ellint_3<Ret> (&data)[Num], Ret toler)
+  {
+    bool test __attribute__((unused)) = true;
+    const Ret eps = std::numeric_limits<Ret>::epsilon();
+    Ret max_abs_diff = -Ret(1);
+    Ret max_abs_frac = -Ret(1);
+    unsigned int num_datum = Num;
+    for (unsigned int i = 0; i < num_datum; ++i)
+      {
+	const Ret f = std::tr1::comp_ellint_3(data[i].k, data[i].nu);
+	const Ret f0 = data[i].f0;
+	const Ret diff = f - f0;
+	if (std::abs(diff) > max_abs_diff)
+	  max_abs_diff = std::abs(diff);
+	if (std::abs(f0) > Ret(10) * eps
+	 && std::abs(f) > Ret(10) * eps)
+	  {
+	    const Ret frac = diff / f0;
+	    if (std::abs(frac) > max_abs_frac)
+	      max_abs_frac = std::abs(frac);
+	  }
+      }
+    VERIFY(max_abs_frac < toler);
+  }
 
-int main(int, char**)
+int
+main()
 {
-  test001<double>();
-  test002<double>();
-  test003<double>();
-  test004<double>();
-  test005<double>();
-  test006<double>();
-  test007<double>();
-  test008<double>();
-  test009<double>();
-  test010<double>();
-  test011<double>();
-  test012<double>();
-  test013<double>();
-  test014<double>();
-  test015<double>();
-  test016<double>();
-  test017<double>();
-  test018<double>();
-  test019<double>();
+  test(data001, toler001);
+  test(data002, toler002);
+  test(data003, toler003);
+  test(data004, toler004);
+  test(data005, toler005);
+  test(data006, toler006);
+  test(data007, toler007);
+  test(data008, toler008);
+  test(data009, toler009);
+  test(data010, toler010);
+  test(data011, toler011);
+  test(data012, toler012);
+  test(data013, toler013);
+  test(data014, toler014);
+  test(data015, toler015);
+  test(data016, toler016);
+  test(data017, toler017);
+  test(data018, toler018);
+  test(data019, toler019);
   return 0;
 }
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc gcc-7.3.0-msp430/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc
--- gcc-7.3.0/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc	2017-01-01 04:07:43.905435000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc	2019-06-25 02:27:32.305851262 -0700
@@ -1,6 +1,7 @@
-// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>
+// { dg-do run { target c++11 } }
+// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
 //
-// Copyright (C) 2007-2017 Free Software Foundation, Inc.
+// Copyright (C) 2016-2018 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -18,10098 +19,6324 @@
 // <http://www.gnu.org/licenses/>.
 
 //  ellint_3
-
-
 //  Compare against values generated by the GNU Scientific Library.
 //  The GSL can be found on the web: http://www.gnu.org/software/gsl/
-
+#include <limits>
 #include <tr1/cmath>
 #if defined(__TEST_DEBUG)
-#include <iostream>
-#define VERIFY(A) \
-if (!(A)) \
-  { \
-    std::cout << "line " << __LINE__ \
-      << "  max_abs_frac = " << max_abs_frac \
-      << std::endl; \
-  }
+#  include <iostream>
+#  define VERIFY(A) \
+  if (!(A)) \
+    { \
+      std::cout << "line " << __LINE__ \
+	<< "  max_abs_frac = " << max_abs_frac \
+	<< std::endl; \
+    }
 #else
-#include <testsuite_hooks.h>
+#  include <testsuite_hooks.h>
 #endif
-#include "../testcase.h"
-
+#include <specfun_testcase.h>
 
 // Test data for k=-0.90000000000000002, nu=0.0000000000000000.
-testcase_ellint_3<double> data001[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17525427376115027, -0.90000000000000002, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35492464591297446, -0.90000000000000002, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.54388221416157134, -0.90000000000000002, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.74797400423532523, -0.90000000000000002, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.97463898451966458, -0.90000000000000002, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.2334463254523440, -0.90000000000000002, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.5355247765594910, -0.90000000000000002, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.8882928567775124, -0.90000000000000002, 0.0000000000000000,
-          1.3962634015954636 },
-  { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.0000000000000000.
-template <typename Tp>
-void test001()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data001)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data001[i].k), Tp(data001[i].nu),
-                   Tp(data001[i].phi));
-      const Tp f0 = data001[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 5.7842011620951154e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
+const testcase_ellint_3<double>
+data001[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17525427376115027, -0.90000000000000002, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35492464591297446, -0.90000000000000002, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.54388221416157123, -0.90000000000000002, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.74797400423532512, -0.90000000000000002, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.97463898451966446, -0.90000000000000002, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.2334463254523438, -0.90000000000000002, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.5355247765594913, -0.90000000000000002, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.8882928567775126, -0.90000000000000002, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler001 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.10000000000000001.
-testcase_ellint_3<double> data002[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17507714233254659, -0.90000000000000002, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35350932904326521, -0.90000000000000002, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53911129989870998, -0.90000000000000002, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.73666644254508429, -0.90000000000000002, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.95250736612100184, -0.90000000000000002, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1950199550905594, -0.90000000000000002, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.4741687286340848, -0.90000000000000002, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.7968678183506059, -0.90000000000000002, 0.10000000000000001,
-          1.3962634015954636 },
-  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.10000000000000001.
-template <typename Tp>
-void test002()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data002)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data002[i].k), Tp(data002[i].nu),
-                   Tp(data002[i].phi));
-      const Tp f0 = data002[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.1500594295134815e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
+const testcase_ellint_3<double>
+data002[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17543204932716244, -0.90000000000000002, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35636022898551184, -0.90000000000000002, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54880278898382584, -0.90000000000000002, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.75988834774529268, -0.90000000000000002, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.99853303003568117, -0.90000000000000002, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.2759958823999022, -0.90000000000000002, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.6051187364639401, -0.90000000000000002, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.9941406879519472, -0.90000000000000002, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 2.4295011187834881, -0.90000000000000002, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler002 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.20000000000000001.
-testcase_ellint_3<double> data003[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17490065089140930, -0.90000000000000002, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.35211377590661436, -0.90000000000000002, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.53448220334204122, -0.90000000000000002, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.72591368943179613, -0.90000000000000002, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.93192539780038763, -0.90000000000000002, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.1600809679692683, -0.90000000000000002, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.4195407225882508, -0.90000000000000002, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.7168966476424528, -0.90000000000000002, 0.20000000000000001,
-          1.3962634015954636 },
-  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.20000000000000001.
-template <typename Tp>
-void test003()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data003)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data003[i].k), Tp(data003[i].nu),
-                   Tp(data003[i].phi));
-      const Tp f0 = data003[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.29999999999999999.
-testcase_ellint_3<double> data004[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17472479532647534, -0.90000000000000002, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.35073750187374114, -0.90000000000000002, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52998766129466979, -0.90000000000000002, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.71566993548699587, -0.90000000000000002, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.91271517762560195, -0.90000000000000002, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.1281241199843370, -0.90000000000000002, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.3704929576917448, -0.90000000000000002, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.6461981511487715, -0.90000000000000002, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.29999999999999999.
-template <typename Tp>
-void test004()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data004)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data004[i].k), Tp(data004[i].nu),
-                   Tp(data004[i].phi));
-      const Tp f0 = data004[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 5.2711357908578066e-16
+// mean(f - f_Boost): 8.0491169285323847e-17
+// variance(f - f_Boost): 7.9985534974304465e-34
+// stddev(f - f_Boost): 2.8281714052423424e-17
+const testcase_ellint_3<double>
+data003[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17561047321968409, -0.90000000000000002, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35781659944356109, -0.90000000000000002, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.55388150905215283, -0.90000000000000002, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.77246874123251441, -0.90000000000000002, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 1.0244466254771925, -0.90000000000000002, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.3234824077640801, -0.90000000000000002, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.6849848968804237, -0.90000000000000002, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 2.1185749045502273, -0.90000000000000002, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.6076835743348412, -0.90000000000000002, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler003 = 2.5000000000000020e-13;
+
+// Test data for k=-0.90000000000000002, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.9955372494296814e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
+const testcase_ellint_3<double>
+data004[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17578954966746221, -0.90000000000000002, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35929429810867447, -0.90000000000000002, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55912757154240811, -0.90000000000000002, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.78578314722025389, -0.90000000000000002, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 1.0526941001131365, -0.90000000000000002, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.3769682234538601, -0.90000000000000002, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.7779437432911238, -0.90000000000000002, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 2.2676509341813631, -0.90000000000000002, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.8256506968858512, -0.90000000000000002, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler004 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.40000000000000002.
-testcase_ellint_3<double> data005[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17454957156468839, -0.90000000000000002, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34938003933330430, -0.90000000000000002, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.52562093533067455, -0.90000000000000002, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.70589461324915703, -0.90000000000000002, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.89472658511942849, -0.90000000000000002, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0987419542323440, -0.90000000000000002, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.3261349565496301, -0.90000000000000002, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.5831293909853767, -0.90000000000000002, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.40000000000000002.
-template <typename Tp>
-void test005()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data005)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data005[i].k), Tp(data005[i].nu),
-                   Tp(data005[i].phi));
-      const Tp f0 = data005[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.7042235432234642e-16
+// mean(f - f_Boost): 2.0261570199409106e-16
+// variance(f - f_Boost): 5.8024227149195491e-32
+// stddev(f - f_Boost): 2.4088218520512364e-16
+const testcase_ellint_3<double>
+data005[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17596928293938452, -0.90000000000000002, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.36079388642472821, -0.90000000000000002, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.56455096667115612, -0.90000000000000002, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.79990996997869435, -0.90000000000000002, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0836647913872215, -0.90000000000000002, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.4378726836091849, -0.90000000000000002, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.8880446720682853, -0.90000000000000002, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.4505848932025227, -0.90000000000000002, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 3.1000689868578615, -0.90000000000000002, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler005 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.50000000000000000.
-testcase_ellint_3<double> data006[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17437497557073336, -0.90000000000000002, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34804093691586013, -0.90000000000000002, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.52137576320372914, -0.90000000000000002, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.69655163996912284, -0.90000000000000002, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.87783188683054236, -0.90000000000000002, 0.50000000000000000,
-          0.87266462599716477 },
-  { 1.0716015959755185, -0.90000000000000002, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.2857636916026747, -0.90000000000000002, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.5264263913252365, -0.90000000000000002, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.50000000000000000.
-template <typename Tp>
-void test006()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data006)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data006[i].k), Tp(data006[i].nu),
-                   Tp(data006[i].phi));
-      const Tp f0 = data006[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.59999999999999998.
-testcase_ellint_3<double> data007[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17420100334657815, -0.90000000000000002, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34671975876122157, -0.90000000000000002, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.51724631570707968, -0.90000000000000002, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.68760879113743056, -0.90000000000000002, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.86192157779698364, -0.90000000000000002, 0.59999999999999998,
-          0.87266462599716477 },
-  { 1.0464279696166354, -0.90000000000000002, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.2488156247094004, -0.90000000000000002, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.4750988777188474, -0.90000000000000002, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.59999999999999998.
-template <typename Tp>
-void test007()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data007)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data007[i].k), Tp(data007[i].nu),
-                   Tp(data007[i].phi));
-      const Tp f0 = data007[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.69999999999999996.
-testcase_ellint_3<double> data008[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17402765093102210, -0.90000000000000002, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34541608382635131, -0.90000000000000002, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.51322715827061705, -0.90000000000000002, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.67903717872440306, -0.90000000000000002, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.84690113601682671, -0.90000000000000002, 0.69999999999999996,
-          0.87266462599716477 },
-  { 1.0229914311548418, -0.90000000000000002, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.2148329639709381, -0.90000000000000002, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.4283586501307806, -0.90000000000000002, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.6600480747670938, -0.90000000000000002, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.69999999999999996.
-template <typename Tp>
-void test008()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data008)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data008[i].k), Tp(data008[i].nu),
-                   Tp(data008[i].phi));
-      const Tp f0 = data008[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.8944086593755267e-16
+// mean(f - f_Boost): 6.9388939039072284e-17
+// variance(f - f_Boost): 1.7333369499485123e-32
+// stddev(f - f_Boost): 1.3165625507162629e-16
+const testcase_ellint_3<double>
+data006[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17614967734498183, -0.90000000000000002, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.36231594750319435, -0.90000000000000002, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.57016256984349567, -0.90000000000000002, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.81494025918293422, -0.90000000000000002, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.1178482279283477, -0.90000000000000002, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.5081455873012106, -0.90000000000000002, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 2.0213599730863998, -0.90000000000000002, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.6822467012926827, -0.90000000000000002, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 3.4591069002104677, -0.90000000000000002, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler006 = 2.5000000000000020e-13;
+
+// Test data for k=-0.90000000000000002, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.0602096790645418e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
+const testcase_ellint_3<double>
+data007[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17633073723493825, -0.90000000000000002, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36386108723492810, -0.90000000000000002, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.57597424744716241, -0.90000000000000002, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.83098051948501150, -0.90000000000000002, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.1558706545698916, -0.90000000000000002, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.5905576379415669, -0.90000000000000002, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 2.1875186010215080, -0.90000000000000002, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.9885767771316849, -0.90000000000000002, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.9549939883570224, -0.90000000000000002, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler007 = 2.5000000000000020e-13;
+
+// Test data for k=-0.90000000000000002, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1938610791060186e-16
+// mean(f - f_Boost): 3.0253577421035517e-16
+// variance(f - f_Boost): 4.2342877557562532e-32
+// stddev(f - f_Boost): 2.0577385051935665e-16
+const testcase_ellint_3<double>
+data008[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17651246700160939, -0.90000000000000002, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36542993547358982, -0.90000000000000002, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.58199897877674867, -0.90000000000000002, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.84815633587352857, -0.90000000000000002, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1985495623872375, -0.90000000000000002, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.6892158134027688, -0.90000000000000002, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.4029722191094236, -0.90000000000000002, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 3.4201084941340052, -0.90000000000000002, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 4.6985482312992435, -0.90000000000000002, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler008 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.80000000000000004.
-testcase_ellint_3<double> data009[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17385491439925149, -0.90000000000000002, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34412950523113928, -0.90000000000000002, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50931321668729612, -0.90000000000000002, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.67081081392296349, -0.90000000000000002, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.83268846097293259, -0.90000000000000002, 0.80000000000000004,
-          0.87266462599716477 },
-  { 1.0010985015814027, -0.90000000000000002, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.1834394045489678, -0.90000000000000002, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.3855695891683188, -0.90000000000000002, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.6044591960982204, -0.90000000000000002, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.80000000000000004.
-template <typename Tp>
-void test009()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data009)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data009[i].k), Tp(data009[i].nu),
-                   Tp(data009[i].phi));
-      const Tp f0 = data009[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.5091520146032660e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 9.8950000698295322e-33
+// stddev(f - f_Boost): 9.9473614943006532e-17
+const testcase_ellint_3<double>
+data009[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17669487107954862, -0.90000000000000002, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36702314729628421, -0.90000000000000002, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.58825099711365492, -0.90000000000000002, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.86661711422209031, -0.90000000000000002, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.2469779109884802, -0.90000000000000002, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.8105469760531578, -0.90000000000000002, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.6989505165893752, -0.90000000000000002, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 4.0935213267757424, -0.90000000000000002, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 5.9820740813645710, -0.90000000000000002, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler009 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.90000000000000002.
-testcase_ellint_3<double> data010[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17368278986240138, -0.90000000000000002, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34285962963961397, -0.90000000000000002, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.50549974644993323, -0.90000000000000002, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.66290623857720898, -0.90000000000000002, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.81921183128847164, -0.90000000000000002, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.98058481956066390, -0.90000000000000002, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.1543223520473567, -0.90000000000000002, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.3462119782292938, -0.90000000000000002, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.90000000000000002, nu=0.90000000000000002.
-template <typename Tp>
-void test010()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data010)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data010[i].k), Tp(data010[i].nu),
-                   Tp(data010[i].phi));
-      const Tp f0 = data010[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.2628580104449673e-16
+// mean(f - f_Boost): 8.5764728652293339e-16
+// variance(f - f_Boost): 8.9671393318321280e-31
+// stddev(f - f_Boost): 9.4694980499666013e-16
+const testcase_ellint_3<double>
+data010[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17687795394604169, -0.90000000000000002, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36864140434751286, -0.90000000000000002, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.59474595366817051, -0.90000000000000002, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.88654237226056665, -0.90000000000000002, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.3026595810616726, -0.90000000000000002, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.9653635459278078, -0.90000000000000002, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 3.1451407527189463, -0.90000000000000002, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 5.3745230680316114, -0.90000000000000002, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 8.9942562031858682, -0.90000000000000002, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler010 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.0000000000000000.
-testcase_ellint_3<double> data011[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17510154241338902, -0.80000000000000004, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35365068839779390, -0.80000000000000004, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53926804409084561, -0.80000000000000004, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.73587926028070383, -0.80000000000000004, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.94770942970071170, -0.80000000000000004, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1789022995388239, -0.80000000000000004, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.4323027881876009, -0.80000000000000004, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.7069629739121674, -0.80000000000000004, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.0000000000000000.
-template <typename Tp>
-void test011()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data011)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data011[i].k), Tp(data011[i].nu),
-                   Tp(data011[i].phi));
-      const Tp f0 = data011[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.5543122344752192e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7898565163847540e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.1368406725192426e-31
+// stddev(f - f_Boost): 4.6225974002926564e-16
+const testcase_ellint_3<double>
+data011[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17510154241338899, -0.80000000000000004, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35365068839779396, -0.80000000000000004, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53926804409084550, -0.80000000000000004, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.73587926028070372, -0.80000000000000004, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.94770942970071170, -0.80000000000000004, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1789022995388236, -0.80000000000000004, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.4323027881876012, -0.80000000000000004, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.7069629739121677, -0.80000000000000004, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.9953027776647294, -0.80000000000000004, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler011 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.10000000000000001.
-testcase_ellint_3<double> data012[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17492468824017166, -0.80000000000000004, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35224443521476911, -0.80000000000000004, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53456851853226961, -0.80000000000000004, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.72488875602364944, -0.80000000000000004, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.92661354274638952, -0.80000000000000004, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1432651144499077, -0.80000000000000004, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.3774479927211429, -0.80000000000000004, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.6287092337196041, -0.80000000000000004, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.10000000000000001.
-template <typename Tp>
-void test012()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data012)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data012[i].k), Tp(data012[i].nu),
-                   Tp(data012[i].phi));
-      const Tp f0 = data012[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3898786942190374e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.9190059990693968e-31
+// stddev(f - f_Boost): 5.4027826155319237e-16
+const testcase_ellint_3<double>
+data012[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17527903952342144, -0.80000000000000004, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35507705313548549, -0.80000000000000004, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54411455987643553, -0.80000000000000004, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.74745625666804383, -0.80000000000000004, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.97046953684238557, -0.80000000000000004, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.2183080025184605, -0.80000000000000004, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.4943711151994405, -0.80000000000000004, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.7972401309544201, -0.80000000000000004, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 2.1172616484005085, -0.80000000000000004, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler012 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.20000000000000001.
-testcase_ellint_3<double> data013[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17474847286224943, -0.80000000000000004, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.35085779529084682, -0.80000000000000004, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.53000829263059157, -0.80000000000000004, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.71443466027453406, -0.80000000000000004, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.90698196872715420, -0.80000000000000004, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.1108198200558581, -0.80000000000000004, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.3284988909963957, -0.80000000000000004, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.5600369318140328, -0.80000000000000004, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.20000000000000001.
-template <typename Tp>
-void test013()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data013)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data013[i].k), Tp(data013[i].nu),
-                   Tp(data013[i].phi));
-      const Tp f0 = data013[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.29999999999999999.
-testcase_ellint_3<double> data014[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17457289217669891, -0.80000000000000004, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34949028801501258, -0.80000000000000004, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52558024362769318, -0.80000000000000004, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.70447281740094914, -0.80000000000000004, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.88864745641528986, -0.80000000000000004, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0811075819341465, -0.80000000000000004, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.2844589654082377, -0.80000000000000004, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.4991461361277849, -0.80000000000000004, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.29999999999999999.
-template <typename Tp>
-void test014()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data014)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data014[i].k), Tp(data014[i].nu),
-                   Tp(data014[i].phi));
-      const Tp f0 = data014[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.8513740186068518e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 2.7528339102381189e-31
+// stddev(f - f_Boost): 5.2467455724840699e-16
+const testcase_ellint_3<double>
+data013[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17545718375086419, -0.80000000000000004, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35652404627248163, -0.80000000000000004, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54911638512920913, -0.80000000000000004, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.75967684282131176, -0.80000000000000004, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.99513526893543769, -0.80000000000000004, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.2622192109995993, -0.80000000000000004, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.5654106676347741, -0.80000000000000004, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.9029531718534984, -0.80000000000000004, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.2624789434186798, -0.80000000000000004, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler013 = 2.5000000000000020e-13;
+
+// Test data for k=-0.80000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.2825261583337354e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 2.8249350208968825e-31
+// stddev(f - f_Boost): 5.3150117788175054e-16
+const testcase_ellint_3<double>
+data014[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17563597931587369, -0.80000000000000004, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35799220412005128, -0.80000000000000004, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55428253691111318, -0.80000000000000004, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.77260647376977365, -0.80000000000000004, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 1.0220015271210958, -0.80000000000000004, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.3115965312302671, -0.80000000000000004, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.6478518468813512, -0.80000000000000004, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 2.0290458414203481, -0.80000000000000004, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.4392042002725693, -0.80000000000000004, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler014 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.40000000000000002.
-testcase_ellint_3<double> data015[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17439794211872178, -0.80000000000000004, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34814144964568972, -0.80000000000000004, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.52127776285273075, -0.80000000000000004, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.69496411438966599, -0.80000000000000004, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.87146878427509589, -0.80000000000000004, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0537579024937762, -0.80000000000000004, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.2445534387922637, -0.80000000000000004, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.4446769766361993, -0.80000000000000004, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.40000000000000002.
-template <typename Tp>
-void test015()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data015)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data015[i].k), Tp(data015[i].nu),
-                   Tp(data015[i].phi));
-      const Tp f0 = data015[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3462748389836647e-16
+// mean(f - f_Boost): 3.3861802251067273e-16
+// variance(f - f_Boost): 4.3719465706454422e-31
+// stddev(f - f_Boost): 6.6120696991527871e-16
+const testcase_ellint_3<double>
+data015[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17581543047866136, -0.80000000000000004, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35948208343061633, -0.80000000000000004, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55962280893702021, -0.80000000000000004, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.78632063889234116, -0.80000000000000004, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0514333069550323, -0.80000000000000004, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.3677213138838757, -0.80000000000000004, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.7451736773665165, -0.80000000000000004, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.1830100424586831, -0.80000000000000004, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.6604037035529724, -0.80000000000000004, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler015 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.50000000000000000.
-testcase_ellint_3<double> data016[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17422361866118047, -0.80000000000000004, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34681083254170475, -0.80000000000000004, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51709470815494440, -0.80000000000000004, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.68587375344080259, -0.80000000000000004, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.85532571852810624, -0.80000000000000004, 0.50000000000000000,
-          0.87266462599716477 },
-  { 1.0284677391874906, -0.80000000000000004, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.2081693942686225, -0.80000000000000004, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.3955803006426311, -0.80000000000000004, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.50000000000000000.
-template <typename Tp>
-void test016()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data016)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data016[i].k), Tp(data016[i].nu),
-                   Tp(data016[i].phi));
-      const Tp f0 = data016[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.59999999999999998.
-testcase_ellint_3<double> data017[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17404991781414092, -0.80000000000000004, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34549800443625167, -0.80000000000000004, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.51302536167001556, -0.80000000000000004, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.67717065003912258, -0.80000000000000004, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.84011512421134416, -0.80000000000000004, 0.59999999999999998,
-          0.87266462599716477 },
-  { 1.0049863847088742, -0.80000000000000004, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.1748145941898918, -0.80000000000000004, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.3510319699755071, -0.80000000000000004, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.59999999999999998.
-template <typename Tp>
-void test017()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data017)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data017[i].k), Tp(data017[i].nu),
-                   Tp(data017[i].phi));
-      const Tp f0 = data017[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.69999999999999996.
-testcase_ellint_3<double> data018[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17387683562442202, -0.80000000000000004, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34420254775101611, -0.80000000000000004, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50906439222143685, -0.80000000000000004, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.66882693152688433, -0.80000000000000004, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.82574792844091316, -0.80000000000000004, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.98310431309490953, -0.80000000000000004, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.1440884535113258, -0.80000000000000004, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.3103743938952537, -0.80000000000000004, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.69999999999999996.
-template <typename Tp>
-void test018()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data018)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data018[i].k), Tp(data018[i].nu),
-                   Tp(data018[i].phi));
-      const Tp f0 = data018[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0388243828581744e-16
+// mean(f - f_Boost): 3.8580250105724191e-16
+// variance(f - f_Boost): 6.4106456575047741e-31
+// stddev(f - f_Boost): 8.0066507713929764e-16
+const testcase_ellint_3<double>
+data016[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17599554153999472, -0.80000000000000004, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.36099426243351540, -0.80000000000000004, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.56514786174780673, -0.80000000000000004, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.80090697622371010, -0.80000000000000004, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0838891627679339, -0.80000000000000004, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.4323506654466280, -0.80000000000000004, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.8625761085390575, -0.80000000000000004, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.3768757305654766, -0.80000000000000004, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.9478781158239746, -0.80000000000000004, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler016 = 2.5000000000000020e-13;
+
+// Test data for k=-0.80000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0631099169042069e-15
+// mean(f - f_Boost): 4.8294701571194306e-16
+// variance(f - f_Boost): 1.1633910328160319e-30
+// stddev(f - f_Boost): 1.0786060600682865e-15
+const testcase_ellint_3<double>
+data017[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17617631684170665, -0.80000000000000004, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36252934193666231, -0.80000000000000004, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.57086932622945163, -0.80000000000000004, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.81646796740150973, -0.80000000000000004, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.1199552158519064, -0.80000000000000004, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.5079766673336394, -0.80000000000000004, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 2.0082747447038165, -0.80000000000000004, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.6315146066775523, -0.80000000000000004, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.3418121892288051, -0.80000000000000004, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler017 = 2.5000000000000020e-13;
+
+// Test data for k=-0.80000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.6544679145741375e-16
+// mean(f - f_Boost): 3.2751579226442120e-16
+// variance(f - f_Boost): 4.4236851331020672e-31
+// stddev(f - f_Boost): 6.6510789599147505e-16
+const testcase_ellint_3<double>
+data018[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17635776076721221, -0.80000000000000004, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36408794649916976, -0.80000000000000004, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.57679992290624138, -0.80000000000000004, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.83312441418142813, -0.80000000000000004, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1603958891464856, -0.80000000000000004, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.5982855143796213, -0.80000000000000004, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.1962484408371821, -0.80000000000000004, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.9873281786111869, -0.80000000000000004, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.9268876980046397, -0.80000000000000004, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler018 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.80000000000000004.
-testcase_ellint_3<double> data019[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17370436817515206, -0.80000000000000004, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34292405894783395, -0.80000000000000004, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50520682176250087, -0.80000000000000004, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.66081751679736189, -0.80000000000000004, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.81214672249355102, -0.80000000000000004, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.96264481387685574, -0.80000000000000004, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.1156611352656258, -0.80000000000000004, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.2730756225143889, -0.80000000000000004, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.4339837018309474, -0.80000000000000004, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.80000000000000004.
-template <typename Tp>
-void test019()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data019)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data019[i].k), Tp(data019[i].nu),
-                   Tp(data019[i].phi));
-      const Tp f0 = data019[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0176949165011079e-16
+// mean(f - f_Boost): 7.0499162063697436e-16
+// variance(f - f_Boost): 1.7230805408026989e-30
+// stddev(f - f_Boost): 1.3126616246400665e-15
+const testcase_ellint_3<double>
+data019[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17653987774203392, -0.80000000000000004, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36567072568046877, -0.80000000000000004, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.58295359996558616, -0.80000000000000004, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.85101998309176108, -0.80000000000000004, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.2062322059736537, -0.80000000000000004, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.7090321420917429, -0.80000000000000004, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.4529058049405066, -0.80000000000000004, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.5368893360106948, -0.80000000000000004, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.9246422058196062, -0.80000000000000004, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler019 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.90000000000000002.
-testcase_ellint_3<double> data020[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17353251158533153, -0.80000000000000004, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34166214791545768, -0.80000000000000004, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.50144799535130580, -0.80000000000000004, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.65311976193814447, -0.80000000000000004, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.79924384892320866, -0.80000000000000004, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.94345762353365625, -0.80000000000000004, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0892582069219159, -0.80000000000000004, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.2387000876610268, -0.80000000000000004, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.80000000000000004, nu=0.90000000000000002.
-template <typename Tp>
-void test020()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data020)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data020[i].k), Tp(data020[i].nu),
-                   Tp(data020[i].phi));
-      const Tp f0 = data020[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7782721357365268e-16
+// mean(f - f_Boost): 8.9928064994637676e-16
+// variance(f - f_Boost): 1.5485199571025344e-30
+// stddev(f - f_Boost): 1.2443954183066307e-15
+const testcase_ellint_3<double>
+data020[10] =
+{
+  { 0.0000000000000000, -0.80000000000000004, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17672267223433513, -0.80000000000000004, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36727835537196063, -0.80000000000000004, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58934569363716649, -0.80000000000000004, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.87032723471138851, -0.80000000000000004, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.2588676111323349, -0.80000000000000004, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.8498731900660019, -0.80000000000000004, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.8368381299300420, -0.80000000000000004, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 4.5674844191654058, -0.80000000000000004, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 7.2263259298637115, -0.80000000000000004, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler020 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.0000000000000000.
-testcase_ellint_3<double> data021[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17496737466916720, -0.69999999999999996, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35254687535677925, -0.69999999999999996, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53536740275997130, -0.69999999999999996, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.72603797651684465, -0.69999999999999996, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.92698296348313458, -0.69999999999999996, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1400447527693316, -0.69999999999999996, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.3657668117194071, -0.69999999999999996, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.6024686895959159, -0.69999999999999996, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.0000000000000000.
-template <typename Tp>
-void test021()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data021)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data021[i].k), Tp(data021[i].nu),
-                   Tp(data021[i].phi));
-      const Tp f0 = data021[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.5425633303580569e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 7.4564398834547797e-34
+// stddev(f - f_Boost): 2.7306482533374340e-17
+const testcase_ellint_3<double>
+data021[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17496737466916723, -0.69999999999999996, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35254687535677931, -0.69999999999999996, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53536740275997130, -0.69999999999999996, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.72603797651684454, -0.69999999999999996, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.92698296348313447, -0.69999999999999996, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1400447527693316, -0.69999999999999996, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.3657668117194071, -0.69999999999999996, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.6024686895959162, -0.69999999999999996, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.8456939983747234, -0.69999999999999996, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler021 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.10000000000000001.
-testcase_ellint_3<double> data022[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17479076384884681, -0.69999999999999996, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35114844900396364, -0.69999999999999996, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53072776947527012, -0.69999999999999996, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.71530198262386246, -0.69999999999999996, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.90666760677828306, -0.69999999999999996, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1063366517438080, -0.69999999999999996, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.3149477243092147, -0.69999999999999996, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.5314886725038925, -0.69999999999999996, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.10000000000000001.
-template <typename Tp>
-void test022()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data022)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data022[i].k), Tp(data022[i].nu),
-                   Tp(data022[i].phi));
-      const Tp f0 = data022[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.2736371663370261e-16
+// mean(f - f_Boost): 8.8817841970012528e-17
+// variance(f - f_Boost): 9.7390235212470591e-34
+// stddev(f - f_Boost): 3.1207408609570677e-17
+const testcase_ellint_3<double>
+data022[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17514462737300920, -0.69999999999999996, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35396527997470451, -0.69999999999999996, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54015179589433981, -0.69999999999999996, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.73734430854477728, -0.69999999999999996, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.94888950796697047, -0.69999999999999996, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1772807959736322, -0.69999999999999996, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.4231796401075831, -0.69999999999999996, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.6841856799887469, -0.69999999999999996, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.9541347343119562, -0.69999999999999996, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler022 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.20000000000000001.
-testcase_ellint_3<double> data023[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17461479077791472, -0.69999999999999996, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34976950621407538, -0.69999999999999996, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52622533231350188, -0.69999999999999996, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.70508774017895226, -0.69999999999999996, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.88775302531730294, -0.69999999999999996, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0756195476149006, -0.69999999999999996, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.2695349716654372, -0.69999999999999996, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.4690814617070540, -0.69999999999999996, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.6721098780092147, -0.69999999999999996, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.20000000000000001.
-template <typename Tp>
-void test023()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data023)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data023[i].k), Tp(data023[i].nu),
-                   Tp(data023[i].phi));
-      const Tp f0 = data023[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.29999999999999999.
-testcase_ellint_3<double> data024[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17443945136076172, -0.69999999999999996, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34840956983535287, -0.69999999999999996, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52185308551329179, -0.69999999999999996, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.69535240431168266, -0.69999999999999996, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.87007983473964923, -0.69999999999999996, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0474657975577066, -0.69999999999999996, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.2286225419931889, -0.69999999999999996, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.4136490671013271, -0.69999999999999996, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.29999999999999999.
-template <typename Tp>
-void test024()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data024)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data024[i].k), Tp(data024[i].nu),
-                   Tp(data024[i].phi));
-      const Tp f0 = data024[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9907249355047774e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
+const testcase_ellint_3<double>
+data023[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17532252613350796, -0.69999999999999996, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35540417596807522, -0.69999999999999996, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54508913033361928, -0.69999999999999996, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.74927635777718415, -0.69999999999999996, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.97261706337936338, -0.69999999999999996, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.2187303976209327, -0.69999999999999996, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.4887796709222487, -0.69999999999999996, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.7796581281839212, -0.69999999999999996, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.0829290325820202, -0.69999999999999996, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler023 = 2.5000000000000020e-13;
+
+// Test data for k=-0.69999999999999996, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.6912897610535316e-16
+// mean(f - f_Boost): 1.6653345369377347e-17
+// variance(f - f_Boost): 2.6207864467918357e-32
+// stddev(f - f_Boost): 1.6188843216214787e-16
+const testcase_ellint_3<double>
+data024[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17550107516328570, -0.69999999999999996, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35686409576571959, -0.69999999999999996, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55018827316513352, -0.69999999999999996, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.76189759494390275, -0.69999999999999996, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.99844623430885615, -0.69999999999999996, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2652862989039833, -0.69999999999999996, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.5647666808691361, -0.69999999999999996, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.8932499694938163, -0.69999999999999996, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.2392290510988535, -0.69999999999999996, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler024 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.40000000000000002.
-testcase_ellint_3<double> data025[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17426474153983226, -0.69999999999999996, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34706817945773732, -0.69999999999999996, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51760452851738159, -0.69999999999999996, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.68605801534722766, -0.69999999999999996, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.85351339387296532, -0.69999999999999996, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0215297967969537, -0.69999999999999996, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1915051074460528, -0.69999999999999996, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.3639821911744707, -0.69999999999999996, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.40000000000000002.
-template <typename Tp>
-void test025()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data025)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data025[i].k), Tp(data025[i].nu),
-                   Tp(data025[i].phi));
-      const Tp f0 = data025[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.5578567644745380e-16
+// mean(f - f_Boost): 1.4710455076283324e-16
+// variance(f - f_Boost): 2.6715739327327140e-33
+// stddev(f - f_Boost): 5.1687270509601433e-17
+const testcase_ellint_3<double>
+data025[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17568027871494424, -0.69999999999999996, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35834559208180261, -0.69999999999999996, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55545885451190613, -0.69999999999999996, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.77528120402568101, -0.69999999999999996, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0267241287600319, -0.69999999999999996, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.3181380338980246, -0.69999999999999996, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.6542840785132085, -0.69999999999999996, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.0315595131131818, -0.69999999999999996, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.4342502915307875, -0.69999999999999996, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler025 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.50000000000000000.
-testcase_ellint_3<double> data026[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17409065729516093, -0.69999999999999996, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34574489064986091, -0.69999999999999996, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51347361925579793, -0.69999999999999996, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.67717079489579290, -0.69999999999999996, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.83793902055292280, -0.69999999999999996, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.99752863545289705, -0.69999999999999996, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.1576240080401499, -0.69999999999999996, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.3191464023923762, -0.69999999999999996, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.50000000000000000.
-template <typename Tp>
-void test026()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data026)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data026[i].k), Tp(data026[i].nu),
-                   Tp(data026[i].phi));
-      const Tp f0 = data026[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.59999999999999998.
-testcase_ellint_3<double> data027[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17391719464391611, -0.69999999999999996, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34443927423869031, -0.69999999999999996, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50945473266486074, -0.69999999999999996, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.66866056326513823, -0.69999999999999996, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.82325830002337352, -0.69999999999999996, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.97522808245669357, -0.69999999999999996, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.1265300613705282, -0.69999999999999996, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.2784066076152003, -0.69999999999999996, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.59999999999999998.
-template <typename Tp>
-void test027()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data027)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data027[i].k), Tp(data027[i].nu),
-                   Tp(data027[i].phi));
-      const Tp f0 = data027[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.69999999999999996.
-testcase_ellint_3<double> data028[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17374434963995028, -0.69999999999999996, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34315091562900674, -0.69999999999999996, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50554262375653358, -0.69999999999999996, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.66050025406305812, -0.69999999999999996, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.80938620118847404, -0.69999999999999996, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.95443223855852144, -0.69999999999999996, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0978573207128302, -0.69999999999999996, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.2411754575007123, -0.69999999999999996, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.69999999999999996.
-template <typename Tp>
-void test028()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data028)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data028[i].k), Tp(data028[i].nu),
-                   Tp(data028[i].phi));
-      const Tp f0 = data028[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.0416041815443256e-16
+// mean(f - f_Boost): 1.9151347174783951e-16
+// variance(f - f_Boost): 7.8758646268991113e-33
+// stddev(f - f_Boost): 8.8746068233466605e-17
+const testcase_ellint_3<double>
+data026[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17586014108156545, -0.69999999999999996, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35984923894341653, -0.69999999999999996, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.56091135606739995, -0.69999999999999996, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.78951212635197054, -0.69999999999999996, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0578865732938729, -0.69999999999999996, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3789149005151722, -0.69999999999999996, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.7620212286086225, -0.69999999999999996, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.2051554347435585, -0.69999999999999996, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.6868019968236991, -0.69999999999999996, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler026 = 2.5000000000000020e-13;
+
+// Test data for k=-0.69999999999999996, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.6515644573247170e-16
+// mean(f - f_Boost): 9.9920072216264091e-17
+// variance(f - f_Boost): 1.2325951644078310e-33
+// stddev(f - f_Boost): 3.5108334685767011e-17
+const testcase_ellint_3<double>
+data027[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17604066659721918, -0.69999999999999996, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36137563278353424, -0.69999999999999996, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.56655721272747606, -0.69999999999999996, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.80468966552978305, -0.69999999999999996, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0924902943683852, -0.69999999999999996, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.4499247992499797, -0.69999999999999996, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.8953714382113815, -0.69999999999999996, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.4323229949248670, -0.69999999999999996, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.0314573496746742, -0.69999999999999996, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler027 = 2.5000000000000020e-13;
+
+// Test data for k=-0.69999999999999996, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.8475278552871384e-16
+// mean(f - f_Boost): 9.9920072216264091e-17
+// variance(f - f_Boost): 1.2325951644078310e-33
+// stddev(f - f_Boost): 3.5108334685767011e-17
+const testcase_ellint_3<double>
+data028[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17622185963747933, -0.69999999999999996, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36292539360435261, -0.69999999999999996, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.57240892970150015, -0.69999999999999996, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.82093084713182629, -0.69999999999999996, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1312609022179871, -0.69999999999999996, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.5345768067715795, -0.69999999999999996, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.0668847445934420, -0.69999999999999996, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.7483444537551240, -0.69999999999999996, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.5408408771788560, -0.69999999999999996, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler028 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.80000000000000004.
-testcase_ellint_3<double> data029[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17357211837335737, -0.69999999999999996, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34187941416012108, -0.69999999999999996, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50173239465478270, -0.69999999999999996, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.65266550725988315, -0.69999999999999996, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.79624879865249298, -0.69999999999999996, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.93497577043296920, -0.69999999999999996, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0713041566930748, -0.69999999999999996, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.2069772023255652, -0.69999999999999996, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.3427110650397533, -0.69999999999999996, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.80000000000000004.
-template <typename Tp>
-void test029()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data029)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data029[i].k), Tp(data029[i].nu),
-                   Tp(data029[i].phi));
-      const Tp f0 = data029[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.8664526853112274e-16
+// mean(f - f_Boost): 1.6930901125533636e-16
+// variance(f - f_Boost): 3.5389557150937801e-33
+// stddev(f - f_Boost): 5.9489122661994095e-17
+const testcase_ellint_3<double>
+data029[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17640372461994805, -0.69999999999999996, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36449916621651091, -0.69999999999999996, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57848021800372573, -0.69999999999999996, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.83837480968392586, -0.69999999999999996, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1751669030061143, -0.69999999999999996, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.6381851899173601, -0.69999999999999996, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.3002065924302197, -0.69999999999999996, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.2337600665337862, -0.69999999999999996, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.4042405729076961, -0.69999999999999996, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler029 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.90000000000000002.
-testcase_ellint_3<double> data030[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17340049697003634, -0.69999999999999996, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34062438249741556, -0.69999999999999996, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49801946510076878, -0.69999999999999996, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.64513432604750487, -0.69999999999999996, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.78378145487573758, -0.69999999999999996, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.91671799500854634, -0.69999999999999996, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0466193579463123, -0.69999999999999996, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1754218079199146, -0.69999999999999996, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.3040500499695911, -0.69999999999999996, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.69999999999999996, nu=0.90000000000000002.
-template <typename Tp>
-void test030()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data030)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data030[i].k), Tp(data030[i].nu),
-                   Tp(data030[i].phi));
-      const Tp f0 = data030[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.5869439826269878e-16
+// mean(f - f_Boost): 6.7723604502134545e-16
+// variance(f - f_Boost): 4.8757508225668289e-31
+// stddev(f - f_Boost): 6.9826576763914390e-16
+const testcase_ellint_3<double>
+data030[10] =
+{
+  { 0.0000000000000000, -0.69999999999999996, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17658626600478800, -0.69999999999999996, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36609762156017206, -0.69999999999999996, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58478615187842409, -0.69999999999999996, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.85718862878291846, -0.69999999999999996, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.2255385617397643, -0.69999999999999996, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.7696521899992939, -0.69999999999999996, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.6476314987883502, -0.69999999999999996, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 4.1373434902898083, -0.69999999999999996, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 6.3796094177887746, -0.69999999999999996, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler030 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.0000000000000000.
-testcase_ellint_3<double> data031[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17485154362988362, -0.59999999999999998, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35160509865544326, -0.59999999999999998, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53210652578446160, -0.59999999999999998, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.71805304664485670, -0.59999999999999998, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.91082759030195970, -0.59999999999999998, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1112333229323361, -0.59999999999999998, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.3191461190365270, -0.59999999999999998, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.5332022105084773, -0.59999999999999998, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.0000000000000000.
-template <typename Tp>
-void test031()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data031)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data031[i].k), Tp(data031[i].nu),
-                   Tp(data031[i].phi));
-      const Tp f0 = data031[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.3664899092028927e-16
+// mean(f - f_Boost): 5.2735593669694933e-17
+// variance(f - f_Boost): 3.4333862218458872e-34
+// stddev(f - f_Boost): 1.8529398861932589e-17
+const testcase_ellint_3<double>
+data031[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17485154362988359, -0.59999999999999998, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35160509865544320, -0.59999999999999998, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53210652578446138, -0.59999999999999998, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.71805304664485659, -0.59999999999999998, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.91082759030195981, -0.59999999999999998, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1112333229323361, -0.59999999999999998, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.3191461190365270, -0.59999999999999998, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.5332022105084779, -0.59999999999999998, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.7507538029157523, -0.59999999999999998, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler031 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.10000000000000001.
-testcase_ellint_3<double> data032[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17467514275022014, -0.59999999999999998, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35021333086258255, -0.59999999999999998, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52751664092962713, -0.59999999999999998, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.70752126971957885, -0.59999999999999998, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.89111058756112871, -0.59999999999999998, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0789241202877768, -0.59999999999999998, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2710800210399946, -0.59999999999999998, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.4669060574440276, -0.59999999999999998, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.10000000000000001.
-template <typename Tp>
-void test032()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data032)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data032[i].k), Tp(data032[i].nu),
-                   Tp(data032[i].phi));
-      const Tp f0 = data032[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.2335247010355137e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 2.2835347143080263e-33
+// stddev(f - f_Boost): 4.7786344433405099e-17
+const testcase_ellint_3<double>
+data032[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17502858548476194, -0.59999999999999998, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35301673150537388, -0.59999999999999998, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53683932476326812, -0.59999999999999998, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.72914228589586771, -0.59999999999999998, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.93208036718354692, -0.59999999999999998, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1468984688863377, -0.59999999999999998, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3733904977062528, -0.59999999999999998, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.6094225663372157, -0.59999999999999998, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.8508766487100685, -0.59999999999999998, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler032 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.20000000000000001.
-testcase_ellint_3<double> data033[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17449937871800653, -0.59999999999999998, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34884093647346553, -0.59999999999999998, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52306221119844110, -0.59999999999999998, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.69749955678982223, -0.59999999999999998, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.87274610682416853, -0.59999999999999998, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0494620540750792, -0.59999999999999998, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.2280847305507339, -0.59999999999999998, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.4085436279696886, -0.59999999999999998, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.20000000000000001.
-template <typename Tp>
-void test033()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data033)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data033[i].k), Tp(data033[i].nu),
-                   Tp(data033[i].phi));
-      const Tp f0 = data033[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.29999999999999999.
-testcase_ellint_3<double> data034[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17432424744393935, -0.59999999999999998, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34748744127146447, -0.59999999999999998, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51873632743924847, -0.59999999999999998, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.68794610396313127, -0.59999999999999998, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.85558070175468726, -0.59999999999999998, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0224416343605653, -0.59999999999999998, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1893144457936788, -0.59999999999999998, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.3566435377982575, -0.59999999999999998, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.29999999999999999.
-template <typename Tp>
-void test034()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data034)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data034[i].k), Tp(data034[i].nu),
-                   Tp(data034[i].phi));
-      const Tp f0 = data034[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0940560416437693e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
+const testcase_ellint_3<double>
+data033[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17520627248155893, -0.59999999999999998, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35444873935437748, -0.59999999999999998, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54172310557682524, -0.59999999999999998, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.74084300280734672, -0.59999999999999998, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.95509001527006121, -0.59999999999999998, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1865688084431796, -0.59999999999999998, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.4352978868932598, -0.59999999999999998, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6983400371331816, -0.59999999999999998, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.9695980282802215, -0.59999999999999998, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler033 = 2.5000000000000020e-13;
+
+// Test data for k=-0.59999999999999998, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.9470074709717020e-16
+// mean(f - f_Boost): 7.4940054162198071e-17
+// variance(f - f_Boost): 1.6823592487044846e-32
+// stddev(f - f_Boost): 1.2970579203352812e-16
+const testcase_ellint_3<double>
+data034[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17538460882640122, -0.59999999999999998, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35590165133735557, -0.59999999999999998, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54676661152254535, -0.59999999999999998, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.75321709418305305, -0.59999999999999998, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.98012637808992920, -0.59999999999999998, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2310891277158875, -0.59999999999999998, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.5069157924585623, -0.59999999999999998, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.8039583598337940, -0.59999999999999998, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.1134154405060599, -0.59999999999999998, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler034 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.40000000000000002.
-testcase_ellint_3<double> data035[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17414974487670720, -0.59999999999999998, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34615238767335027, -0.59999999999999998, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51453257838108579, -0.59999999999999998, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.67882386787534410, -0.59999999999999998, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.83948470233173578, -0.59999999999999998, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.99753496200073977, -0.59999999999999998, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1541101404388487, -0.59999999999999998, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.3100911323398814, -0.59999999999999998, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.40000000000000002.
-template <typename Tp>
-void test035()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data035)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data035[i].k), Tp(data035[i].nu),
-                   Tp(data035[i].phi));
-      const Tp f0 = data035[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.7909659715991921e-16
+// mean(f - f_Boost): -2.7755575615628915e-18
+// variance(f - f_Boost): 2.4044165394594425e-32
+// stddev(f - f_Boost): 1.5506181152880429e-16
+const testcase_ellint_3<double>
+data035[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17556359876533037, -0.59999999999999998, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35737601674244679, -0.59999999999999998, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55197933771320218, -0.59999999999999998, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.76633591620002894, -0.59999999999999998, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0075231136019616, -0.59999999999999998, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2815842073813450, -0.59999999999999998, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5911666941449827, -0.59999999999999998, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.9323227566025762, -0.59999999999999998, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.2925036420985130, -0.59999999999999998, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler035 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.50000000000000000.
-testcase_ellint_3<double> data036[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17397586700252810, -0.59999999999999998, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34483533397138516, -0.59999999999999998, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51044500461706499, -0.59999999999999998, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.67009988034712675, -0.59999999999999998, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.82434762375735193, -0.59999999999999998, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.97447346702798998, -0.59999999999999998, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.1219494000522143, -0.59999999999999998, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2680242605954486, -0.59999999999999998, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.50000000000000000.
-template <typename Tp>
-void test036()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data036)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data036[i].k), Tp(data036[i].nu),
-                   Tp(data036[i].phi));
-      const Tp f0 = data036[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.59999999999999998.
-testcase_ellint_3<double> data037[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17380260984469356, -0.59999999999999998, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34353585361777839, -0.59999999999999998, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50646805774321402, -0.59999999999999998, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.66174468108625517, -0.59999999999999998, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.81007462280278408, -0.59999999999999998, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.95303466945718729, -0.59999999999999998, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0924118588677503, -0.59999999999999998, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.2297640574847937, -0.59999999999999998, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.59999999999999998.
-template <typename Tp>
-void test037()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data037)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data037[i].k), Tp(data037[i].nu),
-                   Tp(data037[i].phi));
-      const Tp f0 = data037[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.69999999999999996.
-testcase_ellint_3<double> data038[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17362996946312009, -0.59999999999999998, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34225353454870588, -0.59999999999999998, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50259656397799546, -0.59999999999999998, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.65373184496628944, -0.59999999999999998, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.79658372884056439, -0.59999999999999998, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.93303240100245421, -0.59999999999999998, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0651547944716557, -0.59999999999999998, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1947676204853441, -0.59999999999999998, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.3232737468822811, -0.59999999999999998, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.69999999999999996.
-template <typename Tp>
-void test038()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data038)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data038[i].k), Tp(data038[i].nu),
-                   Tp(data038[i].phi));
-      const Tp f0 = data038[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6240126899196213e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.0357223256482469e-33
+// stddev(f - f_Boost): 3.2182640128619758e-17
+const testcase_ellint_3<double>
+data036[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17574324658480217, -0.59999999999999998, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35887240603169313, -0.59999999999999998, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55737161826345261, -0.59999999999999998, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.78028227313077458, -0.59999999999999998, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0376989776486290, -0.59999999999999998, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3395933991042925, -0.59999999999999998, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6924049626591782, -0.59999999999999998, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.0931011856518920, -0.59999999999999998, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.5239007084492706, -0.59999999999999998, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler036 = 2.5000000000000020e-13;
+
+// Test data for k=-0.59999999999999998, nu=0.60000000000000009.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.6651378277398083e-16
+// mean(f - f_Boost): 1.1934897514720432e-16
+// variance(f - f_Boost): 1.7585404776158019e-33
+// stddev(f - f_Boost): 4.1934955319110598e-17
+const testcase_ellint_3<double>
+data037[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17592355661219386, -0.59999999999999998, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36039141192661606, -0.59999999999999998, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.56295472636903854, -0.59999999999999998, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.79515295130165986, -0.59999999999999998, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0711886441942242, -0.59999999999999998, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.4072952835139891, -0.59999999999999998, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.8174863977376825, -0.59999999999999998, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.3029921578542232, -0.59999999999999998, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.8388723099514972, -0.59999999999999998, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler037 = 2.5000000000000020e-13;
+
+// Test data for k=-0.59999999999999998, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.2451074234797436e-16
+// mean(f - f_Boost): 5.2735593669694933e-17
+// variance(f - f_Boost): 3.4333862218458872e-34
+// stddev(f - f_Boost): 1.8529398861932589e-17
+const testcase_ellint_3<double>
+data038[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17610453321631936, -0.59999999999999998, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36193365056369764, -0.59999999999999998, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56874098962268527, -0.59999999999999998, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.81106198671477181, -0.59999999999999998, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1086886419010082, -0.59999999999999998, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4879048567239257, -0.59999999999999998, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.9780310073615923, -0.59999999999999998, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.5941545586772712, -0.59999999999999998, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.3029735898397155, -0.59999999999999998, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler038 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.80000000000000004.
-testcase_ellint_3<double> data039[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17345794195390687, -0.59999999999999998, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34098797854531027, -0.59999999999999998, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49882569168826230, -0.59999999999999998, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.64603758566475511, -0.59999999999999998, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.78380365594769730, -0.59999999999999998, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.91430946255611190, -0.59999999999999998, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0398955217270607, -0.59999999999999998, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1625948314277676, -0.59999999999999998, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.80000000000000004.
-template <typename Tp>
-void test039()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data039)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data039[i].k), Tp(data039[i].nu),
-                   Tp(data039[i].phi));
-      const Tp f0 = data039[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.3826960061025914e-16
+// mean(f - f_Boost): 2.7478019859472625e-16
+// variance(f - f_Boost): 4.6451528105588637e-32
+// stddev(f - f_Boost): 2.1552616570984749e-16
+const testcase_ellint_3<double>
+data039[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17628618080795252, -0.59999999999999998, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36349976272521012, -0.59999999999999998, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57474392342151914, -0.59999999999999998, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.82814493499158159, -0.59999999999999998, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1511281795998280, -0.59999999999999998, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5864286332503075, -0.59999999999999998, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.1958944866494527, -0.59999999999999998, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.0398358172574604, -0.59999999999999998, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.0867036409261832, -0.59999999999999998, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler039 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.90000000000000002.
-testcase_ellint_3<double> data040[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17328652344890033, -0.59999999999999998, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33973880062929018, -0.59999999999999998, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49515092233122765, -0.59999999999999998, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.63864042139737043, -0.59999999999999998, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.77167205646538850, -0.59999999999999998, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.89673202848034383, -0.59999999999999998, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0163984492661304, -0.59999999999999998, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1328845785162431, -0.59999999999999998, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.59999999999999998, nu=0.90000000000000002.
-template <typename Tp>
-void test040()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data040)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data040[i].k), Tp(data040[i].nu),
-                   Tp(data040[i].phi));
-      const Tp f0 = data040[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.7440178400898422e-16
+// mean(f - f_Boost): 5.0792703376600914e-16
+// variance(f - f_Boost): 1.9863137923719990e-31
+// stddev(f - f_Boost): 4.4568080420543122e-16
+const testcase_ellint_3<double>
+data040[10] =
+{
+  { 0.0000000000000000, -0.59999999999999998, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17646850384035848, -0.59999999999999998, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36509041515134105, -0.59999999999999998, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58097838596260631, -0.59999999999999998, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.84656453396163722, -0.59999999999999998, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1997828426963724, -0.59999999999999998, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.7112436789225605, -0.59999999999999998, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.5193168553672312, -0.59999999999999998, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.8656670488606686, -0.59999999999999998, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.8709993116265595, -0.59999999999999998, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler040 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.0000000000000000.
-testcase_ellint_3<double> data041[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17475385514035785, -0.50000000000000000, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35081868470101585, -0.50000000000000000, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52942862705190585, -0.50000000000000000, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.71164727562630326, -0.50000000000000000, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.89824523594227768, -0.50000000000000000, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0895506700518851, -0.50000000000000000, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2853005857432933, -0.50000000000000000, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4845545520549484, -0.50000000000000000, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.0000000000000000.
-template <typename Tp>
-void test041()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data041)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data041[i].k), Tp(data041[i].nu),
-                   Tp(data041[i].phi));
-      const Tp f0 = data041[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.4551389361831220e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.5893058141206173e-32
+// stddev(f - f_Boost): 1.6091320064309879e-16
+const testcase_ellint_3<double>
+data041[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17475385514035785, -0.50000000000000000, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35081868470101579, -0.50000000000000000, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52942862705190574, -0.50000000000000000, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.71164727562630326, -0.50000000000000000, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.89824523594227768, -0.50000000000000000, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0895506700518853, -0.50000000000000000, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2853005857432933, -0.50000000000000000, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4845545520549488, -0.50000000000000000, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6857503548125961, -0.50000000000000000, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler041 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.10000000000000001.
-testcase_ellint_3<double> data042[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17457763120814676, -0.50000000000000000, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34943246340849154, -0.50000000000000000, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52487937869610801, -0.50000000000000000, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.70127785096388395, -0.50000000000000000, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.87898815988624479, -0.50000000000000000, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0582764576094172, -0.50000000000000000, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2391936844060207, -0.50000000000000000, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.4214793542995841, -0.50000000000000000, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.10000000000000001.
-template <typename Tp>
-void test042()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data042)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data042[i].k), Tp(data042[i].nu),
-                   Tp(data042[i].phi));
-      const Tp f0 = data042[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7416868347177582e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
+const testcase_ellint_3<double>
+data042[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17493071928248824, -0.50000000000000000, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35222467688034798, -0.50000000000000000, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53411928652008112, -0.50000000000000000, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.72256398117177589, -0.50000000000000000, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.91899583232771009, -0.50000000000000000, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1240549163055360, -0.50000000000000000, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3372938086286021, -0.50000000000000000, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.5570024469132429, -0.50000000000000000, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.7803034946545480, -0.50000000000000000, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler042 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.20000000000000001.
-testcase_ellint_3<double> data043[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17440204336345433, -0.50000000000000000, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34806552388338824, -0.50000000000000000, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52046416757129821, -0.50000000000000000, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.69140924550993876, -0.50000000000000000, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.86104678636125520, -0.50000000000000000, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0297439459053981, -0.50000000000000000, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1979214112912036, -0.50000000000000000, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3659033858648930, -0.50000000000000000, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.20000000000000001.
-template <typename Tp>
-void test043()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data043)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data043[i].k), Tp(data043[i].nu),
-                   Tp(data043[i].phi));
-      const Tp f0 = data043[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.29999999999999999.
-testcase_ellint_3<double> data044[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17422708752228896, -0.50000000000000000, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34671739434855858, -0.50000000000000000, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51617616305641889, -0.50000000000000000, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.68200047612545178, -0.50000000000000000, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.84427217869498372, -0.50000000000000000, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0035637821389782, -0.50000000000000000, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1606800483933113, -0.50000000000000000, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.3164407134643459, -0.50000000000000000, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.29999999999999999.
-template <typename Tp>
-void test044()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data044)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data044[i].k), Tp(data044[i].nu),
-                   Tp(data044[i].phi));
-      const Tp f0 = data044[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1198767993730867e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 5.0311947683004831e-32
+// stddev(f - f_Boost): 2.2430324938128922e-16
+const testcase_ellint_3<double>
+data043[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17510822779582402, -0.50000000000000000, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35365094725531487, -0.50000000000000000, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53895933237328697, -0.50000000000000000, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.73408090840070794, -0.50000000000000000, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.94145442818535396, -0.50000000000000000, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1624120186296487, -0.50000000000000000, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3965823372867114, -0.50000000000000000, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6414308440430099, -0.50000000000000000, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8922947612264018, -0.50000000000000000, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler043 = 2.5000000000000020e-13;
+
+// Test data for k=-0.50000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3800262770228813e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 8.5027191584278157e-32
+// stddev(f - f_Boost): 2.9159422419567599e-16
+const testcase_ellint_3<double>
+data044[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17528638488102041, -0.50000000000000000, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35509802222332720, -0.50000000000000000, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54395740731866193, -0.50000000000000000, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.74625871438752667, -0.50000000000000000, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.96588271186092023, -0.50000000000000000, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2054319584357329, -0.50000000000000000, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4651077994832871, -0.50000000000000000, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.7416018368052644, -0.50000000000000000, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.0277924458111314, -0.50000000000000000, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler044 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.40000000000000002.
-testcase_ellint_3<double> data045[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17405275963859917, -0.50000000000000000, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34538761957029329, -0.50000000000000000, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51200902646603919, -0.50000000000000000, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.67301522212868792, -0.50000000000000000, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.82853844466313320, -0.50000000000000000, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.97942097862681488, -0.50000000000000000, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1268429801220616, -0.50000000000000000, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2720406704533922, -0.50000000000000000, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.40000000000000002.
-template <typename Tp>
-void test045()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data045)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data045[i].k), Tp(data045[i].nu),
-                   Tp(data045[i].phi));
-      const Tp f0 = data045[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.0439932918341581e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 9.0809736800018602e-32
+// stddev(f - f_Boost): 3.0134653938616686e-16
+const testcase_ellint_3<double>
+data045[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17546519477859268, -0.50000000000000000, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35656644822531680, -0.50000000000000000, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54912289677411319, -0.50000000000000000, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.75916731611690047, -0.50000000000000000, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.99260415631328214, -0.50000000000000000, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2541925856918670, -0.50000000000000000, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5456393705347609, -0.50000000000000000, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.8631904972952076, -0.50000000000000000, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.1962905366178065, -0.50000000000000000, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler045 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.50000000000000000.
-testcase_ellint_3<double> data046[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17387905570381157, -0.50000000000000000, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34407576010465207, -0.50000000000000000, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50795686560160835, -0.50000000000000000, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.66442115453330175, -0.50000000000000000, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.81373829119355345, -0.50000000000000000, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.95705743313235825, -0.50000000000000000, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0959131991362556, -0.50000000000000000, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2318900529754597, -0.50000000000000000, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.50000000000000000.
-template <typename Tp>
-void test046()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data046)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data046[i].k), Tp(data046[i].nu),
-                   Tp(data046[i].phi));
-      const Tp f0 = data046[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.59999999999999998.
-testcase_ellint_3<double> data047[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17370597174637581, -0.50000000000000000, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34278139158591414, -0.50000000000000000, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50401419439302719, -0.50000000000000000, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.65618938076167221, -0.50000000000000000, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.79977959248855424, -0.50000000000000000, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.93625925190753545, -0.50000000000000000, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0674905658379710, -0.50000000000000000, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1953481298023048, -0.50000000000000000, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.59999999999999998.
-template <typename Tp>
-void test047()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data047)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data047[i].k), Tp(data047[i].nu),
-                   Tp(data047[i].phi));
-      const Tp f0 = data047[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.69999999999999996.
-testcase_ellint_3<double> data048[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17353350383131641, -0.50000000000000000, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34150410405436771, -0.50000000000000000, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50017589696443487, -0.50000000000000000, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64829398188419962, -0.50000000000000000, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.78658270782402073, -0.50000000000000000, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.91684738336675053, -0.50000000000000000, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0412486789555937, -0.50000000000000000, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1619021847612001, -0.50000000000000000, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.69999999999999996.
-template <typename Tp>
-void test048()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data048)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data048[i].k), Tp(data048[i].nu),
-                   Tp(data048[i].phi));
-      const Tp f0 = data048[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6797816859260978e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
+const testcase_ellint_3<double>
+data046[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17564466176941509, -0.50000000000000000, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35805679276065394, -0.50000000000000000, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55446601496200032, -0.50000000000000000, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.77288783578259013, -0.50000000000000000, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0220246013918972, -0.50000000000000000, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3101681612463965, -0.50000000000000000, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6422994881851025, -0.50000000000000000, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.0152636030998816, -0.50000000000000000, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.4136715042011945, -0.50000000000000000, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler046 = 2.5000000000000020e-13;
+
+// Test data for k=-0.50000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9178421578645735e-16
+// mean(f - f_Boost): 1.3322676295501878e-16
+// variance(f - f_Boost): 1.7749370367472766e-31
+// stddev(f - f_Boost): 4.2130001622920411e-16
+const testcase_ellint_3<double>
+data047[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17582479017522740, -0.50000000000000000, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35956964546660036, -0.50000000000000000, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55999790372984193, -0.50000000000000000, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.78751507911209895, -0.50000000000000000, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0546620505035220, -0.50000000000000000, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3754438357425935, -0.50000000000000000, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.7615727400820127, -0.50000000000000000, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.2134638067565242, -0.50000000000000000, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.7090491861753558, -0.50000000000000000, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler047 = 2.5000000000000020e-13;
+
+// Test data for k=-0.50000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0745105182189226e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 1.9996383743576116e-32
+// stddev(f - f_Boost): 1.4140857026211713e-16
+const testcase_ellint_3<double>
+data048[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17600558435914915, -0.50000000000000000, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36110561926726259, -0.50000000000000000, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56573074641137111, -0.50000000000000000, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.80316073084237205, -0.50000000000000000, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0911910688131461, -0.50000000000000000, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4530946406380640, -0.50000000000000000, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.9144386536785372, -0.50000000000000000, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.4878788958234970, -0.50000000000000000, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.1433945297859225, -0.50000000000000000, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler048 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.80000000000000004.
-testcase_ellint_3<double> data049[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17336164805979126, -0.50000000000000000, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34024350132086773, -0.50000000000000000, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49643719555734084, -0.50000000000000000, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.64071162456976150, -0.50000000000000000, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.77407836177211908, -0.50000000000000000, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.89867058251905652, -0.50000000000000000, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0169181822134912, -0.50000000000000000, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1311363312779448, -0.50000000000000000, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.80000000000000004.
-template <typename Tp>
-void test049()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data049)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data049[i].k), Tp(data049[i].nu),
-                   Tp(data049[i].phi));
-      const Tp f0 = data049[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.4380477375534667e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
+const testcase_ellint_3<double>
+data049[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17618704872620228, -0.50000000000000000, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36266535159745827, -0.50000000000000000, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57167789954529158, -0.50000000000000000, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.81995752984315018, -0.50000000000000000, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1325112162158122, -0.50000000000000000, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5479055930718042, -0.50000000000000000, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.1215243941010486, -0.50000000000000000, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.9069405767650132, -0.50000000000000000, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.8750701888108066, -0.50000000000000000, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler049 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.90000000000000002.
-testcase_ellint_3<double> data050[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17319040056865681, -0.50000000000000000, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33899920036578557, -0.50000000000000000, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49279362182695186, -0.50000000000000000, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.63342123379746151, -0.50000000000000000, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.76220595179550321, -0.50000000000000000, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.88160004743532294, -0.50000000000000000, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.99427448642310134, -0.50000000000000000, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1027091512470093, -0.50000000000000000, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.50000000000000000, nu=0.90000000000000002.
-template <typename Tp>
-void test050()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data050)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data050[i].k), Tp(data050[i].nu),
-                   Tp(data050[i].phi));
-      const Tp f0 = data050[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.0000000000000000.
-testcase_ellint_3<double> data051[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17467414669441531, -0.40000000000000002, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35018222772483443, -0.40000000000000002, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52729015917508748, -0.40000000000000002, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70662374407341255, -0.40000000000000002, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.88859210497602170, -0.40000000000000002, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0733136290471379, -0.40000000000000002, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2605612170157061, -0.40000000000000002, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4497513956433437, -0.40000000000000002, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.0000000000000000.
-template <typename Tp>
-void test051()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data051)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data051[i].k), Tp(data051[i].nu),
-                   Tp(data051[i].phi));
-      const Tp f0 = data051[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.10000000000000001.
-testcase_ellint_3<double> data052[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17449806706684673, -0.40000000000000002, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34880048623856075, -0.40000000000000002, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52277322065757403, -0.40000000000000002, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69638072056918376, -0.40000000000000002, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.86968426619831540, -0.40000000000000002, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0428044206578095, -0.40000000000000002, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2158651158274378, -0.40000000000000002, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3889447129893322, -0.40000000000000002, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.10000000000000001.
-template <typename Tp>
-void test052()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data052)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data052[i].k), Tp(data052[i].nu),
-                   Tp(data052[i].phi));
-      const Tp f0 = data052[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.20000000000000001.
-testcase_ellint_3<double> data053[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17432262290723399, -0.40000000000000002, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34743795258968596, -0.40000000000000002, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51838919472805123, -0.40000000000000002, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68663134739057918, -0.40000000000000002, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.85206432981833979, -0.40000000000000002, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0149595349004430, -0.40000000000000002, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1758349405464676, -0.40000000000000002, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3353337673882635, -0.40000000000000002, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.20000000000000001.
-template <typename Tp>
-void test053()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data053)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data053[i].k), Tp(data053[i].nu),
-                   Tp(data053[i].phi));
-      const Tp f0 = data053[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.29999999999999999.
-testcase_ellint_3<double> data054[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17414781013591543, -0.40000000000000002, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34609415696777285, -0.40000000000000002, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51413131295862546, -0.40000000000000002, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67733527622935630, -0.40000000000000002, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.83558675182733266, -0.40000000000000002, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.98940140808865906, -0.40000000000000002, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1396968797728058, -0.40000000000000002, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2875920037865087, -0.40000000000000002, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.29999999999999999.
-template <typename Tp>
-void test054()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data054)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data054[i].k), Tp(data054[i].nu),
-                   Tp(data054[i].phi));
-      const Tp f0 = data054[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.40000000000000002.
-testcase_ellint_3<double> data055[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17397362471112710, -0.40000000000000002, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34476864603333196, -0.40000000000000002, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50999329415379357, -0.40000000000000002, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66845674551396017, -0.40000000000000002, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.82012848346231748, -0.40000000000000002, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.96582449258349057, -0.40000000000000002, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1068473749476286, -0.40000000000000002, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2447132729159986, -0.40000000000000002, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.40000000000000002.
-template <typename Tp>
-void test055()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data055)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data055[i].k), Tp(data055[i].nu),
-                   Tp(data055[i].phi));
-      const Tp f0 = data055[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.50000000000000000.
-testcase_ellint_3<double> data056[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17380006262854139, -0.40000000000000002, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34346098216756610, -0.40000000000000002, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50596929935059420, -0.40000000000000002, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65996392089131262, -0.40000000000000002, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.80558463511364786, -0.40000000000000002, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.94397834522857704, -0.40000000000000002, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0768075114108115, -0.40000000000000002, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2059184624251329, -0.40000000000000002, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.50000000000000000.
-template <typename Tp>
-void test056()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data056)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data056[i].k), Tp(data056[i].nu),
-                   Tp(data056[i].phi));
-      const Tp f0 = data056[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.59999999999999998.
-testcase_ellint_3<double> data057[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17362711992081248, -0.40000000000000002, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34217074276403953, -0.40000000000000002, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50205389185761617, -0.40000000000000002, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.65182834920372745, -0.40000000000000002, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.79186512820565136, -0.40000000000000002, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.92365535916287134, -0.40000000000000002, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0491915663957907, -0.40000000000000002, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1705934291745104, -0.40000000000000002, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.59999999999999998.
-template <typename Tp>
-void test057()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data057)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data057[i].k), Tp(data057[i].nu),
-                   Tp(data057[i].phi));
-      const Tp f0 = data057[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.69999999999999996.
-testcase_ellint_3<double> data058[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17345479265712871, -0.40000000000000002, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34089751955950354, -0.40000000000000002, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49824200167361343, -0.40000000000000002, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64402450341199413, -0.40000000000000002, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.77889207804122873, -0.40000000000000002, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.90468169720957992, -0.40000000000000002, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0236847823692916, -0.40000000000000002, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1382465247425164, -0.40000000000000002, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.69999999999999996.
-template <typename Tp>
-void test058()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data058)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data058[i].k), Tp(data058[i].nu),
-                   Tp(data058[i].phi));
-      const Tp f0 = data058[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.80000000000000004.
-testcase_ellint_3<double> data059[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17328307694277156, -0.40000000000000002, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33964091800132007, -0.40000000000000002, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49452889372467451, -0.40000000000000002, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63652940095937327, -0.40000000000000002, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.76659772511159097, -0.40000000000000002, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.88691047977338111, -0.40000000000000002, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0000273200611638, -0.40000000000000002, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1084787902188007, -0.40000000000000002, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.80000000000000004.
-template <typename Tp>
-void test059()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data059)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data059[i].k), Tp(data059[i].nu),
-                   Tp(data059[i].phi));
-      const Tp f0 = data059[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.90000000000000002.
-testcase_ellint_3<double> data060[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17311196891868130, -0.40000000000000002, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33840055664911906, -0.40000000000000002, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49091013944075340, -0.40000000000000002, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62932228186809591, -0.40000000000000002, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.75492278323019801, -0.40000000000000002, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.87021659043854294, -0.40000000000000002, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.97800245228239246, -0.40000000000000002, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0809625773173694, -0.40000000000000002, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.40000000000000002, nu=0.90000000000000002.
-template <typename Tp>
-void test060()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data060)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data060[i].k), Tp(data060[i].nu),
-                   Tp(data060[i].phi));
-      const Tp f0 = data060[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.0000000000000000.
-testcase_ellint_3<double> data061[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17461228653000102, -0.30000000000000004, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34969146102798415, -0.30000000000000004, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52565822873726320, -0.30000000000000004, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70284226512408532, -0.30000000000000004, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.88144139195111182, -0.30000000000000004, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0614897067260523, -0.30000000000000004, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2428416824174218, -0.30000000000000004, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4251795877015925, -0.30000000000000004, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6080486199305126, -0.30000000000000004, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.0000000000000000.
-template <typename Tp>
-void test061()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data061)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data061[i].k), Tp(data061[i].nu),
-                   Tp(data061[i].phi));
-      const Tp f0 = data061[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.10000000000000001.
-testcase_ellint_3<double> data062[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17443631884814378, -0.30000000000000004, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34831316835124926, -0.30000000000000004, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52116586276523857, -0.30000000000000004, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69269385837910036, -0.30000000000000004, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.86279023163070856, -0.30000000000000004, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0315321461438265, -0.30000000000000004, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1991449111869024, -0.30000000000000004, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3659561780923211, -0.30000000000000004, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5323534693557526, -0.30000000000000004, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.10000000000000001.
-template <typename Tp>
-void test062()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data062)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data062[i].k), Tp(data062[i].nu),
-                   Tp(data062[i].phi));
-      const Tp f0 = data062[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.20000000000000001.
-testcase_ellint_3<double> data063[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17426098615372090, -0.30000000000000004, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34695402664689923, -0.30000000000000004, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51680555567038933, -0.30000000000000004, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68303375225260210, -0.30000000000000004, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.84540662891295026, -0.30000000000000004, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0041834051646927, -0.30000000000000004, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1599952702345711, -0.30000000000000004, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3137179520499163, -0.30000000000000004, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4663658145259875, -0.30000000000000004, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.20000000000000001.
-template <typename Tp>
-void test063()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data063)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data063[i].k), Tp(data063[i].nu),
-                   Tp(data063[i].phi));
-      const Tp f0 = data063[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.29999999999999999.
-testcase_ellint_3<double> data064[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17408628437042845, -0.30000000000000004, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34561356761638401, -0.30000000000000004, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51257058617875850, -0.30000000000000004, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67382207124602866, -0.30000000000000004, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82914751587825131, -0.30000000000000004, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.97907434814374950, -0.30000000000000004, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1246399297351584, -0.30000000000000004, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2671793970398146, -0.30000000000000004, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4081767433479089, -0.30000000000000004, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.29999999999999999.
-template <typename Tp>
-void test064()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data064)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data064[i].k), Tp(data064[i].nu),
-                   Tp(data064[i].phi));
-      const Tp f0 = data064[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.40000000000000002.
-testcase_ellint_3<double> data065[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17391220945982730, -0.30000000000000004, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34429133937639689, -0.30000000000000004, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50845471668581632, -0.30000000000000004, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66502347027873854, -0.30000000000000004, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.81389191978012254, -0.30000000000000004, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.95590618002140593, -0.30000000000000004, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0924915195213121, -0.30000000000000004, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2253651604038058, -0.30000000000000004, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3563643538969761, -0.30000000000000004, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.40000000000000002.
-template <typename Tp>
-void test065()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data065)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data065[i].k), Tp(data065[i].nu),
-                   Tp(data065[i].phi));
-      const Tp f0 = data065[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.50000000000000000.
-testcase_ellint_3<double> data066[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17373875742088235, -0.30000000000000004, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34298690571124157, -0.30000000000000004, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50445214859646936, -0.30000000000000004, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65660648352418516, -0.30000000000000004, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79953670639287289, -0.30000000000000004, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.93443393926588558, -0.30000000000000004, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0630838369016911, -0.30000000000000004, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1875197325653026, -0.30000000000000004, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3098448759814960, -0.30000000000000004, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.50000000000000000.
-template <typename Tp>
-void test066()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data066)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data066[i].k), Tp(data066[i].nu),
-                   Tp(data066[i].phi));
-      const Tp f0 = data066[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.59999999999999998.
-testcase_ellint_3<double> data067[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17356592428950826, -0.30000000000000004, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34169984536697379, -0.30000000000000004, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50055748266498457, -0.30000000000000004, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64854298527106768, -0.30000000000000004, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.78599329284207431, -0.30000000000000004, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.91445452089128221, -0.30000000000000004, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0360412952290587, -0.30000000000000004, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1530473919778639, -0.30000000000000004, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2677758800420666, -0.30000000000000004, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.59999999999999998.
-template <typename Tp>
-void test067()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data067)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data067[i].k), Tp(data067[i].nu),
-                   Tp(data067[i].phi));
-      const Tp f0 = data067[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.69999999999999996.
-testcase_ellint_3<double> data068[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17339370613812227, -0.30000000000000004, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34042975138455933, -0.30000000000000004, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49676568368075985, -0.30000000000000004, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64080774055753720, -0.30000000000000004, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.77318507779667278, -0.30000000000000004, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.89579782346548631, -0.30000000000000004, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0110573286052202, -0.30000000000000004, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1214710972949633, -0.30000000000000004, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2294913236274980, -0.30000000000000004, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.69999999999999996.
-template <typename Tp>
-void test068()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data068)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data068[i].k), Tp(data068[i].nu),
-                   Tp(data068[i].phi));
-      const Tp f0 = data068[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.80000000000000004.
-testcase_ellint_3<double> data069[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17322209907520361, -0.30000000000000004, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33917623046949996, -0.30000000000000004, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49307204894329176, -0.30000000000000004, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63337802830291723, -0.30000000000000004, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.76104540997689407, -0.30000000000000004, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.87832009635450736, -0.30000000000000004, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.98787879723171790, -0.30000000000000004, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0924036340069336, -0.30000000000000004, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1944567571590046, -0.30000000000000004, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.80000000000000004.
-template <typename Tp>
-void test069()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data069)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data069[i].k), Tp(data069[i].nu),
-                   Tp(data069[i].phi));
-      const Tp f0 = data069[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.90000000000000002.
-testcase_ellint_3<double> data070[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17305109924485948, -0.30000000000000004, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33793890239556984, -0.30000000000000004, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48947218005089738, -0.30000000000000004, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62623332340775151, -0.30000000000000004, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74951596581511148, -0.30000000000000004, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.86189886597756005, -0.30000000000000004, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.96629451153092005, -0.30000000000000004, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0655269133492680, -0.30000000000000004, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1622376896064912, -0.30000000000000004, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.30000000000000004, nu=0.90000000000000002.
-template <typename Tp>
-void test070()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data070)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data070[i].k), Tp(data070[i].nu),
-                   Tp(data070[i].phi));
-      const Tp f0 = data070[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6192315188521289e-16
+// mean(f - f_Boost): 3.5249581031848718e-16
+// variance(f - f_Boost): 2.5029385557256515e-31
+// stddev(f - f_Boost): 5.0029376927217987e-16
+const testcase_ellint_3<double>
+data050[10] =
+{
+  { 0.0000000000000000, -0.50000000000000000, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17636918772384180, -0.50000000000000000, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36424950570740700, -0.50000000000000000, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57785404590231426, -0.50000000000000000, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.83806480521716531, -0.50000000000000000, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1798568683069752, -0.50000000000000000, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6678766243739607, -0.50000000000000000, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.4282976450693483, -0.50000000000000000, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.6810787666126656, -0.50000000000000000, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.5355132096026454, -0.50000000000000000, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler050 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.1423314994346225e-16
+// mean(f - f_Boost): 1.9428902930940238e-17
+// variance(f - f_Boost): 2.2263750157116445e-32
+// stddev(f - f_Boost): 1.4921042241450980e-16
+const testcase_ellint_3<double>
+data051[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17467414669441528, -0.39999999999999991, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35018222772483443, -0.39999999999999991, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52729015917508748, -0.39999999999999991, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70662374407341244, -0.39999999999999991, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.88859210497602159, -0.39999999999999991, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0733136290471381, -0.39999999999999991, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2605612170157066, -0.39999999999999991, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4497513956433439, -0.39999999999999991, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6399998658645112, -0.39999999999999991, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler051 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.8489340395463703e-16
+// mean(f - f_Boost): 6.3837823915946496e-17
+// variance(f - f_Boost): 4.4785242050000272e-32
+// stddev(f - f_Boost): 2.1162523963365114e-16
+const testcase_ellint_3<double>
+data052[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17485086590796767, -0.39999999999999991, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35158366412506992, -0.39999999999999991, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53194731675711726, -0.39999999999999991, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71740615528010931, -0.39999999999999991, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.90896157773487030, -0.39999999999999991, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1069605483834348, -0.39999999999999991, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3109353428823001, -0.39999999999999991, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.5195460789903448, -0.39999999999999991, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.7306968836847187, -0.39999999999999991, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler052 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.0467985583872730e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 1.5826864298542218e-32
+// stddev(f - f_Boost): 1.2580486595733180e-16
+const testcase_ellint_3<double>
+data053[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17502822886437389, -0.39999999999999991, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35300530062530805, -0.39999999999999991, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53675259548210896, -0.39999999999999991, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72878006428676934, -0.39999999999999991, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.93100219010583563, -0.39999999999999991, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1443487271187609, -0.39999999999999991, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3683427764108813, -0.39999999999999991, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6008221459300933, -0.39999999999999991, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8380358826317627, -0.39999999999999991, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler053 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.9973414591826100e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 1.5826864298542218e-32
+// stddev(f - f_Boost): 1.2580486595733180e-16
+const testcase_ellint_3<double>
+data054[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17520623975982899, -0.39999999999999991, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35444766141612105, -0.39999999999999991, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54171455841536009, -0.39999999999999991, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.74080517001084012, -0.39999999999999991, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.95496950509296563, -0.39999999999999991, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1862627879844718, -0.39999999999999991, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4346501803799458, -0.39999999999999991, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6971744798077697, -0.39999999999999991, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.9677924132520139, -0.39999999999999991, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler054 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2577246923979600e-16
+// mean(f - f_Boost): 1.8596235662471373e-16
+// variance(f - f_Boost): 1.6222417021441306e-31
+// stddev(f - f_Boost): 4.0277061736727151e-16
+const testcase_ellint_3<double>
+data055[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17538490283034375, -0.39999999999999991, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35591129064319948, -0.39999999999999991, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54684250413264535, -0.39999999999999991, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.75355027742668290, -0.39999999999999991, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.98117935026780634, -0.39999999999999991, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2337464222030734, -0.39999999999999991, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5125183419289221, -0.39999999999999991, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.8140224451130311, -0.39999999999999991, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.1289968719280026, -0.39999999999999991, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler055 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.8009196014748294e-16
+// mean(f - f_Boost): 1.6375789613221060e-16
+// variance(f - f_Boost): 6.4788283329186610e-32
+// stddev(f - f_Boost): 2.5453542647181080e-16
+const testcase_ellint_3<double>
+data056[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17556422235224273, -0.39999999999999991, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35739675341763921, -0.39999999999999991, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55214655195037188, -0.39999999999999991, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.76709520942047438, -0.39999999999999991, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0100278761577499, -0.39999999999999991, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2882265661384342, -0.39999999999999991, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6059059780051874, -0.39999999999999991, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.9600182740224081, -0.39999999999999991, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.3367461373176508, -0.39999999999999991, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler056 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.8411408870840790e-16
+// mean(f - f_Boost): 9.7144514654701197e-17
+// variance(f - f_Boost): 1.4860570558543486e-32
+// stddev(f - f_Boost): 1.2190393988113545e-16
+const testcase_ellint_3<double>
+data057[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17574420264267029, -0.39999999999999991, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35890463689046265, -0.39999999999999991, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55763773975194486, -0.39999999999999991, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.78153324227761267, -0.39999999999999991, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0420205885765887, -0.39999999999999991, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3517205230381770, -0.39999999999999991, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.7210360970313896, -0.39999999999999991, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.1500780510169242, -0.39999999999999991, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.6186940209850191, -0.39999999999999991, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler057 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.1553900340611668e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.3242789405258207e-32
+// stddev(f - f_Boost): 1.1507731924779187e-16
+const testcase_ellint_3<double>
+data058[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17592484806010436, -0.39999999999999991, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36043555139631439, -0.39999999999999991, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56332813669944881, -0.39999999999999991, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.79697424562157548, -0.39999999999999991, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0778155987523672, -0.39999999999999991, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4272018169896268, -0.39999999999999991, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8684377907453380, -0.39999999999999991, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.4128677409207469, -0.39999999999999991, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.0327078743873241, -0.39999999999999991, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler058 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5727642219519274e-16
+// mean(f - f_Boost): 2.1926904736346843e-16
+// variance(f - f_Boost): 1.5293405480859847e-31
+// stddev(f - f_Boost): 3.9106783913868252e-16
+const testcase_ellint_3<double>
+data059[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17610616300487833, -0.39999999999999991, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36199013167171978, -0.39999999999999991, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56923097361842423, -0.39999999999999991, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.81354878456624347, -0.39999999999999991, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1182902719261825, -0.39999999999999991, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5192950589409022, -0.39999999999999991, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0678761710223981, -0.39999999999999991, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.8135222249879783, -0.39999999999999991, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.7289548002199902, -0.39999999999999991, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler059 = 2.5000000000000020e-13;
+
+// Test data for k=-0.39999999999999991, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.0221626338023938e-16
+// mean(f - f_Boost): 4.1910919179599658e-16
+// variance(f - f_Boost): 6.2246150910247033e-31
+// stddev(f - f_Boost): 7.8896229891070860e-16
+const testcase_ellint_3<double>
+data060[10] =
+{
+  { 0.0000000000000000, -0.39999999999999991, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17628815191971123, -0.39999999999999991, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36356903815378772, -0.39999999999999991, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57536079447000310, -0.39999999999999991, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.83141355850172571, -0.39999999999999991, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1646481598721361, -0.39999999999999991, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6357275034001995, -0.39999999999999991, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.3628787566572398, -0.39999999999999991, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.5521010369134958, -0.39999999999999991, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.3055535102872513, -0.39999999999999991, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler060 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2241249691539529e-16
+// mean(f - f_Boost): 4.9960036108132046e-17
+// variance(f - f_Boost): 4.6872855002064458e-32
+// stddev(f - f_Boost): 2.1650139722889657e-16
+const testcase_ellint_3<double>
+data061[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17461228653000099, -0.29999999999999993, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34969146102798421, -0.29999999999999993, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52565822873726309, -0.29999999999999993, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70284226512408543, -0.29999999999999993, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.88144139195111171, -0.29999999999999993, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0614897067260520, -0.29999999999999993, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2428416824174220, -0.29999999999999993, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4251795877015929, -0.29999999999999993, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6080486199305126, -0.29999999999999993, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler061 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1872304407982844e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 4.0359883022230488e-32
+// stddev(f - f_Boost): 2.0089769292411121e-16
+const testcase_ellint_3<double>
+data062[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17478889331392972, -0.29999999999999993, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35108939018329183, -0.29999999999999993, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53028990896115835, -0.29999999999999993, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71352417052371409, -0.29999999999999993, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.90153086032405894, -0.29999999999999993, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0945187977283313, -0.29999999999999993, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2920699268385680, -0.29999999999999993, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4931243665896394, -0.29999999999999993, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6960848815118226, -0.29999999999999993, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler062 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2247497610332889e-16
+// mean(f - f_Boost): 1.1102230246251565e-16
+// variance(f - f_Boost): 3.8043060629871325e-32
+// stddev(f - f_Boost): 1.9504630380981672e-16
+const testcase_ellint_3<double>
+data063[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17496614335337535, -0.29999999999999993, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35250745937139372, -0.29999999999999993, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53506875002836884, -0.29999999999999993, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72479106622248191, -0.29999999999999993, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.92326451535891607, -0.29999999999999993, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1312092060698349, -0.29999999999999993, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3481473154592321, -0.29999999999999993, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5722049569662748, -0.29999999999999993, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8002173372290498, -0.29999999999999993, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler063 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1678685180047551e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
+const testcase_ellint_3<double>
+data064[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17514404084107435, -0.29999999999999993, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35394619108645647, -0.29999999999999993, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54000325463372689, -0.29999999999999993, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73670193794067651, -0.29999999999999993, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.94689345491722177, -0.29999999999999993, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1723274608389140, -0.29999999999999993, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4128880552936287, -0.29999999999999993, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6659010047449661, -0.29999999999999993, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.9260216862473254, -0.29999999999999993, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler064 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.3983279132797385e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.8245832308692586e-31
+// stddev(f - f_Boost): 4.2715140534349863e-16
+const testcase_ellint_3<double>
+data065[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17532259000954434, -0.29999999999999993, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35540612770983693, -0.29999999999999993, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54510265552938919, -0.29999999999999993, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74932476310965057, -0.29999999999999993, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.97272793583093109, -0.29999999999999993, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2188928987074241, -0.29999999999999993, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4888771674085941, -0.29999999999999993, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7794558498219191, -0.29999999999999993, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0822121773175528, -0.29999999999999993, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler065 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0516138451673425e-16
+// mean(f - f_Boost): 4.7184478546569152e-17
+// variance(f - f_Boost): 1.9448563670505968e-32
+// stddev(f - f_Boost): 1.3945810722401896e-16
+const testcase_ellint_3<double>
+data066[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17550179513158179, -0.29999999999999993, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35688783251681200, -0.29999999999999993, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55037700010142798, -0.29999999999999993, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.76273839789895992, -0.29999999999999993, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0011570518830419, -0.29999999999999993, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2722987414055109, -0.29999999999999993, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5799590511080066, -0.29999999999999993, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.9212367220124293, -0.29999999999999993, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2833505881933971, -0.29999999999999993, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler066 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2121157428443725e-16
+// mean(f - f_Boost): 1.9428902930940239e-16
+// variance(f - f_Boost): 1.5987596229703424e-31
+// stddev(f - f_Boost): 3.9984492281012430e-16
+const testcase_ellint_3<double>
+data067[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17568166052076745, -0.29999999999999993, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35839189074731181, -0.29999999999999993, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55583724744367558, -0.29999999999999993, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77703498090888223, -0.29999999999999993, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0326772113675962, -0.29999999999999993, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3345139983717369, -0.29999999999999993, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6921742922838403, -0.29999999999999993, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.1056608968472186, -0.29999999999999993, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.5560975528589061, -0.29999999999999993, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler067 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0088945789059381e-16
+// mean(f - f_Boost): 1.6653345369377348e-16
+// variance(f - f_Boost): 3.1994213989721786e-31
+// stddev(f - f_Boost): 5.6563428104846852e-16
+const testcase_ellint_3<double>
+data068[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17586219053197988, -0.29999999999999993, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35991891074557669, -0.29999999999999993, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56149538019961731, -0.29999999999999993, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.79232303189667685, -0.29999999999999993, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0679345542878826, -0.29999999999999993, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4084400085913955, -0.29999999999999993, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8357382859296454, -0.29999999999999993, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3604197996171519, -0.29999999999999993, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.9562123549913872, -0.29999999999999993, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler068 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.80000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1197887707781618e-16
+// mean(f - f_Boost): 3.4416913763379854e-16
+// variance(f - f_Boost): 4.3461914185990199e-31
+// stddev(f - f_Boost): 6.5925650687718054e-16
+const testcase_ellint_3<double>
+data069[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17604338956191670, -0.29999999999999993, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36146952517410791, -0.29999999999999993, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56736453393774644, -0.29999999999999993, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80873149979001091, -0.29999999999999993, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1077903069860620, -0.29999999999999993, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4985874311132998, -0.29999999999999993, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0298167266724954, -0.29999999999999993, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.7483929054985432, -0.29999999999999993, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.6283050484567170, -0.29999999999999993, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler069 = 2.5000000000000020e-13;
+
+// Test data for k=-0.29999999999999993, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1301806687926828e-16
+// mean(f - f_Boost): 4.1633363423443370e-16
+// variance(f - f_Boost): 2.2835347143080263e-31
+// stddev(f - f_Boost): 4.7786344433405093e-16
+const testcase_ellint_3<double>
+data070[10] =
+{
+  { 0.0000000000000000, -0.29999999999999993, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17622526204962433, -0.29999999999999993, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36304439230777141, -0.29999999999999993, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57345914744719195, -0.29999999999999993, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82641512928845162, -0.29999999999999993, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1534256210757743, -0.29999999999999993, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6124900353411677, -0.29999999999999993, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.3165905514845089, -0.29999999999999993, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.4625619526539824, -0.29999999999999993, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.1479514944016787, -0.29999999999999993, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler070 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.0000000000000000.
-testcase_ellint_3<double> data071[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17456817290292811, -0.19999999999999996, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34934315932086801, -0.19999999999999996, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52450880529443988, -0.19999999999999996, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70020491009844910, -0.19999999999999996, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87651006649967955, -0.19999999999999996, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0534305870298994, -0.19999999999999996, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2308975521670784, -0.19999999999999996, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4087733584990738, -0.19999999999999996, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5868678474541664, -0.19999999999999996, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.0000000000000000.
-template <typename Tp>
-void test071()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data071)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data071[i].k), Tp(data071[i].nu),
-                   Tp(data071[i].phi));
-      const Tp f0 = data071[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.2156475739151676e-16
+// mean(f - f_Boost): -5.2735593669694933e-17
+// variance(f - f_Boost): 3.0473442641042680e-32
+// stddev(f - f_Boost): 1.7456644190978597e-16
+const testcase_ellint_3<double>
+data071[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17456817290292806, -0.19999999999999996, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34934315932086796, -0.19999999999999996, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52450880529443988, -0.19999999999999996, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70020491009844887, -0.19999999999999996, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87651006649967977, -0.19999999999999996, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0534305870298994, -0.19999999999999996, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2308975521670789, -0.19999999999999996, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4087733584990738, -0.19999999999999996, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5868678474541662, -0.19999999999999996, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler071 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.10000000000000001.
-testcase_ellint_3<double> data072[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17439228502691750, -0.19999999999999996, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34796731137565740, -0.19999999999999996, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52003370294544848, -0.19999999999999996, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69012222258631495, -0.19999999999999996, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85803491465566772, -0.19999999999999996, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0238463961099364, -0.19999999999999996, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1878691059202153, -0.19999999999999996, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3505985031831940, -0.19999999999999996, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5126513474261092, -0.19999999999999996, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.10000000000000001.
-template <typename Tp>
-void test072()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data072)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data072[i].k), Tp(data072[i].nu),
-                   Tp(data072[i].phi));
-      const Tp f0 = data072[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.0890622182605400e-16
+// mean(f - f_Boost): -3.8857805861880476e-17
+// variance(f - f_Boost): 2.8794792590749608e-32
+// stddev(f - f_Boost): 1.6969028431454054e-16
+const testcase_ellint_3<double>
+data072[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17474469953608965, -0.19999999999999996, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35073860234984255, -0.19999999999999996, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52912258712951521, -0.19999999999999996, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71081701558898069, -0.19999999999999996, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89640758521169384, -0.19999999999999996, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0860417038089853, -0.19999999999999996, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2793599255528623, -0.19999999999999996, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4754938544089076, -0.19999999999999996, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6731552050562593, -0.19999999999999996, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler072 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.20000000000000001.
-testcase_ellint_3<double> data073[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17421703179583750, -0.19999999999999996, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34661057411998791, -0.19999999999999996, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51569006052647393, -0.19999999999999996, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68052412821107278, -0.19999999999999996, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.84081341263313825, -0.19999999999999996, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99683359988842890, -0.19999999999999996, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1493086715118852, -0.19999999999999996, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2992699693957541, -0.19999999999999996, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4479323932249568, -0.19999999999999996, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.20000000000000001.
-template <typename Tp>
-void test073()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data073)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data073[i].k), Tp(data073[i].nu),
-                   Tp(data073[i].phi));
-      const Tp f0 = data073[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.29999999999999999.
-testcase_ellint_3<double> data074[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17404240913577707, -0.19999999999999996, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34527248032587193, -0.19999999999999996, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51147118981668416, -0.19999999999999996, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67137107867777635, -0.19999999999999996, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82470418188668893, -0.19999999999999996, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.97202873223594299, -0.19999999999999996, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1144773569375266, -0.19999999999999996, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2535292433701000, -0.19999999999999996, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3908453514752481, -0.19999999999999996, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.29999999999999999.
-template <typename Tp>
-void test074()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data074)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data074[i].k), Tp(data074[i].nu),
-                   Tp(data074[i].phi));
-      const Tp f0 = data074[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.9570963716579749e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 3.1158217732380362e-32
+// stddev(f - f_Boost): 1.7651690494788412e-16
+const testcase_ellint_3<double>
+data073[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17492186907740698, -0.19999999999999996, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35215414286134267, -0.19999999999999996, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53388285615182440, -0.19999999999999996, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72200960282688265, -0.19999999999999996, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91793087614428526, -0.19999999999999996, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1222602841587976, -0.19999999999999996, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3345489407496247, -0.19999999999999996, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5531225705475502, -0.19999999999999996, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7751816279738935, -0.19999999999999996, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler073 = 2.5000000000000020e-13;
+
+// Test data for k=-0.19999999999999996, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.6785817924053817e-16
+// mean(f - f_Boost): -1.1102230246251566e-17
+// variance(f - f_Boost): 9.9840208317034302e-32
+// stddev(f - f_Boost): 3.1597501217190311e-16
+const testcase_ellint_3<double>
+data074[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17509968571715159, -0.19999999999999996, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35359030214835629, -0.19999999999999996, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53879807274537084, -0.19999999999999996, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73384116418059731, -0.19999999999999996, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.94132799329524031, -0.19999999999999996, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1628407021801439, -0.19999999999999996, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3982440216739438, -0.19999999999999996, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6450634983653640, -0.19999999999999996, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8983924169967099, -0.19999999999999996, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler074 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.40000000000000002.
-testcase_ellint_3<double> data075[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17386841301066677, -0.19999999999999996, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34395257914113253, -0.19999999999999996, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50737088376869466, -0.19999999999999996, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66262801717277664, -0.19999999999999996, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80958766645079094, -0.19999999999999996, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94913754236162040, -0.19999999999999996, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0827985514223000, -0.19999999999999996, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2124212429050478, -0.19999999999999996, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3400002519661010, -0.19999999999999996, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.40000000000000002.
-template <typename Tp>
-void test075()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data075)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data075[i].k), Tp(data075[i].nu),
-                   Tp(data075[i].phi));
-      const Tp f0 = data075[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3298410018355870e-16
+// mean(f - f_Boost): 1.3877787807814457e-17
+// variance(f - f_Boost): 9.4370567274974557e-32
+// stddev(f - f_Boost): 3.0719792850046133e-16
+const testcase_ellint_3<double>
+data075[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17527815368535152, -0.19999999999999996, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35504762134297801, -0.19999999999999996, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54387742353211344, -0.19999999999999996, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74637910471804259, -0.19999999999999996, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96690539714174639, -0.19999999999999996, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2087859420184757, -0.19999999999999996, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4729799844168852, -0.19999999999999996, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7564445064596661, -0.19999999999999996, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0512956926676802, -0.19999999999999996, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler075 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.50000000000000000.
-testcase_ellint_3<double> data076[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17369503942181802, -0.19999999999999996, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34265043534362660, -0.19999999999999996, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50338337208655415, -0.19999999999999996, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65426373297163642, -0.19999999999999996, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79536193036145808, -0.19999999999999996, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92791875910061605, -0.19999999999999996, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0538145052725829, -0.19999999999999996, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1752060022875899, -0.19999999999999996, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2943374404397376, -0.19999999999999996, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.50000000000000000.
-template <typename Tp>
-void test076()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data076)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data076[i].k), Tp(data076[i].nu),
-                   Tp(data076[i].phi));
-      const Tp f0 = data076[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.59999999999999998.
-testcase_ellint_3<double> data077[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17352228440746928, -0.19999999999999996, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34136562863713626, -0.19999999999999996, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49950328177638481, -0.19999999999999996, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64625032705690832, -0.19999999999999996, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.78193941198403094, -0.19999999999999996, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90817230934317128, -0.19999999999999996, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0271563751276462, -0.19999999999999996, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1412999379040518, -0.19999999999999996, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2530330675914561, -0.19999999999999996, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.59999999999999998.
-template <typename Tp>
-void test077()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data077)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data077[i].k), Tp(data077[i].nu),
-                   Tp(data077[i].phi));
-      const Tp f0 = data077[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.69999999999999996.
-testcase_ellint_3<double> data078[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17335014404233898, -0.19999999999999996, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34009775298617811, -0.19999999999999996, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49572560201923810, -0.19999999999999996, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63856276669886525, -0.19999999999999996, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76924438644867565, -0.19999999999999996, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88973060843856466, -0.19999999999999996, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0025230471636377, -0.19999999999999996, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1102356376093103, -0.19999999999999996, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2154356555075867, -0.19999999999999996, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.69999999999999996.
-template <typename Tp>
-void test078()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data078)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data078[i].k), Tp(data078[i].nu),
-                   Tp(data078[i].phi));
-      const Tp f0 = data078[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3841806057292116e-16
+// mean(f - f_Boost): 8.0491169285323847e-17
+// variance(f - f_Boost): 8.0538110429953348e-32
+// stddev(f - f_Boost): 2.8379237204328335e-16
+const testcase_ellint_3<double>
+data076[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17545727725228877, -0.19999999999999996, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35652666242062175, -0.19999999999999996, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54913090549102406, -0.19999999999999996, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75970161209211551, -0.19999999999999996, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99504737401590326, -0.19999999999999996, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2614666007124373, -0.19999999999999996, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5625255355205496, -0.19999999999999996, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8954460255613343, -0.19999999999999996, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2481046259421302, -0.19999999999999996, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler076 = 2.5000000000000020e-13;
+
+// Test data for k=-0.19999999999999996, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5317584994994743e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 1.0045745697575397e-31
+// stddev(f - f_Boost): 3.1695024369095219e-16
+const testcase_ellint_3<double>
+data077[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17563706072900442, -0.19999999999999996, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35802800926807238, -0.19999999999999996, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55456942250515051, -0.19999999999999996, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77390003828438203, -0.19999999999999996, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0262441366366397, -0.19999999999999996, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3228192988439669, -0.19999999999999996, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6728005754680795, -0.19999999999999996, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0761587107468511, -0.19999999999999996, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.5148333891629315, -0.19999999999999996, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler077 = 2.5000000000000020e-13;
+
+// Test data for k=-0.19999999999999996, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.1818454249546518e-16
+// mean(f - f_Boost): 3.6082248300317589e-17
+// variance(f - f_Boost): 8.9638010532618564e-32
+// stddev(f - f_Boost): 2.9939607634806868e-16
+const testcase_ellint_3<double>
+data078[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17581750846781172, -0.19999999999999996, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35955226882028513, -0.19999999999999996, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56020489659466499, -0.19999999999999996, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78908196988531487, -0.19999999999999996, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0611336754143517, -0.19999999999999996, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3956969951058884, -0.19999999999999996, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8138131612209609, -0.19999999999999996, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3256365528879561, -0.19999999999999996, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.9058704854500963, -0.19999999999999996, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler078 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.80000000000000004.
-testcase_ellint_3<double> data079[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17317861443718541, -0.19999999999999996, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33884641598718701, -0.19999999999999996, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49204565281259494, -0.19999999999999996, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63117851188220353, -0.19999999999999996, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75721095949544170, -0.19999999999999996, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.87245201443919118, -0.19999999999999996, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97966584238831089, -0.19999999999999996, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0816336325174360, -0.19999999999999996, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1810223448909913, -0.19999999999999996, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.80000000000000004.
-template <typename Tp>
-void test079()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data079)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data079[i].k), Tp(data079[i].nu),
-                   Tp(data079[i].phi));
-      const Tp f0 = data079[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9866614515542431e-16
+// mean(f - f_Boost): 1.8318679906315082e-16
+// variance(f - f_Boost): 3.1335688610218711e-31
+// stddev(f - f_Boost): 5.5978289193417400e-16
+const testcase_ellint_3<double>
+data079[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17599862486281712, -0.19999999999999996, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36110007227128776, -0.19999999999999996, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56605039658567224, -0.19999999999999996, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80537523874517691, -0.19999999999999996, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1005662342414086, -0.19999999999999996, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4845340298105778, -0.19999999999999996, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0043332244969392, -0.19999999999999996, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.7052856676744761, -0.19999999999999996, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5622166386422629, -0.19999999999999996, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler079 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.90000000000000002.
-testcase_ellint_3<double> data080[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17300769173837280, -0.19999999999999996, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33761123827372508, -0.19999999999999996, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48845905690769426, -0.19999999999999996, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62407720017324986, -0.19999999999999996, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74578146525124289, -0.19999999999999996, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85621583540073076, -0.19999999999999996, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95837725988001199, -0.19999999999999996, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0551821412633928, -0.19999999999999996, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1493679916141863, -0.19999999999999996, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.19999999999999996, nu=0.90000000000000002.
-template <typename Tp>
-void test080()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data080)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data080[i].k), Tp(data080[i].nu),
-                   Tp(data080[i].phi));
-      const Tp f0 = data080[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2817178727913890e-16
+// mean(f - f_Boost): 3.4694469519536142e-16
+// variance(f - f_Boost): 6.6311432369155086e-31
+// stddev(f - f_Boost): 8.1431831840598485e-16
+const testcase_ellint_3<double>
+data080[10] =
+{
+  { 0.0000000000000000, -0.19999999999999996, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17618041435044951, -0.19999999999999996, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36267207636502929, -0.19999999999999996, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57212028758237743, -0.19999999999999996, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82293323876704483, -0.19999999999999996, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1457077279880385, -0.19999999999999996, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5967346899325681, -0.19999999999999996, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2856537353421724, -0.19999999999999996, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.4034714304613902, -0.19999999999999996, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.0448269356200361, -0.19999999999999996, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler080 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.0000000000000000.
-testcase_ellint_3<double> data081[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17454173353063665, -0.099999999999999978, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34913506721468085, -0.099999999999999978, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52382550016538953, -0.099999999999999978, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.69864700854177031, -0.099999999999999978, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87361792586964870, -0.099999999999999978, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0487386319621685, -0.099999999999999978, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2239913752078757, -0.099999999999999978, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.3993423113684049, -0.099999999999999978, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.0000000000000000.
-template <typename Tp>
-void test081()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data081)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data081[i].k), Tp(data081[i].nu),
-                   Tp(data081[i].phi));
-      const Tp f0 = data081[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.1735566504509645e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 8.2258607846939269e-33
+// stddev(f - f_Boost): 9.0696531271564778e-17
+const testcase_ellint_3<double>
+data081[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17454173353063662, -0.099999999999999978, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34913506721468096, -0.099999999999999978, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52382550016538953, -0.099999999999999978, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.69864700854177020, -0.099999999999999978, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87361792586964859, -0.099999999999999978, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0487386319621685, -0.099999999999999978, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2239913752078759, -0.099999999999999978, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.3993423113684051, -0.099999999999999978, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5747455615173558, -0.099999999999999978, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler081 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.10000000000000001.
-testcase_ellint_3<double> data082[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17436589347616618, -0.099999999999999978, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34776067871237354, -0.099999999999999978, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.51936064354727807, -0.099999999999999978, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.68860303749364360, -0.099999999999999978, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85524561882332051, -0.099999999999999978, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0193708301908337, -0.099999999999999978, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1813474067123044, -0.099999999999999978, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3417670770424983, -0.099999999999999978, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.10000000000000001.
-template <typename Tp>
-void test082()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data082)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data082[i].k), Tp(data082[i].nu),
-                   Tp(data082[i].phi));
-      const Tp f0 = data082[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.0305747373482148e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
+const testcase_ellint_3<double>
+data082[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17471821213559732, -0.099999999999999978, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35052902610011138, -0.099999999999999978, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52842865990255727, -0.099999999999999978, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.70921799731166713, -0.099999999999999978, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89340330535868662, -0.099999999999999978, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0811075784236857, -0.099999999999999978, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2720133232666426, -0.099999999999999978, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4653630031861395, -0.099999999999999978, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6600374067558428, -0.099999999999999978, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler082 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.20000000000000001.
-testcase_ellint_3<double> data083[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17419068786141345, -0.099999999999999978, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34640537686230127, -0.099999999999999978, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51502689171753957, -0.099999999999999978, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.67904147863672726, -0.099999999999999978, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.83811885126105179, -0.099999999999999978, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99255278555742810, -0.099999999999999978, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1431260546194930, -0.099999999999999978, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2909589656532101, -0.099999999999999978, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.20000000000000001.
-template <typename Tp>
-void test083()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data083)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data083[i].k), Tp(data083[i].nu),
-                   Tp(data083[i].phi));
-      const Tp f0 = data083[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.29999999999999999.
-testcase_ellint_3<double> data084[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17401611261390110, -0.099999999999999978, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34506869507511767, -0.099999999999999978, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51081757604259870, -0.099999999999999978, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.66992297597712303, -0.099999999999999978, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82209722856174228, -0.099999999999999978, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.96792430487669612, -0.099999999999999978, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1085964108954092, -0.099999999999999978, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2456748370836999, -0.099999999999999978, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.29999999999999999.
-template <typename Tp>
-void test084()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data084)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data084[i].k), Tp(data084[i].nu),
-                   Tp(data084[i].phi));
-      const Tp f0 = data084[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 1.6736714959992433e-16
+// mean(f - f_Boost): 5.5511151231257830e-18
+// variance(f - f_Boost): 3.8043060629871325e-36
+// stddev(f - f_Boost): 1.9504630380981673e-18
+const testcase_ellint_3<double>
+data083[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17489533344059083, -0.099999999999999978, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35194305707815038, -0.099999999999999978, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53317790741512527, -0.099999999999999978, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72036681615081222, -0.099999999999999978, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91480372268244303, -0.099999999999999978, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1170528708071514, -0.099999999999999978, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3266916802718358, -0.099999999999999978, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5421622241831547, -0.099999999999999978, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7608656115083421, -0.099999999999999978, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler083 = 2.5000000000000020e-13;
+
+// Test data for k=-0.099999999999999978, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 1.9186071760326645e-16
+// mean(f - f_Boost): -1.6653345369377347e-17
+// variance(f - f_Boost): 3.4238754566884194e-35
+// stddev(f - f_Boost): 5.8513891142945016e-18
+const testcase_ellint_3<double>
+data084[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17507310163441189, -0.099999999999999978, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35337768072524217, -0.099999999999999978, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53808167801629170, -0.099999999999999978, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73215166755955019, -0.099999999999999978, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.93806546000201219, -0.099999999999999978, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1573218723395986, -0.099999999999999978, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3897859679542097, -0.099999999999999978, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6331009404328622, -0.099999999999999978, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8826015946315438, -0.099999999999999978, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler084 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.40000000000000002.
-testcase_ellint_3<double> data085[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17384216369897937, -0.099999999999999978, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34375018311376782, -0.099999999999999978, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50672650758380455, -0.099999999999999978, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66121264213337616, -0.099999999999999978, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80706202005774441, -0.099999999999999978, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94519376138245892, -0.099999999999999978, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0771880300759584, -0.099999999999999978, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2049711557188272, -0.099999999999999978, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.40000000000000002.
-template <typename Tp>
-void test085()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data085)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data085[i].k), Tp(data085[i].nu),
-                   Tp(data085[i].phi));
-      const Tp f0 = data085[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0338059536914377e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 9.5107651574678308e-35
+// stddev(f - f_Boost): 9.7523151904908362e-18
+const testcase_ellint_3<double>
+data085[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17525152094559704, -0.099999999999999978, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35483343742825979, -0.099999999999999978, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54314913099505446, -0.099999999999999978, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74463962034766862, -0.099999999999999978, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96349276837570441, -0.099999999999999978, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2029081382746343, -0.099999999999999978, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4638022887050806, -0.099999999999999978, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7432413830105224, -0.099999999999999978, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0336367403076760, -0.099999999999999978, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler085 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.50000000000000000.
-testcase_ellint_3<double> data086[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17366883711936554, -0.099999999999999978, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34244940634881876, -0.099999999999999978, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50274793281634378, -0.099999999999999978, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65287941633275093, -0.099999999999999978, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79291198790315398, -0.099999999999999978, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92412201537880345, -0.099999999999999978, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0484480076799370, -0.099999999999999978, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1681168130475206, -0.099999999999999978, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.50000000000000000.
-template <typename Tp>
-void test086()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data086)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data086[i].k), Tp(data086[i].nu),
-                   Tp(data086[i].phi));
-      const Tp f0 = data086[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.59999999999999998.
-testcase_ellint_3<double> data087[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17349612891469018, -0.099999999999999978, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34116594505539438, -0.099999999999999978, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49887649430466685, -0.099999999999999978, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64489553282165157, -0.099999999999999978, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.77956016553782437, -0.099999999999999978, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90451074530096309, -0.099999999999999978, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0220113666961632, -0.099999999999999978, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1345351441065563, -0.099999999999999978, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.59999999999999998.
-template <typename Tp>
-void test087()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data087)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data087[i].k), Tp(data087[i].nu),
-                   Tp(data087[i].phi));
-      const Tp f0 = data087[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.69999999999999996.
-testcase_ellint_3<double> data088[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17332403516105052, -0.099999999999999978, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.33989939374896877, -0.099999999999999978, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49510719568614081, -0.099999999999999978, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63723607776354974, -0.099999999999999978, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76693133887935327, -0.099999999999999978, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88619382078823827, -0.099999999999999978, 0.69999999999999996,
-          1.0471975511965976 },
-  { 0.99758012018676490, -0.099999999999999978, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1037642270814410, -0.099999999999999978, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2073745911083187, -0.099999999999999978, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.69999999999999996.
-template <typename Tp>
-void test088()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data088)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data088[i].k), Tp(data088[i].nu),
-                   Tp(data088[i].phi));
-      const Tp f0 = data088[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.9864616042835278e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
+const testcase_ellint_3<double>
+data086[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17543059564292182, -0.099999999999999978, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35631088838721664, -0.099999999999999978, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54839023346436444, -0.099999999999999978, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75790846946088830, -0.099999999999999978, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99146713686720678, -0.099999999999999978, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2551692247937198, -0.099999999999999978, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5524660788146873, -0.099999999999999978, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8806578570830670, -0.099999999999999978, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2279868912966849, -0.099999999999999978, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler086 = 2.5000000000000020e-13;
+
+// Test data for k=-0.099999999999999978, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6726146516228014e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 1.6073193116120635e-34
+// stddev(f - f_Boost): 1.2678009747638087e-17
+const testcase_ellint_3<double>
+data087[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17561033003590576, -0.099999999999999978, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35781061668171932, -0.099999999999999978, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55381585659629196, -0.099999999999999978, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77204910484575640, -0.099999999999999978, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0224751740393108, -0.099999999999999978, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3160230906351114, -0.099999999999999978, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6616282844233206, -0.099999999999999978, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0592555664850392, -0.099999999999999978, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.4913004919173822, -0.099999999999999978, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler087 = 2.5000000000000020e-13;
+
+// Test data for k=-0.099999999999999978, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 2.1004074871280821e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
+const testcase_ellint_3<double>
+data088[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17579072847532518, -0.099999999999999978, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35933322840606297, -0.099999999999999978, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.55943788649460324, -0.099999999999999978, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78716856504031707, -0.099999999999999978, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0571501305617423, -0.099999999999999978, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3882948301743525, -0.099999999999999978, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8011785680114223, -0.099999999999999978, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3057268183616464, -0.099999999999999978, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.8771910188009739, -0.099999999999999978, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler088 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.80000000000000004.
-testcase_ellint_3<double> data089[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17315255197057020, -0.099999999999999978, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33864936055747985, -0.099999999999999978, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49143537041117619, -0.099999999999999978, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.62987861760047492, -0.099999999999999978, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75496005490917517, -0.099999999999999978, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.86903081862701903, -0.099999999999999978, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97490814820725591, -0.099999999999999978, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0754290107171083, -0.099999999999999978, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.80000000000000004.
-template <typename Tp>
-void test089()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data089)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data089[i].k), Tp(data089[i].nu),
-                   Tp(data089[i].phi));
-      const Tp f0 = data089[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.3133043868392355e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 6.1843750436434569e-32
+// stddev(f - f_Boost): 2.4868403735751633e-16
+const testcase_ellint_3<double>
+data089[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17597179535373417, -0.099999999999999978, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36087935387831499, -0.099999999999999978, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56526935244526444, -0.099999999999999978, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80339402590612397, -0.099999999999999978, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.0963358646374459, -0.099999999999999978, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4763748483246868, -0.099999999999999978, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 1.9896610222794102, -0.099999999999999978, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.6806423920122024, -0.099999999999999978, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5246199613295612, -0.099999999999999978, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler089 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.90000000000000002.
-testcase_ellint_3<double> data090[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17298167549096569, -0.099999999999999978, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33741546662741584, -0.099999999999999978, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48785665376856879, -0.099999999999999978, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62280288554518959, -0.099999999999999978, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74358903115455199, -0.099999999999999978, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85290207679298358, -0.099999999999999978, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95379006645397379, -0.099999999999999978, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0492213119872327, -0.099999999999999978, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=-0.099999999999999978, nu=0.90000000000000002.
-template <typename Tp>
-void test090()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data090)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data090[i].k), Tp(data090[i].nu),
-                   Tp(data090[i].phi));
-      const Tp f0 = data090[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5624826890976725e-16
+// mean(f - f_Boost): 2.3314683517128288e-16
+// variance(f - f_Boost): 2.9401198977189756e-31
+// stddev(f - f_Boost): 5.4222872459129045e-16
+const testcase_ellint_3<double>
+data090[10] =
+{
+  { 0.0000000000000000, -0.099999999999999978, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17615353510599349, -0.099999999999999978, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36244964892922371, -0.099999999999999978, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57132457590110530, -0.099999999999999978, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82087808820385000, -0.099999999999999978, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1411894342144451, -0.099999999999999978, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5875929286844597, -0.099999999999999978, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2678622986596659, -0.099999999999999978, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.3697528941897903, -0.099999999999999978, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 4.9862890417305499, -0.099999999999999978, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler090 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.0000000000000000.
-testcase_ellint_3<double> data091[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17453292519943295, 0.0000000000000000, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34906585039886584, 0.0000000000000000, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52359877559829882, 0.0000000000000000, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.69813170079773179, 0.0000000000000000, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87266462599716477, 0.0000000000000000, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0471975511965976, 0.0000000000000000, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2217304763960304, 0.0000000000000000, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.3962634015954631, 0.0000000000000000, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.0000000000000000.
-template <typename Tp>
-void test091()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data091)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data091[i].k), Tp(data091[i].nu),
-                   Tp(data091[i].phi));
-      const Tp f0 = data091[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.1203697876423447e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data091[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17453292519943295, 0.0000000000000000, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34906585039886590, 0.0000000000000000, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52359877559829882, 0.0000000000000000, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.69813170079773179, 0.0000000000000000, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87266462599716477, 0.0000000000000000, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0471975511965976, 0.0000000000000000, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2217304763960306, 0.0000000000000000, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.3962634015954636, 0.0000000000000000, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler091 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.10000000000000001.
-testcase_ellint_3<double> data092[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17435710107516608, 0.0000000000000000, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34769194715329604, 0.0000000000000000, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.51913731575866118, 0.0000000000000000, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.68810051897078461, 0.0000000000000000, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85432615661706823, 0.0000000000000000, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0179006647340796, 0.0000000000000000, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1792120640746322, 0.0000000000000000, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3388834245070498, 0.0000000000000000, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.10000000000000001.
-template <typename Tp>
-void test092()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data092)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data092[i].k), Tp(data092[i].nu),
-                   Tp(data092[i].phi));
-      const Tp f0 = data092[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.1019052604815601e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 9.5107651574678312e-37
+// stddev(f - f_Boost): 9.7523151904908366e-19
+const testcase_ellint_3<double>
+data092[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17470938780535167, 0.0000000000000000, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35045931581655582, 0.0000000000000000, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52819841383849875, 0.0000000000000000, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.70868910807992958, 0.0000000000000000, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89241311307249638, 0.0000000000000000, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0794871444666669, 0.0000000000000000, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2696086247356864, 0.0000000000000000, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4620562617494721, 0.0000000000000000, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6557647109660167, 0.0000000000000000, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler092 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.20000000000000001.
-testcase_ellint_3<double> data093[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17418191132226077, 0.0000000000000000, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34633712256943405, 0.0000000000000000, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51480684302043711, 0.0000000000000000, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.67855102942481949, 0.0000000000000000, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.83723056090326253, 0.0000000000000000, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99114645269578183, 0.0000000000000000, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1411014627915537, 0.0000000000000000, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2882448138013969, 0.0000000000000000, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.20000000000000001.
-template <typename Tp>
-void test093()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data093)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data093[i].k), Tp(data093[i].nu),
-                   Tp(data093[i].phi));
-      const Tp f0 = data093[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.29999999999999999.
-testcase_ellint_3<double> data094[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17400735186871727, 0.0000000000000000, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34500091027020219, 0.0000000000000000, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51060069523901541, 0.0000000000000000, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.66944393961375459, 0.0000000000000000, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82123776744538157, 0.0000000000000000, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.96657579245516523, 0.0000000000000000, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1066703663542414, 0.0000000000000000, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2431094251944901, 0.0000000000000000, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.29999999999999999.
-template <typename Tp>
-void test094()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data094)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data094[i].k), Tp(data094[i].nu),
-                   Tp(data094[i].phi));
-      const Tp f0 = data094[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0831888697465320e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data093[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17488649304197776, 0.0000000000000000, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35187284488675424, 0.0000000000000000, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53294400750146131, 0.0000000000000000, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.71982347021822823, 0.0000000000000000, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91377311030258745, 0.0000000000000000, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1153429007215137, 0.0000000000000000, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3241202847784086, 0.0000000000000000, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5385854914338242, 0.0000000000000000, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7562036827601815, 0.0000000000000000, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler093 = 2.5000000000000020e-13;
+
+// Test data for k=0.0000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0642101770923591e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data094[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17506424509761404, 0.0000000000000000, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35330695794774630, 0.0000000000000000, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53784398359522367, 0.0000000000000000, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73159289408687844, 0.0000000000000000, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.93699031797084975, 0.0000000000000000, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1555098909390267, 0.0000000000000000, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3870184960144325, 0.0000000000000000, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6291980835772994, 0.0000000000000000, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8774607092226381, 0.0000000000000000, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler094 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.40000000000000002.
-testcase_ellint_3<double> data095[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17383341868035865, 0.0000000000000000, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34368286022299821, 0.0000000000000000, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50651268947499406, 0.0000000000000000, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66074441806097550, 0.0000000000000000, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80622931670113485, 0.0000000000000000, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94389791565435233, 0.0000000000000000, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0753503387899728, 0.0000000000000000, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2025374759127518, 0.0000000000000000, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3275651989026322, 0.0000000000000000, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.40000000000000002.
-template <typename Tp>
-void test095()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data095)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data095[i].k), Tp(data095[i].nu),
-                   Tp(data095[i].phi));
-      const Tp f0 = data095[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0449580089795878e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data095[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17524264820030025, 0.0000000000000000, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35476219513871499, 0.0000000000000000, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54290749235440094, 0.0000000000000000, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74406433757109913, 0.0000000000000000, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96236826162553313, 0.0000000000000000, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2009785880262487, 0.0000000000000000, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4608000106167567, 0.0000000000000000, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7389349574753439, 0.0000000000000000, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0278893379868057, 0.0000000000000000, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler095 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.50000000000000000.
-testcase_ellint_3<double> data096[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17366010776037047, 0.0000000000000000, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34238253799539309, 0.0000000000000000, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50253707775976408, 0.0000000000000000, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65242145347295766, 0.0000000000000000, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79210420018698058, 0.0000000000000000, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92287437995632193, 0.0000000000000000, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0466900550798661, 0.0000000000000000, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1658007366618623, 0.0000000000000000, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.50000000000000000.
-template <typename Tp>
-void test096()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data096)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data096[i].k), Tp(data096[i].nu),
-                   Tp(data096[i].phi));
-      const Tp f0 = data096[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.59999999999999998.
-testcase_ellint_3<double> data097[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17348741514884702, 0.0000000000000000, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34109952405241289, 0.0000000000000000, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49866850781226296, 0.0000000000000000, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64444732407062510, 0.0000000000000000, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.77877564686544720, 0.0000000000000000, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90330743691883497, 0.0000000000000000, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0203257987604104, 0.0000000000000000, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1323247918768631, 0.0000000000000000, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.59999999999999998.
-template <typename Tp>
-void test097()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data097)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data097[i].k), Tp(data097[i].nu),
-                   Tp(data097[i].phi));
-      const Tp f0 = data097[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.69999999999999996.
-testcase_ellint_3<double> data098[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17331533692234477, 0.0000000000000000, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.33983341309265941, 0.0000000000000000, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49490198805931990, 0.0000000000000000, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63679715525145308, 0.0000000000000000, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76616861049481944, 0.0000000000000000, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88503143209004220, 0.0000000000000000, 0.69999999999999996,
-          1.0471975511965976 },
-  { 0.99596060249112173, 0.0000000000000000, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1016495050260424, 0.0000000000000000, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.69999999999999996.
-template <typename Tp>
-void test098()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data098)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data098[i].k), Tp(data098[i].nu),
-                   Tp(data098[i].phi));
-      const Tp f0 = data098[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0254203825026289e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data096[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17542170661831016, 0.0000000000000000, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35623911740195419, 0.0000000000000000, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54814449099863127, 0.0000000000000000, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75731546607718081, 0.0000000000000000, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99028751188233310, 0.0000000000000000, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2531022857760581, 0.0000000000000000, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5491761777615785, 0.0000000000000000, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8758359693666533, 0.0000000000000000, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2214414690791831, 0.0000000000000000, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler096 = 2.5000000000000020e-13;
+
+// Test data for k=0.0000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.1742785192400269e-16
+// mean(f - f_Boost): 1.3877787807814457e-17
+// variance(f - f_Boost): 2.3776912893669577e-35
+// stddev(f - f_Boost): 4.8761575952454181e-18
+const testcase_ellint_3<double>
+data097[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17560142466065651, 0.0000000000000000, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35773830754879005, 0.0000000000000000, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55356583986445973, 0.0000000000000000, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77143701715151514, 0.0000000000000000, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0212334940541210, 0.0000000000000000, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3137928444460387, 0.0000000000000000, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6579755004159076, 0.0000000000000000, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0537461418295506, 0.0000000000000000, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.4836470664490253, 0.0000000000000000, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler097 = 2.5000000000000020e-13;
+
+// Test data for k=0.0000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 4
+// max(|f - f_Boost| / |f_Boost|): 3.0903019454022601e-16
+// mean(f - f_Boost): -6.9388939039072284e-17
+// variance(f - f_Boost): 5.9442282234173945e-34
+// stddev(f - f_Boost): 2.4380787976227090e-17
+const testcase_ellint_3<double>
+data098[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17578180667760368, 0.0000000000000000, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35926037139410999, 0.0000000000000000, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.55918341315855080, 0.0000000000000000, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78653584856932546, 0.0000000000000000, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0558379029273324, 0.0000000000000000, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3858662544850615, 0.0000000000000000, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.7970491170359040, 0.0000000000000000, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.2992404490153917, 0.0000000000000000, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.8678686047727382, 0.0000000000000000, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler098 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.80000000000000004.
-testcase_ellint_3<double> data099[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17314386919344213, 0.0000000000000000, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33858381342073240, 0.0000000000000000, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49123285640844738, 0.0000000000000000, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.62944854858904520, 0.0000000000000000, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75421778305499343, 0.0000000000000000, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.86790634112156639, 0.0000000000000000, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97334918087427558, 0.0000000000000000, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0734012615283985, 0.0000000000000000, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.80000000000000004.
-template <typename Tp>
-void test099()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data099)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data099[i].k), Tp(data099[i].nu),
-                   Tp(data099[i].phi));
-      const Tp f0 = data099[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.2373744057922657e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
+const testcase_ellint_3<double>
+data099[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17596285706118869, 0.0000000000000000, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36080593896484231, 0.0000000000000000, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56501022706967863, 0.0000000000000000, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80273891984116930, 0.0000000000000000, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.0949425007763358, 0.0000000000000000, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4736985692253419, 0.0000000000000000, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 1.9848676587180696, 0.0000000000000000, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.6726187823193546, 0.0000000000000000, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5124073655203634, 0.0000000000000000, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler099 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.90000000000000002.
-testcase_ellint_3<double> data100[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17297300811030600, 0.0000000000000000, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33735034635360817, 0.0000000000000000, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48765675230233141, 0.0000000000000000, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62238126886123568, 0.0000000000000000, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74286600807269243, 0.0000000000000000, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85181283909264971, 0.0000000000000000, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95228683995371122, 0.0000000000000000, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0472730487412552, 0.0000000000000000, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.0000000000000000, nu=0.90000000000000002.
-template <typename Tp>
-void test100()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data100)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data100[i].k), Tp(data100[i].nu),
-                   Tp(data100[i].phi));
-      const Tp f0 = data100[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.6108624815885066e-16
+// mean(f - f_Boost): 2.1371793224034264e-16
+// variance(f - f_Boost): 5.6389326618626776e-33
+// stddev(f - f_Boost): 7.5092826966779442e-17
+const testcase_ellint_3<double>
+data100[10] =
+{
+  { 0.0000000000000000, 0.0000000000000000, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17614458024574997, 0.0000000000000000, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36237566578821978, 0.0000000000000000, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57106058859196640, 0.0000000000000000, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82019857015755915, 0.0000000000000000, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1397014388908147, 0.0000000000000000, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5845952415154960, 0.0000000000000000, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2620531413370775, 0.0000000000000000, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.3587842061975066, 0.0000000000000000, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 4.9672941328980507, 0.0000000000000000, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler100 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.0000000000000000.
-testcase_ellint_3<double> data101[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17454173353063665, 0.10000000000000009, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34913506721468085, 0.10000000000000009, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52382550016538953, 0.10000000000000009, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.69864700854177031, 0.10000000000000009, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87361792586964870, 0.10000000000000009, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0487386319621685, 0.10000000000000009, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2239913752078757, 0.10000000000000009, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.3993423113684049, 0.10000000000000009, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.0000000000000000.
-template <typename Tp>
-void test101()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data101)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data101[i].k), Tp(data101[i].nu),
-                   Tp(data101[i].phi));
-      const Tp f0 = data101[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.1735566504509645e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
+const testcase_ellint_3<double>
+data101[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17454173353063662, 0.10000000000000009, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34913506721468096, 0.10000000000000009, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52382550016538953, 0.10000000000000009, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.69864700854177020, 0.10000000000000009, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87361792586964859, 0.10000000000000009, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0487386319621685, 0.10000000000000009, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2239913752078759, 0.10000000000000009, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.3993423113684051, 0.10000000000000009, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5747455615173560, 0.10000000000000009, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler101 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.10000000000000001.
-testcase_ellint_3<double> data102[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17436589347616618, 0.10000000000000009, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34776067871237354, 0.10000000000000009, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.51936064354727807, 0.10000000000000009, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.68860303749364360, 0.10000000000000009, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85524561882332051, 0.10000000000000009, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0193708301908337, 0.10000000000000009, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1813474067123044, 0.10000000000000009, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3417670770424983, 0.10000000000000009, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.10000000000000001.
-template <typename Tp>
-void test102()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data102)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data102[i].k), Tp(data102[i].nu),
-                   Tp(data102[i].phi));
-      const Tp f0 = data102[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.0305747373482148e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
+const testcase_ellint_3<double>
+data102[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17471821213559732, 0.10000000000000009, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35052902610011138, 0.10000000000000009, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52842865990255727, 0.10000000000000009, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.70921799731166713, 0.10000000000000009, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89340330535868662, 0.10000000000000009, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0811075784236857, 0.10000000000000009, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2720133232666426, 0.10000000000000009, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4653630031861395, 0.10000000000000009, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6600374067558428, 0.10000000000000009, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler102 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.20000000000000001.
-testcase_ellint_3<double> data103[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17419068786141345, 0.10000000000000009, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34640537686230127, 0.10000000000000009, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51502689171753957, 0.10000000000000009, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.67904147863672726, 0.10000000000000009, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.83811885126105179, 0.10000000000000009, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99255278555742810, 0.10000000000000009, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1431260546194930, 0.10000000000000009, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2909589656532101, 0.10000000000000009, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.20000000000000001.
-template <typename Tp>
-void test103()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data103)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data103[i].k), Tp(data103[i].nu),
-                   Tp(data103[i].phi));
-      const Tp f0 = data103[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.29999999999999999.
-testcase_ellint_3<double> data104[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17401611261390110, 0.10000000000000009, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34506869507511767, 0.10000000000000009, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51081757604259870, 0.10000000000000009, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.66992297597712303, 0.10000000000000009, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82209722856174228, 0.10000000000000009, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.96792430487669612, 0.10000000000000009, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1085964108954092, 0.10000000000000009, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2456748370836999, 0.10000000000000009, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.29999999999999999.
-template <typename Tp>
-void test104()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data104)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data104[i].k), Tp(data104[i].nu),
-                   Tp(data104[i].phi));
-      const Tp f0 = data104[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 1.6736714959992433e-16
+// mean(f - f_Boost): 5.5511151231257830e-18
+// variance(f - f_Boost): 3.8043060629871325e-36
+// stddev(f - f_Boost): 1.9504630380981673e-18
+const testcase_ellint_3<double>
+data103[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17489533344059083, 0.10000000000000009, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35194305707815038, 0.10000000000000009, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53317790741512527, 0.10000000000000009, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72036681615081222, 0.10000000000000009, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91480372268244303, 0.10000000000000009, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1170528708071514, 0.10000000000000009, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3266916802718358, 0.10000000000000009, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5421622241831547, 0.10000000000000009, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7608656115083421, 0.10000000000000009, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler103 = 2.5000000000000020e-13;
+
+// Test data for k=0.10000000000000009, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 1.9186071760326645e-16
+// mean(f - f_Boost): -1.6653345369377347e-17
+// variance(f - f_Boost): 3.4238754566884194e-35
+// stddev(f - f_Boost): 5.8513891142945016e-18
+const testcase_ellint_3<double>
+data104[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17507310163441189, 0.10000000000000009, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35337768072524217, 0.10000000000000009, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53808167801629170, 0.10000000000000009, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73215166755955019, 0.10000000000000009, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.93806546000201219, 0.10000000000000009, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1573218723395986, 0.10000000000000009, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3897859679542097, 0.10000000000000009, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6331009404328622, 0.10000000000000009, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8826015946315438, 0.10000000000000009, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler104 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.40000000000000002.
-testcase_ellint_3<double> data105[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17384216369897937, 0.10000000000000009, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34375018311376782, 0.10000000000000009, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50672650758380455, 0.10000000000000009, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66121264213337616, 0.10000000000000009, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80706202005774441, 0.10000000000000009, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94519376138245892, 0.10000000000000009, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0771880300759584, 0.10000000000000009, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2049711557188272, 0.10000000000000009, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.40000000000000002.
-template <typename Tp>
-void test105()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data105)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data105[i].k), Tp(data105[i].nu),
-                   Tp(data105[i].phi));
-      const Tp f0 = data105[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0338059536914377e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 9.5107651574678308e-35
+// stddev(f - f_Boost): 9.7523151904908362e-18
+const testcase_ellint_3<double>
+data105[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17525152094559704, 0.10000000000000009, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35483343742825979, 0.10000000000000009, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54314913099505446, 0.10000000000000009, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74463962034766862, 0.10000000000000009, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96349276837570441, 0.10000000000000009, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2029081382746343, 0.10000000000000009, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4638022887050806, 0.10000000000000009, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7432413830105224, 0.10000000000000009, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0336367403076760, 0.10000000000000009, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler105 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.50000000000000000.
-testcase_ellint_3<double> data106[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17366883711936554, 0.10000000000000009, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34244940634881876, 0.10000000000000009, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50274793281634378, 0.10000000000000009, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65287941633275093, 0.10000000000000009, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79291198790315398, 0.10000000000000009, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92412201537880345, 0.10000000000000009, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0484480076799370, 0.10000000000000009, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1681168130475206, 0.10000000000000009, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.50000000000000000.
-template <typename Tp>
-void test106()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data106)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data106[i].k), Tp(data106[i].nu),
-                   Tp(data106[i].phi));
-      const Tp f0 = data106[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.59999999999999998.
-testcase_ellint_3<double> data107[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17349612891469018, 0.10000000000000009, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34116594505539438, 0.10000000000000009, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49887649430466685, 0.10000000000000009, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64489553282165157, 0.10000000000000009, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.77956016553782437, 0.10000000000000009, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90451074530096309, 0.10000000000000009, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0220113666961632, 0.10000000000000009, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1345351441065563, 0.10000000000000009, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.59999999999999998.
-template <typename Tp>
-void test107()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data107)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data107[i].k), Tp(data107[i].nu),
-                   Tp(data107[i].phi));
-      const Tp f0 = data107[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.69999999999999996.
-testcase_ellint_3<double> data108[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17332403516105052, 0.10000000000000009, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.33989939374896877, 0.10000000000000009, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49510719568614081, 0.10000000000000009, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63723607776354974, 0.10000000000000009, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76693133887935327, 0.10000000000000009, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88619382078823827, 0.10000000000000009, 0.69999999999999996,
-          1.0471975511965976 },
-  { 0.99758012018676490, 0.10000000000000009, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1037642270814410, 0.10000000000000009, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2073745911083187, 0.10000000000000009, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.69999999999999996.
-template <typename Tp>
-void test108()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data108)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data108[i].k), Tp(data108[i].nu),
-                   Tp(data108[i].phi));
-      const Tp f0 = data108[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.9864616042835278e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
+const testcase_ellint_3<double>
+data106[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17543059564292182, 0.10000000000000009, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35631088838721664, 0.10000000000000009, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54839023346436455, 0.10000000000000009, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75790846946088830, 0.10000000000000009, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99146713686720678, 0.10000000000000009, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2551692247937198, 0.10000000000000009, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5524660788146873, 0.10000000000000009, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8806578570830670, 0.10000000000000009, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2279868912966849, 0.10000000000000009, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler106 = 2.5000000000000020e-13;
+
+// Test data for k=0.10000000000000009, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6726146516228014e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 1.6073193116120635e-34
+// stddev(f - f_Boost): 1.2678009747638087e-17
+const testcase_ellint_3<double>
+data107[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17561033003590576, 0.10000000000000009, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35781061668171932, 0.10000000000000009, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55381585659629196, 0.10000000000000009, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77204910484575640, 0.10000000000000009, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0224751740393108, 0.10000000000000009, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3160230906351114, 0.10000000000000009, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6616282844233206, 0.10000000000000009, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0592555664850392, 0.10000000000000009, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.4913004919173822, 0.10000000000000009, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler107 = 2.5000000000000020e-13;
+
+// Test data for k=0.10000000000000009, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 2.1004074871280821e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
+const testcase_ellint_3<double>
+data108[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17579072847532518, 0.10000000000000009, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35933322840606297, 0.10000000000000009, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.55943788649460324, 0.10000000000000009, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78716856504031707, 0.10000000000000009, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0571501305617423, 0.10000000000000009, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3882948301743525, 0.10000000000000009, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8011785680114223, 0.10000000000000009, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3057268183616464, 0.10000000000000009, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.8771910188009739, 0.10000000000000009, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler108 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.80000000000000004.
-testcase_ellint_3<double> data109[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17315255197057020, 0.10000000000000009, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33864936055747985, 0.10000000000000009, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49143537041117619, 0.10000000000000009, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.62987861760047492, 0.10000000000000009, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75496005490917517, 0.10000000000000009, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.86903081862701903, 0.10000000000000009, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97490814820725591, 0.10000000000000009, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0754290107171083, 0.10000000000000009, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.80000000000000004.
-template <typename Tp>
-void test109()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data109)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data109[i].k), Tp(data109[i].nu),
-                   Tp(data109[i].phi));
-      const Tp f0 = data109[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.3133043868392355e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 6.1843750436434569e-32
+// stddev(f - f_Boost): 2.4868403735751633e-16
+const testcase_ellint_3<double>
+data109[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17597179535373417, 0.10000000000000009, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36087935387831499, 0.10000000000000009, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56526935244526444, 0.10000000000000009, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80339402590612397, 0.10000000000000009, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.0963358646374459, 0.10000000000000009, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4763748483246868, 0.10000000000000009, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 1.9896610222794102, 0.10000000000000009, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.6806423920122024, 0.10000000000000009, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5246199613295612, 0.10000000000000009, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler109 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.90000000000000002.
-testcase_ellint_3<double> data110[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17298167549096569, 0.10000000000000009, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33741546662741584, 0.10000000000000009, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48785665376856879, 0.10000000000000009, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62280288554518959, 0.10000000000000009, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74358903115455199, 0.10000000000000009, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85290207679298358, 0.10000000000000009, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95379006645397379, 0.10000000000000009, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0492213119872327, 0.10000000000000009, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.10000000000000009, nu=0.90000000000000002.
-template <typename Tp>
-void test110()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data110)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data110[i].k), Tp(data110[i].nu),
-                   Tp(data110[i].phi));
-      const Tp f0 = data110[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.0000000000000000.
-testcase_ellint_3<double> data111[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17456817290292811, 0.19999999999999996, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34934315932086801, 0.19999999999999996, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52450880529443988, 0.19999999999999996, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70020491009844910, 0.19999999999999996, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87651006649967955, 0.19999999999999996, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0534305870298994, 0.19999999999999996, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2308975521670784, 0.19999999999999996, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4087733584990738, 0.19999999999999996, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5868678474541664, 0.19999999999999996, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.0000000000000000.
-template <typename Tp>
-void test111()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data111)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data111[i].k), Tp(data111[i].nu),
-                   Tp(data111[i].phi));
-      const Tp f0 = data111[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.10000000000000001.
-testcase_ellint_3<double> data112[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17439228502691750, 0.19999999999999996, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34796731137565740, 0.19999999999999996, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52003370294544848, 0.19999999999999996, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69012222258631495, 0.19999999999999996, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85803491465566772, 0.19999999999999996, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0238463961099364, 0.19999999999999996, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1878691059202153, 0.19999999999999996, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3505985031831940, 0.19999999999999996, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5126513474261092, 0.19999999999999996, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.10000000000000001.
-template <typename Tp>
-void test112()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data112)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data112[i].k), Tp(data112[i].nu),
-                   Tp(data112[i].phi));
-      const Tp f0 = data112[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.20000000000000001.
-testcase_ellint_3<double> data113[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17421703179583750, 0.19999999999999996, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34661057411998791, 0.19999999999999996, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51569006052647393, 0.19999999999999996, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68052412821107278, 0.19999999999999996, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.84081341263313825, 0.19999999999999996, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99683359988842890, 0.19999999999999996, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1493086715118852, 0.19999999999999996, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2992699693957541, 0.19999999999999996, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4479323932249568, 0.19999999999999996, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.20000000000000001.
-template <typename Tp>
-void test113()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data113)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data113[i].k), Tp(data113[i].nu),
-                   Tp(data113[i].phi));
-      const Tp f0 = data113[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.29999999999999999.
-testcase_ellint_3<double> data114[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17404240913577707, 0.19999999999999996, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34527248032587193, 0.19999999999999996, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51147118981668416, 0.19999999999999996, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67137107867777635, 0.19999999999999996, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82470418188668893, 0.19999999999999996, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.97202873223594299, 0.19999999999999996, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1144773569375266, 0.19999999999999996, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2535292433701000, 0.19999999999999996, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3908453514752481, 0.19999999999999996, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.29999999999999999.
-template <typename Tp>
-void test114()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data114)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data114[i].k), Tp(data114[i].nu),
-                   Tp(data114[i].phi));
-      const Tp f0 = data114[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.40000000000000002.
-testcase_ellint_3<double> data115[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17386841301066677, 0.19999999999999996, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34395257914113253, 0.19999999999999996, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50737088376869466, 0.19999999999999996, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66262801717277664, 0.19999999999999996, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80958766645079094, 0.19999999999999996, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94913754236162040, 0.19999999999999996, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0827985514223000, 0.19999999999999996, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2124212429050478, 0.19999999999999996, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3400002519661010, 0.19999999999999996, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.40000000000000002.
-template <typename Tp>
-void test115()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data115)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data115[i].k), Tp(data115[i].nu),
-                   Tp(data115[i].phi));
-      const Tp f0 = data115[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.50000000000000000.
-testcase_ellint_3<double> data116[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17369503942181802, 0.19999999999999996, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34265043534362660, 0.19999999999999996, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50338337208655415, 0.19999999999999996, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65426373297163642, 0.19999999999999996, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79536193036145808, 0.19999999999999996, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92791875910061605, 0.19999999999999996, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0538145052725829, 0.19999999999999996, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1752060022875899, 0.19999999999999996, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2943374404397376, 0.19999999999999996, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.50000000000000000.
-template <typename Tp>
-void test116()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data116)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data116[i].k), Tp(data116[i].nu),
-                   Tp(data116[i].phi));
-      const Tp f0 = data116[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.59999999999999998.
-testcase_ellint_3<double> data117[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17352228440746928, 0.19999999999999996, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34136562863713626, 0.19999999999999996, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49950328177638481, 0.19999999999999996, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64625032705690832, 0.19999999999999996, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.78193941198403094, 0.19999999999999996, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90817230934317128, 0.19999999999999996, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0271563751276462, 0.19999999999999996, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1412999379040518, 0.19999999999999996, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2530330675914561, 0.19999999999999996, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.59999999999999998.
-template <typename Tp>
-void test117()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data117)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data117[i].k), Tp(data117[i].nu),
-                   Tp(data117[i].phi));
-      const Tp f0 = data117[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.69999999999999996.
-testcase_ellint_3<double> data118[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17335014404233898, 0.19999999999999996, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34009775298617811, 0.19999999999999996, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49572560201923810, 0.19999999999999996, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63856276669886525, 0.19999999999999996, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76924438644867565, 0.19999999999999996, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88973060843856466, 0.19999999999999996, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0025230471636377, 0.19999999999999996, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1102356376093103, 0.19999999999999996, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2154356555075867, 0.19999999999999996, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.69999999999999996.
-template <typename Tp>
-void test118()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data118)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data118[i].k), Tp(data118[i].nu),
-                   Tp(data118[i].phi));
-      const Tp f0 = data118[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.80000000000000004.
-testcase_ellint_3<double> data119[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17317861443718541, 0.19999999999999996, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33884641598718701, 0.19999999999999996, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49204565281259494, 0.19999999999999996, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63117851188220353, 0.19999999999999996, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75721095949544170, 0.19999999999999996, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.87245201443919118, 0.19999999999999996, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97966584238831089, 0.19999999999999996, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0816336325174360, 0.19999999999999996, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1810223448909913, 0.19999999999999996, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.80000000000000004.
-template <typename Tp>
-void test119()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data119)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data119[i].k), Tp(data119[i].nu),
-                   Tp(data119[i].phi));
-      const Tp f0 = data119[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.90000000000000002.
-testcase_ellint_3<double> data120[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17300769173837280, 0.19999999999999996, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33761123827372508, 0.19999999999999996, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48845905690769426, 0.19999999999999996, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62407720017324986, 0.19999999999999996, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74578146525124289, 0.19999999999999996, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85621583540073076, 0.19999999999999996, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95837725988001199, 0.19999999999999996, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0551821412633928, 0.19999999999999996, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1493679916141863, 0.19999999999999996, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.19999999999999996, nu=0.90000000000000002.
-template <typename Tp>
-void test120()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data120)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data120[i].k), Tp(data120[i].nu),
-                   Tp(data120[i].phi));
-      const Tp f0 = data120[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5624826890976725e-16
+// mean(f - f_Boost): 2.3314683517128288e-16
+// variance(f - f_Boost): 2.9401198977189756e-31
+// stddev(f - f_Boost): 5.4222872459129045e-16
+const testcase_ellint_3<double>
+data110[10] =
+{
+  { 0.0000000000000000, 0.10000000000000009, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17615353510599349, 0.10000000000000009, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36244964892922371, 0.10000000000000009, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57132457590110530, 0.10000000000000009, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82087808820385000, 0.10000000000000009, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1411894342144451, 0.10000000000000009, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5875929286844597, 0.10000000000000009, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2678622986596659, 0.10000000000000009, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.3697528941897903, 0.10000000000000009, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 4.9862890417305499, 0.10000000000000009, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler110 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.2156475739151676e-16
+// mean(f - f_Boost): -5.2735593669694933e-17
+// variance(f - f_Boost): 3.0473442641042680e-32
+// stddev(f - f_Boost): 1.7456644190978597e-16
+const testcase_ellint_3<double>
+data111[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17456817290292806, 0.20000000000000018, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34934315932086796, 0.20000000000000018, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52450880529443988, 0.20000000000000018, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70020491009844887, 0.20000000000000018, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87651006649967977, 0.20000000000000018, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0534305870298994, 0.20000000000000018, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2308975521670789, 0.20000000000000018, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4087733584990738, 0.20000000000000018, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5868678474541662, 0.20000000000000018, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler111 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.10000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.0890622182605400e-16
+// mean(f - f_Boost): -3.8857805861880476e-17
+// variance(f - f_Boost): 2.8794792590749608e-32
+// stddev(f - f_Boost): 1.6969028431454054e-16
+const testcase_ellint_3<double>
+data112[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17474469953608965, 0.20000000000000018, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35073860234984255, 0.20000000000000018, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52912258712951521, 0.20000000000000018, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71081701558898069, 0.20000000000000018, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89640758521169384, 0.20000000000000018, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0860417038089853, 0.20000000000000018, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2793599255528623, 0.20000000000000018, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4754938544089076, 0.20000000000000018, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6731552050562593, 0.20000000000000018, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler112 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.9570963716579749e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 3.1158217732380362e-32
+// stddev(f - f_Boost): 1.7651690494788412e-16
+const testcase_ellint_3<double>
+data113[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17492186907740698, 0.20000000000000018, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35215414286134267, 0.20000000000000018, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53388285615182440, 0.20000000000000018, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72200960282688265, 0.20000000000000018, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91793087614428526, 0.20000000000000018, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1222602841587976, 0.20000000000000018, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3345489407496247, 0.20000000000000018, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5531225705475502, 0.20000000000000018, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7751816279738935, 0.20000000000000018, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler113 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.6785817924053817e-16
+// mean(f - f_Boost): -1.1102230246251566e-17
+// variance(f - f_Boost): 9.9840208317034302e-32
+// stddev(f - f_Boost): 3.1597501217190311e-16
+const testcase_ellint_3<double>
+data114[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17509968571715159, 0.20000000000000018, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35359030214835629, 0.20000000000000018, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53879807274537084, 0.20000000000000018, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73384116418059731, 0.20000000000000018, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.94132799329524031, 0.20000000000000018, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1628407021801439, 0.20000000000000018, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3982440216739438, 0.20000000000000018, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6450634983653640, 0.20000000000000018, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8983924169967099, 0.20000000000000018, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler114 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.40000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.6738449250038925e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 2.7810428396951687e-32
+// stddev(f - f_Boost): 1.6676458975739331e-16
+const testcase_ellint_3<double>
+data115[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17527815368535152, 0.20000000000000018, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35504762134297801, 0.20000000000000018, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54387742353211344, 0.20000000000000018, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74637910471804259, 0.20000000000000018, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96690539714174639, 0.20000000000000018, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2087859420184757, 0.20000000000000018, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4729799844168852, 0.20000000000000018, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7564445064596661, 0.20000000000000018, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0512956926676806, 0.20000000000000018, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler115 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3841806057292116e-16
+// mean(f - f_Boost): 3.6082248300317589e-17
+// variance(f - f_Boost): 8.9638010532618564e-32
+// stddev(f - f_Boost): 2.9939607634806868e-16
+const testcase_ellint_3<double>
+data116[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17545727725228877, 0.20000000000000018, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35652666242062175, 0.20000000000000018, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54913090549102406, 0.20000000000000018, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75970161209211551, 0.20000000000000018, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99504737401590326, 0.20000000000000018, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2614666007124373, 0.20000000000000018, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5625255355205498, 0.20000000000000018, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8954460255613346, 0.20000000000000018, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2481046259421302, 0.20000000000000018, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler116 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5317584994994743e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 1.0045745697575397e-31
+// stddev(f - f_Boost): 3.1695024369095219e-16
+const testcase_ellint_3<double>
+data117[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17563706072900442, 0.20000000000000018, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35802800926807238, 0.20000000000000018, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55456942250515051, 0.20000000000000018, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77390003828438203, 0.20000000000000018, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0262441366366397, 0.20000000000000018, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3228192988439669, 0.20000000000000018, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6728005754680795, 0.20000000000000018, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0761587107468511, 0.20000000000000018, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.5148333891629315, 0.20000000000000018, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler117 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2209418045118284e-16
+// mean(f - f_Boost): 2.4980018054066023e-17
+// variance(f - f_Boost): 9.1989071679544611e-32
+// stddev(f - f_Boost): 3.0329700242426498e-16
+const testcase_ellint_3<double>
+data118[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17581750846781172, 0.20000000000000018, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35955226882028513, 0.20000000000000018, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56020489659466499, 0.20000000000000018, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78908196988531498, 0.20000000000000018, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0611336754143517, 0.20000000000000018, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3956969951058884, 0.20000000000000018, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8138131612209609, 0.20000000000000018, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3256365528879561, 0.20000000000000018, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.9058704854500963, 0.20000000000000018, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler118 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7399960886656824e-16
+// mean(f - f_Boost): 1.3877787807814457e-16
+// variance(f - f_Boost): 1.7585404776158019e-31
+// stddev(f - f_Boost): 4.1934955319110593e-16
+const testcase_ellint_3<double>
+data119[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17599862486281712, 0.20000000000000018, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36110007227128776, 0.20000000000000018, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56605039658567224, 0.20000000000000018, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80537523874517691, 0.20000000000000018, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1005662342414086, 0.20000000000000018, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4845340298105778, 0.20000000000000018, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0043332244969392, 0.20000000000000018, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.7052856676744761, 0.20000000000000018, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5622166386422633, 0.20000000000000018, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler119 = 2.5000000000000020e-13;
+
+// Test data for k=0.20000000000000018, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1718503329017390e-16
+// mean(f - f_Boost): 2.3592239273284576e-16
+// variance(f - f_Boost): 2.9295534376290287e-31
+// stddev(f - f_Boost): 5.4125349307224141e-16
+const testcase_ellint_3<double>
+data120[10] =
+{
+  { 0.0000000000000000, 0.20000000000000018, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17618041435044951, 0.20000000000000018, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36267207636502929, 0.20000000000000018, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57212028758237743, 0.20000000000000018, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82293323876704483, 0.20000000000000018, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1457077279880388, 0.20000000000000018, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5967346899325681, 0.20000000000000018, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2856537353421724, 0.20000000000000018, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.4034714304613902, 0.20000000000000018, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.0448269356200370, 0.20000000000000018, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler120 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.0000000000000000.
-testcase_ellint_3<double> data121[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17461228653000102, 0.30000000000000004, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34969146102798415, 0.30000000000000004, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52565822873726320, 0.30000000000000004, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70284226512408532, 0.30000000000000004, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.88144139195111182, 0.30000000000000004, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0614897067260523, 0.30000000000000004, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2428416824174218, 0.30000000000000004, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4251795877015925, 0.30000000000000004, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6080486199305126, 0.30000000000000004, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.0000000000000000.
-template <typename Tp>
-void test121()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data121)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data121[i].k), Tp(data121[i].nu),
-                   Tp(data121[i].phi));
-      const Tp f0 = data121[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2241249691539529e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 2.1399221604302621e-32
+// stddev(f - f_Boost): 1.4628472785736254e-16
+const testcase_ellint_3<double>
+data121[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17461228653000099, 0.30000000000000004, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34969146102798421, 0.30000000000000004, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52565822873726309, 0.30000000000000004, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70284226512408543, 0.30000000000000004, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.88144139195111171, 0.30000000000000004, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0614897067260520, 0.30000000000000004, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2428416824174220, 0.30000000000000004, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4251795877015929, 0.30000000000000004, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6080486199305128, 0.30000000000000004, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler121 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.10000000000000001.
-testcase_ellint_3<double> data122[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17443631884814378, 0.30000000000000004, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34831316835124926, 0.30000000000000004, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52116586276523857, 0.30000000000000004, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69269385837910036, 0.30000000000000004, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.86279023163070856, 0.30000000000000004, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0315321461438265, 0.30000000000000004, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1991449111869024, 0.30000000000000004, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3659561780923211, 0.30000000000000004, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5323534693557526, 0.30000000000000004, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.10000000000000001.
-template <typename Tp>
-void test122()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data122)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data122[i].k), Tp(data122[i].nu),
-                   Tp(data122[i].phi));
-      const Tp f0 = data122[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1872304407982844e-16
+// mean(f - f_Boost): 7.2164496600635178e-17
+// variance(f - f_Boost): 4.3555500115139682e-32
+// stddev(f - f_Boost): 2.0869954507650391e-16
+const testcase_ellint_3<double>
+data122[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17478889331392972, 0.30000000000000004, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35108939018329183, 0.30000000000000004, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53028990896115835, 0.30000000000000004, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71352417052371409, 0.30000000000000004, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.90153086032405894, 0.30000000000000004, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0945187977283313, 0.30000000000000004, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2920699268385683, 0.30000000000000004, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4931243665896394, 0.30000000000000004, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6960848815118226, 0.30000000000000004, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler122 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.20000000000000001.
-testcase_ellint_3<double> data123[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17426098615372090, 0.30000000000000004, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34695402664689923, 0.30000000000000004, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51680555567038933, 0.30000000000000004, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68303375225260210, 0.30000000000000004, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.84540662891295026, 0.30000000000000004, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0041834051646927, 0.30000000000000004, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1599952702345711, 0.30000000000000004, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3137179520499163, 0.30000000000000004, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4663658145259875, 0.30000000000000004, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.20000000000000001.
-template <typename Tp>
-void test123()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data123)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data123[i].k), Tp(data123[i].nu),
-                   Tp(data123[i].phi));
-      const Tp f0 = data123[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.29999999999999999.
-testcase_ellint_3<double> data124[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17408628437042845, 0.30000000000000004, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34561356761638401, 0.30000000000000004, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51257058617875850, 0.30000000000000004, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67382207124602866, 0.30000000000000004, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82914751587825131, 0.30000000000000004, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.97907434814374950, 0.30000000000000004, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1246399297351584, 0.30000000000000004, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2671793970398146, 0.30000000000000004, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4081767433479089, 0.30000000000000004, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.29999999999999999.
-template <typename Tp>
-void test124()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data124)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data124[i].k), Tp(data124[i].nu),
-                   Tp(data124[i].phi));
-      const Tp f0 = data124[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2247497610332889e-16
+// mean(f - f_Boost): 6.6613381477509390e-17
+// variance(f - f_Boost): 1.7591111235252501e-32
+// stddev(f - f_Boost): 1.3263148659067538e-16
+const testcase_ellint_3<double>
+data123[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17496614335337535, 0.30000000000000004, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35250745937139372, 0.30000000000000004, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53506875002836884, 0.30000000000000004, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72479106622248191, 0.30000000000000004, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.92326451535891607, 0.30000000000000004, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1312092060698349, 0.30000000000000004, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3481473154592321, 0.30000000000000004, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5722049569662750, 0.30000000000000004, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8002173372290500, 0.30000000000000004, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler123 = 2.5000000000000020e-13;
+
+// Test data for k=0.30000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1678685180047551e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
+const testcase_ellint_3<double>
+data124[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17514404084107435, 0.30000000000000004, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35394619108645647, 0.30000000000000004, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54000325463372689, 0.30000000000000004, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73670193794067651, 0.30000000000000004, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.94689345491722177, 0.30000000000000004, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1723274608389140, 0.30000000000000004, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4128880552936287, 0.30000000000000004, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6659010047449661, 0.30000000000000004, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.9260216862473254, 0.30000000000000004, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler124 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.40000000000000002.
-testcase_ellint_3<double> data125[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17391220945982730, 0.30000000000000004, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34429133937639689, 0.30000000000000004, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50845471668581632, 0.30000000000000004, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66502347027873854, 0.30000000000000004, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.81389191978012254, 0.30000000000000004, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.95590618002140593, 0.30000000000000004, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0924915195213121, 0.30000000000000004, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2253651604038058, 0.30000000000000004, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3563643538969761, 0.30000000000000004, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.40000000000000002.
-template <typename Tp>
-void test125()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data125)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data125[i].k), Tp(data125[i].nu),
-                   Tp(data125[i].phi));
-      const Tp f0 = data125[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.3983279132797385e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.8245832308692586e-31
+// stddev(f - f_Boost): 4.2715140534349863e-16
+const testcase_ellint_3<double>
+data125[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17532259000954434, 0.30000000000000004, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35540612770983693, 0.30000000000000004, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54510265552938919, 0.30000000000000004, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74932476310965057, 0.30000000000000004, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.97272793583093109, 0.30000000000000004, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2188928987074241, 0.30000000000000004, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4888771674085941, 0.30000000000000004, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7794558498219191, 0.30000000000000004, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0822121773175528, 0.30000000000000004, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler125 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.50000000000000000.
-testcase_ellint_3<double> data126[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17373875742088235, 0.30000000000000004, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34298690571124157, 0.30000000000000004, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50445214859646936, 0.30000000000000004, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65660648352418516, 0.30000000000000004, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79953670639287289, 0.30000000000000004, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.93443393926588558, 0.30000000000000004, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0630838369016911, 0.30000000000000004, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1875197325653026, 0.30000000000000004, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3098448759814960, 0.30000000000000004, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.50000000000000000.
-template <typename Tp>
-void test126()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data126)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data126[i].k), Tp(data126[i].nu),
-                   Tp(data126[i].phi));
-      const Tp f0 = data126[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.59999999999999998.
-testcase_ellint_3<double> data127[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17356592428950826, 0.30000000000000004, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34169984536697379, 0.30000000000000004, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50055748266498457, 0.30000000000000004, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64854298527106768, 0.30000000000000004, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.78599329284207431, 0.30000000000000004, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.91445452089128221, 0.30000000000000004, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0360412952290587, 0.30000000000000004, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1530473919778639, 0.30000000000000004, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2677758800420666, 0.30000000000000004, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.59999999999999998.
-template <typename Tp>
-void test127()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data127)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data127[i].k), Tp(data127[i].nu),
-                   Tp(data127[i].phi));
-      const Tp f0 = data127[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.69999999999999996.
-testcase_ellint_3<double> data128[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17339370613812227, 0.30000000000000004, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34042975138455933, 0.30000000000000004, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49676568368075985, 0.30000000000000004, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64080774055753720, 0.30000000000000004, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.77318507779667278, 0.30000000000000004, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.89579782346548631, 0.30000000000000004, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0110573286052202, 0.30000000000000004, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1214710972949633, 0.30000000000000004, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2294913236274980, 0.30000000000000004, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.69999999999999996.
-template <typename Tp>
-void test128()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data128)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data128[i].k), Tp(data128[i].nu),
-                   Tp(data128[i].phi));
-      const Tp f0 = data128[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0516138451673425e-16
+// mean(f - f_Boost): 4.7184478546569152e-17
+// variance(f - f_Boost): 1.9448563670505968e-32
+// stddev(f - f_Boost): 1.3945810722401896e-16
+const testcase_ellint_3<double>
+data126[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17550179513158179, 0.30000000000000004, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35688783251681200, 0.30000000000000004, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55037700010142798, 0.30000000000000004, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.76273839789895992, 0.30000000000000004, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0011570518830419, 0.30000000000000004, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2722987414055109, 0.30000000000000004, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5799590511080066, 0.30000000000000004, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.9212367220124293, 0.30000000000000004, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2833505881933971, 0.30000000000000004, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler126 = 2.5000000000000020e-13;
+
+// Test data for k=0.30000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2121157428443725e-16
+// mean(f - f_Boost): 1.9428902930940239e-16
+// variance(f - f_Boost): 1.5987596229703424e-31
+// stddev(f - f_Boost): 3.9984492281012430e-16
+const testcase_ellint_3<double>
+data127[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17568166052076745, 0.30000000000000004, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35839189074731181, 0.30000000000000004, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55583724744367558, 0.30000000000000004, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77703498090888223, 0.30000000000000004, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0326772113675962, 0.30000000000000004, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3345139983717369, 0.30000000000000004, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6921742922838403, 0.30000000000000004, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.1056608968472186, 0.30000000000000004, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.5560975528589061, 0.30000000000000004, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler127 = 2.5000000000000020e-13;
+
+// Test data for k=0.30000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0088945789059381e-16
+// mean(f - f_Boost): 2.1094237467877973e-16
+// variance(f - f_Boost): 3.0253363535298873e-31
+// stddev(f - f_Boost): 5.5003057674368314e-16
+const testcase_ellint_3<double>
+data128[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17586219053197988, 0.30000000000000004, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35991891074557669, 0.30000000000000004, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56149538019961731, 0.30000000000000004, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.79232303189667685, 0.30000000000000004, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0679345542878826, 0.30000000000000004, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4084400085913955, 0.30000000000000004, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8357382859296454, 0.30000000000000004, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3604197996171519, 0.30000000000000004, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.9562123549913872, 0.30000000000000004, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler128 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.80000000000000004.
-testcase_ellint_3<double> data129[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17322209907520361, 0.30000000000000004, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33917623046949996, 0.30000000000000004, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49307204894329176, 0.30000000000000004, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63337802830291723, 0.30000000000000004, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.76104540997689407, 0.30000000000000004, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.87832009635450736, 0.30000000000000004, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.98787879723171790, 0.30000000000000004, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0924036340069336, 0.30000000000000004, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1944567571590046, 0.30000000000000004, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.80000000000000004.
-template <typename Tp>
-void test129()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data129)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data129[i].k), Tp(data129[i].nu),
-                   Tp(data129[i].phi));
-      const Tp f0 = data129[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1197887707781618e-16
+// mean(f - f_Boost): 3.4416913763379854e-16
+// variance(f - f_Boost): 4.3461914185990199e-31
+// stddev(f - f_Boost): 6.5925650687718054e-16
+const testcase_ellint_3<double>
+data129[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17604338956191670, 0.30000000000000004, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36146952517410791, 0.30000000000000004, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56736453393774644, 0.30000000000000004, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80873149979001091, 0.30000000000000004, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1077903069860620, 0.30000000000000004, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4985874311132998, 0.30000000000000004, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0298167266724954, 0.30000000000000004, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.7483929054985432, 0.30000000000000004, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.6283050484567170, 0.30000000000000004, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler129 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.90000000000000002.
-testcase_ellint_3<double> data130[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17305109924485948, 0.30000000000000004, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33793890239556984, 0.30000000000000004, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48947218005089738, 0.30000000000000004, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62623332340775151, 0.30000000000000004, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74951596581511148, 0.30000000000000004, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.86189886597756005, 0.30000000000000004, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.96629451153092005, 0.30000000000000004, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0655269133492680, 0.30000000000000004, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1622376896064912, 0.30000000000000004, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.30000000000000004, nu=0.90000000000000002.
-template <typename Tp>
-void test130()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data130)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data130[i].k), Tp(data130[i].nu),
-                   Tp(data130[i].phi));
-      const Tp f0 = data130[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.0000000000000000.
-testcase_ellint_3<double> data131[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17467414669441531, 0.39999999999999991, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35018222772483443, 0.39999999999999991, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52729015917508748, 0.39999999999999991, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70662374407341255, 0.39999999999999991, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.88859210497602170, 0.39999999999999991, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0733136290471379, 0.39999999999999991, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2605612170157061, 0.39999999999999991, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4497513956433437, 0.39999999999999991, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.0000000000000000.
-template <typename Tp>
-void test131()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data131)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data131[i].k), Tp(data131[i].nu),
-                   Tp(data131[i].phi));
-      const Tp f0 = data131[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.10000000000000001.
-testcase_ellint_3<double> data132[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17449806706684673, 0.39999999999999991, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34880048623856075, 0.39999999999999991, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52277322065757403, 0.39999999999999991, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69638072056918376, 0.39999999999999991, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.86968426619831540, 0.39999999999999991, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0428044206578095, 0.39999999999999991, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2158651158274378, 0.39999999999999991, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3889447129893322, 0.39999999999999991, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.10000000000000001.
-template <typename Tp>
-void test132()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data132)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data132[i].k), Tp(data132[i].nu),
-                   Tp(data132[i].phi));
-      const Tp f0 = data132[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.20000000000000001.
-testcase_ellint_3<double> data133[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17432262290723399, 0.39999999999999991, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34743795258968596, 0.39999999999999991, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51838919472805123, 0.39999999999999991, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68663134739057918, 0.39999999999999991, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.85206432981833979, 0.39999999999999991, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0149595349004430, 0.39999999999999991, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1758349405464676, 0.39999999999999991, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3353337673882635, 0.39999999999999991, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.20000000000000001.
-template <typename Tp>
-void test133()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data133)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data133[i].k), Tp(data133[i].nu),
-                   Tp(data133[i].phi));
-      const Tp f0 = data133[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.29999999999999999.
-testcase_ellint_3<double> data134[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17414781013591543, 0.39999999999999991, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34609415696777285, 0.39999999999999991, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51413131295862546, 0.39999999999999991, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67733527622935630, 0.39999999999999991, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.83558675182733266, 0.39999999999999991, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.98940140808865906, 0.39999999999999991, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1396968797728058, 0.39999999999999991, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2875920037865087, 0.39999999999999991, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.29999999999999999.
-template <typename Tp>
-void test134()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data134)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data134[i].k), Tp(data134[i].nu),
-                   Tp(data134[i].phi));
-      const Tp f0 = data134[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.40000000000000002.
-testcase_ellint_3<double> data135[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17397362471112710, 0.39999999999999991, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34476864603333196, 0.39999999999999991, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50999329415379357, 0.39999999999999991, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66845674551396017, 0.39999999999999991, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.82012848346231748, 0.39999999999999991, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.96582449258349057, 0.39999999999999991, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1068473749476286, 0.39999999999999991, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2447132729159986, 0.39999999999999991, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.40000000000000002.
-template <typename Tp>
-void test135()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data135)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data135[i].k), Tp(data135[i].nu),
-                   Tp(data135[i].phi));
-      const Tp f0 = data135[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.50000000000000000.
-testcase_ellint_3<double> data136[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17380006262854139, 0.39999999999999991, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34346098216756610, 0.39999999999999991, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50596929935059420, 0.39999999999999991, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65996392089131262, 0.39999999999999991, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.80558463511364786, 0.39999999999999991, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.94397834522857704, 0.39999999999999991, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0768075114108115, 0.39999999999999991, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2059184624251329, 0.39999999999999991, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.50000000000000000.
-template <typename Tp>
-void test136()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data136)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data136[i].k), Tp(data136[i].nu),
-                   Tp(data136[i].phi));
-      const Tp f0 = data136[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.59999999999999998.
-testcase_ellint_3<double> data137[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17362711992081248, 0.39999999999999991, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34217074276403953, 0.39999999999999991, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50205389185761617, 0.39999999999999991, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.65182834920372745, 0.39999999999999991, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.79186512820565136, 0.39999999999999991, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.92365535916287134, 0.39999999999999991, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0491915663957907, 0.39999999999999991, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1705934291745104, 0.39999999999999991, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.59999999999999998.
-template <typename Tp>
-void test137()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data137)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data137[i].k), Tp(data137[i].nu),
-                   Tp(data137[i].phi));
-      const Tp f0 = data137[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.69999999999999996.
-testcase_ellint_3<double> data138[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17345479265712871, 0.39999999999999991, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34089751955950354, 0.39999999999999991, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49824200167361343, 0.39999999999999991, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64402450341199413, 0.39999999999999991, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.77889207804122873, 0.39999999999999991, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.90468169720957992, 0.39999999999999991, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0236847823692916, 0.39999999999999991, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1382465247425164, 0.39999999999999991, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.69999999999999996.
-template <typename Tp>
-void test138()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data138)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data138[i].k), Tp(data138[i].nu),
-                   Tp(data138[i].phi));
-      const Tp f0 = data138[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.80000000000000004.
-testcase_ellint_3<double> data139[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17328307694277156, 0.39999999999999991, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33964091800132007, 0.39999999999999991, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49452889372467451, 0.39999999999999991, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63652940095937327, 0.39999999999999991, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.76659772511159097, 0.39999999999999991, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.88691047977338111, 0.39999999999999991, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0000273200611640, 0.39999999999999991, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1084787902188007, 0.39999999999999991, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.80000000000000004.
-template <typename Tp>
-void test139()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data139)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data139[i].k), Tp(data139[i].nu),
-                   Tp(data139[i].phi));
-      const Tp f0 = data139[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.90000000000000002.
-testcase_ellint_3<double> data140[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17311196891868130, 0.39999999999999991, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33840055664911906, 0.39999999999999991, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49091013944075340, 0.39999999999999991, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62932228186809591, 0.39999999999999991, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.75492278323019801, 0.39999999999999991, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.87021659043854294, 0.39999999999999991, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.97800245228239246, 0.39999999999999991, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0809625773173694, 0.39999999999999991, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.39999999999999991, nu=0.90000000000000002.
-template <typename Tp>
-void test140()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data140)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data140[i].k), Tp(data140[i].nu),
-                   Tp(data140[i].phi));
-      const Tp f0 = data140[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1301806687926828e-16
+// mean(f - f_Boost): 4.1633363423443370e-16
+// variance(f - f_Boost): 2.2835347143080263e-31
+// stddev(f - f_Boost): 4.7786344433405093e-16
+const testcase_ellint_3<double>
+data130[10] =
+{
+  { 0.0000000000000000, 0.30000000000000004, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17622526204962433, 0.30000000000000004, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36304439230777141, 0.30000000000000004, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57345914744719195, 0.30000000000000004, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82641512928845162, 0.30000000000000004, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1534256210757743, 0.30000000000000004, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6124900353411677, 0.30000000000000004, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.3165905514845089, 0.30000000000000004, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.4625619526539824, 0.30000000000000004, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.1479514944016787, 0.30000000000000004, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler130 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.0000000000000000.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0831445028587608e-15
+// mean(f - f_Boost): 1.7486012637846215e-16
+// variance(f - f_Boost): 3.1664095331106078e-31
+// stddev(f - f_Boost): 5.6270858649132121e-16
+const testcase_ellint_3<double>
+data131[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17467414669441528, 0.40000000000000013, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35018222772483443, 0.40000000000000013, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52729015917508748, 0.40000000000000013, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70662374407341244, 0.40000000000000013, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.88859210497602159, 0.40000000000000013, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0733136290471381, 0.40000000000000013, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2605612170157066, 0.40000000000000013, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4497513956433439, 0.40000000000000013, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6399998658645112, 0.40000000000000013, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler131 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.10000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0263824105456986e-15
+// mean(f - f_Boost): 1.7486012637846215e-16
+// variance(f - f_Boost): 3.1664095331106078e-31
+// stddev(f - f_Boost): 5.6270858649132121e-16
+const testcase_ellint_3<double>
+data132[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17485086590796767, 0.40000000000000013, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35158366412506992, 0.40000000000000013, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53194731675711726, 0.40000000000000013, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71740615528010931, 0.40000000000000013, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.90896157773487030, 0.40000000000000013, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1069605483834348, 0.40000000000000013, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3109353428823001, 0.40000000000000013, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.5195460789903450, 0.40000000000000013, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.7306968836847190, 0.40000000000000013, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler132 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.20000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.6644296021947179e-16
+// mean(f - f_Boost): 2.0816681711721685e-16
+// variance(f - f_Boost): 3.0360740073926687e-31
+// stddev(f - f_Boost): 5.5100580826273227e-16
+const testcase_ellint_3<double>
+data133[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17502822886437389, 0.40000000000000013, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35300530062530805, 0.40000000000000013, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53675259548210896, 0.40000000000000013, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72878006428676934, 0.40000000000000013, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.93100219010583574, 0.40000000000000013, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1443487271187611, 0.40000000000000013, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3683427764108813, 0.40000000000000013, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6008221459300933, 0.40000000000000013, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8380358826317627, 0.40000000000000013, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler133 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0271556462838835e-16
+// mean(f - f_Boost): 2.0816681711721685e-16
+// variance(f - f_Boost): 3.0360740073926687e-31
+// stddev(f - f_Boost): 5.5100580826273227e-16
+const testcase_ellint_3<double>
+data134[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17520623975982899, 0.40000000000000013, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35444766141612105, 0.40000000000000013, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54171455841536009, 0.40000000000000013, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.74080517001084012, 0.40000000000000013, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.95496950509296574, 0.40000000000000013, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1862627879844718, 0.40000000000000013, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4346501803799458, 0.40000000000000013, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6971744798077699, 0.40000000000000013, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.9677924132520139, 0.40000000000000013, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler134 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3436329231972794e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 2.9507053793392374e-31
+// stddev(f - f_Boost): 5.4320395611033958e-16
+const testcase_ellint_3<double>
+data135[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17538490283034375, 0.40000000000000013, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35591129064319948, 0.40000000000000013, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54684250413264535, 0.40000000000000013, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.75355027742668290, 0.40000000000000013, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.98117935026780634, 0.40000000000000013, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2337464222030736, 0.40000000000000013, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5125183419289221, 0.40000000000000013, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.8140224451130313, 0.40000000000000013, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.1289968719280026, 0.40000000000000013, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler135 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.50000000000000000.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.7013794022122431e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
+const testcase_ellint_3<double>
+data136[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17556422235224273, 0.40000000000000013, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35739675341763921, 0.40000000000000013, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55214655195037188, 0.40000000000000013, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.76709520942047438, 0.40000000000000013, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0100278761577499, 0.40000000000000013, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2882265661384342, 0.40000000000000013, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6059059780051876, 0.40000000000000013, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.9600182740224081, 0.40000000000000013, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.3367461373176512, 0.40000000000000013, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler136 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.60000000000000009.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.4792115132836117e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 4.8893797490374802e-31
+// stddev(f - f_Boost): 6.9924099915819294e-16
+const testcase_ellint_3<double>
+data137[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17574420264267029, 0.40000000000000013, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35890463689046265, 0.40000000000000013, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55763773975194486, 0.40000000000000013, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.78153324227761267, 0.40000000000000013, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0420205885765887, 0.40000000000000013, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3517205230381770, 0.40000000000000013, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.7210360970313896, 0.40000000000000013, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.1500780510169246, 0.40000000000000013, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.6186940209850191, 0.40000000000000013, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler137 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.8573292020719759e-16
+// mean(f - f_Boost): 2.2759572004815707e-16
+// variance(f - f_Boost): 2.9613098824898137e-31
+// stddev(f - f_Boost): 5.4417918762938862e-16
+const testcase_ellint_3<double>
+data138[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17592484806010436, 0.40000000000000013, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36043555139631439, 0.40000000000000013, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56332813669944881, 0.40000000000000013, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.79697424562157548, 0.40000000000000013, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0778155987523672, 0.40000000000000013, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4272018169896268, 0.40000000000000013, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8684377907453382, 0.40000000000000013, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.4128677409207473, 0.40000000000000013, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.0327078743873246, 0.40000000000000013, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler138 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.80000000000000004.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.5273712585384737e-16
+// mean(f - f_Boost): 4.5241588253475131e-16
+// variance(f - f_Boost): 1.1866477068555882e-30
+// stddev(f - f_Boost): 1.0893336067778265e-15
+const testcase_ellint_3<double>
+data139[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17610616300487833, 0.40000000000000013, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36199013167171978, 0.40000000000000013, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56923097361842434, 0.40000000000000013, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.81354878456624347, 0.40000000000000013, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1182902719261825, 0.40000000000000013, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5192950589409022, 0.40000000000000013, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0678761710223981, 0.40000000000000013, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.8135222249879788, 0.40000000000000013, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.7289548002199902, 0.40000000000000013, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler139 = 2.5000000000000020e-13;
+
+// Test data for k=0.40000000000000013, nu=0.90000000000000002.
+// max(|f - f_Boost|): 6.2172489379008766e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.1718379478872251e-15
+// mean(f - f_Boost): 8.4099394115355610e-16
+// variance(f - f_Boost): 3.5684096037099424e-30
+// stddev(f - f_Boost): 1.8890234523980751e-15
+const testcase_ellint_3<double>
+data140[10] =
+{
+  { 0.0000000000000000, 0.40000000000000013, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17628815191971123, 0.40000000000000013, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36356903815378772, 0.40000000000000013, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57536079447000310, 0.40000000000000013, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.83141355850172571, 0.40000000000000013, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1646481598721361, 0.40000000000000013, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6357275034001995, 0.40000000000000013, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.3628787566572402, 0.40000000000000013, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.5521010369134962, 0.40000000000000013, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.3055535102872513, 0.40000000000000013, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler140 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.0000000000000000.
-testcase_ellint_3<double> data141[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17475385514035785, 0.50000000000000000, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35081868470101585, 0.50000000000000000, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52942862705190585, 0.50000000000000000, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.71164727562630326, 0.50000000000000000, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.89824523594227768, 0.50000000000000000, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0895506700518851, 0.50000000000000000, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2853005857432933, 0.50000000000000000, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4845545520549484, 0.50000000000000000, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.0000000000000000.
-template <typename Tp>
-void test141()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data141)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data141[i].k), Tp(data141[i].nu),
-                   Tp(data141[i].phi));
-      const Tp f0 = data141[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.4551389361831220e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.5893058141206173e-32
+// stddev(f - f_Boost): 1.6091320064309879e-16
+const testcase_ellint_3<double>
+data141[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17475385514035785, 0.50000000000000000, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35081868470101579, 0.50000000000000000, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52942862705190574, 0.50000000000000000, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.71164727562630326, 0.50000000000000000, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.89824523594227768, 0.50000000000000000, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0895506700518853, 0.50000000000000000, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2853005857432933, 0.50000000000000000, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4845545520549488, 0.50000000000000000, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6857503548125961, 0.50000000000000000, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler141 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.10000000000000001.
-testcase_ellint_3<double> data142[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17457763120814676, 0.50000000000000000, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34943246340849154, 0.50000000000000000, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52487937869610801, 0.50000000000000000, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.70127785096388395, 0.50000000000000000, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.87898815988624479, 0.50000000000000000, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0582764576094172, 0.50000000000000000, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2391936844060207, 0.50000000000000000, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.4214793542995841, 0.50000000000000000, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.10000000000000001.
-template <typename Tp>
-void test142()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data142)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data142[i].k), Tp(data142[i].nu),
-                   Tp(data142[i].phi));
-      const Tp f0 = data142[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7416868347177582e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
+const testcase_ellint_3<double>
+data142[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17493071928248824, 0.50000000000000000, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35222467688034798, 0.50000000000000000, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53411928652008112, 0.50000000000000000, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.72256398117177589, 0.50000000000000000, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.91899583232771009, 0.50000000000000000, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1240549163055360, 0.50000000000000000, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3372938086286021, 0.50000000000000000, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.5570024469132429, 0.50000000000000000, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.7803034946545480, 0.50000000000000000, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler142 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.20000000000000001.
-testcase_ellint_3<double> data143[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17440204336345433, 0.50000000000000000, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34806552388338824, 0.50000000000000000, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52046416757129821, 0.50000000000000000, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.69140924550993876, 0.50000000000000000, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.86104678636125520, 0.50000000000000000, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0297439459053981, 0.50000000000000000, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1979214112912036, 0.50000000000000000, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3659033858648930, 0.50000000000000000, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.20000000000000001.
-template <typename Tp>
-void test143()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data143)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data143[i].k), Tp(data143[i].nu),
-                   Tp(data143[i].phi));
-      const Tp f0 = data143[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.29999999999999999.
-testcase_ellint_3<double> data144[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17422708752228896, 0.50000000000000000, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34671739434855858, 0.50000000000000000, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51617616305641889, 0.50000000000000000, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.68200047612545178, 0.50000000000000000, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.84427217869498372, 0.50000000000000000, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0035637821389782, 0.50000000000000000, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1606800483933113, 0.50000000000000000, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.3164407134643459, 0.50000000000000000, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.29999999999999999.
-template <typename Tp>
-void test144()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data144)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data144[i].k), Tp(data144[i].nu),
-                   Tp(data144[i].phi));
-      const Tp f0 = data144[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1198767993730867e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 5.0311947683004831e-32
+// stddev(f - f_Boost): 2.2430324938128922e-16
+const testcase_ellint_3<double>
+data143[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17510822779582402, 0.50000000000000000, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35365094725531487, 0.50000000000000000, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53895933237328697, 0.50000000000000000, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.73408090840070794, 0.50000000000000000, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.94145442818535396, 0.50000000000000000, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1624120186296487, 0.50000000000000000, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3965823372867114, 0.50000000000000000, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6414308440430099, 0.50000000000000000, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8922947612264018, 0.50000000000000000, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler143 = 2.5000000000000020e-13;
+
+// Test data for k=0.50000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3800262770228813e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 8.5027191584278157e-32
+// stddev(f - f_Boost): 2.9159422419567599e-16
+const testcase_ellint_3<double>
+data144[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17528638488102041, 0.50000000000000000, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35509802222332720, 0.50000000000000000, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54395740731866193, 0.50000000000000000, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.74625871438752667, 0.50000000000000000, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.96588271186092023, 0.50000000000000000, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2054319584357329, 0.50000000000000000, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4651077994832871, 0.50000000000000000, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.7416018368052644, 0.50000000000000000, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.0277924458111314, 0.50000000000000000, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler144 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.40000000000000002.
-testcase_ellint_3<double> data145[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17405275963859917, 0.50000000000000000, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34538761957029329, 0.50000000000000000, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51200902646603919, 0.50000000000000000, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.67301522212868792, 0.50000000000000000, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.82853844466313320, 0.50000000000000000, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.97942097862681488, 0.50000000000000000, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1268429801220616, 0.50000000000000000, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2720406704533922, 0.50000000000000000, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.40000000000000002.
-template <typename Tp>
-void test145()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data145)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data145[i].k), Tp(data145[i].nu),
-                   Tp(data145[i].phi));
-      const Tp f0 = data145[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.0439932918341581e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 9.0809736800018602e-32
+// stddev(f - f_Boost): 3.0134653938616686e-16
+const testcase_ellint_3<double>
+data145[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17546519477859268, 0.50000000000000000, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35656644822531680, 0.50000000000000000, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54912289677411319, 0.50000000000000000, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.75916731611690047, 0.50000000000000000, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.99260415631328214, 0.50000000000000000, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2541925856918670, 0.50000000000000000, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5456393705347609, 0.50000000000000000, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.8631904972952076, 0.50000000000000000, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.1962905366178065, 0.50000000000000000, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler145 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.50000000000000000.
-testcase_ellint_3<double> data146[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17387905570381157, 0.50000000000000000, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34407576010465207, 0.50000000000000000, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50795686560160835, 0.50000000000000000, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.66442115453330175, 0.50000000000000000, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.81373829119355345, 0.50000000000000000, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.95705743313235825, 0.50000000000000000, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0959131991362556, 0.50000000000000000, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2318900529754597, 0.50000000000000000, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.50000000000000000.
-template <typename Tp>
-void test146()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data146)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data146[i].k), Tp(data146[i].nu),
-                   Tp(data146[i].phi));
-      const Tp f0 = data146[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.59999999999999998.
-testcase_ellint_3<double> data147[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17370597174637581, 0.50000000000000000, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34278139158591414, 0.50000000000000000, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50401419439302719, 0.50000000000000000, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.65618938076167221, 0.50000000000000000, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.79977959248855424, 0.50000000000000000, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.93625925190753545, 0.50000000000000000, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0674905658379710, 0.50000000000000000, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1953481298023048, 0.50000000000000000, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.59999999999999998.
-template <typename Tp>
-void test147()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data147)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data147[i].k), Tp(data147[i].nu),
-                   Tp(data147[i].phi));
-      const Tp f0 = data147[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.69999999999999996.
-testcase_ellint_3<double> data148[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17353350383131641, 0.50000000000000000, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34150410405436771, 0.50000000000000000, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50017589696443487, 0.50000000000000000, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64829398188419962, 0.50000000000000000, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.78658270782402073, 0.50000000000000000, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.91684738336675053, 0.50000000000000000, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0412486789555937, 0.50000000000000000, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1619021847612001, 0.50000000000000000, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.69999999999999996.
-template <typename Tp>
-void test148()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data148)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data148[i].k), Tp(data148[i].nu),
-                   Tp(data148[i].phi));
-      const Tp f0 = data148[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6797816859260978e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
+const testcase_ellint_3<double>
+data146[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17564466176941509, 0.50000000000000000, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35805679276065394, 0.50000000000000000, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55446601496200032, 0.50000000000000000, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.77288783578259013, 0.50000000000000000, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0220246013918972, 0.50000000000000000, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3101681612463965, 0.50000000000000000, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6422994881851025, 0.50000000000000000, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.0152636030998816, 0.50000000000000000, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.4136715042011945, 0.50000000000000000, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler146 = 2.5000000000000020e-13;
+
+// Test data for k=0.50000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9178421578645735e-16
+// mean(f - f_Boost): 1.3322676295501878e-16
+// variance(f - f_Boost): 1.7749370367472766e-31
+// stddev(f - f_Boost): 4.2130001622920411e-16
+const testcase_ellint_3<double>
+data147[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17582479017522740, 0.50000000000000000, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35956964546660036, 0.50000000000000000, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55999790372984193, 0.50000000000000000, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.78751507911209895, 0.50000000000000000, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0546620505035220, 0.50000000000000000, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3754438357425935, 0.50000000000000000, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.7615727400820127, 0.50000000000000000, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.2134638067565242, 0.50000000000000000, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.7090491861753558, 0.50000000000000000, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler147 = 2.5000000000000020e-13;
+
+// Test data for k=0.50000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0745105182189226e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 1.9996383743576116e-32
+// stddev(f - f_Boost): 1.4140857026211713e-16
+const testcase_ellint_3<double>
+data148[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17600558435914915, 0.50000000000000000, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36110561926726259, 0.50000000000000000, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56573074641137111, 0.50000000000000000, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.80316073084237205, 0.50000000000000000, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0911910688131461, 0.50000000000000000, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4530946406380640, 0.50000000000000000, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.9144386536785372, 0.50000000000000000, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.4878788958234970, 0.50000000000000000, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.1433945297859225, 0.50000000000000000, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler148 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.80000000000000004.
-testcase_ellint_3<double> data149[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17336164805979126, 0.50000000000000000, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34024350132086773, 0.50000000000000000, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49643719555734084, 0.50000000000000000, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.64071162456976150, 0.50000000000000000, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.77407836177211908, 0.50000000000000000, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.89867058251905652, 0.50000000000000000, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0169181822134912, 0.50000000000000000, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1311363312779448, 0.50000000000000000, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.80000000000000004.
-template <typename Tp>
-void test149()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data149)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data149[i].k), Tp(data149[i].nu),
-                   Tp(data149[i].phi));
-      const Tp f0 = data149[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.4380477375534667e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
+const testcase_ellint_3<double>
+data149[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17618704872620228, 0.50000000000000000, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36266535159745827, 0.50000000000000000, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57167789954529158, 0.50000000000000000, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.81995752984315018, 0.50000000000000000, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1325112162158122, 0.50000000000000000, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5479055930718042, 0.50000000000000000, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.1215243941010486, 0.50000000000000000, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.9069405767650132, 0.50000000000000000, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.8750701888108066, 0.50000000000000000, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler149 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.90000000000000002.
-testcase_ellint_3<double> data150[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17319040056865681, 0.50000000000000000, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33899920036578557, 0.50000000000000000, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49279362182695186, 0.50000000000000000, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.63342123379746151, 0.50000000000000000, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.76220595179550321, 0.50000000000000000, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.88160004743532294, 0.50000000000000000, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.99427448642310134, 0.50000000000000000, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1027091512470093, 0.50000000000000000, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.50000000000000000, nu=0.90000000000000002.
-template <typename Tp>
-void test150()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data150)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data150[i].k), Tp(data150[i].nu),
-                   Tp(data150[i].phi));
-      const Tp f0 = data150[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6192315188521289e-16
+// mean(f - f_Boost): 3.5249581031848718e-16
+// variance(f - f_Boost): 2.5029385557256515e-31
+// stddev(f - f_Boost): 5.0029376927217987e-16
+const testcase_ellint_3<double>
+data150[10] =
+{
+  { 0.0000000000000000, 0.50000000000000000, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17636918772384180, 0.50000000000000000, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36424950570740700, 0.50000000000000000, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57785404590231426, 0.50000000000000000, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.83806480521716531, 0.50000000000000000, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1798568683069752, 0.50000000000000000, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6678766243739607, 0.50000000000000000, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.4282976450693483, 0.50000000000000000, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.6810787666126656, 0.50000000000000000, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.5355132096026454, 0.50000000000000000, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler150 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.0000000000000000.
-testcase_ellint_3<double> data151[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17485154362988362, 0.60000000000000009, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35160509865544326, 0.60000000000000009, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53210652578446160, 0.60000000000000009, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.71805304664485670, 0.60000000000000009, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.91082759030195970, 0.60000000000000009, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1112333229323366, 0.60000000000000009, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.3191461190365270, 0.60000000000000009, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.5332022105084775, 0.60000000000000009, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.0000000000000000.
-template <typename Tp>
-void test151()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data151)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data151[i].k), Tp(data151[i].nu),
-                   Tp(data151[i].phi));
-      const Tp f0 = data151[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.3664899092028927e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 7.8758646268991113e-33
+// stddev(f - f_Boost): 8.8746068233466605e-17
+const testcase_ellint_3<double>
+data151[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17485154362988359, 0.60000000000000009, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35160509865544320, 0.60000000000000009, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53210652578446138, 0.60000000000000009, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.71805304664485659, 0.60000000000000009, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.91082759030195981, 0.60000000000000009, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1112333229323361, 0.60000000000000009, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.3191461190365270, 0.60000000000000009, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.5332022105084779, 0.60000000000000009, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler151 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.10000000000000001.
-testcase_ellint_3<double> data152[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17467514275022014, 0.60000000000000009, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35021333086258255, 0.60000000000000009, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52751664092962713, 0.60000000000000009, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.70752126971957885, 0.60000000000000009, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.89111058756112871, 0.60000000000000009, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0789241202877773, 0.60000000000000009, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2710800210399946, 0.60000000000000009, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.4669060574440278, 0.60000000000000009, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.10000000000000001.
-template <typename Tp>
-void test152()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data152)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data152[i].k), Tp(data152[i].nu),
-                   Tp(data152[i].phi));
-      const Tp f0 = data152[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.2335247010355137e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 2.2835347143080263e-33
+// stddev(f - f_Boost): 4.7786344433405099e-17
+const testcase_ellint_3<double>
+data152[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17502858548476194, 0.60000000000000009, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35301673150537388, 0.60000000000000009, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53683932476326812, 0.60000000000000009, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.72914228589586771, 0.60000000000000009, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.93208036718354692, 0.60000000000000009, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1468984688863377, 0.60000000000000009, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3733904977062528, 0.60000000000000009, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.6094225663372157, 0.60000000000000009, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.8508766487100685, 0.60000000000000009, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler152 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.20000000000000001.
-testcase_ellint_3<double> data153[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17449937871800653, 0.60000000000000009, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34884093647346553, 0.60000000000000009, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52306221119844110, 0.60000000000000009, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.69749955678982223, 0.60000000000000009, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.87274610682416853, 0.60000000000000009, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0494620540750796, 0.60000000000000009, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.2280847305507339, 0.60000000000000009, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.4085436279696888, 0.60000000000000009, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.20000000000000001.
-template <typename Tp>
-void test153()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data153)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data153[i].k), Tp(data153[i].nu),
-                   Tp(data153[i].phi));
-      const Tp f0 = data153[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.29999999999999999.
-testcase_ellint_3<double> data154[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17432424744393935, 0.60000000000000009, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34748744127146447, 0.60000000000000009, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51873632743924847, 0.60000000000000009, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.68794610396313127, 0.60000000000000009, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.85558070175468726, 0.60000000000000009, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0224416343605658, 0.60000000000000009, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1893144457936788, 0.60000000000000009, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.3566435377982575, 0.60000000000000009, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.29999999999999999.
-template <typename Tp>
-void test154()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data154)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data154[i].k), Tp(data154[i].nu),
-                   Tp(data154[i].phi));
-      const Tp f0 = data154[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -2.4980018054066023e-17
+// variance(f - f_Boost): 2.1685495635542404e-32
+// stddev(f - f_Boost): 1.4725995937641163e-16
+const testcase_ellint_3<double>
+data153[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17520627248155893, 0.60000000000000009, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35444873935437748, 0.60000000000000009, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54172310557682524, 0.60000000000000009, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.74084300280734672, 0.60000000000000009, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.95509001527006121, 0.60000000000000009, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1865688084431796, 0.60000000000000009, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.4352978868932600, 0.60000000000000009, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6983400371331818, 0.60000000000000009, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.9695980282802217, 0.60000000000000009, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler153 = 2.5000000000000020e-13;
+
+// Test data for k=0.60000000000000009, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.9470074709717020e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
+const testcase_ellint_3<double>
+data154[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17538460882640122, 0.60000000000000009, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35590165133735557, 0.60000000000000009, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54676661152254535, 0.60000000000000009, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.75321709418305305, 0.60000000000000009, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.98012637808992920, 0.60000000000000009, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2310891277158875, 0.60000000000000009, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.5069157924585623, 0.60000000000000009, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.8039583598337940, 0.60000000000000009, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.1134154405060599, 0.60000000000000009, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler154 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.40000000000000002.
-testcase_ellint_3<double> data155[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17414974487670720, 0.60000000000000009, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34615238767335027, 0.60000000000000009, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51453257838108579, 0.60000000000000009, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.67882386787534410, 0.60000000000000009, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.83948470233173578, 0.60000000000000009, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.99753496200074021, 0.60000000000000009, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1541101404388487, 0.60000000000000009, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.3100911323398816, 0.60000000000000009, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.40000000000000002.
-template <typename Tp>
-void test155()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data155)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data155[i].k), Tp(data155[i].nu),
-                   Tp(data155[i].phi));
-      const Tp f0 = data155[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.8974839914337670e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.2849613290816465e-32
+// stddev(f - f_Boost): 1.5116088545260797e-16
+const testcase_ellint_3<double>
+data155[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17556359876533037, 0.60000000000000009, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35737601674244679, 0.60000000000000009, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55197933771320218, 0.60000000000000009, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.76633591620002905, 0.60000000000000009, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0075231136019616, 0.60000000000000009, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2815842073813450, 0.60000000000000009, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5911666941449827, 0.60000000000000009, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.9323227566025762, 0.60000000000000009, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.2925036420985130, 0.60000000000000009, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler155 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.50000000000000000.
-testcase_ellint_3<double> data156[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17397586700252810, 0.60000000000000009, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34483533397138516, 0.60000000000000009, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51044500461706499, 0.60000000000000009, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.67009988034712675, 0.60000000000000009, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.82434762375735193, 0.60000000000000009, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.97447346702799043, 0.60000000000000009, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.1219494000522143, 0.60000000000000009, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2680242605954488, 0.60000000000000009, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.50000000000000000.
-template <typename Tp>
-void test156()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data156)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data156[i].k), Tp(data156[i].nu),
-                   Tp(data156[i].phi));
-      const Tp f0 = data156[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.59999999999999998.
-testcase_ellint_3<double> data157[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17380260984469356, 0.60000000000000009, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34353585361777839, 0.60000000000000009, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50646805774321402, 0.60000000000000009, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.66174468108625517, 0.60000000000000009, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.81007462280278408, 0.60000000000000009, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.95303466945718773, 0.60000000000000009, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0924118588677503, 0.60000000000000009, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.2297640574847937, 0.60000000000000009, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.59999999999999998.
-template <typename Tp>
-void test157()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data157)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data157[i].k), Tp(data157[i].nu),
-                   Tp(data157[i].phi));
-      const Tp f0 = data157[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.69999999999999996.
-testcase_ellint_3<double> data158[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17362996946312009, 0.60000000000000009, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34225353454870588, 0.60000000000000009, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50259656397799546, 0.60000000000000009, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.65373184496628944, 0.60000000000000009, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.79658372884056439, 0.60000000000000009, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.93303240100245466, 0.60000000000000009, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0651547944716557, 0.60000000000000009, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1947676204853441, 0.60000000000000009, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.3232737468822811, 0.60000000000000009, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.69999999999999996.
-template <typename Tp>
-void test158()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data158)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data158[i].k), Tp(data158[i].nu),
-                   Tp(data158[i].phi));
-      const Tp f0 = data158[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.1397785842303966e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.5339913122479866e-32
+// stddev(f - f_Boost): 1.2385440291923362e-16
+const testcase_ellint_3<double>
+data156[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17574324658480217, 0.60000000000000009, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35887240603169313, 0.60000000000000009, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55737161826345261, 0.60000000000000009, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.78028227313077458, 0.60000000000000009, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0376989776486290, 0.60000000000000009, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3395933991042928, 0.60000000000000009, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6924049626591784, 0.60000000000000009, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.0931011856518920, 0.60000000000000009, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.5239007084492711, 0.60000000000000009, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler156 = 2.5000000000000020e-13;
+
+// Test data for k=0.60000000000000009, nu=0.60000000000000009.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.6651378277398083e-16
+// mean(f - f_Boost): 1.1934897514720432e-16
+// variance(f - f_Boost): 1.7585404776158019e-33
+// stddev(f - f_Boost): 4.1934955319110598e-17
+const testcase_ellint_3<double>
+data157[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17592355661219386, 0.60000000000000009, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36039141192661606, 0.60000000000000009, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.56295472636903854, 0.60000000000000009, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.79515295130165986, 0.60000000000000009, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0711886441942242, 0.60000000000000009, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.4072952835139891, 0.60000000000000009, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.8174863977376825, 0.60000000000000009, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.3029921578542232, 0.60000000000000009, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.8388723099514972, 0.60000000000000009, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler157 = 2.5000000000000020e-13;
+
+// Test data for k=0.60000000000000009, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.0027679235921772e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.2849613290816465e-32
+// stddev(f - f_Boost): 1.5116088545260797e-16
+const testcase_ellint_3<double>
+data158[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17610453321631936, 0.60000000000000009, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36193365056369764, 0.60000000000000009, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56874098962268527, 0.60000000000000009, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.81106198671477181, 0.60000000000000009, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1086886419010082, 0.60000000000000009, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4879048567239257, 0.60000000000000009, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.9780310073615925, 0.60000000000000009, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.5941545586772712, 0.60000000000000009, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.3029735898397159, 0.60000000000000009, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler158 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.80000000000000004.
-testcase_ellint_3<double> data159[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17345794195390687, 0.60000000000000009, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34098797854531027, 0.60000000000000009, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49882569168826230, 0.60000000000000009, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.64603758566475511, 0.60000000000000009, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.78380365594769730, 0.60000000000000009, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.91430946255611223, 0.60000000000000009, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0398955217270607, 0.60000000000000009, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1625948314277679, 0.60000000000000009, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.80000000000000004.
-template <typename Tp>
-void test159()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data159)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data159[i].k), Tp(data159[i].nu),
-                   Tp(data159[i].phi));
-      const Tp f0 = data159[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 7.3044933435043190e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
+const testcase_ellint_3<double>
+data159[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17628618080795252, 0.60000000000000009, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36349976272521012, 0.60000000000000009, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57474392342151914, 0.60000000000000009, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.82814493499158170, 0.60000000000000009, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1511281795998280, 0.60000000000000009, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5864286332503075, 0.60000000000000009, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.1958944866494527, 0.60000000000000009, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.0398358172574604, 0.60000000000000009, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.0867036409261832, 0.60000000000000009, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler159 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.90000000000000002.
-testcase_ellint_3<double> data160[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17328652344890033, 0.60000000000000009, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33973880062929018, 0.60000000000000009, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49515092233122765, 0.60000000000000009, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.63864042139737043, 0.60000000000000009, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.77167205646538850, 0.60000000000000009, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.89673202848034428, 0.60000000000000009, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0163984492661304, 0.60000000000000009, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1328845785162431, 0.60000000000000009, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.2479362973851875, 0.60000000000000009, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.60000000000000009, nu=0.90000000000000002.
-template <typename Tp>
-void test160()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data160)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data160[i].k), Tp(data160[i].nu),
-                   Tp(data160[i].phi));
-      const Tp f0 = data160[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.0000000000000000.
-testcase_ellint_3<double> data161[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17496737466916720, 0.69999999999999996, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35254687535677925, 0.69999999999999996, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53536740275997130, 0.69999999999999996, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.72603797651684465, 0.69999999999999996, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.92698296348313458, 0.69999999999999996, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1400447527693316, 0.69999999999999996, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.3657668117194071, 0.69999999999999996, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.6024686895959159, 0.69999999999999996, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.0000000000000000.
-template <typename Tp>
-void test161()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data161)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data161[i].k), Tp(data161[i].nu),
-                   Tp(data161[i].phi));
-      const Tp f0 = data161[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.10000000000000001.
-testcase_ellint_3<double> data162[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17479076384884681, 0.69999999999999996, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35114844900396364, 0.69999999999999996, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53072776947527012, 0.69999999999999996, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.71530198262386246, 0.69999999999999996, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.90666760677828306, 0.69999999999999996, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1063366517438080, 0.69999999999999996, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.3149477243092147, 0.69999999999999996, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.5314886725038925, 0.69999999999999996, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.10000000000000001.
-template <typename Tp>
-void test162()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data162)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data162[i].k), Tp(data162[i].nu),
-                   Tp(data162[i].phi));
-      const Tp f0 = data162[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.20000000000000001.
-testcase_ellint_3<double> data163[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17461479077791472, 0.69999999999999996, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34976950621407538, 0.69999999999999996, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52622533231350188, 0.69999999999999996, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.70508774017895226, 0.69999999999999996, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.88775302531730294, 0.69999999999999996, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0756195476149006, 0.69999999999999996, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.2695349716654372, 0.69999999999999996, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.4690814617070540, 0.69999999999999996, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.6721098780092147, 0.69999999999999996, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.20000000000000001.
-template <typename Tp>
-void test163()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data163)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data163[i].k), Tp(data163[i].nu),
-                   Tp(data163[i].phi));
-      const Tp f0 = data163[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.29999999999999999.
-testcase_ellint_3<double> data164[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17443945136076172, 0.69999999999999996, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34840956983535287, 0.69999999999999996, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52185308551329179, 0.69999999999999996, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.69535240431168266, 0.69999999999999996, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.87007983473964923, 0.69999999999999996, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0474657975577066, 0.69999999999999996, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.2286225419931889, 0.69999999999999996, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.4136490671013271, 0.69999999999999996, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.29999999999999999.
-template <typename Tp>
-void test164()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data164)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data164[i].k), Tp(data164[i].nu),
-                   Tp(data164[i].phi));
-      const Tp f0 = data164[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.40000000000000002.
-testcase_ellint_3<double> data165[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17426474153983226, 0.69999999999999996, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34706817945773732, 0.69999999999999996, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51760452851738159, 0.69999999999999996, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.68605801534722766, 0.69999999999999996, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.85351339387296532, 0.69999999999999996, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0215297967969537, 0.69999999999999996, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1915051074460528, 0.69999999999999996, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.3639821911744707, 0.69999999999999996, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.40000000000000002.
-template <typename Tp>
-void test165()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data165)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data165[i].k), Tp(data165[i].nu),
-                   Tp(data165[i].phi));
-      const Tp f0 = data165[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.50000000000000000.
-testcase_ellint_3<double> data166[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17409065729516093, 0.69999999999999996, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34574489064986091, 0.69999999999999996, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51347361925579793, 0.69999999999999996, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.67717079489579290, 0.69999999999999996, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.83793902055292280, 0.69999999999999996, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.99752863545289705, 0.69999999999999996, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.1576240080401499, 0.69999999999999996, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.3191464023923762, 0.69999999999999996, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.50000000000000000.
-template <typename Tp>
-void test166()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data166)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data166[i].k), Tp(data166[i].nu),
-                   Tp(data166[i].phi));
-      const Tp f0 = data166[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.59999999999999998.
-testcase_ellint_3<double> data167[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17391719464391611, 0.69999999999999996, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34443927423869031, 0.69999999999999996, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50945473266486074, 0.69999999999999996, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.66866056326513823, 0.69999999999999996, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.82325830002337352, 0.69999999999999996, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.97522808245669357, 0.69999999999999996, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.1265300613705282, 0.69999999999999996, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.2784066076152003, 0.69999999999999996, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.59999999999999998.
-template <typename Tp>
-void test167()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data167)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data167[i].k), Tp(data167[i].nu),
-                   Tp(data167[i].phi));
-      const Tp f0 = data167[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.69999999999999996.
-testcase_ellint_3<double> data168[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17374434963995028, 0.69999999999999996, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34315091562900674, 0.69999999999999996, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50554262375653358, 0.69999999999999996, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.66050025406305812, 0.69999999999999996, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.80938620118847404, 0.69999999999999996, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.95443223855852144, 0.69999999999999996, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0978573207128302, 0.69999999999999996, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.2411754575007123, 0.69999999999999996, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.69999999999999996.
-template <typename Tp>
-void test168()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data168)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data168[i].k), Tp(data168[i].nu),
-                   Tp(data168[i].phi));
-      const Tp f0 = data168[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.80000000000000004.
-testcase_ellint_3<double> data169[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17357211837335737, 0.69999999999999996, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34187941416012108, 0.69999999999999996, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50173239465478270, 0.69999999999999996, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.65266550725988315, 0.69999999999999996, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.79624879865249298, 0.69999999999999996, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.93497577043296920, 0.69999999999999996, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0713041566930748, 0.69999999999999996, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.2069772023255652, 0.69999999999999996, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.3427110650397533, 0.69999999999999996, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.80000000000000004.
-template <typename Tp>
-void test169()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data169)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data169[i].k), Tp(data169[i].nu),
-                   Tp(data169[i].phi));
-      const Tp f0 = data169[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.90000000000000002.
-testcase_ellint_3<double> data170[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17340049697003634, 0.69999999999999996, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34062438249741556, 0.69999999999999996, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49801946510076878, 0.69999999999999996, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.64513432604750487, 0.69999999999999996, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.78378145487573758, 0.69999999999999996, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.91671799500854634, 0.69999999999999996, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0466193579463123, 0.69999999999999996, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1754218079199146, 0.69999999999999996, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.3040500499695911, 0.69999999999999996, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.69999999999999996, nu=0.90000000000000002.
-template <typename Tp>
-void test170()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data170)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data170[i].k), Tp(data170[i].nu),
-                   Tp(data170[i].phi));
-      const Tp f0 = data170[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.5952142720718732e-16
+// mean(f - f_Boost): 4.6351811278100284e-16
+// variance(f - f_Boost): 2.1278339779151204e-31
+// stddev(f - f_Boost): 4.6128450851021651e-16
+const testcase_ellint_3<double>
+data160[10] =
+{
+  { 0.0000000000000000, 0.60000000000000009, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17646850384035848, 0.60000000000000009, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36509041515134105, 0.60000000000000009, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58097838596260631, 0.60000000000000009, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.84656453396163722, 0.60000000000000009, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1997828426963724, 0.60000000000000009, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.7112436789225605, 0.60000000000000009, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.5193168553672312, 0.60000000000000009, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.8656670488606690, 0.60000000000000009, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.8709993116265604, 0.60000000000000009, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler160 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1569224977685422e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 1.6571557210371951e-32
+// stddev(f - f_Boost): 1.2873056051447903e-16
+const testcase_ellint_3<double>
+data161[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17496737466916723, 0.70000000000000018, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35254687535677931, 0.70000000000000018, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53536740275997130, 0.70000000000000018, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.72603797651684454, 0.70000000000000018, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.92698296348313447, 0.70000000000000018, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1400447527693318, 0.70000000000000018, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.3657668117194073, 0.70000000000000018, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.6024686895959164, 0.70000000000000018, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.8456939983747236, 0.70000000000000018, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler161 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.9552278747527691e-16
+// mean(f - f_Boost): 1.1102230246251565e-16
+// variance(f - f_Boost): 1.3695501826753678e-32
+// stddev(f - f_Boost): 1.1702778228589004e-16
+const testcase_ellint_3<double>
+data162[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17514462737300920, 0.70000000000000018, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35396527997470451, 0.70000000000000018, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54015179589433981, 0.70000000000000018, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.73734430854477728, 0.70000000000000018, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.94888950796697047, 0.70000000000000018, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1772807959736322, 0.70000000000000018, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.4231796401075834, 0.70000000000000018, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.6841856799887471, 0.70000000000000018, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.9541347343119564, 0.70000000000000018, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler162 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.7430437016285820e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
+const testcase_ellint_3<double>
+data163[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17532252613350796, 0.70000000000000018, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35540417596807522, 0.70000000000000018, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54508913033361928, 0.70000000000000018, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.74927635777718415, 0.70000000000000018, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.97261706337936338, 0.70000000000000018, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.2187303976209327, 0.70000000000000018, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.4887796709222487, 0.70000000000000018, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.7796581281839214, 0.70000000000000018, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.0829290325820207, 0.70000000000000018, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler163 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.30000000000000004.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.2570807706941696e-16
+// mean(f - f_Boost): 8.8817841970012528e-17
+// variance(f - f_Boost): 1.5582437633995295e-32
+// stddev(f - f_Boost): 1.2482963443828271e-16
+const testcase_ellint_3<double>
+data164[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17550107516328570, 0.70000000000000018, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35686409576571965, 0.70000000000000018, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55018827316513352, 0.70000000000000018, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.76189759494390275, 0.70000000000000018, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.99844623430885626, 0.70000000000000018, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2652862989039833, 0.70000000000000018, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.5647666808691361, 0.70000000000000018, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.8932499694938165, 0.70000000000000018, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.2392290510988535, 0.70000000000000018, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler164 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.3719045096496910e-16
+// mean(f - f_Boost): 1.3600232051658169e-16
+// variance(f - f_Boost): 1.1718213750516114e-32
+// stddev(f - f_Boost): 1.0825069861444829e-16
+const testcase_ellint_3<double>
+data165[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17568027871494424, 0.70000000000000018, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35834559208180261, 0.70000000000000018, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55545885451190613, 0.70000000000000018, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.77528120402568113, 0.70000000000000018, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0267241287600322, 0.70000000000000018, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.3181380338980246, 0.70000000000000018, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.6542840785132087, 0.70000000000000018, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.0315595131131823, 0.70000000000000018, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.4342502915307880, 0.70000000000000018, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler165 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.0277361210295499e-16
+// mean(f - f_Boost): 1.6930901125533636e-16
+// variance(f - f_Boost): 6.3799163752809956e-32
+// stddev(f - f_Boost): 2.5258496343371268e-16
+const testcase_ellint_3<double>
+data166[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17586014108156545, 0.70000000000000018, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35984923894341653, 0.70000000000000018, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.56091135606739995, 0.70000000000000018, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.78951212635197054, 0.70000000000000018, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0578865732938731, 0.70000000000000018, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3789149005151722, 0.70000000000000018, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.7620212286086228, 0.70000000000000018, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.2051554347435589, 0.70000000000000018, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.6868019968236996, 0.70000000000000018, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler166 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.8597454441867134e-16
+// mean(f - f_Boost): 2.5535129566378598e-16
+// variance(f - f_Boost): 2.8561208198482198e-31
+// stddev(f - f_Boost): 5.3442687243889785e-16
+const testcase_ellint_3<double>
+data167[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17604066659721918, 0.70000000000000018, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36137563278353424, 0.70000000000000018, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.56655721272747606, 0.70000000000000018, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.80468966552978305, 0.70000000000000018, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0924902943683852, 0.70000000000000018, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.4499247992499800, 0.70000000000000018, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.8953714382113818, 0.70000000000000018, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.4323229949248670, 0.70000000000000018, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.0314573496746746, 0.70000000000000018, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler167 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.2316852368580916e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 7.4564398834547797e-34
+// stddev(f - f_Boost): 2.7306482533374340e-17
+const testcase_ellint_3<double>
+data168[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17622185963747933, 0.70000000000000018, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36292539360435261, 0.70000000000000018, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.57240892970150015, 0.70000000000000018, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.82093084713182629, 0.70000000000000018, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1312609022179871, 0.70000000000000018, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.5345768067715795, 0.70000000000000018, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.0668847445934424, 0.70000000000000018, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.7483444537551245, 0.70000000000000018, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.5408408771788569, 0.70000000000000018, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler168 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1198716111867353e-16
+// mean(f - f_Boost): 2.2482016248659419e-16
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
+const testcase_ellint_3<double>
+data169[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17640372461994805, 0.70000000000000018, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36449916621651091, 0.70000000000000018, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57848021800372584, 0.70000000000000018, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.83837480968392586, 0.70000000000000018, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1751669030061143, 0.70000000000000018, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.6381851899173603, 0.70000000000000018, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.3002065924302197, 0.70000000000000018, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.2337600665337871, 0.70000000000000018, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.4042405729076970, 0.70000000000000018, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler169 = 2.5000000000000020e-13;
+
+// Test data for k=0.70000000000000018, nu=0.90000000000000002.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.5869439826269878e-16
+// mean(f - f_Boost): 7.4384942649885490e-16
+// variance(f - f_Boost): 9.7403930714297352e-31
+// stddev(f - f_Boost): 9.8693429727767263e-16
+const testcase_ellint_3<double>
+data170[10] =
+{
+  { 0.0000000000000000, 0.70000000000000018, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17658626600478800, 0.70000000000000018, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36609762156017206, 0.70000000000000018, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58478615187842409, 0.70000000000000018, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.85718862878291846, 0.70000000000000018, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.2255385617397643, 0.70000000000000018, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.7696521899992941, 0.70000000000000018, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.6476314987883507, 0.70000000000000018, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 4.1373434902898083, 0.70000000000000018, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 6.3796094177887763, 0.70000000000000018, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler170 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.0000000000000000.
-testcase_ellint_3<double> data171[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17510154241338902, 0.80000000000000004, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35365068839779390, 0.80000000000000004, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53926804409084561, 0.80000000000000004, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.73587926028070383, 0.80000000000000004, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.94770942970071170, 0.80000000000000004, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1789022995388239, 0.80000000000000004, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.4323027881876009, 0.80000000000000004, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.7069629739121674, 0.80000000000000004, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.0000000000000000.
-template <typename Tp>
-void test171()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data171)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data171[i].k), Tp(data171[i].nu),
-                   Tp(data171[i].phi));
-      const Tp f0 = data171[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.5543122344752192e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7898565163847540e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.1368406725192426e-31
+// stddev(f - f_Boost): 4.6225974002926564e-16
+const testcase_ellint_3<double>
+data171[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17510154241338899, 0.80000000000000004, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35365068839779396, 0.80000000000000004, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53926804409084550, 0.80000000000000004, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.73587926028070372, 0.80000000000000004, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.94770942970071170, 0.80000000000000004, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1789022995388236, 0.80000000000000004, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.4323027881876012, 0.80000000000000004, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.7069629739121677, 0.80000000000000004, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.9953027776647294, 0.80000000000000004, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler171 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.10000000000000001.
-testcase_ellint_3<double> data172[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17492468824017166, 0.80000000000000004, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35224443521476911, 0.80000000000000004, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53456851853226961, 0.80000000000000004, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.72488875602364944, 0.80000000000000004, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.92661354274638952, 0.80000000000000004, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1432651144499077, 0.80000000000000004, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.3774479927211429, 0.80000000000000004, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.6287092337196041, 0.80000000000000004, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.10000000000000001.
-template <typename Tp>
-void test172()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data172)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data172[i].k), Tp(data172[i].nu),
-                   Tp(data172[i].phi));
-      const Tp f0 = data172[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3898786942190374e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.9190059990693968e-31
+// stddev(f - f_Boost): 5.4027826155319237e-16
+const testcase_ellint_3<double>
+data172[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17527903952342144, 0.80000000000000004, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35507705313548549, 0.80000000000000004, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54411455987643553, 0.80000000000000004, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.74745625666804383, 0.80000000000000004, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.97046953684238557, 0.80000000000000004, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.2183080025184605, 0.80000000000000004, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.4943711151994405, 0.80000000000000004, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.7972401309544201, 0.80000000000000004, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 2.1172616484005085, 0.80000000000000004, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler172 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.20000000000000001.
-testcase_ellint_3<double> data173[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17474847286224943, 0.80000000000000004, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.35085779529084682, 0.80000000000000004, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.53000829263059157, 0.80000000000000004, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.71443466027453406, 0.80000000000000004, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.90698196872715420, 0.80000000000000004, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.1108198200558581, 0.80000000000000004, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.3284988909963957, 0.80000000000000004, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.5600369318140328, 0.80000000000000004, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.20000000000000001.
-template <typename Tp>
-void test173()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data173)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data173[i].k), Tp(data173[i].nu),
-                   Tp(data173[i].phi));
-      const Tp f0 = data173[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.29999999999999999.
-testcase_ellint_3<double> data174[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17457289217669891, 0.80000000000000004, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34949028801501258, 0.80000000000000004, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52558024362769318, 0.80000000000000004, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.70447281740094914, 0.80000000000000004, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.88864745641528986, 0.80000000000000004, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0811075819341465, 0.80000000000000004, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.2844589654082377, 0.80000000000000004, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.4991461361277849, 0.80000000000000004, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.29999999999999999.
-template <typename Tp>
-void test174()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data174)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data174[i].k), Tp(data174[i].nu),
-                   Tp(data174[i].phi));
-      const Tp f0 = data174[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.8513740186068518e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 2.7528339102381189e-31
+// stddev(f - f_Boost): 5.2467455724840699e-16
+const testcase_ellint_3<double>
+data173[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17545718375086419, 0.80000000000000004, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35652404627248163, 0.80000000000000004, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54911638512920913, 0.80000000000000004, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.75967684282131176, 0.80000000000000004, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.99513526893543769, 0.80000000000000004, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.2622192109995993, 0.80000000000000004, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.5654106676347741, 0.80000000000000004, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.9029531718534984, 0.80000000000000004, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.2624789434186798, 0.80000000000000004, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler173 = 2.5000000000000020e-13;
+
+// Test data for k=0.80000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.2825261583337354e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 2.8249350208968825e-31
+// stddev(f - f_Boost): 5.3150117788175054e-16
+const testcase_ellint_3<double>
+data174[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17563597931587369, 0.80000000000000004, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35799220412005128, 0.80000000000000004, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55428253691111318, 0.80000000000000004, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.77260647376977365, 0.80000000000000004, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 1.0220015271210958, 0.80000000000000004, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.3115965312302671, 0.80000000000000004, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.6478518468813512, 0.80000000000000004, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 2.0290458414203481, 0.80000000000000004, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.4392042002725693, 0.80000000000000004, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler174 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.40000000000000002.
-testcase_ellint_3<double> data175[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17439794211872178, 0.80000000000000004, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34814144964568972, 0.80000000000000004, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.52127776285273075, 0.80000000000000004, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.69496411438966599, 0.80000000000000004, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.87146878427509589, 0.80000000000000004, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0537579024937762, 0.80000000000000004, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.2445534387922637, 0.80000000000000004, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.4446769766361993, 0.80000000000000004, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.40000000000000002.
-template <typename Tp>
-void test175()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data175)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data175[i].k), Tp(data175[i].nu),
-                   Tp(data175[i].phi));
-      const Tp f0 = data175[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3462748389836647e-16
+// mean(f - f_Boost): 3.3861802251067273e-16
+// variance(f - f_Boost): 4.3719465706454422e-31
+// stddev(f - f_Boost): 6.6120696991527871e-16
+const testcase_ellint_3<double>
+data175[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17581543047866136, 0.80000000000000004, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35948208343061633, 0.80000000000000004, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55962280893702021, 0.80000000000000004, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.78632063889234116, 0.80000000000000004, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0514333069550323, 0.80000000000000004, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.3677213138838757, 0.80000000000000004, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.7451736773665165, 0.80000000000000004, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.1830100424586831, 0.80000000000000004, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.6604037035529724, 0.80000000000000004, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler175 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.50000000000000000.
-testcase_ellint_3<double> data176[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17422361866118047, 0.80000000000000004, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34681083254170475, 0.80000000000000004, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51709470815494440, 0.80000000000000004, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.68587375344080259, 0.80000000000000004, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.85532571852810624, 0.80000000000000004, 0.50000000000000000,
-          0.87266462599716477 },
-  { 1.0284677391874906, 0.80000000000000004, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.2081693942686225, 0.80000000000000004, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.3955803006426311, 0.80000000000000004, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.50000000000000000.
-template <typename Tp>
-void test176()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data176)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data176[i].k), Tp(data176[i].nu),
-                   Tp(data176[i].phi));
-      const Tp f0 = data176[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.59999999999999998.
-testcase_ellint_3<double> data177[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17404991781414092, 0.80000000000000004, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34549800443625167, 0.80000000000000004, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.51302536167001556, 0.80000000000000004, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.67717065003912258, 0.80000000000000004, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.84011512421134416, 0.80000000000000004, 0.59999999999999998,
-          0.87266462599716477 },
-  { 1.0049863847088742, 0.80000000000000004, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.1748145941898918, 0.80000000000000004, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.3510319699755071, 0.80000000000000004, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.59999999999999998.
-template <typename Tp>
-void test177()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data177)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data177[i].k), Tp(data177[i].nu),
-                   Tp(data177[i].phi));
-      const Tp f0 = data177[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.69999999999999996.
-testcase_ellint_3<double> data178[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17387683562442202, 0.80000000000000004, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34420254775101611, 0.80000000000000004, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50906439222143685, 0.80000000000000004, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.66882693152688433, 0.80000000000000004, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.82574792844091316, 0.80000000000000004, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.98310431309490953, 0.80000000000000004, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.1440884535113258, 0.80000000000000004, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.3103743938952537, 0.80000000000000004, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.69999999999999996.
-template <typename Tp>
-void test178()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data178)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data178[i].k), Tp(data178[i].nu),
-                   Tp(data178[i].phi));
-      const Tp f0 = data178[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0388243828581744e-16
+// mean(f - f_Boost): 3.8580250105724191e-16
+// variance(f - f_Boost): 6.4106456575047741e-31
+// stddev(f - f_Boost): 8.0066507713929764e-16
+const testcase_ellint_3<double>
+data176[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17599554153999472, 0.80000000000000004, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.36099426243351540, 0.80000000000000004, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.56514786174780673, 0.80000000000000004, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.80090697622371010, 0.80000000000000004, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0838891627679339, 0.80000000000000004, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.4323506654466280, 0.80000000000000004, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.8625761085390575, 0.80000000000000004, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.3768757305654766, 0.80000000000000004, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.9478781158239746, 0.80000000000000004, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler176 = 2.5000000000000020e-13;
+
+// Test data for k=0.80000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0631099169042069e-15
+// mean(f - f_Boost): 4.8294701571194306e-16
+// variance(f - f_Boost): 1.1633910328160319e-30
+// stddev(f - f_Boost): 1.0786060600682865e-15
+const testcase_ellint_3<double>
+data177[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17617631684170665, 0.80000000000000004, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36252934193666231, 0.80000000000000004, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.57086932622945163, 0.80000000000000004, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.81646796740150973, 0.80000000000000004, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.1199552158519064, 0.80000000000000004, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.5079766673336394, 0.80000000000000004, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 2.0082747447038165, 0.80000000000000004, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.6315146066775523, 0.80000000000000004, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.3418121892288051, 0.80000000000000004, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler177 = 2.5000000000000020e-13;
+
+// Test data for k=0.80000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.6544679145741375e-16
+// mean(f - f_Boost): 3.2751579226442120e-16
+// variance(f - f_Boost): 4.4236851331020672e-31
+// stddev(f - f_Boost): 6.6510789599147505e-16
+const testcase_ellint_3<double>
+data178[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17635776076721221, 0.80000000000000004, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36408794649916976, 0.80000000000000004, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.57679992290624138, 0.80000000000000004, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.83312441418142813, 0.80000000000000004, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1603958891464856, 0.80000000000000004, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.5982855143796213, 0.80000000000000004, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.1962484408371821, 0.80000000000000004, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.9873281786111869, 0.80000000000000004, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.9268876980046397, 0.80000000000000004, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler178 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.80000000000000004.
-testcase_ellint_3<double> data179[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17370436817515206, 0.80000000000000004, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34292405894783395, 0.80000000000000004, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50520682176250087, 0.80000000000000004, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.66081751679736189, 0.80000000000000004, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.81214672249355102, 0.80000000000000004, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.96264481387685574, 0.80000000000000004, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.1156611352656258, 0.80000000000000004, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.2730756225143889, 0.80000000000000004, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.4339837018309474, 0.80000000000000004, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.80000000000000004.
-template <typename Tp>
-void test179()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data179)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data179[i].k), Tp(data179[i].nu),
-                   Tp(data179[i].phi));
-      const Tp f0 = data179[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0176949165011079e-16
+// mean(f - f_Boost): 7.0499162063697436e-16
+// variance(f - f_Boost): 1.7230805408026989e-30
+// stddev(f - f_Boost): 1.3126616246400665e-15
+const testcase_ellint_3<double>
+data179[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17653987774203392, 0.80000000000000004, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36567072568046877, 0.80000000000000004, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.58295359996558616, 0.80000000000000004, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.85101998309176108, 0.80000000000000004, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.2062322059736537, 0.80000000000000004, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.7090321420917429, 0.80000000000000004, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.4529058049405066, 0.80000000000000004, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.5368893360106948, 0.80000000000000004, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.9246422058196062, 0.80000000000000004, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler179 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.90000000000000002.
-testcase_ellint_3<double> data180[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17353251158533153, 0.80000000000000004, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34166214791545768, 0.80000000000000004, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.50144799535130580, 0.80000000000000004, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.65311976193814447, 0.80000000000000004, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.79924384892320866, 0.80000000000000004, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.94345762353365625, 0.80000000000000004, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0892582069219159, 0.80000000000000004, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.2387000876610268, 0.80000000000000004, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.80000000000000004, nu=0.90000000000000002.
-template <typename Tp>
-void test180()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data180)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data180[i].k), Tp(data180[i].nu),
-                   Tp(data180[i].phi));
-      const Tp f0 = data180[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.0000000000000000.
-testcase_ellint_3<double> data181[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17525427376115027, 0.89999999999999991, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35492464591297446, 0.89999999999999991, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.54388221416157123, 0.89999999999999991, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.74797400423532501, 0.89999999999999991, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.97463898451966458, 0.89999999999999991, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.2334463254523438, 0.89999999999999991, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.5355247765594910, 0.89999999999999991, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.8882928567775117, 0.89999999999999991, 0.0000000000000000,
-          1.3962634015954636 },
-  { 2.2805491384227699, 0.89999999999999991, 0.0000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.0000000000000000.
-template <typename Tp>
-void test181()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data181)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data181[i].k), Tp(data181[i].nu),
-                   Tp(data181[i].phi));
-      const Tp f0 = data181[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.10000000000000001.
-testcase_ellint_3<double> data182[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17507714233254659, 0.89999999999999991, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35350932904326521, 0.89999999999999991, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53911129989870987, 0.89999999999999991, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.73666644254508407, 0.89999999999999991, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.95250736612100184, 0.89999999999999991, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1950199550905591, 0.89999999999999991, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.4741687286340848, 0.89999999999999991, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.7968678183506053, 0.89999999999999991, 0.10000000000000001,
-          1.3962634015954636 },
-  { 2.1537868513875282, 0.89999999999999991, 0.10000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.10000000000000001.
-template <typename Tp>
-void test182()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data182)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data182[i].k), Tp(data182[i].nu),
-                   Tp(data182[i].phi));
-      const Tp f0 = data182[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.20000000000000001.
-testcase_ellint_3<double> data183[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17490065089140930, 0.89999999999999991, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.35211377590661436, 0.89999999999999991, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.53448220334204111, 0.89999999999999991, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.72591368943179591, 0.89999999999999991, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.93192539780038763, 0.89999999999999991, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.1600809679692681, 0.89999999999999991, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.4195407225882508, 0.89999999999999991, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.7168966476424521, 0.89999999999999991, 0.20000000000000001,
-          1.3962634015954636 },
-  { 2.0443194576468890, 0.89999999999999991, 0.20000000000000001,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.20000000000000001.
-template <typename Tp>
-void test183()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data183)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data183[i].k), Tp(data183[i].nu),
-                   Tp(data183[i].phi));
-      const Tp f0 = data183[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.29999999999999999.
-testcase_ellint_3<double> data184[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17472479532647534, 0.89999999999999991, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.35073750187374114, 0.89999999999999991, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52998766129466968, 0.89999999999999991, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.71566993548699565, 0.89999999999999991, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.91271517762560195, 0.89999999999999991, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.1281241199843368, 0.89999999999999991, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.3704929576917448, 0.89999999999999991, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.6461981511487711, 0.89999999999999991, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.9486280260314424, 0.89999999999999991, 0.29999999999999999,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.29999999999999999.
-template <typename Tp>
-void test184()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data184)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data184[i].k), Tp(data184[i].nu),
-                   Tp(data184[i].phi));
-      const Tp f0 = data184[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.40000000000000002.
-testcase_ellint_3<double> data185[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17454957156468839, 0.89999999999999991, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34938003933330430, 0.89999999999999991, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.52562093533067444, 0.89999999999999991, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.70589461324915681, 0.89999999999999991, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.89472658511942849, 0.89999999999999991, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0987419542323438, 0.89999999999999991, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.3261349565496301, 0.89999999999999991, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.5831293909853761, 0.89999999999999991, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.8641114227238347, 0.89999999999999991, 0.40000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.40000000000000002.
-template <typename Tp>
-void test185()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data185)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data185[i].k), Tp(data185[i].nu),
-                   Tp(data185[i].phi));
-      const Tp f0 = data185[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.50000000000000000.
-testcase_ellint_3<double> data186[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17437497557073336, 0.89999999999999991, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34804093691586013, 0.89999999999999991, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.52137576320372903, 0.89999999999999991, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.69655163996912262, 0.89999999999999991, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.87783188683054236, 0.89999999999999991, 0.50000000000000000,
-          0.87266462599716477 },
-  { 1.0716015959755183, 0.89999999999999991, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.2857636916026749, 0.89999999999999991, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.5264263913252358, 0.89999999999999991, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.7888013241937859, 0.89999999999999991, 0.50000000000000000,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.50000000000000000.
-template <typename Tp>
-void test186()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data186)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data186[i].k), Tp(data186[i].nu),
-                   Tp(data186[i].phi));
-      const Tp f0 = data186[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.59999999999999998.
-testcase_ellint_3<double> data187[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17420100334657815, 0.89999999999999991, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34671975876122157, 0.89999999999999991, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.51724631570707957, 0.89999999999999991, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.68760879113743034, 0.89999999999999991, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.86192157779698364, 0.89999999999999991, 0.59999999999999998,
-          0.87266462599716477 },
-  { 1.0464279696166352, 0.89999999999999991, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.2488156247094004, 0.89999999999999991, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.4750988777188470, 0.89999999999999991, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.7211781128919521, 0.89999999999999991, 0.59999999999999998,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.59999999999999998.
-template <typename Tp>
-void test187()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data187)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data187[i].k), Tp(data187[i].nu),
-                   Tp(data187[i].phi));
-      const Tp f0 = data187[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.69999999999999996.
-testcase_ellint_3<double> data188[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17402765093102210, 0.89999999999999991, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34541608382635131, 0.89999999999999991, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.51322715827061693, 0.89999999999999991, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.67903717872440283, 0.89999999999999991, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.84690113601682671, 0.89999999999999991, 0.69999999999999996,
-          0.87266462599716477 },
-  { 1.0229914311548416, 0.89999999999999991, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.2148329639709381, 0.89999999999999991, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.4283586501307799, 0.89999999999999991, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.6600480747670936, 0.89999999999999991, 0.69999999999999996,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.69999999999999996.
-template <typename Tp>
-void test188()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data188)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data188[i].k), Tp(data188[i].nu),
-                   Tp(data188[i].phi));
-      const Tp f0 = data188[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.80000000000000004.
-testcase_ellint_3<double> data189[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17385491439925149, 0.89999999999999991, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34412950523113928, 0.89999999999999991, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50931321668729601, 0.89999999999999991, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.67081081392296327, 0.89999999999999991, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.83268846097293259, 0.89999999999999991, 0.80000000000000004,
-          0.87266462599716477 },
-  { 1.0010985015814025, 0.89999999999999991, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.1834394045489678, 0.89999999999999991, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.3855695891683182, 0.89999999999999991, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.6044591960982200, 0.89999999999999991, 0.80000000000000004,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.80000000000000004.
-template <typename Tp>
-void test189()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data189)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data189[i].k), Tp(data189[i].nu),
-                   Tp(data189[i].phi));
-      const Tp f0 = data189[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.90000000000000002.
-testcase_ellint_3<double> data190[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17368278986240138, 0.89999999999999991, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34285962963961397, 0.89999999999999991, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.50549974644993312, 0.89999999999999991, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.66290623857720876, 0.89999999999999991, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.81921183128847164, 0.89999999999999991, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.98058481956066368, 0.89999999999999991, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.1543223520473569, 0.89999999999999991, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.3462119782292934, 0.89999999999999991, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.5536420236310944, 0.89999999999999991, 0.90000000000000002,
-          1.5707963267948966 },
-};
-
-// Test function for k=0.89999999999999991, nu=0.90000000000000002.
-template <typename Tp>
-void test190()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data190)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data190[i].k), Tp(data190[i].nu),
-                   Tp(data190[i].phi));
-      const Tp f0 = data190[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7782721357365268e-16
+// mean(f - f_Boost): 8.9928064994637676e-16
+// variance(f - f_Boost): 1.5485199571025344e-30
+// stddev(f - f_Boost): 1.2443954183066307e-15
+const testcase_ellint_3<double>
+data180[10] =
+{
+  { 0.0000000000000000, 0.80000000000000004, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17672267223433513, 0.80000000000000004, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36727835537196063, 0.80000000000000004, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58934569363716649, 0.80000000000000004, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.87032723471138851, 0.80000000000000004, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.2588676111323349, 0.80000000000000004, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.8498731900660019, 0.80000000000000004, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.8368381299300420, 0.80000000000000004, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 4.5674844191654058, 0.80000000000000004, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 7.2263259298637115, 0.80000000000000004, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler180 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.3381508715713360e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
+const testcase_ellint_3<double>
+data181[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17525427376115027, 0.90000000000000013, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35492464591297446, 0.90000000000000013, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.54388221416157123, 0.90000000000000013, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.74797400423532512, 0.90000000000000013, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.97463898451966446, 0.90000000000000013, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.2334463254523440, 0.90000000000000013, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.5355247765594915, 0.90000000000000013, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.8882928567775128, 0.90000000000000013, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 2.2805491384227707, 0.90000000000000013, 0.0000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler181 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.1500594295134815e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.0357223256482469e-33
+// stddev(f - f_Boost): 3.2182640128619758e-17
+const testcase_ellint_3<double>
+data182[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17543204932716244, 0.90000000000000013, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35636022898551184, 0.90000000000000013, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54880278898382595, 0.90000000000000013, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.75988834774529268, 0.90000000000000013, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.99853303003568117, 0.90000000000000013, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.2759958823999022, 0.90000000000000013, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.6051187364639401, 0.90000000000000013, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.9941406879519474, 0.90000000000000013, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 2.4295011187834890, 0.90000000000000013, 0.10000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler182 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.9533518431433547e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
+const testcase_ellint_3<double>
+data183[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17561047321968409, 0.90000000000000013, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35781659944356109, 0.90000000000000013, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.55388150905215283, 0.90000000000000013, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.77246874123251441, 0.90000000000000013, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 1.0244466254771925, 0.90000000000000013, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.3234824077640801, 0.90000000000000013, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.6849848968804240, 0.90000000000000013, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 2.1185749045502278, 0.90000000000000013, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.6076835743348417, 0.90000000000000013, 0.20000000000000001, 
+	  1.5707963267948966 },
+};
+const double toler183 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.30000000000000004.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.9712691025502371e-16
+// mean(f - f_Boost): 6.9388939039072284e-17
+// variance(f - f_Boost): 5.9442282234173945e-34
+// stddev(f - f_Boost): 2.4380787976227090e-17
+const testcase_ellint_3<double>
+data184[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17578954966746221, 0.90000000000000013, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35929429810867447, 0.90000000000000013, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55912757154240822, 0.90000000000000013, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.78578314722025389, 0.90000000000000013, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 1.0526941001131365, 0.90000000000000013, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.3769682234538601, 0.90000000000000013, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.7779437432911240, 0.90000000000000013, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 2.2676509341813635, 0.90000000000000013, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.8256506968858517, 0.90000000000000013, 0.30000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler184 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.7042235432234642e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
+const testcase_ellint_3<double>
+data185[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17596928293938452, 0.90000000000000013, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.36079388642472821, 0.90000000000000013, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.56455096667115612, 0.90000000000000013, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.79990996997869435, 0.90000000000000013, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0836647913872215, 0.90000000000000013, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.4378726836091849, 0.90000000000000013, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.8880446720682853, 0.90000000000000013, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.4505848932025232, 0.90000000000000013, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 3.1000689868578624, 0.90000000000000013, 0.40000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler185 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.3939646155354115e-16
+// mean(f - f_Boost): 1.5820678100908481e-16
+// variance(f - f_Boost): 1.0089970755557622e-32
+// stddev(f - f_Boost): 1.0044884646205561e-16
+const testcase_ellint_3<double>
+data186[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17614967734498183, 0.90000000000000013, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.36231594750319435, 0.90000000000000013, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.57016256984349567, 0.90000000000000013, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.81494025918293422, 0.90000000000000013, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.1178482279283477, 0.90000000000000013, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.5081455873012106, 0.90000000000000013, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 2.0213599730863998, 0.90000000000000013, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.6822467012926832, 0.90000000000000013, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 3.4591069002104686, 0.90000000000000013, 0.50000000000000000, 
+	  1.5707963267948966 },
+};
+const double toler186 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.4914274070443813e-16
+// mean(f - f_Boost): 3.4694469519536142e-16
+// variance(f - f_Boost): 2.5224926888894056e-31
+// stddev(f - f_Boost): 5.0224423231027804e-16
+const testcase_ellint_3<double>
+data187[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17633073723493825, 0.90000000000000013, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36386108723492810, 0.90000000000000013, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.57597424744716241, 0.90000000000000013, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.83098051948501150, 0.90000000000000013, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.1558706545698916, 0.90000000000000013, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.5905576379415669, 0.90000000000000013, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 2.1875186010215084, 0.90000000000000013, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.9885767771316853, 0.90000000000000013, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.9549939883570238, 0.90000000000000013, 0.60000000000000009, 
+	  1.5707963267948966 },
+};
+const double toler187 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.5442489886293633e-16
+// mean(f - f_Boost): 4.3576253716537392e-16
+// variance(f - f_Boost): 2.2187568928205130e-31
+// stddev(f - f_Boost): 4.7103682370070737e-16
+const testcase_ellint_3<double>
+data188[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17651246700160939, 0.90000000000000013, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36542993547358982, 0.90000000000000013, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.58199897877674867, 0.90000000000000013, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.84815633587352857, 0.90000000000000013, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1985495623872375, 0.90000000000000013, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.6892158134027691, 0.90000000000000013, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.4029722191094236, 0.90000000000000013, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 3.4201084941340061, 0.90000000000000013, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 4.6985482312992444, 0.90000000000000013, 0.70000000000000007, 
+	  1.5707963267948966 },
+};
+const double toler188 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9362432595976420e-16
+// mean(f - f_Boost): 3.0531133177191805e-16
+// variance(f - f_Boost): 1.1508025840536076e-32
+// stddev(f - f_Boost): 1.0727546709539920e-16
+const testcase_ellint_3<double>
+data189[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17669487107954862, 0.90000000000000013, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36702314729628421, 0.90000000000000013, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.58825099711365492, 0.90000000000000013, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.86661711422209031, 0.90000000000000013, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.2469779109884802, 0.90000000000000013, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.8105469760531578, 0.90000000000000013, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.6989505165893752, 0.90000000000000013, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 4.0935213267757433, 0.90000000000000013, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 5.9820740813645727, 0.90000000000000013, 0.80000000000000004, 
+	  1.5707963267948966 },
+};
+const double toler189 = 2.5000000000000020e-13;
+
+// Test data for k=0.90000000000000013, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9577148062669782e-16
+// mean(f - f_Boost): 5.9119376061289588e-16
+// variance(f - f_Boost): 1.7340883003959522e-31
+// stddev(f - f_Boost): 4.1642385863395872e-16
+const testcase_ellint_3<double>
+data190[10] =
+{
+  { 0.0000000000000000, 0.90000000000000013, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17687795394604169, 0.90000000000000013, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36864140434751286, 0.90000000000000013, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.59474595366817051, 0.90000000000000013, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.88654237226056665, 0.90000000000000013, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.3026595810616726, 0.90000000000000013, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.9653635459278080, 0.90000000000000013, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 3.1451407527189468, 0.90000000000000013, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 5.3745230680316132, 0.90000000000000013, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 8.9942562031858717, 0.90000000000000013, 0.90000000000000002, 
+	  1.5707963267948966 },
+};
+const double toler190 = 2.5000000000000020e-13;
+
+template<typename Ret, unsigned int Num>
+  void
+  test(const testcase_ellint_3<Ret> (&data)[Num], Ret toler)
+  {
+    bool test __attribute__((unused)) = true;
+    const Ret eps = std::numeric_limits<Ret>::epsilon();
+    Ret max_abs_diff = -Ret(1);
+    Ret max_abs_frac = -Ret(1);
+    unsigned int num_datum = Num;
+    for (unsigned int i = 0; i < num_datum; ++i)
+  	 {
+	const Ret f = std::tr1::ellint_3(data[i].k, data[i].nu,
+		     data[i].phi);
+	const Ret f0 = data[i].f0;
+	const Ret diff = f - f0;
+	if (std::abs(diff) > max_abs_diff)
+	  max_abs_diff = std::abs(diff);
+	if (std::abs(f0) > Ret(10) * eps
+	 && std::abs(f) > Ret(10) * eps)
+	  {
+	    const Ret frac = diff / f0;
+	    if (std::abs(frac) > max_abs_frac)
+	      max_abs_frac = std::abs(frac);
+	  }
+      }
+    VERIFY(max_abs_frac < toler);
+  }
 
-int main(int, char**)
+int
+main()
 {
-  test001<double>();
-  test002<double>();
-  test003<double>();
-  test004<double>();
-  test005<double>();
-  test006<double>();
-  test007<double>();
-  test008<double>();
-  test009<double>();
-  test010<double>();
-  test011<double>();
-  test012<double>();
-  test013<double>();
-  test014<double>();
-  test015<double>();
-  test016<double>();
-  test017<double>();
-  test018<double>();
-  test019<double>();
-  test020<double>();
-  test021<double>();
-  test022<double>();
-  test023<double>();
-  test024<double>();
-  test025<double>();
-  test026<double>();
-  test027<double>();
-  test028<double>();
-  test029<double>();
-  test030<double>();
-  test031<double>();
-  test032<double>();
-  test033<double>();
-  test034<double>();
-  test035<double>();
-  test036<double>();
-  test037<double>();
-  test038<double>();
-  test039<double>();
-  test040<double>();
-  test041<double>();
-  test042<double>();
-  test043<double>();
-  test044<double>();
-  test045<double>();
-  test046<double>();
-  test047<double>();
-  test048<double>();
-  test049<double>();
-  test050<double>();
-  test051<double>();
-  test052<double>();
-  test053<double>();
-  test054<double>();
-  test055<double>();
-  test056<double>();
-  test057<double>();
-  test058<double>();
-  test059<double>();
-  test060<double>();
-  test061<double>();
-  test062<double>();
-  test063<double>();
-  test064<double>();
-  test065<double>();
-  test066<double>();
-  test067<double>();
-  test068<double>();
-  test069<double>();
-  test070<double>();
-  test071<double>();
-  test072<double>();
-  test073<double>();
-  test074<double>();
-  test075<double>();
-  test076<double>();
-  test077<double>();
-  test078<double>();
-  test079<double>();
-  test080<double>();
-  test081<double>();
-  test082<double>();
-  test083<double>();
-  test084<double>();
-  test085<double>();
-  test086<double>();
-  test087<double>();
-  test088<double>();
-  test089<double>();
-  test090<double>();
-  test091<double>();
-  test092<double>();
-  test093<double>();
-  test094<double>();
-  test095<double>();
-  test096<double>();
-  test097<double>();
-  test098<double>();
-  test099<double>();
-  test100<double>();
-  test101<double>();
-  test102<double>();
-  test103<double>();
-  test104<double>();
-  test105<double>();
-  test106<double>();
-  test107<double>();
-  test108<double>();
-  test109<double>();
-  test110<double>();
-  test111<double>();
-  test112<double>();
-  test113<double>();
-  test114<double>();
-  test115<double>();
-  test116<double>();
-  test117<double>();
-  test118<double>();
-  test119<double>();
-  test120<double>();
-  test121<double>();
-  test122<double>();
-  test123<double>();
-  test124<double>();
-  test125<double>();
-  test126<double>();
-  test127<double>();
-  test128<double>();
-  test129<double>();
-  test130<double>();
-  test131<double>();
-  test132<double>();
-  test133<double>();
-  test134<double>();
-  test135<double>();
-  test136<double>();
-  test137<double>();
-  test138<double>();
-  test139<double>();
-  test140<double>();
-  test141<double>();
-  test142<double>();
-  test143<double>();
-  test144<double>();
-  test145<double>();
-  test146<double>();
-  test147<double>();
-  test148<double>();
-  test149<double>();
-  test150<double>();
-  test151<double>();
-  test152<double>();
-  test153<double>();
-  test154<double>();
-  test155<double>();
-  test156<double>();
-  test157<double>();
-  test158<double>();
-  test159<double>();
-  test160<double>();
-  test161<double>();
-  test162<double>();
-  test163<double>();
-  test164<double>();
-  test165<double>();
-  test166<double>();
-  test167<double>();
-  test168<double>();
-  test169<double>();
-  test170<double>();
-  test171<double>();
-  test172<double>();
-  test173<double>();
-  test174<double>();
-  test175<double>();
-  test176<double>();
-  test177<double>();
-  test178<double>();
-  test179<double>();
-  test180<double>();
-  test181<double>();
-  test182<double>();
-  test183<double>();
-  test184<double>();
-  test185<double>();
-  test186<double>();
-  test187<double>();
-  test188<double>();
-  test189<double>();
-  test190<double>();
+  test(data001, toler001);
+  test(data002, toler002);
+  test(data003, toler003);
+  test(data004, toler004);
+  test(data005, toler005);
+  test(data006, toler006);
+  test(data007, toler007);
+  test(data008, toler008);
+  test(data009, toler009);
+  test(data010, toler010);
+  test(data011, toler011);
+  test(data012, toler012);
+  test(data013, toler013);
+  test(data014, toler014);
+  test(data015, toler015);
+  test(data016, toler016);
+  test(data017, toler017);
+  test(data018, toler018);
+  test(data019, toler019);
+  test(data020, toler020);
+  test(data021, toler021);
+  test(data022, toler022);
+  test(data023, toler023);
+  test(data024, toler024);
+  test(data025, toler025);
+  test(data026, toler026);
+  test(data027, toler027);
+  test(data028, toler028);
+  test(data029, toler029);
+  test(data030, toler030);
+  test(data031, toler031);
+  test(data032, toler032);
+  test(data033, toler033);
+  test(data034, toler034);
+  test(data035, toler035);
+  test(data036, toler036);
+  test(data037, toler037);
+  test(data038, toler038);
+  test(data039, toler039);
+  test(data040, toler040);
+  test(data041, toler041);
+  test(data042, toler042);
+  test(data043, toler043);
+  test(data044, toler044);
+  test(data045, toler045);
+  test(data046, toler046);
+  test(data047, toler047);
+  test(data048, toler048);
+  test(data049, toler049);
+  test(data050, toler050);
+  test(data051, toler051);
+  test(data052, toler052);
+  test(data053, toler053);
+  test(data054, toler054);
+  test(data055, toler055);
+  test(data056, toler056);
+  test(data057, toler057);
+  test(data058, toler058);
+  test(data059, toler059);
+  test(data060, toler060);
+  test(data061, toler061);
+  test(data062, toler062);
+  test(data063, toler063);
+  test(data064, toler064);
+  test(data065, toler065);
+  test(data066, toler066);
+  test(data067, toler067);
+  test(data068, toler068);
+  test(data069, toler069);
+  test(data070, toler070);
+  test(data071, toler071);
+  test(data072, toler072);
+  test(data073, toler073);
+  test(data074, toler074);
+  test(data075, toler075);
+  test(data076, toler076);
+  test(data077, toler077);
+  test(data078, toler078);
+  test(data079, toler079);
+  test(data080, toler080);
+  test(data081, toler081);
+  test(data082, toler082);
+  test(data083, toler083);
+  test(data084, toler084);
+  test(data085, toler085);
+  test(data086, toler086);
+  test(data087, toler087);
+  test(data088, toler088);
+  test(data089, toler089);
+  test(data090, toler090);
+  test(data091, toler091);
+  test(data092, toler092);
+  test(data093, toler093);
+  test(data094, toler094);
+  test(data095, toler095);
+  test(data096, toler096);
+  test(data097, toler097);
+  test(data098, toler098);
+  test(data099, toler099);
+  test(data100, toler100);
+  test(data101, toler101);
+  test(data102, toler102);
+  test(data103, toler103);
+  test(data104, toler104);
+  test(data105, toler105);
+  test(data106, toler106);
+  test(data107, toler107);
+  test(data108, toler108);
+  test(data109, toler109);
+  test(data110, toler110);
+  test(data111, toler111);
+  test(data112, toler112);
+  test(data113, toler113);
+  test(data114, toler114);
+  test(data115, toler115);
+  test(data116, toler116);
+  test(data117, toler117);
+  test(data118, toler118);
+  test(data119, toler119);
+  test(data120, toler120);
+  test(data121, toler121);
+  test(data122, toler122);
+  test(data123, toler123);
+  test(data124, toler124);
+  test(data125, toler125);
+  test(data126, toler126);
+  test(data127, toler127);
+  test(data128, toler128);
+  test(data129, toler129);
+  test(data130, toler130);
+  test(data131, toler131);
+  test(data132, toler132);
+  test(data133, toler133);
+  test(data134, toler134);
+  test(data135, toler135);
+  test(data136, toler136);
+  test(data137, toler137);
+  test(data138, toler138);
+  test(data139, toler139);
+  test(data140, toler140);
+  test(data141, toler141);
+  test(data142, toler142);
+  test(data143, toler143);
+  test(data144, toler144);
+  test(data145, toler145);
+  test(data146, toler146);
+  test(data147, toler147);
+  test(data148, toler148);
+  test(data149, toler149);
+  test(data150, toler150);
+  test(data151, toler151);
+  test(data152, toler152);
+  test(data153, toler153);
+  test(data154, toler154);
+  test(data155, toler155);
+  test(data156, toler156);
+  test(data157, toler157);
+  test(data158, toler158);
+  test(data159, toler159);
+  test(data160, toler160);
+  test(data161, toler161);
+  test(data162, toler162);
+  test(data163, toler163);
+  test(data164, toler164);
+  test(data165, toler165);
+  test(data166, toler166);
+  test(data167, toler167);
+  test(data168, toler168);
+  test(data169, toler169);
+  test(data170, toler170);
+  test(data171, toler171);
+  test(data172, toler172);
+  test(data173, toler173);
+  test(data174, toler174);
+  test(data175, toler175);
+  test(data176, toler176);
+  test(data177, toler177);
+  test(data178, toler178);
+  test(data179, toler179);
+  test(data180, toler180);
+  test(data181, toler181);
+  test(data182, toler182);
+  test(data183, toler183);
+  test(data184, toler184);
+  test(data185, toler185);
+  test(data186, toler186);
+  test(data187, toler187);
+  test(data188, toler188);
+  test(data189, toler189);
+  test(data190, toler190);
   return 0;
 }
diff -ruN gcc-7.3.0/libstdc++-v3/testsuite/util/testsuite_allocator.h gcc-7.3.0-msp430/libstdc++-v3/testsuite/util/testsuite_allocator.h
--- gcc-7.3.0/libstdc++-v3/testsuite/util/testsuite_allocator.h	2017-01-27 08:17:04.215026000 -0800
+++ gcc-7.3.0-msp430/libstdc++-v3/testsuite/util/testsuite_allocator.h	2019-06-25 02:27:32.305851262 -0700
@@ -570,6 +570,8 @@
 
       explicit PointerBase(T* p = nullptr) : value(p) { }
 
+      PointerBase(std::nullptr_t) : value(nullptr) { }
+
       template<typename D, typename U,
 	       typename = decltype(static_cast<T*>(std::declval<U*>()))>
 	PointerBase(const PointerBase<D, U>& p) : value(p.value) { }
@@ -603,7 +605,11 @@
       }
 
     private:
-      Derived& derived() { return static_cast<Derived&>(*this); }
+      Derived&
+      derived() { return static_cast<Derived&>(*this); }
+
+      const Derived&
+      derived() const { return static_cast<const Derived&>(*this); }
     };
 
     template<typename D, typename T>
diff -ruN gcc-7.3.0/libvtv/ChangeLog gcc-7.3.0-msp430/libvtv/ChangeLog
--- gcc-7.3.0/libvtv/ChangeLog	2018-01-25 00:17:27.198117000 -0800
+++ gcc-7.3.0-msp430/libvtv/ChangeLog	2019-06-25 02:27:32.305851262 -0700
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
diff -ruN gcc-7.3.0/libvtv/configure gcc-7.3.0-msp430/libvtv/configure
--- gcc-7.3.0/libvtv/configure	2018-01-25 00:17:54.163232057 -0800
+++ gcc-7.3.0-msp430/libvtv/configure	2019-06-25 02:27:32.309851232 -0700
@@ -15516,7 +15516,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
