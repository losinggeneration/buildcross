diff -urN binutils-2.20.1.old/bfd/archures.c binutils-2.20.1/bfd/archures.c
--- binutils-2.20.1.old/bfd/archures.c	2009-09-10 06:47:11.000000000 -0500
+++ binutils-2.20.1/bfd/archures.c	2010-04-13 09:49:42.333467988 -0500
@@ -368,6 +368,13 @@
 .#define bfd_mach_avr5		5
 .#define bfd_mach_avr51		51
 .#define bfd_mach_avr6		6
+.#define bfd_mach_avrxmega1 101
+.#define bfd_mach_avrxmega2 102
+.#define bfd_mach_avrxmega3 103
+.#define bfd_mach_avrxmega4 104
+.#define bfd_mach_avrxmega5 105
+.#define bfd_mach_avrxmega6 106
+.#define bfd_mach_avrxmega7 107
 .  bfd_arch_bfin,        {* ADI Blackfin *}
 .#define bfd_mach_bfin          1
 .  bfd_arch_cr16,       {* National Semiconductor CompactRISC (ie CR16). *}
diff -urN binutils-2.20.1.old/bfd/archures.c.orig binutils-2.20.1/bfd/archures.c.orig
--- binutils-2.20.1.old/bfd/archures.c.orig	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/bfd/archures.c.orig	2009-09-10 06:47:11.000000000 -0500
@@ -0,0 +1,1268 @@
+/* BFD library support routines for architectures.
+   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Free Software Foundation, Inc.
+   Hacked by John Gilmore and Steve Chamberlain of Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "safe-ctype.h"
+
+/*
+
+SECTION
+	Architectures
+
+	BFD keeps one atom in a BFD describing the
+	architecture of the data attached to the BFD: a pointer to a
+	<<bfd_arch_info_type>>.
+
+	Pointers to structures can be requested independently of a BFD
+	so that an architecture's information can be interrogated
+	without access to an open BFD.
+
+	The architecture information is provided by each architecture package.
+	The set of default architectures is selected by the macro
+	<<SELECT_ARCHITECTURES>>.  This is normally set up in the
+	@file{config/@var{target}.mt} file of your choice.  If the name is not
+	defined, then all the architectures supported are included.
+
+	When BFD starts up, all the architectures are called with an
+	initialize method.  It is up to the architecture back end to
+	insert as many items into the list of architectures as it wants to;
+	generally this would be one for each machine and one for the
+	default case (an item with a machine field of 0).
+
+	BFD's idea of an architecture is implemented in	@file{archures.c}.
+*/
+
+/*
+
+SUBSECTION
+	bfd_architecture
+
+DESCRIPTION
+	This enum gives the object file's CPU architecture, in a
+	global sense---i.e., what processor family does it belong to?
+	Another field indicates which processor within
+	the family is in use.  The machine gives a number which
+	distinguishes different versions of the architecture,
+	containing, for example, 2 and 3 for Intel i960 KA and i960 KB,
+	and 68020 and 68030 for Motorola 68020 and 68030.
+
+.enum bfd_architecture
+.{
+.  bfd_arch_unknown,   {* File arch not known.  *}
+.  bfd_arch_obscure,   {* Arch known, not one of these.  *}
+.  bfd_arch_m68k,      {* Motorola 68xxx *}
+.#define bfd_mach_m68000 1
+.#define bfd_mach_m68008 2
+.#define bfd_mach_m68010 3
+.#define bfd_mach_m68020 4
+.#define bfd_mach_m68030 5
+.#define bfd_mach_m68040 6
+.#define bfd_mach_m68060 7
+.#define bfd_mach_cpu32  8
+.#define bfd_mach_fido   9
+.#define bfd_mach_mcf_isa_a_nodiv 10
+.#define bfd_mach_mcf_isa_a 11
+.#define bfd_mach_mcf_isa_a_mac 12
+.#define bfd_mach_mcf_isa_a_emac 13
+.#define bfd_mach_mcf_isa_aplus 14
+.#define bfd_mach_mcf_isa_aplus_mac 15
+.#define bfd_mach_mcf_isa_aplus_emac 16
+.#define bfd_mach_mcf_isa_b_nousp 17
+.#define bfd_mach_mcf_isa_b_nousp_mac 18
+.#define bfd_mach_mcf_isa_b_nousp_emac 19
+.#define bfd_mach_mcf_isa_b 20
+.#define bfd_mach_mcf_isa_b_mac 21
+.#define bfd_mach_mcf_isa_b_emac 22
+.#define bfd_mach_mcf_isa_b_float 23
+.#define bfd_mach_mcf_isa_b_float_mac 24
+.#define bfd_mach_mcf_isa_b_float_emac 25
+.#define bfd_mach_mcf_isa_c 26
+.#define bfd_mach_mcf_isa_c_mac 27
+.#define bfd_mach_mcf_isa_c_emac 28
+.#define bfd_mach_mcf_isa_c_nodiv 29
+.#define bfd_mach_mcf_isa_c_nodiv_mac 30
+.#define bfd_mach_mcf_isa_c_nodiv_emac 31
+.  bfd_arch_vax,       {* DEC Vax *}
+.  bfd_arch_i960,      {* Intel 960 *}
+.    {* The order of the following is important.
+.       lower number indicates a machine type that
+.       only accepts a subset of the instructions
+.       available to machines with higher numbers.
+.       The exception is the "ca", which is
+.       incompatible with all other machines except
+.       "core".  *}
+.
+.#define bfd_mach_i960_core      1
+.#define bfd_mach_i960_ka_sa     2
+.#define bfd_mach_i960_kb_sb     3
+.#define bfd_mach_i960_mc        4
+.#define bfd_mach_i960_xa        5
+.#define bfd_mach_i960_ca        6
+.#define bfd_mach_i960_jx	 7
+.#define bfd_mach_i960_hx        8
+.
+.  bfd_arch_or32,      {* OpenRISC 32 *}
+.
+.  bfd_arch_sparc,     {* SPARC *}
+.#define bfd_mach_sparc			1
+.{* The difference between v8plus and v9 is that v9 is a true 64 bit env.  *}
+.#define bfd_mach_sparc_sparclet	2
+.#define bfd_mach_sparc_sparclite	3
+.#define bfd_mach_sparc_v8plus		4
+.#define bfd_mach_sparc_v8plusa		5 {* with ultrasparc add'ns.  *}
+.#define bfd_mach_sparc_sparclite_le	6
+.#define bfd_mach_sparc_v9		7
+.#define bfd_mach_sparc_v9a		8 {* with ultrasparc add'ns.  *}
+.#define bfd_mach_sparc_v8plusb		9 {* with cheetah add'ns.  *}
+.#define bfd_mach_sparc_v9b		10 {* with cheetah add'ns.  *}
+.{* Nonzero if MACH has the v9 instruction set.  *}
+.#define bfd_mach_sparc_v9_p(mach) \
+.  ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9b \
+.   && (mach) != bfd_mach_sparc_sparclite_le)
+.{* Nonzero if MACH is a 64 bit sparc architecture.  *}
+.#define bfd_mach_sparc_64bit_p(mach) \
+.  ((mach) >= bfd_mach_sparc_v9 && (mach) != bfd_mach_sparc_v8plusb)
+.  bfd_arch_spu,       {* PowerPC SPU *}
+.#define bfd_mach_spu		256 
+.  bfd_arch_mips,      {* MIPS Rxxxx *}
+.#define bfd_mach_mips3000		3000
+.#define bfd_mach_mips3900		3900
+.#define bfd_mach_mips4000		4000
+.#define bfd_mach_mips4010		4010
+.#define bfd_mach_mips4100		4100
+.#define bfd_mach_mips4111		4111
+.#define bfd_mach_mips4120		4120
+.#define bfd_mach_mips4300		4300
+.#define bfd_mach_mips4400		4400
+.#define bfd_mach_mips4600		4600
+.#define bfd_mach_mips4650		4650
+.#define bfd_mach_mips5000		5000
+.#define bfd_mach_mips5400		5400
+.#define bfd_mach_mips5500		5500
+.#define bfd_mach_mips6000		6000
+.#define bfd_mach_mips7000		7000
+.#define bfd_mach_mips8000		8000
+.#define bfd_mach_mips9000		9000
+.#define bfd_mach_mips10000		10000
+.#define bfd_mach_mips12000		12000
+.#define bfd_mach_mips14000		14000
+.#define bfd_mach_mips16000		16000
+.#define bfd_mach_mips16		16
+.#define bfd_mach_mips5                 5
+.#define bfd_mach_mips_loongson_2e      3001
+.#define bfd_mach_mips_loongson_2f      3002
+.#define bfd_mach_mips_sb1              12310201 {* octal 'SB', 01 *}
+.#define bfd_mach_mips_octeon		6501
+.#define bfd_mach_mips_xlr              887682   {* decimal 'XLR'  *}
+.#define bfd_mach_mipsisa32             32
+.#define bfd_mach_mipsisa32r2           33
+.#define bfd_mach_mipsisa64             64
+.#define bfd_mach_mipsisa64r2           65
+.  bfd_arch_i386,      {* Intel 386 *}
+.#define bfd_mach_i386_i386 1
+.#define bfd_mach_i386_i8086 2
+.#define bfd_mach_i386_i386_intel_syntax 3
+.#define bfd_mach_x86_64 64
+.#define bfd_mach_x86_64_intel_syntax 65
+.  bfd_arch_l1om,   {* Intel L1OM *}
+.#define bfd_mach_l1om 66
+.#define bfd_mach_l1om_intel_syntax 67
+.  bfd_arch_we32k,     {* AT&T WE32xxx *}
+.  bfd_arch_tahoe,     {* CCI/Harris Tahoe *}
+.  bfd_arch_i860,      {* Intel 860 *}
+.  bfd_arch_i370,      {* IBM 360/370 Mainframes *}
+.  bfd_arch_romp,      {* IBM ROMP PC/RT *}
+.  bfd_arch_convex,    {* Convex *}
+.  bfd_arch_m88k,      {* Motorola 88xxx *}
+.  bfd_arch_m98k,      {* Motorola 98xxx *}
+.  bfd_arch_pyramid,   {* Pyramid Technology *}
+.  bfd_arch_h8300,     {* Renesas H8/300 (formerly Hitachi H8/300) *}
+.#define bfd_mach_h8300    1
+.#define bfd_mach_h8300h   2
+.#define bfd_mach_h8300s   3
+.#define bfd_mach_h8300hn  4
+.#define bfd_mach_h8300sn  5
+.#define bfd_mach_h8300sx  6
+.#define bfd_mach_h8300sxn 7
+.  bfd_arch_pdp11,     {* DEC PDP-11 *}
+.  bfd_arch_plugin,
+.  bfd_arch_powerpc,   {* PowerPC *}
+.#define bfd_mach_ppc		32
+.#define bfd_mach_ppc64		64
+.#define bfd_mach_ppc_403	403
+.#define bfd_mach_ppc_403gc	4030
+.#define bfd_mach_ppc_405	405
+.#define bfd_mach_ppc_505	505
+.#define bfd_mach_ppc_601	601
+.#define bfd_mach_ppc_602	602
+.#define bfd_mach_ppc_603	603
+.#define bfd_mach_ppc_ec603e	6031
+.#define bfd_mach_ppc_604	604
+.#define bfd_mach_ppc_620	620
+.#define bfd_mach_ppc_630	630
+.#define bfd_mach_ppc_750	750
+.#define bfd_mach_ppc_860	860
+.#define bfd_mach_ppc_a35	35
+.#define bfd_mach_ppc_rs64ii	642
+.#define bfd_mach_ppc_rs64iii	643
+.#define bfd_mach_ppc_7400	7400
+.#define bfd_mach_ppc_e500      500
+.#define bfd_mach_ppc_e500mc    5001
+.  bfd_arch_rs6000,    {* IBM RS/6000 *}
+.#define bfd_mach_rs6k		6000
+.#define bfd_mach_rs6k_rs1	6001
+.#define bfd_mach_rs6k_rsc	6003
+.#define bfd_mach_rs6k_rs2	6002
+.  bfd_arch_hppa,      {* HP PA RISC *}
+.#define bfd_mach_hppa10	10
+.#define bfd_mach_hppa11	11
+.#define bfd_mach_hppa20	20
+.#define bfd_mach_hppa20w	25
+.  bfd_arch_d10v,      {* Mitsubishi D10V *}
+.#define bfd_mach_d10v		1
+.#define bfd_mach_d10v_ts2	2
+.#define bfd_mach_d10v_ts3	3
+.  bfd_arch_d30v,      {* Mitsubishi D30V *}
+.  bfd_arch_dlx,       {* DLX *}
+.  bfd_arch_m68hc11,   {* Motorola 68HC11 *}
+.  bfd_arch_m68hc12,   {* Motorola 68HC12 *}
+.#define bfd_mach_m6812_default 0
+.#define bfd_mach_m6812         1
+.#define bfd_mach_m6812s        2
+.  bfd_arch_z8k,       {* Zilog Z8000 *}
+.#define bfd_mach_z8001		1
+.#define bfd_mach_z8002		2
+.  bfd_arch_h8500,     {* Renesas H8/500 (formerly Hitachi H8/500) *}
+.  bfd_arch_sh,        {* Renesas / SuperH SH (formerly Hitachi SH) *}
+.#define bfd_mach_sh            1
+.#define bfd_mach_sh2        0x20
+.#define bfd_mach_sh_dsp     0x2d
+.#define bfd_mach_sh2a       0x2a
+.#define bfd_mach_sh2a_nofpu 0x2b
+.#define bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu 0x2a1
+.#define bfd_mach_sh2a_nofpu_or_sh3_nommu 0x2a2
+.#define bfd_mach_sh2a_or_sh4  0x2a3
+.#define bfd_mach_sh2a_or_sh3e 0x2a4
+.#define bfd_mach_sh2e       0x2e
+.#define bfd_mach_sh3        0x30
+.#define bfd_mach_sh3_nommu  0x31
+.#define bfd_mach_sh3_dsp    0x3d
+.#define bfd_mach_sh3e       0x3e
+.#define bfd_mach_sh4        0x40
+.#define bfd_mach_sh4_nofpu  0x41
+.#define bfd_mach_sh4_nommu_nofpu  0x42
+.#define bfd_mach_sh4a       0x4a
+.#define bfd_mach_sh4a_nofpu 0x4b
+.#define bfd_mach_sh4al_dsp  0x4d
+.#define bfd_mach_sh5        0x50
+.  bfd_arch_alpha,     {* Dec Alpha *}
+.#define bfd_mach_alpha_ev4  0x10
+.#define bfd_mach_alpha_ev5  0x20
+.#define bfd_mach_alpha_ev6  0x30
+.  bfd_arch_arm,       {* Advanced Risc Machines ARM.  *}
+.#define bfd_mach_arm_unknown	0
+.#define bfd_mach_arm_2		1
+.#define bfd_mach_arm_2a	2
+.#define bfd_mach_arm_3		3
+.#define bfd_mach_arm_3M 	4
+.#define bfd_mach_arm_4 	5
+.#define bfd_mach_arm_4T 	6
+.#define bfd_mach_arm_5 	7
+.#define bfd_mach_arm_5T	8
+.#define bfd_mach_arm_5TE	9
+.#define bfd_mach_arm_XScale	10
+.#define bfd_mach_arm_ep9312	11
+.#define bfd_mach_arm_iWMMXt	12
+.#define bfd_mach_arm_iWMMXt2	13
+.  bfd_arch_ns32k,     {* National Semiconductors ns32000 *}
+.  bfd_arch_w65,       {* WDC 65816 *}
+.  bfd_arch_tic30,     {* Texas Instruments TMS320C30 *}
+.  bfd_arch_tic4x,     {* Texas Instruments TMS320C3X/4X *}
+.#define bfd_mach_tic3x         30
+.#define bfd_mach_tic4x         40
+.  bfd_arch_tic54x,    {* Texas Instruments TMS320C54X *}
+.  bfd_arch_tic80,     {* TI TMS320c80 (MVP) *}
+.  bfd_arch_v850,      {* NEC V850 *}
+.#define bfd_mach_v850          1
+.#define bfd_mach_v850e 	'E'
+.#define bfd_mach_v850e1	'1'
+.  bfd_arch_arc,       {* ARC Cores *}
+.#define bfd_mach_arc_5         5
+.#define bfd_mach_arc_6         6
+.#define bfd_mach_arc_7         7
+.#define bfd_mach_arc_8         8
+. bfd_arch_m32c,     {* Renesas M16C/M32C.  *}
+.#define bfd_mach_m16c        0x75
+.#define bfd_mach_m32c        0x78
+.  bfd_arch_m32r,      {* Renesas M32R (formerly Mitsubishi M32R/D) *}
+.#define bfd_mach_m32r		1 {* For backwards compatibility.  *}
+.#define bfd_mach_m32rx		'x'
+.#define bfd_mach_m32r2		'2'
+.  bfd_arch_mn10200,   {* Matsushita MN10200 *}
+.  bfd_arch_mn10300,   {* Matsushita MN10300 *}
+.#define bfd_mach_mn10300		300
+.#define bfd_mach_am33		330
+.#define bfd_mach_am33_2	332
+.  bfd_arch_fr30,
+.#define bfd_mach_fr30		0x46523330
+.  bfd_arch_frv,
+.#define bfd_mach_frv		1
+.#define bfd_mach_frvsimple	2
+.#define bfd_mach_fr300		300
+.#define bfd_mach_fr400		400
+.#define bfd_mach_fr450		450
+.#define bfd_mach_frvtomcat	499	{* fr500 prototype *}
+.#define bfd_mach_fr500		500
+.#define bfd_mach_fr550		550
+.  bfd_arch_moxie,       {* The moxie processor *}
+.#define bfd_mach_moxie		1
+.  bfd_arch_mcore,
+.  bfd_arch_mep,
+.#define bfd_mach_mep		1
+.#define bfd_mach_mep_h1	0x6831
+.#define bfd_mach_mep_c5	0x6335
+.  bfd_arch_ia64,      {* HP/Intel ia64 *}
+.#define bfd_mach_ia64_elf64	64
+.#define bfd_mach_ia64_elf32	32
+.  bfd_arch_ip2k,      {* Ubicom IP2K microcontrollers. *}
+.#define bfd_mach_ip2022	1
+.#define bfd_mach_ip2022ext	2
+. bfd_arch_iq2000,     {* Vitesse IQ2000.  *}
+.#define bfd_mach_iq2000        1
+.#define bfd_mach_iq10          2
+.  bfd_arch_mt,
+.#define bfd_mach_ms1           1
+.#define bfd_mach_mrisc2        2
+.#define bfd_mach_ms2           3
+.  bfd_arch_pj,
+.  bfd_arch_avr,       {* Atmel AVR microcontrollers.  *}
+.#define bfd_mach_avr1		1
+.#define bfd_mach_avr2		2
+.#define bfd_mach_avr25		25
+.#define bfd_mach_avr3		3
+.#define bfd_mach_avr31		31
+.#define bfd_mach_avr35		35
+.#define bfd_mach_avr4		4
+.#define bfd_mach_avr5		5
+.#define bfd_mach_avr51		51
+.#define bfd_mach_avr6		6
+.  bfd_arch_bfin,        {* ADI Blackfin *}
+.#define bfd_mach_bfin          1
+.  bfd_arch_cr16,       {* National Semiconductor CompactRISC (ie CR16). *}
+.#define bfd_mach_cr16		1
+.  bfd_arch_cr16c,       {* National Semiconductor CompactRISC. *}
+.#define bfd_mach_cr16c		1
+.  bfd_arch_crx,       {*  National Semiconductor CRX.  *}
+.#define bfd_mach_crx		1
+.  bfd_arch_cris,      {* Axis CRIS *}
+.#define bfd_mach_cris_v0_v10	255
+.#define bfd_mach_cris_v32	32
+.#define bfd_mach_cris_v10_v32	1032
+.  bfd_arch_s390,      {* IBM s390 *}
+.#define bfd_mach_s390_31       31
+.#define bfd_mach_s390_64       64
+.  bfd_arch_score,     {* Sunplus score *} 
+.#define bfd_mach_score3         3
+.#define bfd_mach_score7         7
+.  bfd_arch_openrisc,  {* OpenRISC *}
+.  bfd_arch_mmix,      {* Donald Knuth's educational processor.  *}
+.  bfd_arch_xstormy16,
+.#define bfd_mach_xstormy16	1
+.  bfd_arch_msp430,    {* Texas Instruments MSP430 architecture.  *}
+.#define bfd_mach_msp11          11
+.#define bfd_mach_msp110         110
+.#define bfd_mach_msp12          12
+.#define bfd_mach_msp13          13
+.#define bfd_mach_msp14          14
+.#define bfd_mach_msp15          15
+.#define bfd_mach_msp16          16
+.#define bfd_mach_msp21          21
+.#define bfd_mach_msp31          31
+.#define bfd_mach_msp32          32
+.#define bfd_mach_msp33          33
+.#define bfd_mach_msp41          41
+.#define bfd_mach_msp42          42
+.#define bfd_mach_msp43          43
+.#define bfd_mach_msp44          44
+.  bfd_arch_xc16x,     {* Infineon's XC16X Series.               *}
+.#define bfd_mach_xc16x         1
+.#define bfd_mach_xc16xl        2
+.#define bfd_mach_xc16xs         3
+.  bfd_arch_xtensa,    {* Tensilica's Xtensa cores.  *}
+.#define bfd_mach_xtensa	1
+.   bfd_arch_maxq,     {* Dallas MAXQ 10/20 *}
+.#define bfd_mach_maxq10    10
+.#define bfd_mach_maxq20    20
+.  bfd_arch_z80,
+.#define bfd_mach_z80strict      1 {* No undocumented opcodes.  *}
+.#define bfd_mach_z80            3 {* With ixl, ixh, iyl, and iyh.  *}
+.#define bfd_mach_z80full        7 {* All undocumented instructions.  *}
+.#define bfd_mach_r800           11 {* R800: successor with multiplication.  *}
+.  bfd_arch_lm32,      {* Lattice Mico32 *}
+.#define bfd_mach_lm32      1
+.  bfd_arch_microblaze,{* Xilinx MicroBlaze. *}
+.  bfd_arch_last
+.  };
+*/
+
+/*
+SUBSECTION
+	bfd_arch_info
+
+DESCRIPTION
+	This structure contains information on architectures for use
+	within BFD.
+
+.
+.typedef struct bfd_arch_info
+.{
+.  int bits_per_word;
+.  int bits_per_address;
+.  int bits_per_byte;
+.  enum bfd_architecture arch;
+.  unsigned long mach;
+.  const char *arch_name;
+.  const char *printable_name;
+.  unsigned int section_align_power;
+.  {* TRUE if this is the default machine for the architecture.
+.     The default arch should be the first entry for an arch so that
+.     all the entries for that arch can be accessed via <<next>>.  *}
+.  bfd_boolean the_default;
+.  const struct bfd_arch_info * (*compatible)
+.    (const struct bfd_arch_info *a, const struct bfd_arch_info *b);
+.
+.  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);
+.
+.  const struct bfd_arch_info *next;
+.}
+.bfd_arch_info_type;
+.
+*/
+
+extern const bfd_arch_info_type bfd_alpha_arch;
+extern const bfd_arch_info_type bfd_arc_arch;
+extern const bfd_arch_info_type bfd_arm_arch;
+extern const bfd_arch_info_type bfd_avr_arch;
+extern const bfd_arch_info_type bfd_bfin_arch;
+extern const bfd_arch_info_type bfd_cr16_arch;
+extern const bfd_arch_info_type bfd_cr16c_arch;
+extern const bfd_arch_info_type bfd_cris_arch;
+extern const bfd_arch_info_type bfd_crx_arch;
+extern const bfd_arch_info_type bfd_d10v_arch;
+extern const bfd_arch_info_type bfd_d30v_arch;
+extern const bfd_arch_info_type bfd_dlx_arch;
+extern const bfd_arch_info_type bfd_fr30_arch;
+extern const bfd_arch_info_type bfd_frv_arch;
+extern const bfd_arch_info_type bfd_h8300_arch;
+extern const bfd_arch_info_type bfd_h8500_arch;
+extern const bfd_arch_info_type bfd_hppa_arch;
+extern const bfd_arch_info_type bfd_i370_arch;
+extern const bfd_arch_info_type bfd_i386_arch;
+extern const bfd_arch_info_type bfd_i860_arch;
+extern const bfd_arch_info_type bfd_i960_arch;
+extern const bfd_arch_info_type bfd_ia64_arch;
+extern const bfd_arch_info_type bfd_ip2k_arch;
+extern const bfd_arch_info_type bfd_iq2000_arch;
+extern const bfd_arch_info_type bfd_l1om_arch;
+extern const bfd_arch_info_type bfd_lm32_arch;
+extern const bfd_arch_info_type bfd_m32c_arch;
+extern const bfd_arch_info_type bfd_m32r_arch;
+extern const bfd_arch_info_type bfd_m68hc11_arch;
+extern const bfd_arch_info_type bfd_m68hc12_arch;
+extern const bfd_arch_info_type bfd_m68k_arch;
+extern const bfd_arch_info_type bfd_m88k_arch;
+extern const bfd_arch_info_type bfd_maxq_arch;
+extern const bfd_arch_info_type bfd_mcore_arch;
+extern const bfd_arch_info_type bfd_mep_arch;
+extern const bfd_arch_info_type bfd_mips_arch;
+extern const bfd_arch_info_type bfd_microblaze_arch;
+extern const bfd_arch_info_type bfd_mmix_arch;
+extern const bfd_arch_info_type bfd_mn10200_arch;
+extern const bfd_arch_info_type bfd_mn10300_arch;
+extern const bfd_arch_info_type bfd_moxie_arch;
+extern const bfd_arch_info_type bfd_msp430_arch;
+extern const bfd_arch_info_type bfd_mt_arch;
+extern const bfd_arch_info_type bfd_ns32k_arch;
+extern const bfd_arch_info_type bfd_openrisc_arch;
+extern const bfd_arch_info_type bfd_or32_arch;
+extern const bfd_arch_info_type bfd_pdp11_arch;
+extern const bfd_arch_info_type bfd_pj_arch;
+extern const bfd_arch_info_type bfd_plugin_arch;
+extern const bfd_arch_info_type bfd_powerpc_archs[];
+#define bfd_powerpc_arch bfd_powerpc_archs[0]
+extern const bfd_arch_info_type bfd_rs6000_arch;
+extern const bfd_arch_info_type bfd_s390_arch;
+extern const bfd_arch_info_type bfd_score_arch;
+extern const bfd_arch_info_type bfd_sh_arch;
+extern const bfd_arch_info_type bfd_sparc_arch;
+extern const bfd_arch_info_type bfd_spu_arch;
+extern const bfd_arch_info_type bfd_tic30_arch;
+extern const bfd_arch_info_type bfd_tic4x_arch;
+extern const bfd_arch_info_type bfd_tic54x_arch;
+extern const bfd_arch_info_type bfd_tic80_arch;
+extern const bfd_arch_info_type bfd_v850_arch;
+extern const bfd_arch_info_type bfd_vax_arch;
+extern const bfd_arch_info_type bfd_w65_arch;
+extern const bfd_arch_info_type bfd_we32k_arch;
+extern const bfd_arch_info_type bfd_xstormy16_arch;
+extern const bfd_arch_info_type bfd_xtensa_arch;
+extern const bfd_arch_info_type bfd_xc16x_arch;
+extern const bfd_arch_info_type bfd_z80_arch;
+extern const bfd_arch_info_type bfd_z8k_arch;
+
+static const bfd_arch_info_type * const bfd_archures_list[] =
+  {
+#ifdef SELECT_ARCHITECTURES
+    SELECT_ARCHITECTURES,
+#else
+    &bfd_alpha_arch,
+    &bfd_arc_arch,
+    &bfd_arm_arch,
+    &bfd_avr_arch,
+    &bfd_bfin_arch,
+    &bfd_cr16_arch,
+    &bfd_cr16c_arch,
+    &bfd_cris_arch,
+    &bfd_crx_arch,
+    &bfd_d10v_arch,
+    &bfd_d30v_arch,
+    &bfd_dlx_arch,
+    &bfd_fr30_arch,
+    &bfd_frv_arch,
+    &bfd_h8300_arch,
+    &bfd_h8500_arch,
+    &bfd_hppa_arch,
+    &bfd_i370_arch,
+    &bfd_i386_arch,
+    &bfd_i860_arch,
+    &bfd_i960_arch,
+    &bfd_ia64_arch,
+    &bfd_ip2k_arch,
+    &bfd_iq2000_arch,
+    &bfd_l1om_arch,
+    &bfd_lm32_arch,
+    &bfd_m32c_arch,
+    &bfd_m32r_arch,
+    &bfd_m68hc11_arch,
+    &bfd_m68hc12_arch,
+    &bfd_m68k_arch,
+    &bfd_m88k_arch,
+    &bfd_maxq_arch,
+    &bfd_mcore_arch,
+    &bfd_mep_arch,
+    &bfd_microblaze_arch,
+    &bfd_mips_arch,
+    &bfd_mmix_arch,
+    &bfd_mn10200_arch,
+    &bfd_mn10300_arch,
+    &bfd_moxie_arch,
+    &bfd_msp430_arch,
+    &bfd_mt_arch,
+    &bfd_ns32k_arch,
+    &bfd_openrisc_arch,
+    &bfd_or32_arch,
+    &bfd_pdp11_arch,
+    &bfd_powerpc_arch,
+    &bfd_rs6000_arch,
+    &bfd_s390_arch,
+    &bfd_score_arch,
+    &bfd_sh_arch,
+    &bfd_sparc_arch,
+    &bfd_spu_arch,
+    &bfd_tic30_arch,
+    &bfd_tic4x_arch,
+    &bfd_tic54x_arch,
+    &bfd_tic80_arch,
+    &bfd_v850_arch,
+    &bfd_vax_arch,
+    &bfd_w65_arch,
+    &bfd_we32k_arch,
+    &bfd_xstormy16_arch,
+    &bfd_xtensa_arch,
+    &bfd_xc16x_arch,
+    &bfd_z80_arch,
+    &bfd_z8k_arch,
+#endif
+  0
+};
+
+/*
+FUNCTION
+	bfd_printable_name
+
+SYNOPSIS
+	const char *bfd_printable_name (bfd *abfd);
+
+DESCRIPTION
+	Return a printable string representing the architecture and machine
+	from the pointer to the architecture info structure.
+
+*/
+
+const char *
+bfd_printable_name (bfd *abfd)
+{
+  return abfd->arch_info->printable_name;
+}
+
+/*
+FUNCTION
+	bfd_scan_arch
+
+SYNOPSIS
+	const bfd_arch_info_type *bfd_scan_arch (const char *string);
+
+DESCRIPTION
+	Figure out if BFD supports any cpu which could be described with
+	the name @var{string}.  Return a pointer to an <<arch_info>>
+	structure if a machine is found, otherwise NULL.
+*/
+
+const bfd_arch_info_type *
+bfd_scan_arch (const char *string)
+{
+  const bfd_arch_info_type * const *app, *ap;
+
+  /* Look through all the installed architectures.  */
+  for (app = bfd_archures_list; *app != NULL; app++)
+    {
+      for (ap = *app; ap != NULL; ap = ap->next)
+	{
+	  if (ap->scan (ap, string))
+	    return ap;
+	}
+    }
+
+  return NULL;
+}
+
+/*
+FUNCTION
+	bfd_arch_list
+
+SYNOPSIS
+	const char **bfd_arch_list (void);
+
+DESCRIPTION
+	Return a freshly malloced NULL-terminated vector of the names
+	of all the valid BFD architectures.  Do not modify the names.
+*/
+
+const char **
+bfd_arch_list (void)
+{
+  int vec_length = 0;
+  const char **name_ptr;
+  const char **name_list;
+  const bfd_arch_info_type * const *app;
+  bfd_size_type amt;
+
+  /* Determine the number of architectures.  */
+  vec_length = 0;
+  for (app = bfd_archures_list; *app != NULL; app++)
+    {
+      const bfd_arch_info_type *ap;
+      for (ap = *app; ap != NULL; ap = ap->next)
+	{
+	  vec_length++;
+	}
+    }
+
+  amt = (vec_length + 1) * sizeof (char **);
+  name_list = (const char **) bfd_malloc (amt);
+  if (name_list == NULL)
+    return NULL;
+
+  /* Point the list at each of the names.  */
+  name_ptr = name_list;
+  for (app = bfd_archures_list; *app != NULL; app++)
+    {
+      const bfd_arch_info_type *ap;
+      for (ap = *app; ap != NULL; ap = ap->next)
+	{
+	  *name_ptr = ap->printable_name;
+	  name_ptr++;
+	}
+    }
+  *name_ptr = NULL;
+
+  return name_list;
+}
+
+/*
+FUNCTION
+	bfd_arch_get_compatible
+
+SYNOPSIS
+	const bfd_arch_info_type *bfd_arch_get_compatible
+	  (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);
+
+DESCRIPTION
+	Determine whether two BFDs' architectures and machine types
+	are compatible.  Calculates the lowest common denominator
+	between the two architectures and machine types implied by
+	the BFDs and returns a pointer to an <<arch_info>> structure
+	describing the compatible machine.
+*/
+
+const bfd_arch_info_type *
+bfd_arch_get_compatible (const bfd *abfd,
+			 const bfd *bbfd,
+			 bfd_boolean accept_unknowns)
+{
+  const bfd * ubfd = NULL;
+
+  /* Look for an unknown architecture.  */
+  if (((ubfd = abfd) && ubfd->arch_info->arch == bfd_arch_unknown)
+      || ((ubfd = bbfd) && ubfd->arch_info->arch == bfd_arch_unknown))
+    {
+      /* We can allow an unknown architecture if accept_unknowns
+	 is true, or if the target is the "binary" format, which
+	 has an unknown architecture.  Since the binary format can
+	 only be set by explicit request from the user, it is safe
+	 to assume that they know what they are doing.  */
+      if (accept_unknowns
+	  || strcmp (bfd_get_target (ubfd), "binary") == 0)
+	return ubfd->arch_info;
+      return NULL;
+    }
+
+  /* Otherwise architecture-specific code has to decide.  */
+  return abfd->arch_info->compatible (abfd->arch_info, bbfd->arch_info);
+}
+
+/*
+INTERNAL_DEFINITION
+	bfd_default_arch_struct
+
+DESCRIPTION
+	The <<bfd_default_arch_struct>> is an item of
+	<<bfd_arch_info_type>> which has been initialized to a fairly
+	generic state.  A BFD starts life by pointing to this
+	structure, until the correct back end has determined the real
+	architecture of the file.
+
+.extern const bfd_arch_info_type bfd_default_arch_struct;
+*/
+
+const bfd_arch_info_type bfd_default_arch_struct = {
+  32, 32, 8, bfd_arch_unknown, 0, "unknown", "unknown", 2, TRUE,
+  bfd_default_compatible,
+  bfd_default_scan,
+  0,
+};
+
+/*
+FUNCTION
+	bfd_set_arch_info
+
+SYNOPSIS
+	void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);
+
+DESCRIPTION
+	Set the architecture info of @var{abfd} to @var{arg}.
+*/
+
+void
+bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg)
+{
+  abfd->arch_info = arg;
+}
+
+/*
+INTERNAL_FUNCTION
+	bfd_default_set_arch_mach
+
+SYNOPSIS
+	bfd_boolean bfd_default_set_arch_mach
+	  (bfd *abfd, enum bfd_architecture arch, unsigned long mach);
+
+DESCRIPTION
+	Set the architecture and machine type in BFD @var{abfd}
+	to @var{arch} and @var{mach}.  Find the correct
+	pointer to a structure and insert it into the <<arch_info>>
+	pointer.
+*/
+
+bfd_boolean
+bfd_default_set_arch_mach (bfd *abfd,
+			   enum bfd_architecture arch,
+			   unsigned long mach)
+{
+  abfd->arch_info = bfd_lookup_arch (arch, mach);
+  if (abfd->arch_info != NULL)
+    return TRUE;
+
+  abfd->arch_info = &bfd_default_arch_struct;
+  bfd_set_error (bfd_error_bad_value);
+  return FALSE;
+}
+
+/*
+FUNCTION
+	bfd_get_arch
+
+SYNOPSIS
+	enum bfd_architecture bfd_get_arch (bfd *abfd);
+
+DESCRIPTION
+	Return the enumerated type which describes the BFD @var{abfd}'s
+	architecture.
+*/
+
+enum bfd_architecture
+bfd_get_arch (bfd *abfd)
+{
+  return abfd->arch_info->arch;
+}
+
+/*
+FUNCTION
+	bfd_get_mach
+
+SYNOPSIS
+	unsigned long bfd_get_mach (bfd *abfd);
+
+DESCRIPTION
+	Return the long type which describes the BFD @var{abfd}'s
+	machine.
+*/
+
+unsigned long
+bfd_get_mach (bfd *abfd)
+{
+  return abfd->arch_info->mach;
+}
+
+/*
+FUNCTION
+	bfd_arch_bits_per_byte
+
+SYNOPSIS
+	unsigned int bfd_arch_bits_per_byte (bfd *abfd);
+
+DESCRIPTION
+	Return the number of bits in one of the BFD @var{abfd}'s
+	architecture's bytes.
+*/
+
+unsigned int
+bfd_arch_bits_per_byte (bfd *abfd)
+{
+  return abfd->arch_info->bits_per_byte;
+}
+
+/*
+FUNCTION
+	bfd_arch_bits_per_address
+
+SYNOPSIS
+	unsigned int bfd_arch_bits_per_address (bfd *abfd);
+
+DESCRIPTION
+	Return the number of bits in one of the BFD @var{abfd}'s
+	architecture's addresses.
+*/
+
+unsigned int
+bfd_arch_bits_per_address (bfd *abfd)
+{
+  return abfd->arch_info->bits_per_address;
+}
+
+/*
+INTERNAL_FUNCTION
+	bfd_default_compatible
+
+SYNOPSIS
+	const bfd_arch_info_type *bfd_default_compatible
+	  (const bfd_arch_info_type *a, const bfd_arch_info_type *b);
+
+DESCRIPTION
+	The default function for testing for compatibility.
+*/
+
+const bfd_arch_info_type *
+bfd_default_compatible (const bfd_arch_info_type *a,
+			const bfd_arch_info_type *b)
+{
+  if (a->arch != b->arch)
+    return NULL;
+
+  if (a->bits_per_word != b->bits_per_word)
+    return NULL;
+
+  if (a->mach > b->mach)
+    return a;
+
+  if (b->mach > a->mach)
+    return b;
+
+  return a;
+}
+
+/*
+INTERNAL_FUNCTION
+	bfd_default_scan
+
+SYNOPSIS
+	bfd_boolean bfd_default_scan
+	  (const struct bfd_arch_info *info, const char *string);
+
+DESCRIPTION
+	The default function for working out whether this is an
+	architecture hit and a machine hit.
+*/
+
+bfd_boolean
+bfd_default_scan (const bfd_arch_info_type *info, const char *string)
+{
+  const char *ptr_src;
+  const char *ptr_tst;
+  unsigned long number;
+  enum bfd_architecture arch;
+  const char *printable_name_colon;
+
+  /* Exact match of the architecture name (ARCH_NAME) and also the
+     default architecture?  */
+  if (strcasecmp (string, info->arch_name) == 0
+      && info->the_default)
+    return TRUE;
+
+  /* Exact match of the machine name (PRINTABLE_NAME)?  */
+  if (strcasecmp (string, info->printable_name) == 0)
+    return TRUE;
+
+  /* Given that printable_name contains no colon, attempt to match:
+     ARCH_NAME [ ":" ] PRINTABLE_NAME?  */
+  printable_name_colon = strchr (info->printable_name, ':');
+  if (printable_name_colon == NULL)
+    {
+      size_t strlen_arch_name = strlen (info->arch_name);
+      if (strncasecmp (string, info->arch_name, strlen_arch_name) == 0)
+	{
+	  if (string[strlen_arch_name] == ':')
+	    {
+	      if (strcasecmp (string + strlen_arch_name + 1,
+			      info->printable_name) == 0)
+		return TRUE;
+	    }
+	  else
+	    {
+	      if (strcasecmp (string + strlen_arch_name,
+			      info->printable_name) == 0)
+		return TRUE;
+	    }
+	}
+    }
+
+  /* Given that PRINTABLE_NAME has the form: <arch> ":" <mach>;
+     Attempt to match: <arch> <mach>?  */
+  if (printable_name_colon != NULL)
+    {
+      size_t colon_index = printable_name_colon - info->printable_name;
+      if (strncasecmp (string, info->printable_name, colon_index) == 0
+	  && strcasecmp (string + colon_index,
+			 info->printable_name + colon_index + 1) == 0)
+	return TRUE;
+    }
+
+  /* Given that PRINTABLE_NAME has the form: <arch> ":" <mach>; Do not
+     attempt to match just <mach>, it could be ambiguous.  This test
+     is left until later.  */
+
+  /* NOTE: The below is retained for compatibility only.  Please do
+     not add to this code.  */
+
+  /* See how much of the supplied string matches with the
+     architecture, eg the string m68k:68020 would match the 68k entry
+     up to the :, then we get left with the machine number.  */
+
+  for (ptr_src = string, ptr_tst = info->arch_name;
+       *ptr_src && *ptr_tst;
+       ptr_src++, ptr_tst++)
+    {
+      if (*ptr_src != *ptr_tst)
+	break;
+    }
+
+  /* Chewed up as much of the architecture as will match, skip any
+     colons.  */
+  if (*ptr_src == ':')
+    ptr_src++;
+
+  if (*ptr_src == 0)
+    {
+      /* Nothing more, then only keep this one if it is the default
+	 machine for this architecture.  */
+      return info->the_default;
+    }
+
+  number = 0;
+  while (ISDIGIT (*ptr_src))
+    {
+      number = number * 10 + *ptr_src - '0';
+      ptr_src++;
+    }
+
+  /* NOTE: The below is retained for compatibility only.
+     PLEASE DO NOT ADD TO THIS CODE.  */
+
+  switch (number)
+    {
+      /* FIXME: These are needed to parse IEEE objects.  */
+      /* The following seven case's are here only for compatibility with
+	 older binutils (at least IEEE objects from binutils 2.9.1 require
+	 them).  */
+    case bfd_mach_m68000:
+    case bfd_mach_m68010:
+    case bfd_mach_m68020:
+    case bfd_mach_m68030:
+    case bfd_mach_m68040:
+    case bfd_mach_m68060:
+    case bfd_mach_cpu32:
+      arch = bfd_arch_m68k;
+      break;
+    case 68000:
+      arch = bfd_arch_m68k;
+      number = bfd_mach_m68000;
+      break;
+    case 68010:
+      arch = bfd_arch_m68k;
+      number = bfd_mach_m68010;
+      break;
+    case 68020:
+      arch = bfd_arch_m68k;
+      number = bfd_mach_m68020;
+      break;
+    case 68030:
+      arch = bfd_arch_m68k;
+      number = bfd_mach_m68030;
+      break;
+    case 68040:
+      arch = bfd_arch_m68k;
+      number = bfd_mach_m68040;
+      break;
+    case 68060:
+      arch = bfd_arch_m68k;
+      number = bfd_mach_m68060;
+      break;
+    case 68332:
+      arch = bfd_arch_m68k;
+      number = bfd_mach_cpu32;
+      break;
+    case 5200:
+      arch = bfd_arch_m68k;
+      number = bfd_mach_mcf_isa_a_nodiv;
+      break;
+    case 5206:
+      arch = bfd_arch_m68k;
+      number = bfd_mach_mcf_isa_a_mac;
+      break;
+    case 5307:
+      arch = bfd_arch_m68k;
+      number = bfd_mach_mcf_isa_a_mac;
+      break;
+    case 5407:
+      arch = bfd_arch_m68k;
+      number = bfd_mach_mcf_isa_b_nousp_mac;
+      break;
+    case 5282:
+      arch = bfd_arch_m68k;
+      number = bfd_mach_mcf_isa_aplus_emac;
+      break;
+
+    case 32000:
+      arch = bfd_arch_we32k;
+      break;
+
+    case 3000:
+      arch = bfd_arch_mips;
+      number = bfd_mach_mips3000;
+      break;
+
+    case 4000:
+      arch = bfd_arch_mips;
+      number = bfd_mach_mips4000;
+      break;
+
+    case 6000:
+      arch = bfd_arch_rs6000;
+      break;
+
+    case 7410:
+      arch = bfd_arch_sh;
+      number = bfd_mach_sh_dsp;
+      break;
+
+    case 7708:
+      arch = bfd_arch_sh;
+      number = bfd_mach_sh3;
+      break;
+
+    case 7729:
+      arch = bfd_arch_sh;
+      number = bfd_mach_sh3_dsp;
+      break;
+
+    case 7750:
+      arch = bfd_arch_sh;
+      number = bfd_mach_sh4;
+      break;
+
+    default:
+      return FALSE;
+    }
+
+  if (arch != info->arch)
+    return FALSE;
+
+  if (number != info->mach)
+    return FALSE;
+
+  return TRUE;
+}
+
+/*
+FUNCTION
+	bfd_get_arch_info
+
+SYNOPSIS
+	const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);
+
+DESCRIPTION
+	Return the architecture info struct in @var{abfd}.
+*/
+
+const bfd_arch_info_type *
+bfd_get_arch_info (bfd *abfd)
+{
+  return abfd->arch_info;
+}
+
+/*
+FUNCTION
+	bfd_lookup_arch
+
+SYNOPSIS
+	const bfd_arch_info_type *bfd_lookup_arch
+	  (enum bfd_architecture arch, unsigned long machine);
+
+DESCRIPTION
+	Look for the architecture info structure which matches the
+	arguments @var{arch} and @var{machine}. A machine of 0 matches the
+	machine/architecture structure which marks itself as the
+	default.
+*/
+
+const bfd_arch_info_type *
+bfd_lookup_arch (enum bfd_architecture arch, unsigned long machine)
+{
+  const bfd_arch_info_type * const *app, *ap;
+
+  for (app = bfd_archures_list; *app != NULL; app++)
+    {
+      for (ap = *app; ap != NULL; ap = ap->next)
+	{
+	  if (ap->arch == arch
+	      && (ap->mach == machine
+		  || (machine == 0 && ap->the_default)))
+	    return ap;
+	}
+    }
+
+  return NULL;
+}
+
+/*
+FUNCTION
+	bfd_printable_arch_mach
+
+SYNOPSIS
+	const char *bfd_printable_arch_mach
+	  (enum bfd_architecture arch, unsigned long machine);
+
+DESCRIPTION
+	Return a printable string representing the architecture and
+	machine type.
+
+	This routine is depreciated.
+*/
+
+const char *
+bfd_printable_arch_mach (enum bfd_architecture arch, unsigned long machine)
+{
+  const bfd_arch_info_type *ap = bfd_lookup_arch (arch, machine);
+
+  if (ap)
+    return ap->printable_name;
+  return "UNKNOWN!";
+}
+
+/*
+FUNCTION
+	bfd_octets_per_byte
+
+SYNOPSIS
+	unsigned int bfd_octets_per_byte (bfd *abfd);
+
+DESCRIPTION
+	Return the number of octets (8-bit quantities) per target byte
+        (minimum addressable unit).  In most cases, this will be one, but some
+        DSP targets have 16, 32, or even 48 bits per byte.
+*/
+
+unsigned int
+bfd_octets_per_byte (bfd *abfd)
+{
+  return bfd_arch_mach_octets_per_byte (bfd_get_arch (abfd),
+					bfd_get_mach (abfd));
+}
+
+/*
+FUNCTION
+	bfd_arch_mach_octets_per_byte
+
+SYNOPSIS
+	unsigned int bfd_arch_mach_octets_per_byte
+	  (enum bfd_architecture arch, unsigned long machine);
+
+DESCRIPTION
+	See bfd_octets_per_byte.
+
+        This routine is provided for those cases where a bfd * is not
+        available
+*/
+
+unsigned int
+bfd_arch_mach_octets_per_byte (enum bfd_architecture arch,
+			       unsigned long mach)
+{
+  const bfd_arch_info_type *ap = bfd_lookup_arch (arch, mach);
+
+  if (ap)
+    return ap->bits_per_byte / 8;
+  return 1;
+}
diff -urN binutils-2.20.1.old/bfd/bfd-in2.h binutils-2.20.1/bfd/bfd-in2.h
--- binutils-2.20.1.old/bfd/bfd-in2.h	2010-02-03 07:28:24.000000000 -0600
+++ binutils-2.20.1/bfd/bfd-in2.h	2010-04-13 09:49:42.337948099 -0500
@@ -2042,6 +2042,13 @@
 #define bfd_mach_avr5          5
 #define bfd_mach_avr51         51
 #define bfd_mach_avr6          6
+#define bfd_mach_avrxmega1 101
+#define bfd_mach_avrxmega2 102
+#define bfd_mach_avrxmega3 103
+#define bfd_mach_avrxmega4 104
+#define bfd_mach_avrxmega5 105
+#define bfd_mach_avrxmega6 106
+#define bfd_mach_avrxmega7 107
   bfd_arch_bfin,        /* ADI Blackfin */
 #define bfd_mach_bfin          1
   bfd_arch_cr16,       /* National Semiconductor CompactRISC (ie CR16). */
diff -urN binutils-2.20.1.old/bfd/bfd-in2.h.orig binutils-2.20.1/bfd/bfd-in2.h.orig
--- binutils-2.20.1.old/bfd/bfd-in2.h.orig	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/bfd/bfd-in2.h.orig	2010-02-03 07:28:24.000000000 -0600
@@ -0,0 +1,5724 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*-  This file is automatically 
+   generated from "bfd-in.h", "init.c", "opncls.c", "libbfd.c", 
+   "bfdio.c", "bfdwin.c", "section.c", "archures.c", "reloc.c", 
+   "syms.c", "bfd.c", "archive.c", "corefile.c", "targets.c", "format.c", 
+   "linker.c", "simple.c" and "compress.c".
+   Run "make headers" in your build bfd/ to regenerate.  */
+
+/* Main header file for the bfd library -- portable access to object files.
+
+   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+   Free Software Foundation, Inc.
+
+   Contributed by Cygnus Support.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef __BFD_H_SEEN__
+#define __BFD_H_SEEN__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "ansidecl.h"
+#include "symcat.h"
+#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
+#ifndef SABER
+/* This hack is to avoid a problem with some strict ANSI C preprocessors.
+   The problem is, "32_" is not a valid preprocessing token, and we don't
+   want extra underscores (e.g., "nlm_32_").  The XCONCAT2 macro will
+   cause the inner CONCAT2 macros to be evaluated first, producing
+   still-valid pp-tokens.  Then the final concatenation can be done.  */
+#undef CONCAT4
+#define CONCAT4(a,b,c,d) XCONCAT2(CONCAT2(a,b),CONCAT2(c,d))
+#endif
+#endif
+
+/* This is a utility macro to handle the situation where the code
+   wants to place a constant string into the code, followed by a
+   comma and then the length of the string.  Doing this by hand
+   is error prone, so using this macro is safer.  */
+#define STRING_COMMA_LEN(STR) (STR), (sizeof (STR) - 1)
+/* Unfortunately it is not possible to use the STRING_COMMA_LEN macro
+   to create the arguments to another macro, since the preprocessor
+   will mis-count the number of arguments to the outer macro (by not
+   evaluating STRING_COMMA_LEN and so missing the comma).  This is a
+   problem for example when trying to use STRING_COMMA_LEN to build
+   the arguments to the strncmp() macro.  Hence this alternative
+   definition of strncmp is provided here.
+   
+   Note - these macros do NOT work if STR2 is not a constant string.  */
+#define CONST_STRNEQ(STR1,STR2) (strncmp ((STR1), (STR2), sizeof (STR2) - 1) == 0)
+  /* strcpy() can have a similar problem, but since we know we are
+     copying a constant string, we can use memcpy which will be faster
+     since there is no need to check for a NUL byte inside STR.  We
+     can also save time if we do not need to copy the terminating NUL.  */
+#define LITMEMCPY(DEST,STR2) memcpy ((DEST), (STR2), sizeof (STR2) - 1)
+#define LITSTRCPY(DEST,STR2) memcpy ((DEST), (STR2), sizeof (STR2))
+
+
+#define BFD_SUPPORTS_PLUGINS @supports_plugins@
+
+/* The word size used by BFD on the host.  This may be 64 with a 32
+   bit target if the host is 64 bit, or if other 64 bit targets have
+   been selected with --enable-targets, or if --enable-64-bit-bfd.  */
+#define BFD_ARCH_SIZE @wordsize@
+
+/* The word size of the default bfd target.  */
+#define BFD_DEFAULT_TARGET_SIZE @bfd_default_target_size@
+
+#define BFD_HOST_64BIT_LONG @BFD_HOST_64BIT_LONG@
+#define BFD_HOST_64BIT_LONG_LONG @BFD_HOST_64BIT_LONG_LONG@
+#if @BFD_HOST_64_BIT_DEFINED@
+#define BFD_HOST_64_BIT @BFD_HOST_64_BIT@
+#define BFD_HOST_U_64_BIT @BFD_HOST_U_64_BIT@
+typedef BFD_HOST_64_BIT bfd_int64_t;
+typedef BFD_HOST_U_64_BIT bfd_uint64_t;
+#endif
+
+#if BFD_ARCH_SIZE >= 64
+#define BFD64
+#endif
+
+#ifndef INLINE
+#if __GNUC__ >= 2
+#define INLINE __inline__
+#else
+#define INLINE
+#endif
+#endif
+
+/* Declaring a type wide enough to hold a host long and a host pointer.  */
+#define BFD_HOSTPTR_T	@BFD_HOSTPTR_T@
+typedef BFD_HOSTPTR_T bfd_hostptr_t;
+
+/* Forward declaration.  */
+typedef struct bfd bfd;
+
+/* Boolean type used in bfd.  Too many systems define their own
+   versions of "boolean" for us to safely typedef a "boolean" of
+   our own.  Using an enum for "bfd_boolean" has its own set of
+   problems, with strange looking casts required to avoid warnings
+   on some older compilers.  Thus we just use an int.
+
+   General rule: Functions which are bfd_boolean return TRUE on
+   success and FALSE on failure (unless they're a predicate).  */
+
+typedef int bfd_boolean;
+#undef FALSE
+#undef TRUE
+#define FALSE 0
+#define TRUE 1
+
+#ifdef BFD64
+
+#ifndef BFD_HOST_64_BIT
+ #error No 64 bit integer type available
+#endif /* ! defined (BFD_HOST_64_BIT) */
+
+typedef BFD_HOST_U_64_BIT bfd_vma;
+typedef BFD_HOST_64_BIT bfd_signed_vma;
+typedef BFD_HOST_U_64_BIT bfd_size_type;
+typedef BFD_HOST_U_64_BIT symvalue;
+
+#if BFD_HOST_64BIT_LONG
+#define BFD_VMA_FMT "l"
+#elif defined (__MSVCRT__)
+#define BFD_VMA_FMT "I64"
+#else
+#define BFD_VMA_FMT "ll"
+#endif
+
+#ifndef fprintf_vma
+#define sprintf_vma(s,x) sprintf (s, "%016" BFD_VMA_FMT "x", x)
+#define fprintf_vma(f,x) fprintf (f, "%016" BFD_VMA_FMT "x", x)
+#endif
+
+#else /* not BFD64  */
+
+/* Represent a target address.  Also used as a generic unsigned type
+   which is guaranteed to be big enough to hold any arithmetic types
+   we need to deal with.  */
+typedef unsigned long bfd_vma;
+
+/* A generic signed type which is guaranteed to be big enough to hold any
+   arithmetic types we need to deal with.  Can be assumed to be compatible
+   with bfd_vma in the same way that signed and unsigned ints are compatible
+   (as parameters, in assignment, etc).  */
+typedef long bfd_signed_vma;
+
+typedef unsigned long symvalue;
+typedef unsigned long bfd_size_type;
+
+/* Print a bfd_vma x on stream s.  */
+#define BFD_VMA_FMT "l"
+#define fprintf_vma(s,x) fprintf (s, "%08" BFD_VMA_FMT "x", x)
+#define sprintf_vma(s,x) sprintf (s, "%08" BFD_VMA_FMT "x", x)
+
+#endif /* not BFD64  */
+
+#define HALF_BFD_SIZE_TYPE \
+  (((bfd_size_type) 1) << (8 * sizeof (bfd_size_type) / 2))
+
+#ifndef BFD_HOST_64_BIT
+/* Fall back on a 32 bit type.  The idea is to make these types always
+   available for function return types, but in the case that
+   BFD_HOST_64_BIT is undefined such a function should abort or
+   otherwise signal an error.  */
+typedef bfd_signed_vma bfd_int64_t;
+typedef bfd_vma bfd_uint64_t;
+#endif
+
+/* An offset into a file.  BFD always uses the largest possible offset
+   based on the build time availability of fseek, fseeko, or fseeko64.  */
+typedef @bfd_file_ptr@ file_ptr;
+typedef unsigned @bfd_file_ptr@ ufile_ptr;
+
+extern void bfd_sprintf_vma (bfd *, char *, bfd_vma);
+extern void bfd_fprintf_vma (bfd *, void *, bfd_vma);
+
+#define printf_vma(x) fprintf_vma(stdout,x)
+#define bfd_printf_vma(abfd,x) bfd_fprintf_vma (abfd,stdout,x)
+
+typedef unsigned int flagword;	/* 32 bits of flags */
+typedef unsigned char bfd_byte;
+
+/* File formats.  */
+
+typedef enum bfd_format
+{
+  bfd_unknown = 0,	/* File format is unknown.  */
+  bfd_object,		/* Linker/assembler/compiler output.  */
+  bfd_archive,		/* Object archive file.  */
+  bfd_core,		/* Core dump.  */
+  bfd_type_end		/* Marks the end; don't use it!  */
+}
+bfd_format;
+
+/* Symbols and relocation.  */
+
+/* A count of carsyms (canonical archive symbols).  */
+typedef unsigned long symindex;
+
+/* How to perform a relocation.  */
+typedef const struct reloc_howto_struct reloc_howto_type;
+
+#define BFD_NO_MORE_SYMBOLS ((symindex) ~0)
+
+/* General purpose part of a symbol X;
+   target specific parts are in libcoff.h, libaout.h, etc.  */
+
+#define bfd_get_section(x) ((x)->section)
+#define bfd_get_output_section(x) ((x)->section->output_section)
+#define bfd_set_section(x,y) ((x)->section) = (y)
+#define bfd_asymbol_base(x) ((x)->section->vma)
+#define bfd_asymbol_value(x) (bfd_asymbol_base(x) + (x)->value)
+#define bfd_asymbol_name(x) ((x)->name)
+/*Perhaps future: #define bfd_asymbol_bfd(x) ((x)->section->owner)*/
+#define bfd_asymbol_bfd(x) ((x)->the_bfd)
+#define bfd_asymbol_flavour(x)			\
+  (((x)->flags & BSF_SYNTHETIC) != 0		\
+   ? bfd_target_unknown_flavour			\
+   : bfd_asymbol_bfd (x)->xvec->flavour)
+
+/* A canonical archive symbol.  */
+/* This is a type pun with struct ranlib on purpose!  */
+typedef struct carsym
+{
+  char *name;
+  file_ptr file_offset;	/* Look here to find the file.  */
+}
+carsym;			/* To make these you call a carsymogen.  */
+
+/* Used in generating armaps (archive tables of contents).
+   Perhaps just a forward definition would do?  */
+struct orl 			/* Output ranlib.  */
+{
+  char **name;		/* Symbol name.  */
+  union
+  {
+    file_ptr pos;
+    bfd *abfd;
+  } u;			/* bfd* or file position.  */
+  int namidx;		/* Index into string table.  */
+};
+
+/* Linenumber stuff.  */
+typedef struct lineno_cache_entry
+{
+  unsigned int line_number;	/* Linenumber from start of function.  */
+  union
+  {
+    struct bfd_symbol *sym;	/* Function name.  */
+    bfd_vma offset;	    		/* Offset into section.  */
+  } u;
+}
+alent;
+
+/* Object and core file sections.  */
+
+#define	align_power(addr, align)	\
+  (((addr) + ((bfd_vma) 1 << (align)) - 1) & ((bfd_vma) -1 << (align)))
+
+typedef struct bfd_section *sec_ptr;
+
+#define bfd_get_section_name(bfd, ptr) ((ptr)->name + 0)
+#define bfd_get_section_vma(bfd, ptr) ((ptr)->vma + 0)
+#define bfd_get_section_lma(bfd, ptr) ((ptr)->lma + 0)
+#define bfd_get_section_alignment(bfd, ptr) ((ptr)->alignment_power + 0)
+#define bfd_section_name(bfd, ptr) ((ptr)->name)
+#define bfd_section_size(bfd, ptr) ((ptr)->size)
+#define bfd_get_section_size(ptr) ((ptr)->size)
+#define bfd_section_vma(bfd, ptr) ((ptr)->vma)
+#define bfd_section_lma(bfd, ptr) ((ptr)->lma)
+#define bfd_section_alignment(bfd, ptr) ((ptr)->alignment_power)
+#define bfd_get_section_flags(bfd, ptr) ((ptr)->flags + 0)
+#define bfd_get_section_userdata(bfd, ptr) ((ptr)->userdata)
+
+#define bfd_is_com_section(ptr) (((ptr)->flags & SEC_IS_COMMON) != 0)
+
+#define bfd_set_section_vma(bfd, ptr, val) (((ptr)->vma = (ptr)->lma = (val)), ((ptr)->user_set_vma = TRUE), TRUE)
+#define bfd_set_section_alignment(bfd, ptr, val) (((ptr)->alignment_power = (val)),TRUE)
+#define bfd_set_section_userdata(bfd, ptr, val) (((ptr)->userdata = (val)),TRUE)
+/* Find the address one past the end of SEC.  */
+#define bfd_get_section_limit(bfd, sec) \
+  (((sec)->rawsize ? (sec)->rawsize : (sec)->size) \
+   / bfd_octets_per_byte (bfd))
+
+/* Return TRUE if section has been discarded.  */
+#define elf_discarded_section(sec)				\
+  (!bfd_is_abs_section (sec)					\
+   && bfd_is_abs_section ((sec)->output_section)		\
+   && (sec)->sec_info_type != ELF_INFO_TYPE_MERGE		\
+   && (sec)->sec_info_type != ELF_INFO_TYPE_JUST_SYMS)
+
+/* Forward define.  */
+struct stat;
+
+typedef enum bfd_print_symbol
+{
+  bfd_print_symbol_name,
+  bfd_print_symbol_more,
+  bfd_print_symbol_all
+} bfd_print_symbol_type;
+
+/* Information about a symbol that nm needs.  */
+
+typedef struct _symbol_info
+{
+  symvalue value;
+  char type;
+  const char *name;            /* Symbol name.  */
+  unsigned char stab_type;     /* Stab type.  */
+  char stab_other;             /* Stab other.  */
+  short stab_desc;             /* Stab desc.  */
+  const char *stab_name;       /* String for stab type.  */
+} symbol_info;
+
+/* Get the name of a stabs type code.  */
+
+extern const char *bfd_get_stab_name (int);
+
+/* Hash table routines.  There is no way to free up a hash table.  */
+
+/* An element in the hash table.  Most uses will actually use a larger
+   structure, and an instance of this will be the first field.  */
+
+struct bfd_hash_entry
+{
+  /* Next entry for this hash code.  */
+  struct bfd_hash_entry *next;
+  /* String being hashed.  */
+  const char *string;
+  /* Hash code.  This is the full hash code, not the index into the
+     table.  */
+  unsigned long hash;
+};
+
+/* A hash table.  */
+
+struct bfd_hash_table
+{
+  /* The hash array.  */
+  struct bfd_hash_entry **table;
+  /* A function used to create new elements in the hash table.  The
+     first entry is itself a pointer to an element.  When this
+     function is first invoked, this pointer will be NULL.  However,
+     having the pointer permits a hierarchy of method functions to be
+     built each of which calls the function in the superclass.  Thus
+     each function should be written to allocate a new block of memory
+     only if the argument is NULL.  */
+  struct bfd_hash_entry *(*newfunc)
+    (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
+   /* An objalloc for this hash table.  This is a struct objalloc *,
+     but we use void * to avoid requiring the inclusion of objalloc.h.  */
+  void *memory;
+  /* The number of slots in the hash table.  */
+  unsigned int size;
+  /* The number of entries in the hash table.  */
+  unsigned int count;
+  /* The size of elements.  */
+  unsigned int entsize;
+  /* If non-zero, don't grow the hash table.  */
+  unsigned int frozen:1;
+};
+
+/* Initialize a hash table.  */
+extern bfd_boolean bfd_hash_table_init
+  (struct bfd_hash_table *,
+   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
+			       struct bfd_hash_table *,
+			       const char *),
+   unsigned int);
+
+/* Initialize a hash table specifying a size.  */
+extern bfd_boolean bfd_hash_table_init_n
+  (struct bfd_hash_table *,
+   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
+			       struct bfd_hash_table *,
+			       const char *),
+   unsigned int, unsigned int);
+
+/* Free up a hash table.  */
+extern void bfd_hash_table_free
+  (struct bfd_hash_table *);
+
+/* Look up a string in a hash table.  If CREATE is TRUE, a new entry
+   will be created for this string if one does not already exist.  The
+   COPY argument must be TRUE if this routine should copy the string
+   into newly allocated memory when adding an entry.  */
+extern struct bfd_hash_entry *bfd_hash_lookup
+  (struct bfd_hash_table *, const char *, bfd_boolean create,
+   bfd_boolean copy);
+
+/* Insert an entry in a hash table.  */
+extern struct bfd_hash_entry *bfd_hash_insert
+  (struct bfd_hash_table *, const char *, unsigned long);
+
+/* Replace an entry in a hash table.  */
+extern void bfd_hash_replace
+  (struct bfd_hash_table *, struct bfd_hash_entry *old,
+   struct bfd_hash_entry *nw);
+
+/* Base method for creating a hash table entry.  */
+extern struct bfd_hash_entry *bfd_hash_newfunc
+  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
+
+/* Grab some space for a hash table entry.  */
+extern void *bfd_hash_allocate
+  (struct bfd_hash_table *, unsigned int);
+
+/* Traverse a hash table in a random order, calling a function on each
+   element.  If the function returns FALSE, the traversal stops.  The
+   INFO argument is passed to the function.  */
+extern void bfd_hash_traverse
+  (struct bfd_hash_table *,
+   bfd_boolean (*) (struct bfd_hash_entry *, void *),
+   void *info);
+
+/* Allows the default size of a hash table to be configured. New hash
+   tables allocated using bfd_hash_table_init will be created with
+   this size.  */
+extern void bfd_hash_set_default_size (bfd_size_type);
+
+/* This structure is used to keep track of stabs in sections
+   information while linking.  */
+
+struct stab_info
+{
+  /* A hash table used to hold stabs strings.  */
+  struct bfd_strtab_hash *strings;
+  /* The header file hash table.  */
+  struct bfd_hash_table includes;
+  /* The first .stabstr section.  */
+  struct bfd_section *stabstr;
+};
+
+#define COFF_SWAP_TABLE (void *) &bfd_coff_std_swap_table
+
+/* User program access to BFD facilities.  */
+
+/* Direct I/O routines, for programs which know more about the object
+   file than BFD does.  Use higher level routines if possible.  */
+
+extern bfd_size_type bfd_bread (void *, bfd_size_type, bfd *);
+extern bfd_size_type bfd_bwrite (const void *, bfd_size_type, bfd *);
+extern int bfd_seek (bfd *, file_ptr, int);
+extern file_ptr bfd_tell (bfd *);
+extern int bfd_flush (bfd *);
+extern int bfd_stat (bfd *, struct stat *);
+
+/* Deprecated old routines.  */
+#if __GNUC__
+#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_read", __FILE__, __LINE__, __FUNCTION__),	\
+   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_write", __FILE__, __LINE__, __FUNCTION__),	\
+   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#else
+#define bfd_read(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_read", (const char *) 0, 0, (const char *) 0), \
+   bfd_bread ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#define bfd_write(BUF, ELTSIZE, NITEMS, ABFD)				\
+  (warn_deprecated ("bfd_write", (const char *) 0, 0, (const char *) 0),\
+   bfd_bwrite ((BUF), (ELTSIZE) * (NITEMS), (ABFD)))
+#endif
+extern void warn_deprecated (const char *, const char *, int, const char *);
+
+/* Cast from const char * to char * so that caller can assign to
+   a char * without a warning.  */
+#define bfd_get_filename(abfd) ((char *) (abfd)->filename)
+#define bfd_get_cacheable(abfd) ((abfd)->cacheable)
+#define bfd_get_format(abfd) ((abfd)->format)
+#define bfd_get_target(abfd) ((abfd)->xvec->name)
+#define bfd_get_flavour(abfd) ((abfd)->xvec->flavour)
+#define bfd_family_coff(abfd) \
+  (bfd_get_flavour (abfd) == bfd_target_coff_flavour || \
+   bfd_get_flavour (abfd) == bfd_target_xcoff_flavour)
+#define bfd_big_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_BIG)
+#define bfd_little_endian(abfd) ((abfd)->xvec->byteorder == BFD_ENDIAN_LITTLE)
+#define bfd_header_big_endian(abfd) \
+  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_BIG)
+#define bfd_header_little_endian(abfd) \
+  ((abfd)->xvec->header_byteorder == BFD_ENDIAN_LITTLE)
+#define bfd_get_file_flags(abfd) ((abfd)->flags)
+#define bfd_applicable_file_flags(abfd) ((abfd)->xvec->object_flags)
+#define bfd_applicable_section_flags(abfd) ((abfd)->xvec->section_flags)
+#define bfd_my_archive(abfd) ((abfd)->my_archive)
+#define bfd_has_map(abfd) ((abfd)->has_armap)
+#define bfd_is_thin_archive(abfd) ((abfd)->is_thin_archive)
+
+#define bfd_valid_reloc_types(abfd) ((abfd)->xvec->valid_reloc_types)
+#define bfd_usrdata(abfd) ((abfd)->usrdata)
+
+#define bfd_get_start_address(abfd) ((abfd)->start_address)
+#define bfd_get_symcount(abfd) ((abfd)->symcount)
+#define bfd_get_outsymbols(abfd) ((abfd)->outsymbols)
+#define bfd_count_sections(abfd) ((abfd)->section_count)
+
+#define bfd_get_dynamic_symcount(abfd) ((abfd)->dynsymcount)
+
+#define bfd_get_symbol_leading_char(abfd) ((abfd)->xvec->symbol_leading_char)
+
+#define bfd_set_cacheable(abfd,bool) (((abfd)->cacheable = bool), TRUE)
+
+extern bfd_boolean bfd_cache_close
+  (bfd *abfd);
+/* NB: This declaration should match the autogenerated one in libbfd.h.  */
+
+extern bfd_boolean bfd_cache_close_all (void);
+
+extern bfd_boolean bfd_record_phdr
+  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,
+   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);
+
+/* Byte swapping routines.  */
+
+bfd_uint64_t bfd_getb64 (const void *);
+bfd_uint64_t bfd_getl64 (const void *);
+bfd_int64_t bfd_getb_signed_64 (const void *);
+bfd_int64_t bfd_getl_signed_64 (const void *);
+bfd_vma bfd_getb32 (const void *);
+bfd_vma bfd_getl32 (const void *);
+bfd_signed_vma bfd_getb_signed_32 (const void *);
+bfd_signed_vma bfd_getl_signed_32 (const void *);
+bfd_vma bfd_getb16 (const void *);
+bfd_vma bfd_getl16 (const void *);
+bfd_signed_vma bfd_getb_signed_16 (const void *);
+bfd_signed_vma bfd_getl_signed_16 (const void *);
+void bfd_putb64 (bfd_uint64_t, void *);
+void bfd_putl64 (bfd_uint64_t, void *);
+void bfd_putb32 (bfd_vma, void *);
+void bfd_putl32 (bfd_vma, void *);
+void bfd_putb16 (bfd_vma, void *);
+void bfd_putl16 (bfd_vma, void *);
+
+/* Byte swapping routines which take size and endiannes as arguments.  */
+
+bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);
+void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);
+
+extern bfd_boolean bfd_section_already_linked_table_init (void);
+extern void bfd_section_already_linked_table_free (void);
+
+/* Externally visible ECOFF routines.  */
+
+#if defined(__STDC__) || defined(ALMOST_STDC)
+struct ecoff_debug_info;
+struct ecoff_debug_swap;
+struct ecoff_extr;
+struct bfd_symbol;
+struct bfd_link_info;
+struct bfd_link_hash_entry;
+struct bfd_elf_version_tree;
+#endif
+extern bfd_vma bfd_ecoff_get_gp_value
+  (bfd * abfd);
+extern bfd_boolean bfd_ecoff_set_gp_value
+  (bfd *abfd, bfd_vma gp_value);
+extern bfd_boolean bfd_ecoff_set_regmasks
+  (bfd *abfd, unsigned long gprmask, unsigned long fprmask,
+   unsigned long *cprmask);
+extern void *bfd_ecoff_debug_init
+  (bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
+extern void bfd_ecoff_debug_free
+  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, struct bfd_link_info *);
+extern bfd_boolean bfd_ecoff_debug_accumulate
+  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
+   struct ecoff_debug_info *input_debug,
+   const struct ecoff_debug_swap *input_swap, struct bfd_link_info *);
+extern bfd_boolean bfd_ecoff_debug_accumulate_other
+  (void *handle, bfd *output_bfd, struct ecoff_debug_info *output_debug,
+   const struct ecoff_debug_swap *output_swap, bfd *input_bfd,
+   struct bfd_link_info *);
+extern bfd_boolean bfd_ecoff_debug_externals
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap, bfd_boolean relocatable,
+   bfd_boolean (*get_extr) (struct bfd_symbol *, struct ecoff_extr *),
+   void (*set_index) (struct bfd_symbol *, bfd_size_type));
+extern bfd_boolean bfd_ecoff_debug_one_external
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap, const char *name,
+   struct ecoff_extr *esym);
+extern bfd_size_type bfd_ecoff_debug_size
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap);
+extern bfd_boolean bfd_ecoff_write_debug
+  (bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap, file_ptr where);
+extern bfd_boolean bfd_ecoff_write_accumulated_debug
+  (void *handle, bfd *abfd, struct ecoff_debug_info *debug,
+   const struct ecoff_debug_swap *swap,
+   struct bfd_link_info *info, file_ptr where);
+
+/* Externally visible ELF routines.  */
+
+struct bfd_link_needed_list
+{
+  struct bfd_link_needed_list *next;
+  bfd *by;
+  const char *name;
+};
+
+enum dynamic_lib_link_class {
+  DYN_NORMAL = 0,
+  DYN_AS_NEEDED = 1,
+  DYN_DT_NEEDED = 2,
+  DYN_NO_ADD_NEEDED = 4,
+  DYN_NO_NEEDED = 8
+};
+
+enum notice_asneeded_action {
+  notice_as_needed,
+  notice_not_needed,
+  notice_needed
+};
+
+extern bfd_boolean bfd_elf_record_link_assignment
+  (bfd *, struct bfd_link_info *, const char *, bfd_boolean,
+   bfd_boolean);
+extern struct bfd_link_needed_list *bfd_elf_get_needed_list
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_elf_get_bfd_needed_list
+  (bfd *, struct bfd_link_needed_list **);
+extern bfd_boolean bfd_elf_size_dynamic_sections
+  (bfd *, const char *, const char *, const char *, const char * const *,
+   struct bfd_link_info *, struct bfd_section **,
+   struct bfd_elf_version_tree *);
+extern bfd_boolean bfd_elf_size_dynsym_hash_dynstr
+  (bfd *, struct bfd_link_info *);
+extern void bfd_elf_set_dt_needed_name
+  (bfd *, const char *);
+extern const char *bfd_elf_get_dt_soname
+  (bfd *);
+extern void bfd_elf_set_dyn_lib_class
+  (bfd *, enum dynamic_lib_link_class);
+extern int bfd_elf_get_dyn_lib_class
+  (bfd *);
+extern struct bfd_link_needed_list *bfd_elf_get_runpath_list
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_elf_discard_info
+  (bfd *, struct bfd_link_info *);
+extern unsigned int _bfd_elf_default_action_discarded
+  (struct bfd_section *);
+
+/* Return an upper bound on the number of bytes required to store a
+   copy of ABFD's program header table entries.  Return -1 if an error
+   occurs; bfd_get_error will return an appropriate code.  */
+extern long bfd_get_elf_phdr_upper_bound
+  (bfd *abfd);
+
+/* Copy ABFD's program header table entries to *PHDRS.  The entries
+   will be stored as an array of Elf_Internal_Phdr structures, as
+   defined in include/elf/internal.h.  To find out how large the
+   buffer needs to be, call bfd_get_elf_phdr_upper_bound.
+
+   Return the number of program header table entries read, or -1 if an
+   error occurs; bfd_get_error will return an appropriate code.  */
+extern int bfd_get_elf_phdrs
+  (bfd *abfd, void *phdrs);
+
+/* Create a new BFD as if by bfd_openr.  Rather than opening a file,
+   reconstruct an ELF file by reading the segments out of remote memory
+   based on the ELF file header at EHDR_VMA and the ELF program headers it
+   points to.  If not null, *LOADBASEP is filled in with the difference
+   between the VMAs from which the segments were read, and the VMAs the
+   file headers (and hence BFD's idea of each section's VMA) put them at.
+
+   The function TARGET_READ_MEMORY is called to copy LEN bytes from the
+   remote memory at target address VMA into the local buffer at MYADDR; it
+   should return zero on success or an `errno' code on failure.  TEMPL must
+   be a BFD for an ELF target with the word size and byte order found in
+   the remote memory.  */
+extern bfd *bfd_elf_bfd_from_remote_memory
+  (bfd *templ, bfd_vma ehdr_vma, bfd_vma *loadbasep,
+   int (*target_read_memory) (bfd_vma vma, bfd_byte *myaddr, int len));
+
+/* Return the arch_size field of an elf bfd, or -1 if not elf.  */
+extern int bfd_get_arch_size
+  (bfd *);
+
+/* Return TRUE if address "naturally" sign extends, or -1 if not elf.  */
+extern int bfd_get_sign_extend_vma
+  (bfd *);
+
+extern struct bfd_section *_bfd_elf_tls_setup
+  (bfd *, struct bfd_link_info *);
+
+extern void _bfd_fix_excluded_sec_syms
+  (bfd *, struct bfd_link_info *);
+
+extern unsigned bfd_m68k_mach_to_features (int);
+
+extern int bfd_m68k_features_to_mach (unsigned);
+
+extern bfd_boolean bfd_m68k_elf32_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
+   char **);
+
+extern void bfd_elf_m68k_set_target_options (struct bfd_link_info *, int);
+
+extern bfd_boolean bfd_bfin_elf32_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
+   char **);
+
+extern bfd_boolean bfd_cr16_elf32_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *,
+   char **);
+
+/* SunOS shared library support routines for the linker.  */
+
+extern struct bfd_link_needed_list *bfd_sunos_get_needed_list
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_sunos_record_link_assignment
+  (bfd *, struct bfd_link_info *, const char *);
+extern bfd_boolean bfd_sunos_size_dynamic_sections
+  (bfd *, struct bfd_link_info *, struct bfd_section **,
+   struct bfd_section **, struct bfd_section **);
+
+/* Linux shared library support routines for the linker.  */
+
+extern bfd_boolean bfd_i386linux_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_m68klinux_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+extern bfd_boolean bfd_sparclinux_size_dynamic_sections
+  (bfd *, struct bfd_link_info *);
+
+/* mmap hacks */
+
+struct _bfd_window_internal;
+typedef struct _bfd_window_internal bfd_window_internal;
+
+typedef struct _bfd_window
+{
+  /* What the user asked for.  */
+  void *data;
+  bfd_size_type size;
+  /* The actual window used by BFD.  Small user-requested read-only
+     regions sharing a page may share a single window into the object
+     file.  Read-write versions shouldn't until I've fixed things to
+     keep track of which portions have been claimed by the
+     application; don't want to give the same region back when the
+     application wants two writable copies!  */
+  struct _bfd_window_internal *i;
+}
+bfd_window;
+
+extern void bfd_init_window
+  (bfd_window *);
+extern void bfd_free_window
+  (bfd_window *);
+extern bfd_boolean bfd_get_file_window
+  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);
+
+/* XCOFF support routines for the linker.  */
+
+extern bfd_boolean bfd_xcoff_split_import_path
+  (bfd *, const char *, const char **, const char **);
+extern bfd_boolean bfd_xcoff_set_archive_import_path
+  (struct bfd_link_info *, bfd *, const char *);
+extern bfd_boolean bfd_xcoff_link_record_set
+  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_size_type);
+extern bfd_boolean bfd_xcoff_import_symbol
+  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, bfd_vma,
+   const char *, const char *, const char *, unsigned int);
+extern bfd_boolean bfd_xcoff_export_symbol
+  (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *);
+extern bfd_boolean bfd_xcoff_link_count_reloc
+  (bfd *, struct bfd_link_info *, const char *);
+extern bfd_boolean bfd_xcoff_record_link_assignment
+  (bfd *, struct bfd_link_info *, const char *);
+extern bfd_boolean bfd_xcoff_size_dynamic_sections
+  (bfd *, struct bfd_link_info *, const char *, const char *,
+   unsigned long, unsigned long, unsigned long, bfd_boolean,
+   int, bfd_boolean, unsigned int, struct bfd_section **, bfd_boolean);
+extern bfd_boolean bfd_xcoff_link_generate_rtinit
+  (bfd *, const char *, const char *, bfd_boolean);
+
+/* XCOFF support routines for ar.  */
+extern bfd_boolean bfd_xcoff_ar_archive_set_magic
+  (bfd *, char *);
+
+/* Externally visible COFF routines.  */
+
+#if defined(__STDC__) || defined(ALMOST_STDC)
+struct internal_syment;
+union internal_auxent;
+#endif
+
+extern bfd_boolean bfd_coff_get_syment
+  (bfd *, struct bfd_symbol *, struct internal_syment *);
+
+extern bfd_boolean bfd_coff_get_auxent
+  (bfd *, struct bfd_symbol *, int, union internal_auxent *);
+
+extern bfd_boolean bfd_coff_set_symbol_class
+  (bfd *, struct bfd_symbol *, unsigned int);
+
+extern bfd_boolean bfd_m68k_coff_create_embedded_relocs
+  (bfd *, struct bfd_link_info *, struct bfd_section *, struct bfd_section *, char **);
+
+/* ARM VFP11 erratum workaround support.  */
+typedef enum
+{
+  BFD_ARM_VFP11_FIX_DEFAULT,
+  BFD_ARM_VFP11_FIX_NONE,
+  BFD_ARM_VFP11_FIX_SCALAR,
+  BFD_ARM_VFP11_FIX_VECTOR
+} bfd_arm_vfp11_fix;
+
+extern void bfd_elf32_arm_init_maps
+  (bfd *);
+
+extern void bfd_elf32_arm_set_vfp11_fix
+  (bfd *, struct bfd_link_info *);
+
+extern void bfd_elf32_arm_set_cortex_a8_fix
+  (bfd *, struct bfd_link_info *);
+
+extern bfd_boolean bfd_elf32_arm_vfp11_erratum_scan
+  (bfd *, struct bfd_link_info *);
+
+extern void bfd_elf32_arm_vfp11_fix_veneer_locations
+  (bfd *, struct bfd_link_info *);
+
+/* ARM Interworking support.  Called from linker.  */
+extern bfd_boolean bfd_arm_allocate_interworking_sections
+  (struct bfd_link_info *);
+
+extern bfd_boolean bfd_arm_process_before_allocation
+  (bfd *, struct bfd_link_info *, int);
+
+extern bfd_boolean bfd_arm_get_bfd_for_interworking
+  (bfd *, struct bfd_link_info *);
+
+/* PE ARM Interworking support.  Called from linker.  */
+extern bfd_boolean bfd_arm_pe_allocate_interworking_sections
+  (struct bfd_link_info *);
+
+extern bfd_boolean bfd_arm_pe_process_before_allocation
+  (bfd *, struct bfd_link_info *, int);
+
+extern bfd_boolean bfd_arm_pe_get_bfd_for_interworking
+  (bfd *, struct bfd_link_info *);
+
+/* ELF ARM Interworking support.  Called from linker.  */
+extern bfd_boolean bfd_elf32_arm_allocate_interworking_sections
+  (struct bfd_link_info *);
+
+extern bfd_boolean bfd_elf32_arm_process_before_allocation
+  (bfd *, struct bfd_link_info *);
+
+void bfd_elf32_arm_set_target_relocs
+  (bfd *, struct bfd_link_info *, int, char *, int, int, bfd_arm_vfp11_fix,
+   int, int, int, int);
+
+extern bfd_boolean bfd_elf32_arm_get_bfd_for_interworking
+  (bfd *, struct bfd_link_info *);
+
+extern bfd_boolean bfd_elf32_arm_add_glue_sections_to_bfd
+  (bfd *, struct bfd_link_info *);
+
+/* ELF ARM mapping symbol support */
+#define BFD_ARM_SPECIAL_SYM_TYPE_MAP	(1 << 0)
+#define BFD_ARM_SPECIAL_SYM_TYPE_TAG	(1 << 1)
+#define BFD_ARM_SPECIAL_SYM_TYPE_OTHER  (1 << 2)
+#define BFD_ARM_SPECIAL_SYM_TYPE_ANY	(~0)
+extern bfd_boolean bfd_is_arm_special_symbol_name
+  (const char * name, int type);
+
+extern void bfd_elf32_arm_set_byteswap_code (struct bfd_link_info *, int);
+
+/* ARM Note section processing.  */
+extern bfd_boolean bfd_arm_merge_machines
+  (bfd *, bfd *);
+
+extern bfd_boolean bfd_arm_update_notes
+  (bfd *, const char *);
+
+extern unsigned int bfd_arm_get_mach_from_notes
+  (bfd *, const char *);
+
+/* ARM stub generation support.  Called from the linker.  */
+extern int elf32_arm_setup_section_lists
+  (bfd *, struct bfd_link_info *);
+extern void elf32_arm_next_input_section
+  (struct bfd_link_info *, struct bfd_section *);
+extern bfd_boolean elf32_arm_size_stubs
+  (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
+   struct bfd_section * (*) (const char *, struct bfd_section *), void (*) (void));
+extern bfd_boolean elf32_arm_build_stubs
+  (struct bfd_link_info *);
+
+/* ARM unwind section editing support.  */
+extern bfd_boolean elf32_arm_fix_exidx_coverage
+  (struct bfd_section **, unsigned int, struct bfd_link_info *);
+
+/* PowerPC @tls opcode transform/validate.  */
+extern unsigned int _bfd_elf_ppc_at_tls_transform
+  (unsigned int, unsigned int);
+/* PowerPC @tprel opcode transform/validate.  */
+extern unsigned int _bfd_elf_ppc_at_tprel_transform
+  (unsigned int, unsigned int);
+
+/* TI COFF load page support.  */
+extern void bfd_ticoff_set_section_load_page
+  (struct bfd_section *, int);
+
+extern int bfd_ticoff_get_section_load_page
+  (struct bfd_section *);
+
+/* H8/300 functions.  */
+extern bfd_vma bfd_h8300_pad_address
+  (bfd *, bfd_vma);
+
+/* IA64 Itanium code generation.  Called from linker.  */
+extern void bfd_elf32_ia64_after_parse
+  (int);
+
+extern void bfd_elf64_ia64_after_parse
+  (int);
+
+/* This structure is used for a comdat section, as in PE.  A comdat
+   section is associated with a particular symbol.  When the linker
+   sees a comdat section, it keeps only one of the sections with a
+   given name and associated with a given symbol.  */
+
+struct coff_comdat_info
+{
+  /* The name of the symbol associated with a comdat section.  */
+  const char *name;
+
+  /* The local symbol table index of the symbol associated with a
+     comdat section.  This is only meaningful to the object file format
+     specific code; it is not an index into the list returned by
+     bfd_canonicalize_symtab.  */
+  long symbol;
+};
+
+extern struct coff_comdat_info *bfd_coff_get_comdat_section
+  (bfd *, struct bfd_section *);
+
+/* Extracted from init.c.  */
+void bfd_init (void);
+
+/* Extracted from opncls.c.  */
+bfd *bfd_fopen (const char *filename, const char *target,
+    const char *mode, int fd);
+
+bfd *bfd_openr (const char *filename, const char *target);
+
+bfd *bfd_fdopenr (const char *filename, const char *target, int fd);
+
+bfd *bfd_openstreamr (const char *, const char *, void *);
+
+bfd *bfd_openr_iovec (const char *filename, const char *target,
+    void *(*open) (struct bfd *nbfd,
+    void *open_closure),
+    void *open_closure,
+    file_ptr (*pread) (struct bfd *nbfd,
+    void *stream,
+    void *buf,
+    file_ptr nbytes,
+    file_ptr offset),
+    int (*close) (struct bfd *nbfd,
+    void *stream),
+    int (*stat) (struct bfd *abfd,
+    void *stream,
+    struct stat *sb));
+
+bfd *bfd_openw (const char *filename, const char *target);
+
+bfd_boolean bfd_close (bfd *abfd);
+
+bfd_boolean bfd_close_all_done (bfd *);
+
+bfd *bfd_create (const char *filename, bfd *templ);
+
+bfd_boolean bfd_make_writable (bfd *abfd);
+
+bfd_boolean bfd_make_readable (bfd *abfd);
+
+unsigned long bfd_calc_gnu_debuglink_crc32
+   (unsigned long crc, const unsigned char *buf, bfd_size_type len);
+
+char *bfd_follow_gnu_debuglink (bfd *abfd, const char *dir);
+
+struct bfd_section *bfd_create_gnu_debuglink_section
+   (bfd *abfd, const char *filename);
+
+bfd_boolean bfd_fill_in_gnu_debuglink_section
+   (bfd *abfd, struct bfd_section *sect, const char *filename);
+
+/* Extracted from libbfd.c.  */
+
+/* Byte swapping macros for user section data.  */
+
+#define bfd_put_8(abfd, val, ptr) \
+  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
+#define bfd_put_signed_8 \
+  bfd_put_8
+#define bfd_get_8(abfd, ptr) \
+  (*(unsigned char *) (ptr) & 0xff)
+#define bfd_get_signed_8(abfd, ptr) \
+  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)
+
+#define bfd_put_16(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
+#define bfd_put_signed_16 \
+  bfd_put_16
+#define bfd_get_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx16, (ptr))
+#define bfd_get_signed_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
+
+#define bfd_put_32(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
+#define bfd_put_signed_32 \
+  bfd_put_32
+#define bfd_get_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx32, (ptr))
+#define bfd_get_signed_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))
+
+#define bfd_put_64(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
+#define bfd_put_signed_64 \
+  bfd_put_64
+#define bfd_get_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx64, (ptr))
+#define bfd_get_signed_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))
+
+#define bfd_get(bits, abfd, ptr)                       \
+  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
+   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
+   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
+   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
+   : (abort (), (bfd_vma) - 1))
+
+#define bfd_put(bits, abfd, val, ptr)                  \
+  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
+   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
+   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
+   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
+   : (abort (), (void) 0))
+
+
+/* Byte swapping macros for file header data.  */
+
+#define bfd_h_put_8(abfd, val, ptr) \
+  bfd_put_8 (abfd, val, ptr)
+#define bfd_h_put_signed_8(abfd, val, ptr) \
+  bfd_put_8 (abfd, val, ptr)
+#define bfd_h_get_8(abfd, ptr) \
+  bfd_get_8 (abfd, ptr)
+#define bfd_h_get_signed_8(abfd, ptr) \
+  bfd_get_signed_8 (abfd, ptr)
+
+#define bfd_h_put_16(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
+#define bfd_h_put_signed_16 \
+  bfd_h_put_16
+#define bfd_h_get_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx16, (ptr))
+#define bfd_h_get_signed_16(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))
+
+#define bfd_h_put_32(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
+#define bfd_h_put_signed_32 \
+  bfd_h_put_32
+#define bfd_h_get_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx32, (ptr))
+#define bfd_h_get_signed_32(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))
+
+#define bfd_h_put_64(abfd, val, ptr) \
+  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
+#define bfd_h_put_signed_64 \
+  bfd_h_put_64
+#define bfd_h_get_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx64, (ptr))
+#define bfd_h_get_signed_64(abfd, ptr) \
+  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))
+
+/* Aliases for the above, which should eventually go away.  */
+
+#define H_PUT_64  bfd_h_put_64
+#define H_PUT_32  bfd_h_put_32
+#define H_PUT_16  bfd_h_put_16
+#define H_PUT_8   bfd_h_put_8
+#define H_PUT_S64 bfd_h_put_signed_64
+#define H_PUT_S32 bfd_h_put_signed_32
+#define H_PUT_S16 bfd_h_put_signed_16
+#define H_PUT_S8  bfd_h_put_signed_8
+#define H_GET_64  bfd_h_get_64
+#define H_GET_32  bfd_h_get_32
+#define H_GET_16  bfd_h_get_16
+#define H_GET_8   bfd_h_get_8
+#define H_GET_S64 bfd_h_get_signed_64
+#define H_GET_S32 bfd_h_get_signed_32
+#define H_GET_S16 bfd_h_get_signed_16
+#define H_GET_S8  bfd_h_get_signed_8
+
+
+/* Extracted from bfdio.c.  */
+long bfd_get_mtime (bfd *abfd);
+
+file_ptr bfd_get_size (bfd *abfd);
+
+void *bfd_mmap (bfd *abfd, void *addr, bfd_size_type len,
+    int prot, int flags, file_ptr offset);
+
+/* Extracted from bfdwin.c.  */
+/* Extracted from section.c.  */
+typedef struct bfd_section
+{
+  /* The name of the section; the name isn't a copy, the pointer is
+     the same as that passed to bfd_make_section.  */
+  const char *name;
+
+  /* A unique sequence number.  */
+  int id;
+
+  /* Which section in the bfd; 0..n-1 as sections are created in a bfd.  */
+  int index;
+
+  /* The next section in the list belonging to the BFD, or NULL.  */
+  struct bfd_section *next;
+
+  /* The previous section in the list belonging to the BFD, or NULL.  */
+  struct bfd_section *prev;
+
+  /* The field flags contains attributes of the section. Some
+     flags are read in from the object file, and some are
+     synthesized from other information.  */
+  flagword flags;
+
+#define SEC_NO_FLAGS   0x000
+
+  /* Tells the OS to allocate space for this section when loading.
+     This is clear for a section containing debug information only.  */
+#define SEC_ALLOC      0x001
+
+  /* Tells the OS to load the section from the file when loading.
+     This is clear for a .bss section.  */
+#define SEC_LOAD       0x002
+
+  /* The section contains data still to be relocated, so there is
+     some relocation information too.  */
+#define SEC_RELOC      0x004
+
+  /* A signal to the OS that the section contains read only data.  */
+#define SEC_READONLY   0x008
+
+  /* The section contains code only.  */
+#define SEC_CODE       0x010
+
+  /* The section contains data only.  */
+#define SEC_DATA       0x020
+
+  /* The section will reside in ROM.  */
+#define SEC_ROM        0x040
+
+  /* The section contains constructor information. This section
+     type is used by the linker to create lists of constructors and
+     destructors used by <<g++>>. When a back end sees a symbol
+     which should be used in a constructor list, it creates a new
+     section for the type of name (e.g., <<__CTOR_LIST__>>), attaches
+     the symbol to it, and builds a relocation. To build the lists
+     of constructors, all the linker has to do is catenate all the
+     sections called <<__CTOR_LIST__>> and relocate the data
+     contained within - exactly the operations it would peform on
+     standard data.  */
+#define SEC_CONSTRUCTOR 0x080
+
+  /* The section has contents - a data section could be
+     <<SEC_ALLOC>> | <<SEC_HAS_CONTENTS>>; a debug section could be
+     <<SEC_HAS_CONTENTS>>  */
+#define SEC_HAS_CONTENTS 0x100
+
+  /* An instruction to the linker to not output the section
+     even if it has information which would normally be written.  */
+#define SEC_NEVER_LOAD 0x200
+
+  /* The section contains thread local data.  */
+#define SEC_THREAD_LOCAL 0x400
+
+  /* The section has GOT references.  This flag is only for the
+     linker, and is currently only used by the elf32-hppa back end.
+     It will be set if global offset table references were detected
+     in this section, which indicate to the linker that the section
+     contains PIC code, and must be handled specially when doing a
+     static link.  */
+#define SEC_HAS_GOT_REF 0x800
+
+  /* The section contains common symbols (symbols may be defined
+     multiple times, the value of a symbol is the amount of
+     space it requires, and the largest symbol value is the one
+     used).  Most targets have exactly one of these (which we
+     translate to bfd_com_section_ptr), but ECOFF has two.  */
+#define SEC_IS_COMMON 0x1000
+
+  /* The section contains only debugging information.  For
+     example, this is set for ELF .debug and .stab sections.
+     strip tests this flag to see if a section can be
+     discarded.  */
+#define SEC_DEBUGGING 0x2000
+
+  /* The contents of this section are held in memory pointed to
+     by the contents field.  This is checked by bfd_get_section_contents,
+     and the data is retrieved from memory if appropriate.  */
+#define SEC_IN_MEMORY 0x4000
+
+  /* The contents of this section are to be excluded by the
+     linker for executable and shared objects unless those
+     objects are to be further relocated.  */
+#define SEC_EXCLUDE 0x8000
+
+  /* The contents of this section are to be sorted based on the sum of
+     the symbol and addend values specified by the associated relocation
+     entries.  Entries without associated relocation entries will be
+     appended to the end of the section in an unspecified order.  */
+#define SEC_SORT_ENTRIES 0x10000
+
+  /* When linking, duplicate sections of the same name should be
+     discarded, rather than being combined into a single section as
+     is usually done.  This is similar to how common symbols are
+     handled.  See SEC_LINK_DUPLICATES below.  */
+#define SEC_LINK_ONCE 0x20000
+
+  /* If SEC_LINK_ONCE is set, this bitfield describes how the linker
+     should handle duplicate sections.  */
+#define SEC_LINK_DUPLICATES 0xc0000
+
+  /* This value for SEC_LINK_DUPLICATES means that duplicate
+     sections with the same name should simply be discarded.  */
+#define SEC_LINK_DUPLICATES_DISCARD 0x0
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if there are any duplicate sections, although
+     it should still only link one copy.  */
+#define SEC_LINK_DUPLICATES_ONE_ONLY 0x40000
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if any duplicate sections are a different size.  */
+#define SEC_LINK_DUPLICATES_SAME_SIZE 0x80000
+
+  /* This value for SEC_LINK_DUPLICATES means that the linker
+     should warn if any duplicate sections contain different
+     contents.  */
+#define SEC_LINK_DUPLICATES_SAME_CONTENTS \
+  (SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE)
+
+  /* This section was created by the linker as part of dynamic
+     relocation or other arcane processing.  It is skipped when
+     going through the first-pass output, trusting that someone
+     else up the line will take care of it later.  */
+#define SEC_LINKER_CREATED 0x100000
+
+  /* This section should not be subject to garbage collection.
+     Also set to inform the linker that this section should not be
+     listed in the link map as discarded.  */
+#define SEC_KEEP 0x200000
+
+  /* This section contains "short" data, and should be placed
+     "near" the GP.  */
+#define SEC_SMALL_DATA 0x400000
+
+  /* Attempt to merge identical entities in the section.
+     Entity size is given in the entsize field.  */
+#define SEC_MERGE 0x800000
+
+  /* If given with SEC_MERGE, entities to merge are zero terminated
+     strings where entsize specifies character size instead of fixed
+     size entries.  */
+#define SEC_STRINGS 0x1000000
+
+  /* This section contains data about section groups.  */
+#define SEC_GROUP 0x2000000
+
+  /* The section is a COFF shared library section.  This flag is
+     only for the linker.  If this type of section appears in
+     the input file, the linker must copy it to the output file
+     without changing the vma or size.  FIXME: Although this
+     was originally intended to be general, it really is COFF
+     specific (and the flag was renamed to indicate this).  It
+     might be cleaner to have some more general mechanism to
+     allow the back end to control what the linker does with
+     sections.  */
+#define SEC_COFF_SHARED_LIBRARY 0x4000000
+
+  /* This section contains data which may be shared with other
+     executables or shared objects. This is for COFF only.  */
+#define SEC_COFF_SHARED 0x8000000
+
+  /* When a section with this flag is being linked, then if the size of
+     the input section is less than a page, it should not cross a page
+     boundary.  If the size of the input section is one page or more,
+     it should be aligned on a page boundary.  This is for TI
+     TMS320C54X only.  */
+#define SEC_TIC54X_BLOCK 0x10000000
+
+  /* Conditionally link this section; do not link if there are no
+     references found to any symbol in the section.  This is for TI
+     TMS320C54X only.  */
+#define SEC_TIC54X_CLINK 0x20000000
+
+  /* Indicate that section has the no read flag set. This happens
+     when memory read flag isn't set. */
+#define SEC_COFF_NOREAD 0x40000000
+
+  /*  End of section flags.  */
+
+  /* Some internal packed boolean fields.  */
+
+  /* See the vma field.  */
+  unsigned int user_set_vma : 1;
+
+  /* A mark flag used by some of the linker backends.  */
+  unsigned int linker_mark : 1;
+
+  /* Another mark flag used by some of the linker backends.  Set for
+     output sections that have an input section.  */
+  unsigned int linker_has_input : 1;
+
+  /* Mark flag used by some linker backends for garbage collection.  */
+  unsigned int gc_mark : 1;
+
+  /* The following flags are used by the ELF linker. */
+
+  /* Mark sections which have been allocated to segments.  */
+  unsigned int segment_mark : 1;
+
+  /* Type of sec_info information.  */
+  unsigned int sec_info_type:3;
+#define ELF_INFO_TYPE_NONE      0
+#define ELF_INFO_TYPE_STABS     1
+#define ELF_INFO_TYPE_MERGE     2
+#define ELF_INFO_TYPE_EH_FRAME  3
+#define ELF_INFO_TYPE_JUST_SYMS 4
+
+  /* Nonzero if this section uses RELA relocations, rather than REL.  */
+  unsigned int use_rela_p:1;
+
+  /* Bits used by various backends.  The generic code doesn't touch
+     these fields.  */
+
+  /* Nonzero if this section has TLS related relocations.  */
+  unsigned int has_tls_reloc:1;
+
+  /* Nonzero if this section has a call to __tls_get_addr.  */
+  unsigned int has_tls_get_addr_call:1;
+
+  /* Nonzero if this section has a gp reloc.  */
+  unsigned int has_gp_reloc:1;
+
+  /* Nonzero if this section needs the relax finalize pass.  */
+  unsigned int need_finalize_relax:1;
+
+  /* Whether relocations have been processed.  */
+  unsigned int reloc_done : 1;
+
+  /* End of internal packed boolean fields.  */
+
+  /*  The virtual memory address of the section - where it will be
+      at run time.  The symbols are relocated against this.  The
+      user_set_vma flag is maintained by bfd; if it's not set, the
+      backend can assign addresses (for example, in <<a.out>>, where
+      the default address for <<.data>> is dependent on the specific
+      target and various flags).  */
+  bfd_vma vma;
+
+  /*  The load address of the section - where it would be in a
+      rom image; really only used for writing section header
+      information.  */
+  bfd_vma lma;
+
+  /* The size of the section in octets, as it will be output.
+     Contains a value even if the section has no contents (e.g., the
+     size of <<.bss>>).  */
+  bfd_size_type size;
+
+  /* For input sections, the original size on disk of the section, in
+     octets.  This field should be set for any section whose size is
+     changed by linker relaxation.  It is required for sections where
+     the linker relaxation scheme doesn't cache altered section and
+     reloc contents (stabs, eh_frame, SEC_MERGE, some coff relaxing
+     targets), and thus the original size needs to be kept to read the
+     section multiple times.  For output sections, rawsize holds the
+     section size calculated on a previous linker relaxation pass.  */
+  bfd_size_type rawsize;
+
+  /* Relaxation table. */
+  struct relax_table *relax;
+
+  /* Count of used relaxation table entries. */
+  int relax_count;
+
+
+  /* If this section is going to be output, then this value is the
+     offset in *bytes* into the output section of the first byte in the
+     input section (byte ==> smallest addressable unit on the
+     target).  In most cases, if this was going to start at the
+     100th octet (8-bit quantity) in the output section, this value
+     would be 100.  However, if the target byte size is 16 bits
+     (bfd_octets_per_byte is "2"), this value would be 50.  */
+  bfd_vma output_offset;
+
+  /* The output section through which to map on output.  */
+  struct bfd_section *output_section;
+
+  /* The alignment requirement of the section, as an exponent of 2 -
+     e.g., 3 aligns to 2^3 (or 8).  */
+  unsigned int alignment_power;
+
+  /* If an input section, a pointer to a vector of relocation
+     records for the data in this section.  */
+  struct reloc_cache_entry *relocation;
+
+  /* If an output section, a pointer to a vector of pointers to
+     relocation records for the data in this section.  */
+  struct reloc_cache_entry **orelocation;
+
+  /* The number of relocation records in one of the above.  */
+  unsigned reloc_count;
+
+  /* Information below is back end specific - and not always used
+     or updated.  */
+
+  /* File position of section data.  */
+  file_ptr filepos;
+
+  /* File position of relocation info.  */
+  file_ptr rel_filepos;
+
+  /* File position of line data.  */
+  file_ptr line_filepos;
+
+  /* Pointer to data for applications.  */
+  void *userdata;
+
+  /* If the SEC_IN_MEMORY flag is set, this points to the actual
+     contents.  */
+  unsigned char *contents;
+
+  /* Attached line number information.  */
+  alent *lineno;
+
+  /* Number of line number records.  */
+  unsigned int lineno_count;
+
+  /* Entity size for merging purposes.  */
+  unsigned int entsize;
+
+  /* Points to the kept section if this section is a link-once section,
+     and is discarded.  */
+  struct bfd_section *kept_section;
+
+  /* When a section is being output, this value changes as more
+     linenumbers are written out.  */
+  file_ptr moving_line_filepos;
+
+  /* What the section number is in the target world.  */
+  int target_index;
+
+  void *used_by_bfd;
+
+  /* If this is a constructor section then here is a list of the
+     relocations created to relocate items within it.  */
+  struct relent_chain *constructor_chain;
+
+  /* The BFD which owns the section.  */
+  bfd *owner;
+
+  /* A symbol which points at this section only.  */
+  struct bfd_symbol *symbol;
+  struct bfd_symbol **symbol_ptr_ptr;
+
+  /* Early in the link process, map_head and map_tail are used to build
+     a list of input sections attached to an output section.  Later,
+     output sections use these fields for a list of bfd_link_order
+     structs.  */
+  union {
+    struct bfd_link_order *link_order;
+    struct bfd_section *s;
+  } map_head, map_tail;
+} asection;
+
+/* Relax table contains information about instructions which can
+   be removed by relaxation -- replacing a long address with a 
+   short address.  */
+struct relax_table {
+  /* Address where bytes may be deleted. */
+  bfd_vma addr;
+  
+  /* Number of bytes to be deleted.  */
+  int size;
+};
+
+/* These sections are global, and are managed by BFD.  The application
+   and target back end are not permitted to change the values in
+   these sections.  New code should use the section_ptr macros rather
+   than referring directly to the const sections.  The const sections
+   may eventually vanish.  */
+#define BFD_ABS_SECTION_NAME "*ABS*"
+#define BFD_UND_SECTION_NAME "*UND*"
+#define BFD_COM_SECTION_NAME "*COM*"
+#define BFD_IND_SECTION_NAME "*IND*"
+
+/* The absolute section.  */
+extern asection bfd_abs_section;
+#define bfd_abs_section_ptr ((asection *) &bfd_abs_section)
+#define bfd_is_abs_section(sec) ((sec) == bfd_abs_section_ptr)
+/* Pointer to the undefined section.  */
+extern asection bfd_und_section;
+#define bfd_und_section_ptr ((asection *) &bfd_und_section)
+#define bfd_is_und_section(sec) ((sec) == bfd_und_section_ptr)
+/* Pointer to the common section.  */
+extern asection bfd_com_section;
+#define bfd_com_section_ptr ((asection *) &bfd_com_section)
+/* Pointer to the indirect section.  */
+extern asection bfd_ind_section;
+#define bfd_ind_section_ptr ((asection *) &bfd_ind_section)
+#define bfd_is_ind_section(sec) ((sec) == bfd_ind_section_ptr)
+
+#define bfd_is_const_section(SEC)              \
+ (   ((SEC) == bfd_abs_section_ptr)            \
+  || ((SEC) == bfd_und_section_ptr)            \
+  || ((SEC) == bfd_com_section_ptr)            \
+  || ((SEC) == bfd_ind_section_ptr))
+
+/* Macros to handle insertion and deletion of a bfd's sections.  These
+   only handle the list pointers, ie. do not adjust section_count,
+   target_index etc.  */
+#define bfd_section_list_remove(ABFD, S) \
+  do                                                   \
+    {                                                  \
+      asection *_s = S;                                \
+      asection *_next = _s->next;                      \
+      asection *_prev = _s->prev;                      \
+      if (_prev)                                       \
+        _prev->next = _next;                           \
+      else                                             \
+        (ABFD)->sections = _next;                      \
+      if (_next)                                       \
+        _next->prev = _prev;                           \
+      else                                             \
+        (ABFD)->section_last = _prev;                  \
+    }                                                  \
+  while (0)
+#define bfd_section_list_append(ABFD, S) \
+  do                                                   \
+    {                                                  \
+      asection *_s = S;                                \
+      bfd *_abfd = ABFD;                               \
+      _s->next = NULL;                                 \
+      if (_abfd->section_last)                         \
+        {                                              \
+          _s->prev = _abfd->section_last;              \
+          _abfd->section_last->next = _s;              \
+        }                                              \
+      else                                             \
+        {                                              \
+          _s->prev = NULL;                             \
+          _abfd->sections = _s;                        \
+        }                                              \
+      _abfd->section_last = _s;                        \
+    }                                                  \
+  while (0)
+#define bfd_section_list_prepend(ABFD, S) \
+  do                                                   \
+    {                                                  \
+      asection *_s = S;                                \
+      bfd *_abfd = ABFD;                               \
+      _s->prev = NULL;                                 \
+      if (_abfd->sections)                             \
+        {                                              \
+          _s->next = _abfd->sections;                  \
+          _abfd->sections->prev = _s;                  \
+        }                                              \
+      else                                             \
+        {                                              \
+          _s->next = NULL;                             \
+          _abfd->section_last = _s;                    \
+        }                                              \
+      _abfd->sections = _s;                            \
+    }                                                  \
+  while (0)
+#define bfd_section_list_insert_after(ABFD, A, S) \
+  do                                                   \
+    {                                                  \
+      asection *_a = A;                                \
+      asection *_s = S;                                \
+      asection *_next = _a->next;                      \
+      _s->next = _next;                                \
+      _s->prev = _a;                                   \
+      _a->next = _s;                                   \
+      if (_next)                                       \
+        _next->prev = _s;                              \
+      else                                             \
+        (ABFD)->section_last = _s;                     \
+    }                                                  \
+  while (0)
+#define bfd_section_list_insert_before(ABFD, B, S) \
+  do                                                   \
+    {                                                  \
+      asection *_b = B;                                \
+      asection *_s = S;                                \
+      asection *_prev = _b->prev;                      \
+      _s->prev = _prev;                                \
+      _s->next = _b;                                   \
+      _b->prev = _s;                                   \
+      if (_prev)                                       \
+        _prev->next = _s;                              \
+      else                                             \
+        (ABFD)->sections = _s;                         \
+    }                                                  \
+  while (0)
+#define bfd_section_removed_from_list(ABFD, S) \
+  ((S)->next == NULL ? (ABFD)->section_last != (S) : (S)->next->prev != (S))
+
+#define BFD_FAKE_SECTION(SEC, FLAGS, SYM, NAME, IDX)                   \
+  /* name, id,  index, next, prev, flags, user_set_vma,            */  \
+  { NAME,  IDX, 0,     NULL, NULL, FLAGS, 0,                           \
+                                                                       \
+  /* linker_mark, linker_has_input, gc_mark,                       */  \
+     0,           0,                1,                                 \
+                                                                       \
+  /* segment_mark, sec_info_type, use_rela_p, has_tls_reloc,       */  \
+     0,            0,             0,          0,                       \
+                                                                       \
+  /* has_tls_get_addr_call, has_gp_reloc, need_finalize_relax,     */  \
+     0,                     0,            0,                           \
+                                                                       \
+  /* reloc_done, vma, lma, size, rawsize, relax, relax_count,      */  \
+     0,          0,   0,   0,    0,       0,     0,                    \
+                                                                       \
+  /* output_offset, output_section,              alignment_power,  */  \
+     0,             (struct bfd_section *) &SEC, 0,                    \
+                                                                       \
+  /* relocation, orelocation, reloc_count, filepos, rel_filepos,   */  \
+     NULL,       NULL,        0,           0,       0,                 \
+                                                                       \
+  /* line_filepos, userdata, contents, lineno, lineno_count,       */  \
+     0,            NULL,     NULL,     NULL,   0,                      \
+                                                                       \
+  /* entsize, kept_section, moving_line_filepos,                    */ \
+     0,       NULL,          0,                                        \
+                                                                       \
+  /* target_index, used_by_bfd, constructor_chain, owner,          */  \
+     0,            NULL,        NULL,              NULL,               \
+                                                                       \
+  /* symbol,                    symbol_ptr_ptr,                    */  \
+     (struct bfd_symbol *) SYM, &SEC.symbol,                           \
+                                                                       \
+  /* map_head, map_tail                                            */  \
+     { NULL }, { NULL }                                                \
+    }
+
+void bfd_section_list_clear (bfd *);
+
+asection *bfd_get_section_by_name (bfd *abfd, const char *name);
+
+asection *bfd_get_section_by_name_if
+   (bfd *abfd,
+    const char *name,
+    bfd_boolean (*func) (bfd *abfd, asection *sect, void *obj),
+    void *obj);
+
+char *bfd_get_unique_section_name
+   (bfd *abfd, const char *templat, int *count);
+
+asection *bfd_make_section_old_way (bfd *abfd, const char *name);
+
+asection *bfd_make_section_anyway_with_flags
+   (bfd *abfd, const char *name, flagword flags);
+
+asection *bfd_make_section_anyway (bfd *abfd, const char *name);
+
+asection *bfd_make_section_with_flags
+   (bfd *, const char *name, flagword flags);
+
+asection *bfd_make_section (bfd *, const char *name);
+
+bfd_boolean bfd_set_section_flags
+   (bfd *abfd, asection *sec, flagword flags);
+
+void bfd_map_over_sections
+   (bfd *abfd,
+    void (*func) (bfd *abfd, asection *sect, void *obj),
+    void *obj);
+
+asection *bfd_sections_find_if
+   (bfd *abfd,
+    bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),
+    void *obj);
+
+bfd_boolean bfd_set_section_size
+   (bfd *abfd, asection *sec, bfd_size_type val);
+
+bfd_boolean bfd_set_section_contents
+   (bfd *abfd, asection *section, const void *data,
+    file_ptr offset, bfd_size_type count);
+
+bfd_boolean bfd_get_section_contents
+   (bfd *abfd, asection *section, void *location, file_ptr offset,
+    bfd_size_type count);
+
+bfd_boolean bfd_malloc_and_get_section
+   (bfd *abfd, asection *section, bfd_byte **buf);
+
+bfd_boolean bfd_copy_private_section_data
+   (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);
+
+#define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \
+     BFD_SEND (obfd, _bfd_copy_private_section_data, \
+               (ibfd, isection, obfd, osection))
+bfd_boolean bfd_generic_is_group_section (bfd *, const asection *sec);
+
+bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);
+
+/* Extracted from archures.c.  */
+enum bfd_architecture
+{
+  bfd_arch_unknown,   /* File arch not known.  */
+  bfd_arch_obscure,   /* Arch known, not one of these.  */
+  bfd_arch_m68k,      /* Motorola 68xxx */
+#define bfd_mach_m68000 1
+#define bfd_mach_m68008 2
+#define bfd_mach_m68010 3
+#define bfd_mach_m68020 4
+#define bfd_mach_m68030 5
+#define bfd_mach_m68040 6
+#define bfd_mach_m68060 7
+#define bfd_mach_cpu32  8
+#define bfd_mach_fido   9
+#define bfd_mach_mcf_isa_a_nodiv 10
+#define bfd_mach_mcf_isa_a 11
+#define bfd_mach_mcf_isa_a_mac 12
+#define bfd_mach_mcf_isa_a_emac 13
+#define bfd_mach_mcf_isa_aplus 14
+#define bfd_mach_mcf_isa_aplus_mac 15
+#define bfd_mach_mcf_isa_aplus_emac 16
+#define bfd_mach_mcf_isa_b_nousp 17
+#define bfd_mach_mcf_isa_b_nousp_mac 18
+#define bfd_mach_mcf_isa_b_nousp_emac 19
+#define bfd_mach_mcf_isa_b 20
+#define bfd_mach_mcf_isa_b_mac 21
+#define bfd_mach_mcf_isa_b_emac 22
+#define bfd_mach_mcf_isa_b_float 23
+#define bfd_mach_mcf_isa_b_float_mac 24
+#define bfd_mach_mcf_isa_b_float_emac 25
+#define bfd_mach_mcf_isa_c 26
+#define bfd_mach_mcf_isa_c_mac 27
+#define bfd_mach_mcf_isa_c_emac 28
+#define bfd_mach_mcf_isa_c_nodiv 29
+#define bfd_mach_mcf_isa_c_nodiv_mac 30
+#define bfd_mach_mcf_isa_c_nodiv_emac 31
+  bfd_arch_vax,       /* DEC Vax */
+  bfd_arch_i960,      /* Intel 960 */
+    /* The order of the following is important.
+       lower number indicates a machine type that
+       only accepts a subset of the instructions
+       available to machines with higher numbers.
+       The exception is the "ca", which is
+       incompatible with all other machines except
+       "core".  */
+
+#define bfd_mach_i960_core      1
+#define bfd_mach_i960_ka_sa     2
+#define bfd_mach_i960_kb_sb     3
+#define bfd_mach_i960_mc        4
+#define bfd_mach_i960_xa        5
+#define bfd_mach_i960_ca        6
+#define bfd_mach_i960_jx        7
+#define bfd_mach_i960_hx        8
+
+  bfd_arch_or32,      /* OpenRISC 32 */
+
+  bfd_arch_sparc,     /* SPARC */
+#define bfd_mach_sparc                 1
+/* The difference between v8plus and v9 is that v9 is a true 64 bit env.  */
+#define bfd_mach_sparc_sparclet        2
+#define bfd_mach_sparc_sparclite       3
+#define bfd_mach_sparc_v8plus          4
+#define bfd_mach_sparc_v8plusa         5 /* with ultrasparc add'ns.  */
+#define bfd_mach_sparc_sparclite_le    6
+#define bfd_mach_sparc_v9              7
+#define bfd_mach_sparc_v9a             8 /* with ultrasparc add'ns.  */
+#define bfd_mach_sparc_v8plusb         9 /* with cheetah add'ns.  */
+#define bfd_mach_sparc_v9b             10 /* with cheetah add'ns.  */
+/* Nonzero if MACH has the v9 instruction set.  */
+#define bfd_mach_sparc_v9_p(mach) \
+  ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9b \
+   && (mach) != bfd_mach_sparc_sparclite_le)
+/* Nonzero if MACH is a 64 bit sparc architecture.  */
+#define bfd_mach_sparc_64bit_p(mach) \
+  ((mach) >= bfd_mach_sparc_v9 && (mach) != bfd_mach_sparc_v8plusb)
+  bfd_arch_spu,       /* PowerPC SPU */
+#define bfd_mach_spu           256 
+  bfd_arch_mips,      /* MIPS Rxxxx */
+#define bfd_mach_mips3000              3000
+#define bfd_mach_mips3900              3900
+#define bfd_mach_mips4000              4000
+#define bfd_mach_mips4010              4010
+#define bfd_mach_mips4100              4100
+#define bfd_mach_mips4111              4111
+#define bfd_mach_mips4120              4120
+#define bfd_mach_mips4300              4300
+#define bfd_mach_mips4400              4400
+#define bfd_mach_mips4600              4600
+#define bfd_mach_mips4650              4650
+#define bfd_mach_mips5000              5000
+#define bfd_mach_mips5400              5400
+#define bfd_mach_mips5500              5500
+#define bfd_mach_mips6000              6000
+#define bfd_mach_mips7000              7000
+#define bfd_mach_mips8000              8000
+#define bfd_mach_mips9000              9000
+#define bfd_mach_mips10000             10000
+#define bfd_mach_mips12000             12000
+#define bfd_mach_mips14000             14000
+#define bfd_mach_mips16000             16000
+#define bfd_mach_mips16                16
+#define bfd_mach_mips5                 5
+#define bfd_mach_mips_loongson_2e      3001
+#define bfd_mach_mips_loongson_2f      3002
+#define bfd_mach_mips_sb1              12310201 /* octal 'SB', 01 */
+#define bfd_mach_mips_octeon           6501
+#define bfd_mach_mips_xlr              887682   /* decimal 'XLR'  */
+#define bfd_mach_mipsisa32             32
+#define bfd_mach_mipsisa32r2           33
+#define bfd_mach_mipsisa64             64
+#define bfd_mach_mipsisa64r2           65
+  bfd_arch_i386,      /* Intel 386 */
+#define bfd_mach_i386_i386 1
+#define bfd_mach_i386_i8086 2
+#define bfd_mach_i386_i386_intel_syntax 3
+#define bfd_mach_x86_64 64
+#define bfd_mach_x86_64_intel_syntax 65
+  bfd_arch_l1om,   /* Intel L1OM */
+#define bfd_mach_l1om 66
+#define bfd_mach_l1om_intel_syntax 67
+  bfd_arch_we32k,     /* AT&T WE32xxx */
+  bfd_arch_tahoe,     /* CCI/Harris Tahoe */
+  bfd_arch_i860,      /* Intel 860 */
+  bfd_arch_i370,      /* IBM 360/370 Mainframes */
+  bfd_arch_romp,      /* IBM ROMP PC/RT */
+  bfd_arch_convex,    /* Convex */
+  bfd_arch_m88k,      /* Motorola 88xxx */
+  bfd_arch_m98k,      /* Motorola 98xxx */
+  bfd_arch_pyramid,   /* Pyramid Technology */
+  bfd_arch_h8300,     /* Renesas H8/300 (formerly Hitachi H8/300) */
+#define bfd_mach_h8300    1
+#define bfd_mach_h8300h   2
+#define bfd_mach_h8300s   3
+#define bfd_mach_h8300hn  4
+#define bfd_mach_h8300sn  5
+#define bfd_mach_h8300sx  6
+#define bfd_mach_h8300sxn 7
+  bfd_arch_pdp11,     /* DEC PDP-11 */
+  bfd_arch_plugin,
+  bfd_arch_powerpc,   /* PowerPC */
+#define bfd_mach_ppc           32
+#define bfd_mach_ppc64         64
+#define bfd_mach_ppc_403       403
+#define bfd_mach_ppc_403gc     4030
+#define bfd_mach_ppc_405       405
+#define bfd_mach_ppc_505       505
+#define bfd_mach_ppc_601       601
+#define bfd_mach_ppc_602       602
+#define bfd_mach_ppc_603       603
+#define bfd_mach_ppc_ec603e    6031
+#define bfd_mach_ppc_604       604
+#define bfd_mach_ppc_620       620
+#define bfd_mach_ppc_630       630
+#define bfd_mach_ppc_750       750
+#define bfd_mach_ppc_860       860
+#define bfd_mach_ppc_a35       35
+#define bfd_mach_ppc_rs64ii    642
+#define bfd_mach_ppc_rs64iii   643
+#define bfd_mach_ppc_7400      7400
+#define bfd_mach_ppc_e500      500
+#define bfd_mach_ppc_e500mc    5001
+  bfd_arch_rs6000,    /* IBM RS/6000 */
+#define bfd_mach_rs6k          6000
+#define bfd_mach_rs6k_rs1      6001
+#define bfd_mach_rs6k_rsc      6003
+#define bfd_mach_rs6k_rs2      6002
+  bfd_arch_hppa,      /* HP PA RISC */
+#define bfd_mach_hppa10        10
+#define bfd_mach_hppa11        11
+#define bfd_mach_hppa20        20
+#define bfd_mach_hppa20w       25
+  bfd_arch_d10v,      /* Mitsubishi D10V */
+#define bfd_mach_d10v          1
+#define bfd_mach_d10v_ts2      2
+#define bfd_mach_d10v_ts3      3
+  bfd_arch_d30v,      /* Mitsubishi D30V */
+  bfd_arch_dlx,       /* DLX */
+  bfd_arch_m68hc11,   /* Motorola 68HC11 */
+  bfd_arch_m68hc12,   /* Motorola 68HC12 */
+#define bfd_mach_m6812_default 0
+#define bfd_mach_m6812         1
+#define bfd_mach_m6812s        2
+  bfd_arch_z8k,       /* Zilog Z8000 */
+#define bfd_mach_z8001         1
+#define bfd_mach_z8002         2
+  bfd_arch_h8500,     /* Renesas H8/500 (formerly Hitachi H8/500) */
+  bfd_arch_sh,        /* Renesas / SuperH SH (formerly Hitachi SH) */
+#define bfd_mach_sh            1
+#define bfd_mach_sh2        0x20
+#define bfd_mach_sh_dsp     0x2d
+#define bfd_mach_sh2a       0x2a
+#define bfd_mach_sh2a_nofpu 0x2b
+#define bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu 0x2a1
+#define bfd_mach_sh2a_nofpu_or_sh3_nommu 0x2a2
+#define bfd_mach_sh2a_or_sh4  0x2a3
+#define bfd_mach_sh2a_or_sh3e 0x2a4
+#define bfd_mach_sh2e       0x2e
+#define bfd_mach_sh3        0x30
+#define bfd_mach_sh3_nommu  0x31
+#define bfd_mach_sh3_dsp    0x3d
+#define bfd_mach_sh3e       0x3e
+#define bfd_mach_sh4        0x40
+#define bfd_mach_sh4_nofpu  0x41
+#define bfd_mach_sh4_nommu_nofpu  0x42
+#define bfd_mach_sh4a       0x4a
+#define bfd_mach_sh4a_nofpu 0x4b
+#define bfd_mach_sh4al_dsp  0x4d
+#define bfd_mach_sh5        0x50
+  bfd_arch_alpha,     /* Dec Alpha */
+#define bfd_mach_alpha_ev4  0x10
+#define bfd_mach_alpha_ev5  0x20
+#define bfd_mach_alpha_ev6  0x30
+  bfd_arch_arm,       /* Advanced Risc Machines ARM.  */
+#define bfd_mach_arm_unknown   0
+#define bfd_mach_arm_2         1
+#define bfd_mach_arm_2a        2
+#define bfd_mach_arm_3         3
+#define bfd_mach_arm_3M        4
+#define bfd_mach_arm_4         5
+#define bfd_mach_arm_4T        6
+#define bfd_mach_arm_5         7
+#define bfd_mach_arm_5T        8
+#define bfd_mach_arm_5TE       9
+#define bfd_mach_arm_XScale    10
+#define bfd_mach_arm_ep9312    11
+#define bfd_mach_arm_iWMMXt    12
+#define bfd_mach_arm_iWMMXt2   13
+  bfd_arch_ns32k,     /* National Semiconductors ns32000 */
+  bfd_arch_w65,       /* WDC 65816 */
+  bfd_arch_tic30,     /* Texas Instruments TMS320C30 */
+  bfd_arch_tic4x,     /* Texas Instruments TMS320C3X/4X */
+#define bfd_mach_tic3x         30
+#define bfd_mach_tic4x         40
+  bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
+  bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
+  bfd_arch_v850,      /* NEC V850 */
+#define bfd_mach_v850          1
+#define bfd_mach_v850e         'E'
+#define bfd_mach_v850e1        '1'
+  bfd_arch_arc,       /* ARC Cores */
+#define bfd_mach_arc_5         5
+#define bfd_mach_arc_6         6
+#define bfd_mach_arc_7         7
+#define bfd_mach_arc_8         8
+ bfd_arch_m32c,     /* Renesas M16C/M32C.  */
+#define bfd_mach_m16c        0x75
+#define bfd_mach_m32c        0x78
+  bfd_arch_m32r,      /* Renesas M32R (formerly Mitsubishi M32R/D) */
+#define bfd_mach_m32r          1 /* For backwards compatibility.  */
+#define bfd_mach_m32rx         'x'
+#define bfd_mach_m32r2         '2'
+  bfd_arch_mn10200,   /* Matsushita MN10200 */
+  bfd_arch_mn10300,   /* Matsushita MN10300 */
+#define bfd_mach_mn10300               300
+#define bfd_mach_am33          330
+#define bfd_mach_am33_2        332
+  bfd_arch_fr30,
+#define bfd_mach_fr30          0x46523330
+  bfd_arch_frv,
+#define bfd_mach_frv           1
+#define bfd_mach_frvsimple     2
+#define bfd_mach_fr300         300
+#define bfd_mach_fr400         400
+#define bfd_mach_fr450         450
+#define bfd_mach_frvtomcat     499     /* fr500 prototype */
+#define bfd_mach_fr500         500
+#define bfd_mach_fr550         550
+  bfd_arch_moxie,       /* The moxie processor */
+#define bfd_mach_moxie         1
+  bfd_arch_mcore,
+  bfd_arch_mep,
+#define bfd_mach_mep           1
+#define bfd_mach_mep_h1        0x6831
+#define bfd_mach_mep_c5        0x6335
+  bfd_arch_ia64,      /* HP/Intel ia64 */
+#define bfd_mach_ia64_elf64    64
+#define bfd_mach_ia64_elf32    32
+  bfd_arch_ip2k,      /* Ubicom IP2K microcontrollers. */
+#define bfd_mach_ip2022        1
+#define bfd_mach_ip2022ext     2
+ bfd_arch_iq2000,     /* Vitesse IQ2000.  */
+#define bfd_mach_iq2000        1
+#define bfd_mach_iq10          2
+  bfd_arch_mt,
+#define bfd_mach_ms1           1
+#define bfd_mach_mrisc2        2
+#define bfd_mach_ms2           3
+  bfd_arch_pj,
+  bfd_arch_avr,       /* Atmel AVR microcontrollers.  */
+#define bfd_mach_avr1          1
+#define bfd_mach_avr2          2
+#define bfd_mach_avr25         25
+#define bfd_mach_avr3          3
+#define bfd_mach_avr31         31
+#define bfd_mach_avr35         35
+#define bfd_mach_avr4          4
+#define bfd_mach_avr5          5
+#define bfd_mach_avr51         51
+#define bfd_mach_avr6          6
+  bfd_arch_bfin,        /* ADI Blackfin */
+#define bfd_mach_bfin          1
+  bfd_arch_cr16,       /* National Semiconductor CompactRISC (ie CR16). */
+#define bfd_mach_cr16          1
+  bfd_arch_cr16c,       /* National Semiconductor CompactRISC. */
+#define bfd_mach_cr16c         1
+  bfd_arch_crx,       /*  National Semiconductor CRX.  */
+#define bfd_mach_crx           1
+  bfd_arch_cris,      /* Axis CRIS */
+#define bfd_mach_cris_v0_v10   255
+#define bfd_mach_cris_v32      32
+#define bfd_mach_cris_v10_v32  1032
+  bfd_arch_s390,      /* IBM s390 */
+#define bfd_mach_s390_31       31
+#define bfd_mach_s390_64       64
+  bfd_arch_score,     /* Sunplus score */ 
+#define bfd_mach_score3         3
+#define bfd_mach_score7         7
+  bfd_arch_openrisc,  /* OpenRISC */
+  bfd_arch_mmix,      /* Donald Knuth's educational processor.  */
+  bfd_arch_xstormy16,
+#define bfd_mach_xstormy16     1
+  bfd_arch_msp430,    /* Texas Instruments MSP430 architecture.  */
+#define bfd_mach_msp11          11
+#define bfd_mach_msp110         110
+#define bfd_mach_msp12          12
+#define bfd_mach_msp13          13
+#define bfd_mach_msp14          14
+#define bfd_mach_msp15          15
+#define bfd_mach_msp16          16
+#define bfd_mach_msp21          21
+#define bfd_mach_msp31          31
+#define bfd_mach_msp32          32
+#define bfd_mach_msp33          33
+#define bfd_mach_msp41          41
+#define bfd_mach_msp42          42
+#define bfd_mach_msp43          43
+#define bfd_mach_msp44          44
+  bfd_arch_xc16x,     /* Infineon's XC16X Series.               */
+#define bfd_mach_xc16x         1
+#define bfd_mach_xc16xl        2
+#define bfd_mach_xc16xs         3
+  bfd_arch_xtensa,    /* Tensilica's Xtensa cores.  */
+#define bfd_mach_xtensa        1
+   bfd_arch_maxq,     /* Dallas MAXQ 10/20 */
+#define bfd_mach_maxq10    10
+#define bfd_mach_maxq20    20
+  bfd_arch_z80,
+#define bfd_mach_z80strict      1 /* No undocumented opcodes.  */
+#define bfd_mach_z80            3 /* With ixl, ixh, iyl, and iyh.  */
+#define bfd_mach_z80full        7 /* All undocumented instructions.  */
+#define bfd_mach_r800           11 /* R800: successor with multiplication.  */
+  bfd_arch_lm32,      /* Lattice Mico32 */
+#define bfd_mach_lm32      1
+  bfd_arch_microblaze,/* Xilinx MicroBlaze. */
+  bfd_arch_last
+  };
+
+typedef struct bfd_arch_info
+{
+  int bits_per_word;
+  int bits_per_address;
+  int bits_per_byte;
+  enum bfd_architecture arch;
+  unsigned long mach;
+  const char *arch_name;
+  const char *printable_name;
+  unsigned int section_align_power;
+  /* TRUE if this is the default machine for the architecture.
+     The default arch should be the first entry for an arch so that
+     all the entries for that arch can be accessed via <<next>>.  */
+  bfd_boolean the_default;
+  const struct bfd_arch_info * (*compatible)
+    (const struct bfd_arch_info *a, const struct bfd_arch_info *b);
+
+  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);
+
+  const struct bfd_arch_info *next;
+}
+bfd_arch_info_type;
+
+const char *bfd_printable_name (bfd *abfd);
+
+const bfd_arch_info_type *bfd_scan_arch (const char *string);
+
+const char **bfd_arch_list (void);
+
+const bfd_arch_info_type *bfd_arch_get_compatible
+   (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);
+
+void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);
+
+enum bfd_architecture bfd_get_arch (bfd *abfd);
+
+unsigned long bfd_get_mach (bfd *abfd);
+
+unsigned int bfd_arch_bits_per_byte (bfd *abfd);
+
+unsigned int bfd_arch_bits_per_address (bfd *abfd);
+
+const bfd_arch_info_type *bfd_get_arch_info (bfd *abfd);
+
+const bfd_arch_info_type *bfd_lookup_arch
+   (enum bfd_architecture arch, unsigned long machine);
+
+const char *bfd_printable_arch_mach
+   (enum bfd_architecture arch, unsigned long machine);
+
+unsigned int bfd_octets_per_byte (bfd *abfd);
+
+unsigned int bfd_arch_mach_octets_per_byte
+   (enum bfd_architecture arch, unsigned long machine);
+
+/* Extracted from reloc.c.  */
+typedef enum bfd_reloc_status
+{
+  /* No errors detected.  */
+  bfd_reloc_ok,
+
+  /* The relocation was performed, but there was an overflow.  */
+  bfd_reloc_overflow,
+
+  /* The address to relocate was not within the section supplied.  */
+  bfd_reloc_outofrange,
+
+  /* Used by special functions.  */
+  bfd_reloc_continue,
+
+  /* Unsupported relocation size requested.  */
+  bfd_reloc_notsupported,
+
+  /* Unused.  */
+  bfd_reloc_other,
+
+  /* The symbol to relocate against was undefined.  */
+  bfd_reloc_undefined,
+
+  /* The relocation was performed, but may not be ok - presently
+     generated only when linking i960 coff files with i960 b.out
+     symbols.  If this type is returned, the error_message argument
+     to bfd_perform_relocation will be set.  */
+  bfd_reloc_dangerous
+ }
+ bfd_reloc_status_type;
+
+
+typedef struct reloc_cache_entry
+{
+  /* A pointer into the canonical table of pointers.  */
+  struct bfd_symbol **sym_ptr_ptr;
+
+  /* offset in section.  */
+  bfd_size_type address;
+
+  /* addend for relocation value.  */
+  bfd_vma addend;
+
+  /* Pointer to how to perform the required relocation.  */
+  reloc_howto_type *howto;
+
+}
+arelent;
+
+enum complain_overflow
+{
+  /* Do not complain on overflow.  */
+  complain_overflow_dont,
+
+  /* Complain if the value overflows when considered as a signed
+     number one bit larger than the field.  ie. A bitfield of N bits
+     is allowed to represent -2**n to 2**n-1.  */
+  complain_overflow_bitfield,
+
+  /* Complain if the value overflows when considered as a signed
+     number.  */
+  complain_overflow_signed,
+
+  /* Complain if the value overflows when considered as an
+     unsigned number.  */
+  complain_overflow_unsigned
+};
+
+struct reloc_howto_struct
+{
+  /*  The type field has mainly a documentary use - the back end can
+      do what it wants with it, though normally the back end's
+      external idea of what a reloc number is stored
+      in this field.  For example, a PC relative word relocation
+      in a coff environment has the type 023 - because that's
+      what the outside world calls a R_PCRWORD reloc.  */
+  unsigned int type;
+
+  /*  The value the final relocation is shifted right by.  This drops
+      unwanted data from the relocation.  */
+  unsigned int rightshift;
+
+  /*  The size of the item to be relocated.  This is *not* a
+      power-of-two measure.  To get the number of bytes operated
+      on by a type of relocation, use bfd_get_reloc_size.  */
+  int size;
+
+  /*  The number of bits in the item to be relocated.  This is used
+      when doing overflow checking.  */
+  unsigned int bitsize;
+
+  /*  Notes that the relocation is relative to the location in the
+      data section of the addend.  The relocation function will
+      subtract from the relocation value the address of the location
+      being relocated.  */
+  bfd_boolean pc_relative;
+
+  /*  The bit position of the reloc value in the destination.
+      The relocated value is left shifted by this amount.  */
+  unsigned int bitpos;
+
+  /* What type of overflow error should be checked for when
+     relocating.  */
+  enum complain_overflow complain_on_overflow;
+
+  /* If this field is non null, then the supplied function is
+     called rather than the normal function.  This allows really
+     strange relocation methods to be accommodated (e.g., i960 callj
+     instructions).  */
+  bfd_reloc_status_type (*special_function)
+    (bfd *, arelent *, struct bfd_symbol *, void *, asection *,
+     bfd *, char **);
+
+  /* The textual name of the relocation type.  */
+  char *name;
+
+  /* Some formats record a relocation addend in the section contents
+     rather than with the relocation.  For ELF formats this is the
+     distinction between USE_REL and USE_RELA (though the code checks
+     for USE_REL == 1/0).  The value of this field is TRUE if the
+     addend is recorded with the section contents; when performing a
+     partial link (ld -r) the section contents (the data) will be
+     modified.  The value of this field is FALSE if addends are
+     recorded with the relocation (in arelent.addend); when performing
+     a partial link the relocation will be modified.
+     All relocations for all ELF USE_RELA targets should set this field
+     to FALSE (values of TRUE should be looked on with suspicion).
+     However, the converse is not true: not all relocations of all ELF
+     USE_REL targets set this field to TRUE.  Why this is so is peculiar
+     to each particular target.  For relocs that aren't used in partial
+     links (e.g. GOT stuff) it doesn't matter what this is set to.  */
+  bfd_boolean partial_inplace;
+
+  /* src_mask selects the part of the instruction (or data) to be used
+     in the relocation sum.  If the target relocations don't have an
+     addend in the reloc, eg. ELF USE_REL, src_mask will normally equal
+     dst_mask to extract the addend from the section contents.  If
+     relocations do have an addend in the reloc, eg. ELF USE_RELA, this
+     field should be zero.  Non-zero values for ELF USE_RELA targets are
+     bogus as in those cases the value in the dst_mask part of the
+     section contents should be treated as garbage.  */
+  bfd_vma src_mask;
+
+  /* dst_mask selects which parts of the instruction (or data) are
+     replaced with a relocated value.  */
+  bfd_vma dst_mask;
+
+  /* When some formats create PC relative instructions, they leave
+     the value of the pc of the place being relocated in the offset
+     slot of the instruction, so that a PC relative relocation can
+     be made just by adding in an ordinary offset (e.g., sun3 a.out).
+     Some formats leave the displacement part of an instruction
+     empty (e.g., m88k bcs); this flag signals the fact.  */
+  bfd_boolean pcrel_offset;
+};
+
+#define HOWTO(C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC) \
+  { (unsigned) C, R, S, B, P, BI, O, SF, NAME, INPLACE, MASKSRC, MASKDST, PC }
+#define NEWHOWTO(FUNCTION, NAME, SIZE, REL, IN) \
+  HOWTO (0, 0, SIZE, 0, REL, 0, complain_overflow_dont, FUNCTION, \
+         NAME, FALSE, 0, 0, IN)
+
+#define EMPTY_HOWTO(C) \
+  HOWTO ((C), 0, 0, 0, FALSE, 0, complain_overflow_dont, NULL, \
+         NULL, FALSE, 0, 0, FALSE)
+
+#define HOWTO_PREPARE(relocation, symbol)               \
+  {                                                     \
+    if (symbol != NULL)                                 \
+      {                                                 \
+        if (bfd_is_com_section (symbol->section))       \
+          {                                             \
+            relocation = 0;                             \
+          }                                             \
+        else                                            \
+          {                                             \
+            relocation = symbol->value;                 \
+          }                                             \
+      }                                                 \
+  }
+
+unsigned int bfd_get_reloc_size (reloc_howto_type *);
+
+typedef struct relent_chain
+{
+  arelent relent;
+  struct relent_chain *next;
+}
+arelent_chain;
+
+bfd_reloc_status_type bfd_check_overflow
+   (enum complain_overflow how,
+    unsigned int bitsize,
+    unsigned int rightshift,
+    unsigned int addrsize,
+    bfd_vma relocation);
+
+bfd_reloc_status_type bfd_perform_relocation
+   (bfd *abfd,
+    arelent *reloc_entry,
+    void *data,
+    asection *input_section,
+    bfd *output_bfd,
+    char **error_message);
+
+bfd_reloc_status_type bfd_install_relocation
+   (bfd *abfd,
+    arelent *reloc_entry,
+    void *data, bfd_vma data_start,
+    asection *input_section,
+    char **error_message);
+
+enum bfd_reloc_code_real {
+  _dummy_first_bfd_reloc_code_real,
+
+
+/* Basic absolute relocations of N bits.  */
+  BFD_RELOC_64,
+  BFD_RELOC_32,
+  BFD_RELOC_26,
+  BFD_RELOC_24,
+  BFD_RELOC_16,
+  BFD_RELOC_14,
+  BFD_RELOC_8,
+
+/* PC-relative relocations.  Sometimes these are relative to the address
+of the relocation itself; sometimes they are relative to the start of
+the section containing the relocation.  It depends on the specific target.
+
+The 24-bit relocation is used in some Intel 960 configurations.  */
+  BFD_RELOC_64_PCREL,
+  BFD_RELOC_32_PCREL,
+  BFD_RELOC_24_PCREL,
+  BFD_RELOC_16_PCREL,
+  BFD_RELOC_12_PCREL,
+  BFD_RELOC_8_PCREL,
+
+/* Section relative relocations.  Some targets need this for DWARF2.  */
+  BFD_RELOC_32_SECREL,
+
+/* For ELF.  */
+  BFD_RELOC_32_GOT_PCREL,
+  BFD_RELOC_16_GOT_PCREL,
+  BFD_RELOC_8_GOT_PCREL,
+  BFD_RELOC_32_GOTOFF,
+  BFD_RELOC_16_GOTOFF,
+  BFD_RELOC_LO16_GOTOFF,
+  BFD_RELOC_HI16_GOTOFF,
+  BFD_RELOC_HI16_S_GOTOFF,
+  BFD_RELOC_8_GOTOFF,
+  BFD_RELOC_64_PLT_PCREL,
+  BFD_RELOC_32_PLT_PCREL,
+  BFD_RELOC_24_PLT_PCREL,
+  BFD_RELOC_16_PLT_PCREL,
+  BFD_RELOC_8_PLT_PCREL,
+  BFD_RELOC_64_PLTOFF,
+  BFD_RELOC_32_PLTOFF,
+  BFD_RELOC_16_PLTOFF,
+  BFD_RELOC_LO16_PLTOFF,
+  BFD_RELOC_HI16_PLTOFF,
+  BFD_RELOC_HI16_S_PLTOFF,
+  BFD_RELOC_8_PLTOFF,
+
+/* Relocations used by 68K ELF.  */
+  BFD_RELOC_68K_GLOB_DAT,
+  BFD_RELOC_68K_JMP_SLOT,
+  BFD_RELOC_68K_RELATIVE,
+  BFD_RELOC_68K_TLS_GD32,
+  BFD_RELOC_68K_TLS_GD16,
+  BFD_RELOC_68K_TLS_GD8,
+  BFD_RELOC_68K_TLS_LDM32,
+  BFD_RELOC_68K_TLS_LDM16,
+  BFD_RELOC_68K_TLS_LDM8,
+  BFD_RELOC_68K_TLS_LDO32,
+  BFD_RELOC_68K_TLS_LDO16,
+  BFD_RELOC_68K_TLS_LDO8,
+  BFD_RELOC_68K_TLS_IE32,
+  BFD_RELOC_68K_TLS_IE16,
+  BFD_RELOC_68K_TLS_IE8,
+  BFD_RELOC_68K_TLS_LE32,
+  BFD_RELOC_68K_TLS_LE16,
+  BFD_RELOC_68K_TLS_LE8,
+
+/* Linkage-table relative.  */
+  BFD_RELOC_32_BASEREL,
+  BFD_RELOC_16_BASEREL,
+  BFD_RELOC_LO16_BASEREL,
+  BFD_RELOC_HI16_BASEREL,
+  BFD_RELOC_HI16_S_BASEREL,
+  BFD_RELOC_8_BASEREL,
+  BFD_RELOC_RVA,
+
+/* Absolute 8-bit relocation, but used to form an address like 0xFFnn.  */
+  BFD_RELOC_8_FFnn,
+
+/* These PC-relative relocations are stored as word displacements --
+i.e., byte displacements shifted right two bits.  The 30-bit word
+displacement (<<32_PCREL_S2>> -- 32 bits, shifted 2) is used on the
+SPARC.  (SPARC tools generally refer to this as <<WDISP30>>.)  The
+signed 16-bit displacement is used on the MIPS, and the 23-bit
+displacement is used on the Alpha.  */
+  BFD_RELOC_32_PCREL_S2,
+  BFD_RELOC_16_PCREL_S2,
+  BFD_RELOC_23_PCREL_S2,
+
+/* High 22 bits and low 10 bits of 32-bit value, placed into lower bits of
+the target word.  These are used on the SPARC.  */
+  BFD_RELOC_HI22,
+  BFD_RELOC_LO10,
+
+/* For systems that allocate a Global Pointer register, these are
+displacements off that register.  These relocation types are
+handled specially, because the value the register will have is
+decided relatively late.  */
+  BFD_RELOC_GPREL16,
+  BFD_RELOC_GPREL32,
+
+/* Reloc types used for i960/b.out.  */
+  BFD_RELOC_I960_CALLJ,
+
+/* SPARC ELF relocations.  There is probably some overlap with other
+relocation types already defined.  */
+  BFD_RELOC_NONE,
+  BFD_RELOC_SPARC_WDISP22,
+  BFD_RELOC_SPARC22,
+  BFD_RELOC_SPARC13,
+  BFD_RELOC_SPARC_GOT10,
+  BFD_RELOC_SPARC_GOT13,
+  BFD_RELOC_SPARC_GOT22,
+  BFD_RELOC_SPARC_PC10,
+  BFD_RELOC_SPARC_PC22,
+  BFD_RELOC_SPARC_WPLT30,
+  BFD_RELOC_SPARC_COPY,
+  BFD_RELOC_SPARC_GLOB_DAT,
+  BFD_RELOC_SPARC_JMP_SLOT,
+  BFD_RELOC_SPARC_RELATIVE,
+  BFD_RELOC_SPARC_UA16,
+  BFD_RELOC_SPARC_UA32,
+  BFD_RELOC_SPARC_UA64,
+  BFD_RELOC_SPARC_GOTDATA_HIX22,
+  BFD_RELOC_SPARC_GOTDATA_LOX10,
+  BFD_RELOC_SPARC_GOTDATA_OP_HIX22,
+  BFD_RELOC_SPARC_GOTDATA_OP_LOX10,
+  BFD_RELOC_SPARC_GOTDATA_OP,
+
+/* I think these are specific to SPARC a.out (e.g., Sun 4).  */
+  BFD_RELOC_SPARC_BASE13,
+  BFD_RELOC_SPARC_BASE22,
+
+/* SPARC64 relocations  */
+#define BFD_RELOC_SPARC_64 BFD_RELOC_64
+  BFD_RELOC_SPARC_10,
+  BFD_RELOC_SPARC_11,
+  BFD_RELOC_SPARC_OLO10,
+  BFD_RELOC_SPARC_HH22,
+  BFD_RELOC_SPARC_HM10,
+  BFD_RELOC_SPARC_LM22,
+  BFD_RELOC_SPARC_PC_HH22,
+  BFD_RELOC_SPARC_PC_HM10,
+  BFD_RELOC_SPARC_PC_LM22,
+  BFD_RELOC_SPARC_WDISP16,
+  BFD_RELOC_SPARC_WDISP19,
+  BFD_RELOC_SPARC_7,
+  BFD_RELOC_SPARC_6,
+  BFD_RELOC_SPARC_5,
+#define BFD_RELOC_SPARC_DISP64 BFD_RELOC_64_PCREL
+  BFD_RELOC_SPARC_PLT32,
+  BFD_RELOC_SPARC_PLT64,
+  BFD_RELOC_SPARC_HIX22,
+  BFD_RELOC_SPARC_LOX10,
+  BFD_RELOC_SPARC_H44,
+  BFD_RELOC_SPARC_M44,
+  BFD_RELOC_SPARC_L44,
+  BFD_RELOC_SPARC_REGISTER,
+
+/* SPARC little endian relocation  */
+  BFD_RELOC_SPARC_REV32,
+
+/* SPARC TLS relocations  */
+  BFD_RELOC_SPARC_TLS_GD_HI22,
+  BFD_RELOC_SPARC_TLS_GD_LO10,
+  BFD_RELOC_SPARC_TLS_GD_ADD,
+  BFD_RELOC_SPARC_TLS_GD_CALL,
+  BFD_RELOC_SPARC_TLS_LDM_HI22,
+  BFD_RELOC_SPARC_TLS_LDM_LO10,
+  BFD_RELOC_SPARC_TLS_LDM_ADD,
+  BFD_RELOC_SPARC_TLS_LDM_CALL,
+  BFD_RELOC_SPARC_TLS_LDO_HIX22,
+  BFD_RELOC_SPARC_TLS_LDO_LOX10,
+  BFD_RELOC_SPARC_TLS_LDO_ADD,
+  BFD_RELOC_SPARC_TLS_IE_HI22,
+  BFD_RELOC_SPARC_TLS_IE_LO10,
+  BFD_RELOC_SPARC_TLS_IE_LD,
+  BFD_RELOC_SPARC_TLS_IE_LDX,
+  BFD_RELOC_SPARC_TLS_IE_ADD,
+  BFD_RELOC_SPARC_TLS_LE_HIX22,
+  BFD_RELOC_SPARC_TLS_LE_LOX10,
+  BFD_RELOC_SPARC_TLS_DTPMOD32,
+  BFD_RELOC_SPARC_TLS_DTPMOD64,
+  BFD_RELOC_SPARC_TLS_DTPOFF32,
+  BFD_RELOC_SPARC_TLS_DTPOFF64,
+  BFD_RELOC_SPARC_TLS_TPOFF32,
+  BFD_RELOC_SPARC_TLS_TPOFF64,
+
+/* SPU Relocations.  */
+  BFD_RELOC_SPU_IMM7,
+  BFD_RELOC_SPU_IMM8,
+  BFD_RELOC_SPU_IMM10,
+  BFD_RELOC_SPU_IMM10W,
+  BFD_RELOC_SPU_IMM16,
+  BFD_RELOC_SPU_IMM16W,
+  BFD_RELOC_SPU_IMM18,
+  BFD_RELOC_SPU_PCREL9a,
+  BFD_RELOC_SPU_PCREL9b,
+  BFD_RELOC_SPU_PCREL16,
+  BFD_RELOC_SPU_LO16,
+  BFD_RELOC_SPU_HI16,
+  BFD_RELOC_SPU_PPU32,
+  BFD_RELOC_SPU_PPU64,
+  BFD_RELOC_SPU_ADD_PIC,
+
+/* Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
+"addend" in some special way.
+For GPDISP_HI16 ("gpdisp") relocations, the symbol is ignored when
+writing; when reading, it will be the absolute section symbol.  The
+addend is the displacement in bytes of the "lda" instruction from
+the "ldah" instruction (which is at the address of this reloc).  */
+  BFD_RELOC_ALPHA_GPDISP_HI16,
+
+/* For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
+with GPDISP_HI16 relocs.  The addend is ignored when writing the
+relocations out, and is filled in with the file's GP value on
+reading, for convenience.  */
+  BFD_RELOC_ALPHA_GPDISP_LO16,
+
+/* The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
+relocation except that there is no accompanying GPDISP_LO16
+relocation.  */
+  BFD_RELOC_ALPHA_GPDISP,
+
+/* The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
+the assembler turns it into a LDQ instruction to load the address of
+the symbol, and then fills in a register in the real instruction.
+
+The LITERAL reloc, at the LDQ instruction, refers to the .lita
+section symbol.  The addend is ignored when writing, but is filled
+in with the file's GP value on reading, for convenience, as with the
+GPDISP_LO16 reloc.
+
+The ELF_LITERAL reloc is somewhere between 16_GOTOFF and GPDISP_LO16.
+It should refer to the symbol to be referenced, as with 16_GOTOFF,
+but it generates output not based on the position within the .got
+section, but relative to the GP value chosen for the file during the
+final link stage.
+
+The LITUSE reloc, on the instruction using the loaded address, gives
+information to the linker that it might be able to use to optimize
+away some literal section references.  The symbol is ignored (read
+as the absolute section symbol), and the "addend" indicates the type
+of instruction using the register:
+1 - "memory" fmt insn
+2 - byte-manipulation (byte offset reg)
+3 - jsr (target of branch)  */
+  BFD_RELOC_ALPHA_LITERAL,
+  BFD_RELOC_ALPHA_ELF_LITERAL,
+  BFD_RELOC_ALPHA_LITUSE,
+
+/* The HINT relocation indicates a value that should be filled into the
+"hint" field of a jmp/jsr/ret instruction, for possible branch-
+prediction logic which may be provided on some processors.  */
+  BFD_RELOC_ALPHA_HINT,
+
+/* The LINKAGE relocation outputs a linkage pair in the object file,
+which is filled by the linker.  */
+  BFD_RELOC_ALPHA_LINKAGE,
+
+/* The CODEADDR relocation outputs a STO_CA in the object file,
+which is filled by the linker.  */
+  BFD_RELOC_ALPHA_CODEADDR,
+
+/* The GPREL_HI/LO relocations together form a 32-bit offset from the
+GP register.  */
+  BFD_RELOC_ALPHA_GPREL_HI16,
+  BFD_RELOC_ALPHA_GPREL_LO16,
+
+/* Like BFD_RELOC_23_PCREL_S2, except that the source and target must
+share a common GP, and the target address is adjusted for
+STO_ALPHA_STD_GPLOAD.  */
+  BFD_RELOC_ALPHA_BRSGP,
+
+/* The NOP relocation outputs a NOP if the longword displacement
+between two procedure entry points is < 2^21.  */
+  BFD_RELOC_ALPHA_NOP,
+
+/* The BSR relocation outputs a BSR if the longword displacement
+between two procedure entry points is < 2^21.  */
+  BFD_RELOC_ALPHA_BSR,
+
+/* The LDA relocation outputs a LDA if the longword displacement
+between two procedure entry points is < 2^16.  */
+  BFD_RELOC_ALPHA_LDA,
+
+/* The BOH relocation outputs a BSR if the longword displacement
+between two procedure entry points is < 2^21, or else a hint.  */
+  BFD_RELOC_ALPHA_BOH,
+
+/* Alpha thread-local storage relocations.  */
+  BFD_RELOC_ALPHA_TLSGD,
+  BFD_RELOC_ALPHA_TLSLDM,
+  BFD_RELOC_ALPHA_DTPMOD64,
+  BFD_RELOC_ALPHA_GOTDTPREL16,
+  BFD_RELOC_ALPHA_DTPREL64,
+  BFD_RELOC_ALPHA_DTPREL_HI16,
+  BFD_RELOC_ALPHA_DTPREL_LO16,
+  BFD_RELOC_ALPHA_DTPREL16,
+  BFD_RELOC_ALPHA_GOTTPREL16,
+  BFD_RELOC_ALPHA_TPREL64,
+  BFD_RELOC_ALPHA_TPREL_HI16,
+  BFD_RELOC_ALPHA_TPREL_LO16,
+  BFD_RELOC_ALPHA_TPREL16,
+
+/* Bits 27..2 of the relocation address shifted right 2 bits;
+simple reloc otherwise.  */
+  BFD_RELOC_MIPS_JMP,
+
+/* The MIPS16 jump instruction.  */
+  BFD_RELOC_MIPS16_JMP,
+
+/* MIPS16 GP relative reloc.  */
+  BFD_RELOC_MIPS16_GPREL,
+
+/* High 16 bits of 32-bit value; simple reloc.  */
+  BFD_RELOC_HI16,
+
+/* High 16 bits of 32-bit value but the low 16 bits will be sign
+extended and added to form the final result.  If the low 16
+bits form a negative number, we need to add one to the high value
+to compensate for the borrow when the low bits are added.  */
+  BFD_RELOC_HI16_S,
+
+/* Low 16 bits.  */
+  BFD_RELOC_LO16,
+
+/* High 16 bits of 32-bit pc-relative value  */
+  BFD_RELOC_HI16_PCREL,
+
+/* High 16 bits of 32-bit pc-relative value, adjusted  */
+  BFD_RELOC_HI16_S_PCREL,
+
+/* Low 16 bits of pc-relative value  */
+  BFD_RELOC_LO16_PCREL,
+
+/* Equivalent of BFD_RELOC_MIPS_*, but with the MIPS16 layout of
+16-bit immediate fields  */
+  BFD_RELOC_MIPS16_GOT16,
+  BFD_RELOC_MIPS16_CALL16,
+
+/* MIPS16 high 16 bits of 32-bit value.  */
+  BFD_RELOC_MIPS16_HI16,
+
+/* MIPS16 high 16 bits of 32-bit value but the low 16 bits will be sign
+extended and added to form the final result.  If the low 16
+bits form a negative number, we need to add one to the high value
+to compensate for the borrow when the low bits are added.  */
+  BFD_RELOC_MIPS16_HI16_S,
+
+/* MIPS16 low 16 bits.  */
+  BFD_RELOC_MIPS16_LO16,
+
+/* Relocation against a MIPS literal section.  */
+  BFD_RELOC_MIPS_LITERAL,
+
+/* MIPS ELF relocations.  */
+  BFD_RELOC_MIPS_GOT16,
+  BFD_RELOC_MIPS_CALL16,
+  BFD_RELOC_MIPS_GOT_HI16,
+  BFD_RELOC_MIPS_GOT_LO16,
+  BFD_RELOC_MIPS_CALL_HI16,
+  BFD_RELOC_MIPS_CALL_LO16,
+  BFD_RELOC_MIPS_SUB,
+  BFD_RELOC_MIPS_GOT_PAGE,
+  BFD_RELOC_MIPS_GOT_OFST,
+  BFD_RELOC_MIPS_GOT_DISP,
+  BFD_RELOC_MIPS_SHIFT5,
+  BFD_RELOC_MIPS_SHIFT6,
+  BFD_RELOC_MIPS_INSERT_A,
+  BFD_RELOC_MIPS_INSERT_B,
+  BFD_RELOC_MIPS_DELETE,
+  BFD_RELOC_MIPS_HIGHEST,
+  BFD_RELOC_MIPS_HIGHER,
+  BFD_RELOC_MIPS_SCN_DISP,
+  BFD_RELOC_MIPS_REL16,
+  BFD_RELOC_MIPS_RELGOT,
+  BFD_RELOC_MIPS_JALR,
+  BFD_RELOC_MIPS_TLS_DTPMOD32,
+  BFD_RELOC_MIPS_TLS_DTPREL32,
+  BFD_RELOC_MIPS_TLS_DTPMOD64,
+  BFD_RELOC_MIPS_TLS_DTPREL64,
+  BFD_RELOC_MIPS_TLS_GD,
+  BFD_RELOC_MIPS_TLS_LDM,
+  BFD_RELOC_MIPS_TLS_DTPREL_HI16,
+  BFD_RELOC_MIPS_TLS_DTPREL_LO16,
+  BFD_RELOC_MIPS_TLS_GOTTPREL,
+  BFD_RELOC_MIPS_TLS_TPREL32,
+  BFD_RELOC_MIPS_TLS_TPREL64,
+  BFD_RELOC_MIPS_TLS_TPREL_HI16,
+  BFD_RELOC_MIPS_TLS_TPREL_LO16,
+
+
+/* MIPS ELF relocations (VxWorks and PLT extensions).  */
+  BFD_RELOC_MIPS_COPY,
+  BFD_RELOC_MIPS_JUMP_SLOT,
+
+
+/* Moxie ELF relocations.  */
+  BFD_RELOC_MOXIE_10_PCREL,
+
+
+/* Fujitsu Frv Relocations.  */
+  BFD_RELOC_FRV_LABEL16,
+  BFD_RELOC_FRV_LABEL24,
+  BFD_RELOC_FRV_LO16,
+  BFD_RELOC_FRV_HI16,
+  BFD_RELOC_FRV_GPREL12,
+  BFD_RELOC_FRV_GPRELU12,
+  BFD_RELOC_FRV_GPREL32,
+  BFD_RELOC_FRV_GPRELHI,
+  BFD_RELOC_FRV_GPRELLO,
+  BFD_RELOC_FRV_GOT12,
+  BFD_RELOC_FRV_GOTHI,
+  BFD_RELOC_FRV_GOTLO,
+  BFD_RELOC_FRV_FUNCDESC,
+  BFD_RELOC_FRV_FUNCDESC_GOT12,
+  BFD_RELOC_FRV_FUNCDESC_GOTHI,
+  BFD_RELOC_FRV_FUNCDESC_GOTLO,
+  BFD_RELOC_FRV_FUNCDESC_VALUE,
+  BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
+  BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
+  BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
+  BFD_RELOC_FRV_GOTOFF12,
+  BFD_RELOC_FRV_GOTOFFHI,
+  BFD_RELOC_FRV_GOTOFFLO,
+  BFD_RELOC_FRV_GETTLSOFF,
+  BFD_RELOC_FRV_TLSDESC_VALUE,
+  BFD_RELOC_FRV_GOTTLSDESC12,
+  BFD_RELOC_FRV_GOTTLSDESCHI,
+  BFD_RELOC_FRV_GOTTLSDESCLO,
+  BFD_RELOC_FRV_TLSMOFF12,
+  BFD_RELOC_FRV_TLSMOFFHI,
+  BFD_RELOC_FRV_TLSMOFFLO,
+  BFD_RELOC_FRV_GOTTLSOFF12,
+  BFD_RELOC_FRV_GOTTLSOFFHI,
+  BFD_RELOC_FRV_GOTTLSOFFLO,
+  BFD_RELOC_FRV_TLSOFF,
+  BFD_RELOC_FRV_TLSDESC_RELAX,
+  BFD_RELOC_FRV_GETTLSOFF_RELAX,
+  BFD_RELOC_FRV_TLSOFF_RELAX,
+  BFD_RELOC_FRV_TLSMOFF,
+
+
+/* This is a 24bit GOT-relative reloc for the mn10300.  */
+  BFD_RELOC_MN10300_GOTOFF24,
+
+/* This is a 32bit GOT-relative reloc for the mn10300, offset by two bytes
+in the instruction.  */
+  BFD_RELOC_MN10300_GOT32,
+
+/* This is a 24bit GOT-relative reloc for the mn10300, offset by two bytes
+in the instruction.  */
+  BFD_RELOC_MN10300_GOT24,
+
+/* This is a 16bit GOT-relative reloc for the mn10300, offset by two bytes
+in the instruction.  */
+  BFD_RELOC_MN10300_GOT16,
+
+/* Copy symbol at runtime.  */
+  BFD_RELOC_MN10300_COPY,
+
+/* Create GOT entry.  */
+  BFD_RELOC_MN10300_GLOB_DAT,
+
+/* Create PLT entry.  */
+  BFD_RELOC_MN10300_JMP_SLOT,
+
+/* Adjust by program base.  */
+  BFD_RELOC_MN10300_RELATIVE,
+
+/* Together with another reloc targeted at the same location,
+allows for a value that is the difference of two symbols
+in the same section.  */
+  BFD_RELOC_MN10300_SYM_DIFF,
+
+/* The addend of this reloc is an alignment power that must
+be honoured at the offset's location, regardless of linker
+relaxation.  */
+  BFD_RELOC_MN10300_ALIGN,
+
+
+/* i386/elf relocations  */
+  BFD_RELOC_386_GOT32,
+  BFD_RELOC_386_PLT32,
+  BFD_RELOC_386_COPY,
+  BFD_RELOC_386_GLOB_DAT,
+  BFD_RELOC_386_JUMP_SLOT,
+  BFD_RELOC_386_RELATIVE,
+  BFD_RELOC_386_GOTOFF,
+  BFD_RELOC_386_GOTPC,
+  BFD_RELOC_386_TLS_TPOFF,
+  BFD_RELOC_386_TLS_IE,
+  BFD_RELOC_386_TLS_GOTIE,
+  BFD_RELOC_386_TLS_LE,
+  BFD_RELOC_386_TLS_GD,
+  BFD_RELOC_386_TLS_LDM,
+  BFD_RELOC_386_TLS_LDO_32,
+  BFD_RELOC_386_TLS_IE_32,
+  BFD_RELOC_386_TLS_LE_32,
+  BFD_RELOC_386_TLS_DTPMOD32,
+  BFD_RELOC_386_TLS_DTPOFF32,
+  BFD_RELOC_386_TLS_TPOFF32,
+  BFD_RELOC_386_TLS_GOTDESC,
+  BFD_RELOC_386_TLS_DESC_CALL,
+  BFD_RELOC_386_TLS_DESC,
+  BFD_RELOC_386_IRELATIVE,
+
+/* x86-64/elf relocations  */
+  BFD_RELOC_X86_64_GOT32,
+  BFD_RELOC_X86_64_PLT32,
+  BFD_RELOC_X86_64_COPY,
+  BFD_RELOC_X86_64_GLOB_DAT,
+  BFD_RELOC_X86_64_JUMP_SLOT,
+  BFD_RELOC_X86_64_RELATIVE,
+  BFD_RELOC_X86_64_GOTPCREL,
+  BFD_RELOC_X86_64_32S,
+  BFD_RELOC_X86_64_DTPMOD64,
+  BFD_RELOC_X86_64_DTPOFF64,
+  BFD_RELOC_X86_64_TPOFF64,
+  BFD_RELOC_X86_64_TLSGD,
+  BFD_RELOC_X86_64_TLSLD,
+  BFD_RELOC_X86_64_DTPOFF32,
+  BFD_RELOC_X86_64_GOTTPOFF,
+  BFD_RELOC_X86_64_TPOFF32,
+  BFD_RELOC_X86_64_GOTOFF64,
+  BFD_RELOC_X86_64_GOTPC32,
+  BFD_RELOC_X86_64_GOT64,
+  BFD_RELOC_X86_64_GOTPCREL64,
+  BFD_RELOC_X86_64_GOTPC64,
+  BFD_RELOC_X86_64_GOTPLT64,
+  BFD_RELOC_X86_64_PLTOFF64,
+  BFD_RELOC_X86_64_GOTPC32_TLSDESC,
+  BFD_RELOC_X86_64_TLSDESC_CALL,
+  BFD_RELOC_X86_64_TLSDESC,
+  BFD_RELOC_X86_64_IRELATIVE,
+
+/* ns32k relocations  */
+  BFD_RELOC_NS32K_IMM_8,
+  BFD_RELOC_NS32K_IMM_16,
+  BFD_RELOC_NS32K_IMM_32,
+  BFD_RELOC_NS32K_IMM_8_PCREL,
+  BFD_RELOC_NS32K_IMM_16_PCREL,
+  BFD_RELOC_NS32K_IMM_32_PCREL,
+  BFD_RELOC_NS32K_DISP_8,
+  BFD_RELOC_NS32K_DISP_16,
+  BFD_RELOC_NS32K_DISP_32,
+  BFD_RELOC_NS32K_DISP_8_PCREL,
+  BFD_RELOC_NS32K_DISP_16_PCREL,
+  BFD_RELOC_NS32K_DISP_32_PCREL,
+
+/* PDP11 relocations  */
+  BFD_RELOC_PDP11_DISP_8_PCREL,
+  BFD_RELOC_PDP11_DISP_6_PCREL,
+
+/* Picojava relocs.  Not all of these appear in object files.  */
+  BFD_RELOC_PJ_CODE_HI16,
+  BFD_RELOC_PJ_CODE_LO16,
+  BFD_RELOC_PJ_CODE_DIR16,
+  BFD_RELOC_PJ_CODE_DIR32,
+  BFD_RELOC_PJ_CODE_REL16,
+  BFD_RELOC_PJ_CODE_REL32,
+
+/* Power(rs6000) and PowerPC relocations.  */
+  BFD_RELOC_PPC_B26,
+  BFD_RELOC_PPC_BA26,
+  BFD_RELOC_PPC_TOC16,
+  BFD_RELOC_PPC_B16,
+  BFD_RELOC_PPC_B16_BRTAKEN,
+  BFD_RELOC_PPC_B16_BRNTAKEN,
+  BFD_RELOC_PPC_BA16,
+  BFD_RELOC_PPC_BA16_BRTAKEN,
+  BFD_RELOC_PPC_BA16_BRNTAKEN,
+  BFD_RELOC_PPC_COPY,
+  BFD_RELOC_PPC_GLOB_DAT,
+  BFD_RELOC_PPC_JMP_SLOT,
+  BFD_RELOC_PPC_RELATIVE,
+  BFD_RELOC_PPC_LOCAL24PC,
+  BFD_RELOC_PPC_EMB_NADDR32,
+  BFD_RELOC_PPC_EMB_NADDR16,
+  BFD_RELOC_PPC_EMB_NADDR16_LO,
+  BFD_RELOC_PPC_EMB_NADDR16_HI,
+  BFD_RELOC_PPC_EMB_NADDR16_HA,
+  BFD_RELOC_PPC_EMB_SDAI16,
+  BFD_RELOC_PPC_EMB_SDA2I16,
+  BFD_RELOC_PPC_EMB_SDA2REL,
+  BFD_RELOC_PPC_EMB_SDA21,
+  BFD_RELOC_PPC_EMB_MRKREF,
+  BFD_RELOC_PPC_EMB_RELSEC16,
+  BFD_RELOC_PPC_EMB_RELST_LO,
+  BFD_RELOC_PPC_EMB_RELST_HI,
+  BFD_RELOC_PPC_EMB_RELST_HA,
+  BFD_RELOC_PPC_EMB_BIT_FLD,
+  BFD_RELOC_PPC_EMB_RELSDA,
+  BFD_RELOC_PPC64_HIGHER,
+  BFD_RELOC_PPC64_HIGHER_S,
+  BFD_RELOC_PPC64_HIGHEST,
+  BFD_RELOC_PPC64_HIGHEST_S,
+  BFD_RELOC_PPC64_TOC16_LO,
+  BFD_RELOC_PPC64_TOC16_HI,
+  BFD_RELOC_PPC64_TOC16_HA,
+  BFD_RELOC_PPC64_TOC,
+  BFD_RELOC_PPC64_PLTGOT16,
+  BFD_RELOC_PPC64_PLTGOT16_LO,
+  BFD_RELOC_PPC64_PLTGOT16_HI,
+  BFD_RELOC_PPC64_PLTGOT16_HA,
+  BFD_RELOC_PPC64_ADDR16_DS,
+  BFD_RELOC_PPC64_ADDR16_LO_DS,
+  BFD_RELOC_PPC64_GOT16_DS,
+  BFD_RELOC_PPC64_GOT16_LO_DS,
+  BFD_RELOC_PPC64_PLT16_LO_DS,
+  BFD_RELOC_PPC64_SECTOFF_DS,
+  BFD_RELOC_PPC64_SECTOFF_LO_DS,
+  BFD_RELOC_PPC64_TOC16_DS,
+  BFD_RELOC_PPC64_TOC16_LO_DS,
+  BFD_RELOC_PPC64_PLTGOT16_DS,
+  BFD_RELOC_PPC64_PLTGOT16_LO_DS,
+
+/* PowerPC and PowerPC64 thread-local storage relocations.  */
+  BFD_RELOC_PPC_TLS,
+  BFD_RELOC_PPC_TLSGD,
+  BFD_RELOC_PPC_TLSLD,
+  BFD_RELOC_PPC_DTPMOD,
+  BFD_RELOC_PPC_TPREL16,
+  BFD_RELOC_PPC_TPREL16_LO,
+  BFD_RELOC_PPC_TPREL16_HI,
+  BFD_RELOC_PPC_TPREL16_HA,
+  BFD_RELOC_PPC_TPREL,
+  BFD_RELOC_PPC_DTPREL16,
+  BFD_RELOC_PPC_DTPREL16_LO,
+  BFD_RELOC_PPC_DTPREL16_HI,
+  BFD_RELOC_PPC_DTPREL16_HA,
+  BFD_RELOC_PPC_DTPREL,
+  BFD_RELOC_PPC_GOT_TLSGD16,
+  BFD_RELOC_PPC_GOT_TLSGD16_LO,
+  BFD_RELOC_PPC_GOT_TLSGD16_HI,
+  BFD_RELOC_PPC_GOT_TLSGD16_HA,
+  BFD_RELOC_PPC_GOT_TLSLD16,
+  BFD_RELOC_PPC_GOT_TLSLD16_LO,
+  BFD_RELOC_PPC_GOT_TLSLD16_HI,
+  BFD_RELOC_PPC_GOT_TLSLD16_HA,
+  BFD_RELOC_PPC_GOT_TPREL16,
+  BFD_RELOC_PPC_GOT_TPREL16_LO,
+  BFD_RELOC_PPC_GOT_TPREL16_HI,
+  BFD_RELOC_PPC_GOT_TPREL16_HA,
+  BFD_RELOC_PPC_GOT_DTPREL16,
+  BFD_RELOC_PPC_GOT_DTPREL16_LO,
+  BFD_RELOC_PPC_GOT_DTPREL16_HI,
+  BFD_RELOC_PPC_GOT_DTPREL16_HA,
+  BFD_RELOC_PPC64_TPREL16_DS,
+  BFD_RELOC_PPC64_TPREL16_LO_DS,
+  BFD_RELOC_PPC64_TPREL16_HIGHER,
+  BFD_RELOC_PPC64_TPREL16_HIGHERA,
+  BFD_RELOC_PPC64_TPREL16_HIGHEST,
+  BFD_RELOC_PPC64_TPREL16_HIGHESTA,
+  BFD_RELOC_PPC64_DTPREL16_DS,
+  BFD_RELOC_PPC64_DTPREL16_LO_DS,
+  BFD_RELOC_PPC64_DTPREL16_HIGHER,
+  BFD_RELOC_PPC64_DTPREL16_HIGHERA,
+  BFD_RELOC_PPC64_DTPREL16_HIGHEST,
+  BFD_RELOC_PPC64_DTPREL16_HIGHESTA,
+
+/* IBM 370/390 relocations  */
+  BFD_RELOC_I370_D12,
+
+/* The type of reloc used to build a constructor table - at the moment
+probably a 32 bit wide absolute relocation, but the target can choose.
+It generally does map to one of the other relocation types.  */
+  BFD_RELOC_CTOR,
+
+/* ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are
+not stored in the instruction.  */
+  BFD_RELOC_ARM_PCREL_BRANCH,
+
+/* ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
+not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
+field in the instruction.  */
+  BFD_RELOC_ARM_PCREL_BLX,
+
+/* Thumb 22 bit pc-relative branch.  The lowest bit must be zero and is
+not stored in the instruction.  The 2nd lowest bit comes from a 1 bit
+field in the instruction.  */
+  BFD_RELOC_THUMB_PCREL_BLX,
+
+/* ARM 26-bit pc-relative branch for an unconditional BL or BLX instruction.  */
+  BFD_RELOC_ARM_PCREL_CALL,
+
+/* ARM 26-bit pc-relative branch for B or conditional BL instruction.  */
+  BFD_RELOC_ARM_PCREL_JUMP,
+
+/* Thumb 7-, 9-, 12-, 20-, 23-, and 25-bit pc-relative branches.
+The lowest bit must be zero and is not stored in the instruction.
+Note that the corresponding ELF R_ARM_THM_JUMPnn constant has an
+"nn" one smaller in all cases.  Note further that BRANCH23
+corresponds to R_ARM_THM_CALL.  */
+  BFD_RELOC_THUMB_PCREL_BRANCH7,
+  BFD_RELOC_THUMB_PCREL_BRANCH9,
+  BFD_RELOC_THUMB_PCREL_BRANCH12,
+  BFD_RELOC_THUMB_PCREL_BRANCH20,
+  BFD_RELOC_THUMB_PCREL_BRANCH23,
+  BFD_RELOC_THUMB_PCREL_BRANCH25,
+
+/* 12-bit immediate offset, used in ARM-format ldr and str instructions.  */
+  BFD_RELOC_ARM_OFFSET_IMM,
+
+/* 5-bit immediate offset, used in Thumb-format ldr and str instructions.  */
+  BFD_RELOC_ARM_THUMB_OFFSET,
+
+/* Pc-relative or absolute relocation depending on target.  Used for
+entries in .init_array sections.  */
+  BFD_RELOC_ARM_TARGET1,
+
+/* Read-only segment base relative address.  */
+  BFD_RELOC_ARM_ROSEGREL32,
+
+/* Data segment base relative address.  */
+  BFD_RELOC_ARM_SBREL32,
+
+/* This reloc is used for references to RTTI data from exception handling
+tables.  The actual definition depends on the target.  It may be a
+pc-relative or some form of GOT-indirect relocation.  */
+  BFD_RELOC_ARM_TARGET2,
+
+/* 31-bit PC relative address.  */
+  BFD_RELOC_ARM_PREL31,
+
+/* Low and High halfword relocations for MOVW and MOVT instructions.  */
+  BFD_RELOC_ARM_MOVW,
+  BFD_RELOC_ARM_MOVT,
+  BFD_RELOC_ARM_MOVW_PCREL,
+  BFD_RELOC_ARM_MOVT_PCREL,
+  BFD_RELOC_ARM_THUMB_MOVW,
+  BFD_RELOC_ARM_THUMB_MOVT,
+  BFD_RELOC_ARM_THUMB_MOVW_PCREL,
+  BFD_RELOC_ARM_THUMB_MOVT_PCREL,
+
+/* Relocations for setting up GOTs and PLTs for shared libraries.  */
+  BFD_RELOC_ARM_JUMP_SLOT,
+  BFD_RELOC_ARM_GLOB_DAT,
+  BFD_RELOC_ARM_GOT32,
+  BFD_RELOC_ARM_PLT32,
+  BFD_RELOC_ARM_RELATIVE,
+  BFD_RELOC_ARM_GOTOFF,
+  BFD_RELOC_ARM_GOTPC,
+
+/* ARM thread-local storage relocations.  */
+  BFD_RELOC_ARM_TLS_GD32,
+  BFD_RELOC_ARM_TLS_LDO32,
+  BFD_RELOC_ARM_TLS_LDM32,
+  BFD_RELOC_ARM_TLS_DTPOFF32,
+  BFD_RELOC_ARM_TLS_DTPMOD32,
+  BFD_RELOC_ARM_TLS_TPOFF32,
+  BFD_RELOC_ARM_TLS_IE32,
+  BFD_RELOC_ARM_TLS_LE32,
+
+/* ARM group relocations.  */
+  BFD_RELOC_ARM_ALU_PC_G0_NC,
+  BFD_RELOC_ARM_ALU_PC_G0,
+  BFD_RELOC_ARM_ALU_PC_G1_NC,
+  BFD_RELOC_ARM_ALU_PC_G1,
+  BFD_RELOC_ARM_ALU_PC_G2,
+  BFD_RELOC_ARM_LDR_PC_G0,
+  BFD_RELOC_ARM_LDR_PC_G1,
+  BFD_RELOC_ARM_LDR_PC_G2,
+  BFD_RELOC_ARM_LDRS_PC_G0,
+  BFD_RELOC_ARM_LDRS_PC_G1,
+  BFD_RELOC_ARM_LDRS_PC_G2,
+  BFD_RELOC_ARM_LDC_PC_G0,
+  BFD_RELOC_ARM_LDC_PC_G1,
+  BFD_RELOC_ARM_LDC_PC_G2,
+  BFD_RELOC_ARM_ALU_SB_G0_NC,
+  BFD_RELOC_ARM_ALU_SB_G0,
+  BFD_RELOC_ARM_ALU_SB_G1_NC,
+  BFD_RELOC_ARM_ALU_SB_G1,
+  BFD_RELOC_ARM_ALU_SB_G2,
+  BFD_RELOC_ARM_LDR_SB_G0,
+  BFD_RELOC_ARM_LDR_SB_G1,
+  BFD_RELOC_ARM_LDR_SB_G2,
+  BFD_RELOC_ARM_LDRS_SB_G0,
+  BFD_RELOC_ARM_LDRS_SB_G1,
+  BFD_RELOC_ARM_LDRS_SB_G2,
+  BFD_RELOC_ARM_LDC_SB_G0,
+  BFD_RELOC_ARM_LDC_SB_G1,
+  BFD_RELOC_ARM_LDC_SB_G2,
+
+/* Annotation of BX instructions.  */
+  BFD_RELOC_ARM_V4BX,
+
+/* These relocs are only used within the ARM assembler.  They are not
+(at present) written to any object files.  */
+  BFD_RELOC_ARM_IMMEDIATE,
+  BFD_RELOC_ARM_ADRL_IMMEDIATE,
+  BFD_RELOC_ARM_T32_IMMEDIATE,
+  BFD_RELOC_ARM_T32_ADD_IMM,
+  BFD_RELOC_ARM_T32_IMM12,
+  BFD_RELOC_ARM_T32_ADD_PC12,
+  BFD_RELOC_ARM_SHIFT_IMM,
+  BFD_RELOC_ARM_SMC,
+  BFD_RELOC_ARM_SWI,
+  BFD_RELOC_ARM_MULTI,
+  BFD_RELOC_ARM_CP_OFF_IMM,
+  BFD_RELOC_ARM_CP_OFF_IMM_S2,
+  BFD_RELOC_ARM_T32_CP_OFF_IMM,
+  BFD_RELOC_ARM_T32_CP_OFF_IMM_S2,
+  BFD_RELOC_ARM_ADR_IMM,
+  BFD_RELOC_ARM_LDR_IMM,
+  BFD_RELOC_ARM_LITERAL,
+  BFD_RELOC_ARM_IN_POOL,
+  BFD_RELOC_ARM_OFFSET_IMM8,
+  BFD_RELOC_ARM_T32_OFFSET_U8,
+  BFD_RELOC_ARM_T32_OFFSET_IMM,
+  BFD_RELOC_ARM_HWLITERAL,
+  BFD_RELOC_ARM_THUMB_ADD,
+  BFD_RELOC_ARM_THUMB_IMM,
+  BFD_RELOC_ARM_THUMB_SHIFT,
+
+/* Renesas / SuperH SH relocs.  Not all of these appear in object files.  */
+  BFD_RELOC_SH_PCDISP8BY2,
+  BFD_RELOC_SH_PCDISP12BY2,
+  BFD_RELOC_SH_IMM3,
+  BFD_RELOC_SH_IMM3U,
+  BFD_RELOC_SH_DISP12,
+  BFD_RELOC_SH_DISP12BY2,
+  BFD_RELOC_SH_DISP12BY4,
+  BFD_RELOC_SH_DISP12BY8,
+  BFD_RELOC_SH_DISP20,
+  BFD_RELOC_SH_DISP20BY8,
+  BFD_RELOC_SH_IMM4,
+  BFD_RELOC_SH_IMM4BY2,
+  BFD_RELOC_SH_IMM4BY4,
+  BFD_RELOC_SH_IMM8,
+  BFD_RELOC_SH_IMM8BY2,
+  BFD_RELOC_SH_IMM8BY4,
+  BFD_RELOC_SH_PCRELIMM8BY2,
+  BFD_RELOC_SH_PCRELIMM8BY4,
+  BFD_RELOC_SH_SWITCH16,
+  BFD_RELOC_SH_SWITCH32,
+  BFD_RELOC_SH_USES,
+  BFD_RELOC_SH_COUNT,
+  BFD_RELOC_SH_ALIGN,
+  BFD_RELOC_SH_CODE,
+  BFD_RELOC_SH_DATA,
+  BFD_RELOC_SH_LABEL,
+  BFD_RELOC_SH_LOOP_START,
+  BFD_RELOC_SH_LOOP_END,
+  BFD_RELOC_SH_COPY,
+  BFD_RELOC_SH_GLOB_DAT,
+  BFD_RELOC_SH_JMP_SLOT,
+  BFD_RELOC_SH_RELATIVE,
+  BFD_RELOC_SH_GOTPC,
+  BFD_RELOC_SH_GOT_LOW16,
+  BFD_RELOC_SH_GOT_MEDLOW16,
+  BFD_RELOC_SH_GOT_MEDHI16,
+  BFD_RELOC_SH_GOT_HI16,
+  BFD_RELOC_SH_GOTPLT_LOW16,
+  BFD_RELOC_SH_GOTPLT_MEDLOW16,
+  BFD_RELOC_SH_GOTPLT_MEDHI16,
+  BFD_RELOC_SH_GOTPLT_HI16,
+  BFD_RELOC_SH_PLT_LOW16,
+  BFD_RELOC_SH_PLT_MEDLOW16,
+  BFD_RELOC_SH_PLT_MEDHI16,
+  BFD_RELOC_SH_PLT_HI16,
+  BFD_RELOC_SH_GOTOFF_LOW16,
+  BFD_RELOC_SH_GOTOFF_MEDLOW16,
+  BFD_RELOC_SH_GOTOFF_MEDHI16,
+  BFD_RELOC_SH_GOTOFF_HI16,
+  BFD_RELOC_SH_GOTPC_LOW16,
+  BFD_RELOC_SH_GOTPC_MEDLOW16,
+  BFD_RELOC_SH_GOTPC_MEDHI16,
+  BFD_RELOC_SH_GOTPC_HI16,
+  BFD_RELOC_SH_COPY64,
+  BFD_RELOC_SH_GLOB_DAT64,
+  BFD_RELOC_SH_JMP_SLOT64,
+  BFD_RELOC_SH_RELATIVE64,
+  BFD_RELOC_SH_GOT10BY4,
+  BFD_RELOC_SH_GOT10BY8,
+  BFD_RELOC_SH_GOTPLT10BY4,
+  BFD_RELOC_SH_GOTPLT10BY8,
+  BFD_RELOC_SH_GOTPLT32,
+  BFD_RELOC_SH_SHMEDIA_CODE,
+  BFD_RELOC_SH_IMMU5,
+  BFD_RELOC_SH_IMMS6,
+  BFD_RELOC_SH_IMMS6BY32,
+  BFD_RELOC_SH_IMMU6,
+  BFD_RELOC_SH_IMMS10,
+  BFD_RELOC_SH_IMMS10BY2,
+  BFD_RELOC_SH_IMMS10BY4,
+  BFD_RELOC_SH_IMMS10BY8,
+  BFD_RELOC_SH_IMMS16,
+  BFD_RELOC_SH_IMMU16,
+  BFD_RELOC_SH_IMM_LOW16,
+  BFD_RELOC_SH_IMM_LOW16_PCREL,
+  BFD_RELOC_SH_IMM_MEDLOW16,
+  BFD_RELOC_SH_IMM_MEDLOW16_PCREL,
+  BFD_RELOC_SH_IMM_MEDHI16,
+  BFD_RELOC_SH_IMM_MEDHI16_PCREL,
+  BFD_RELOC_SH_IMM_HI16,
+  BFD_RELOC_SH_IMM_HI16_PCREL,
+  BFD_RELOC_SH_PT_16,
+  BFD_RELOC_SH_TLS_GD_32,
+  BFD_RELOC_SH_TLS_LD_32,
+  BFD_RELOC_SH_TLS_LDO_32,
+  BFD_RELOC_SH_TLS_IE_32,
+  BFD_RELOC_SH_TLS_LE_32,
+  BFD_RELOC_SH_TLS_DTPMOD32,
+  BFD_RELOC_SH_TLS_DTPOFF32,
+  BFD_RELOC_SH_TLS_TPOFF32,
+
+/* ARC Cores relocs.
+ARC 22 bit pc-relative branch.  The lowest two bits must be zero and are
+not stored in the instruction.  The high 20 bits are installed in bits 26
+through 7 of the instruction.  */
+  BFD_RELOC_ARC_B22_PCREL,
+
+/* ARC 26 bit absolute branch.  The lowest two bits must be zero and are not
+stored in the instruction.  The high 24 bits are installed in bits 23
+through 0.  */
+  BFD_RELOC_ARC_B26,
+
+/* ADI Blackfin 16 bit immediate absolute reloc.  */
+  BFD_RELOC_BFIN_16_IMM,
+
+/* ADI Blackfin 16 bit immediate absolute reloc higher 16 bits.  */
+  BFD_RELOC_BFIN_16_HIGH,
+
+/* ADI Blackfin 'a' part of LSETUP.  */
+  BFD_RELOC_BFIN_4_PCREL,
+
+/* ADI Blackfin.  */
+  BFD_RELOC_BFIN_5_PCREL,
+
+/* ADI Blackfin 16 bit immediate absolute reloc lower 16 bits.  */
+  BFD_RELOC_BFIN_16_LOW,
+
+/* ADI Blackfin.  */
+  BFD_RELOC_BFIN_10_PCREL,
+
+/* ADI Blackfin 'b' part of LSETUP.  */
+  BFD_RELOC_BFIN_11_PCREL,
+
+/* ADI Blackfin.  */
+  BFD_RELOC_BFIN_12_PCREL_JUMP,
+
+/* ADI Blackfin Short jump, pcrel.  */
+  BFD_RELOC_BFIN_12_PCREL_JUMP_S,
+
+/* ADI Blackfin Call.x not implemented.  */
+  BFD_RELOC_BFIN_24_PCREL_CALL_X,
+
+/* ADI Blackfin Long Jump pcrel.  */
+  BFD_RELOC_BFIN_24_PCREL_JUMP_L,
+
+/* ADI Blackfin FD-PIC relocations.  */
+  BFD_RELOC_BFIN_GOT17M4,
+  BFD_RELOC_BFIN_GOTHI,
+  BFD_RELOC_BFIN_GOTLO,
+  BFD_RELOC_BFIN_FUNCDESC,
+  BFD_RELOC_BFIN_FUNCDESC_GOT17M4,
+  BFD_RELOC_BFIN_FUNCDESC_GOTHI,
+  BFD_RELOC_BFIN_FUNCDESC_GOTLO,
+  BFD_RELOC_BFIN_FUNCDESC_VALUE,
+  BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4,
+  BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI,
+  BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO,
+  BFD_RELOC_BFIN_GOTOFF17M4,
+  BFD_RELOC_BFIN_GOTOFFHI,
+  BFD_RELOC_BFIN_GOTOFFLO,
+
+/* ADI Blackfin GOT relocation.  */
+  BFD_RELOC_BFIN_GOT,
+
+/* ADI Blackfin PLTPC relocation.  */
+  BFD_RELOC_BFIN_PLTPC,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_PUSH,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_CONST,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_ADD,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_SUB,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_MULT,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_DIV,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_MOD,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LSHIFT,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_RSHIFT,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_AND,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_OR,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_XOR,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LAND,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LOR,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_LEN,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_NEG,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_COMP,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_PAGE,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_HWPAGE,
+
+/* ADI Blackfin arithmetic relocation.  */
+  BFD_ARELOC_BFIN_ADDR,
+
+/* Mitsubishi D10V relocs.
+This is a 10-bit reloc with the right 2 bits
+assumed to be 0.  */
+  BFD_RELOC_D10V_10_PCREL_R,
+
+/* Mitsubishi D10V relocs.
+This is a 10-bit reloc with the right 2 bits
+assumed to be 0.  This is the same as the previous reloc
+except it is in the left container, i.e.,
+shifted left 15 bits.  */
+  BFD_RELOC_D10V_10_PCREL_L,
+
+/* This is an 18-bit reloc with the right 2 bits
+assumed to be 0.  */
+  BFD_RELOC_D10V_18,
+
+/* This is an 18-bit reloc with the right 2 bits
+assumed to be 0.  */
+  BFD_RELOC_D10V_18_PCREL,
+
+/* Mitsubishi D30V relocs.
+This is a 6-bit absolute reloc.  */
+  BFD_RELOC_D30V_6,
+
+/* This is a 6-bit pc-relative reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_9_PCREL,
+
+/* This is a 6-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container.  */
+  BFD_RELOC_D30V_9_PCREL_R,
+
+/* This is a 12-bit absolute reloc with the
+right 3 bitsassumed to be 0.  */
+  BFD_RELOC_D30V_15,
+
+/* This is a 12-bit pc-relative reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_15_PCREL,
+
+/* This is a 12-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container.  */
+  BFD_RELOC_D30V_15_PCREL_R,
+
+/* This is an 18-bit absolute reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_21,
+
+/* This is an 18-bit pc-relative reloc with
+the right 3 bits assumed to be 0.  */
+  BFD_RELOC_D30V_21_PCREL,
+
+/* This is an 18-bit pc-relative reloc with
+the right 3 bits assumed to be 0. Same
+as the previous reloc but on the right side
+of the container.  */
+  BFD_RELOC_D30V_21_PCREL_R,
+
+/* This is a 32-bit absolute reloc.  */
+  BFD_RELOC_D30V_32,
+
+/* This is a 32-bit pc-relative reloc.  */
+  BFD_RELOC_D30V_32_PCREL,
+
+/* DLX relocs  */
+  BFD_RELOC_DLX_HI16_S,
+
+/* DLX relocs  */
+  BFD_RELOC_DLX_LO16,
+
+/* DLX relocs  */
+  BFD_RELOC_DLX_JMP26,
+
+/* Renesas M16C/M32C Relocations.  */
+  BFD_RELOC_M32C_HI8,
+  BFD_RELOC_M32C_RL_JUMP,
+  BFD_RELOC_M32C_RL_1ADDR,
+  BFD_RELOC_M32C_RL_2ADDR,
+
+/* Renesas M32R (formerly Mitsubishi M32R) relocs.
+This is a 24 bit absolute address.  */
+  BFD_RELOC_M32R_24,
+
+/* This is a 10-bit pc-relative reloc with the right 2 bits assumed to be 0.  */
+  BFD_RELOC_M32R_10_PCREL,
+
+/* This is an 18-bit reloc with the right 2 bits assumed to be 0.  */
+  BFD_RELOC_M32R_18_PCREL,
+
+/* This is a 26-bit reloc with the right 2 bits assumed to be 0.  */
+  BFD_RELOC_M32R_26_PCREL,
+
+/* This is a 16-bit reloc containing the high 16 bits of an address
+used when the lower 16 bits are treated as unsigned.  */
+  BFD_RELOC_M32R_HI16_ULO,
+
+/* This is a 16-bit reloc containing the high 16 bits of an address
+used when the lower 16 bits are treated as signed.  */
+  BFD_RELOC_M32R_HI16_SLO,
+
+/* This is a 16-bit reloc containing the lower 16 bits of an address.  */
+  BFD_RELOC_M32R_LO16,
+
+/* This is a 16-bit reloc containing the small data area offset for use in
+add3, load, and store instructions.  */
+  BFD_RELOC_M32R_SDA16,
+
+/* For PIC.  */
+  BFD_RELOC_M32R_GOT24,
+  BFD_RELOC_M32R_26_PLTREL,
+  BFD_RELOC_M32R_COPY,
+  BFD_RELOC_M32R_GLOB_DAT,
+  BFD_RELOC_M32R_JMP_SLOT,
+  BFD_RELOC_M32R_RELATIVE,
+  BFD_RELOC_M32R_GOTOFF,
+  BFD_RELOC_M32R_GOTOFF_HI_ULO,
+  BFD_RELOC_M32R_GOTOFF_HI_SLO,
+  BFD_RELOC_M32R_GOTOFF_LO,
+  BFD_RELOC_M32R_GOTPC24,
+  BFD_RELOC_M32R_GOT16_HI_ULO,
+  BFD_RELOC_M32R_GOT16_HI_SLO,
+  BFD_RELOC_M32R_GOT16_LO,
+  BFD_RELOC_M32R_GOTPC_HI_ULO,
+  BFD_RELOC_M32R_GOTPC_HI_SLO,
+  BFD_RELOC_M32R_GOTPC_LO,
+
+/* This is a 9-bit reloc  */
+  BFD_RELOC_V850_9_PCREL,
+
+/* This is a 22-bit reloc  */
+  BFD_RELOC_V850_22_PCREL,
+
+/* This is a 16 bit offset from the short data area pointer.  */
+  BFD_RELOC_V850_SDA_16_16_OFFSET,
+
+/* This is a 16 bit offset (of which only 15 bits are used) from the
+short data area pointer.  */
+  BFD_RELOC_V850_SDA_15_16_OFFSET,
+
+/* This is a 16 bit offset from the zero data area pointer.  */
+  BFD_RELOC_V850_ZDA_16_16_OFFSET,
+
+/* This is a 16 bit offset (of which only 15 bits are used) from the
+zero data area pointer.  */
+  BFD_RELOC_V850_ZDA_15_16_OFFSET,
+
+/* This is an 8 bit offset (of which only 6 bits are used) from the
+tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_6_8_OFFSET,
+
+/* This is an 8bit offset (of which only 7 bits are used) from the tiny
+data area pointer.  */
+  BFD_RELOC_V850_TDA_7_8_OFFSET,
+
+/* This is a 7 bit offset from the tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_7_7_OFFSET,
+
+/* This is a 16 bit offset from the tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_16_16_OFFSET,
+
+/* This is a 5 bit offset (of which only 4 bits are used) from the tiny
+data area pointer.  */
+  BFD_RELOC_V850_TDA_4_5_OFFSET,
+
+/* This is a 4 bit offset from the tiny data area pointer.  */
+  BFD_RELOC_V850_TDA_4_4_OFFSET,
+
+/* This is a 16 bit offset from the short data area pointer, with the
+bits placed non-contiguously in the instruction.  */
+  BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET,
+
+/* This is a 16 bit offset from the zero data area pointer, with the
+bits placed non-contiguously in the instruction.  */
+  BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET,
+
+/* This is a 6 bit offset from the call table base pointer.  */
+  BFD_RELOC_V850_CALLT_6_7_OFFSET,
+
+/* This is a 16 bit offset from the call table base pointer.  */
+  BFD_RELOC_V850_CALLT_16_16_OFFSET,
+
+/* Used for relaxing indirect function calls.  */
+  BFD_RELOC_V850_LONGCALL,
+
+/* Used for relaxing indirect jumps.  */
+  BFD_RELOC_V850_LONGJUMP,
+
+/* Used to maintain alignment whilst relaxing.  */
+  BFD_RELOC_V850_ALIGN,
+
+/* This is a variation of BFD_RELOC_LO16 that can be used in v850e ld.bu
+instructions.  */
+  BFD_RELOC_V850_LO16_SPLIT_OFFSET,
+
+/* This is a 32bit pcrel reloc for the mn10300, offset by two bytes in the
+instruction.  */
+  BFD_RELOC_MN10300_32_PCREL,
+
+/* This is a 16bit pcrel reloc for the mn10300, offset by two bytes in the
+instruction.  */
+  BFD_RELOC_MN10300_16_PCREL,
+
+/* This is a 8bit DP reloc for the tms320c30, where the most
+significant 8 bits of a 24 bit word are placed into the least
+significant 8 bits of the opcode.  */
+  BFD_RELOC_TIC30_LDP,
+
+/* This is a 7bit reloc for the tms320c54x, where the least
+significant 7 bits of a 16 bit word are placed into the least
+significant 7 bits of the opcode.  */
+  BFD_RELOC_TIC54X_PARTLS7,
+
+/* This is a 9bit DP reloc for the tms320c54x, where the most
+significant 9 bits of a 16 bit word are placed into the least
+significant 9 bits of the opcode.  */
+  BFD_RELOC_TIC54X_PARTMS9,
+
+/* This is an extended address 23-bit reloc for the tms320c54x.  */
+  BFD_RELOC_TIC54X_23,
+
+/* This is a 16-bit reloc for the tms320c54x, where the least
+significant 16 bits of a 23-bit extended address are placed into
+the opcode.  */
+  BFD_RELOC_TIC54X_16_OF_23,
+
+/* This is a reloc for the tms320c54x, where the most
+significant 7 bits of a 23-bit extended address are placed into
+the opcode.  */
+  BFD_RELOC_TIC54X_MS7_OF_23,
+
+/* This is a 48 bit reloc for the FR30 that stores 32 bits.  */
+  BFD_RELOC_FR30_48,
+
+/* This is a 32 bit reloc for the FR30 that stores 20 bits split up into
+two sections.  */
+  BFD_RELOC_FR30_20,
+
+/* This is a 16 bit reloc for the FR30 that stores a 6 bit word offset in
+4 bits.  */
+  BFD_RELOC_FR30_6_IN_4,
+
+/* This is a 16 bit reloc for the FR30 that stores an 8 bit byte offset
+into 8 bits.  */
+  BFD_RELOC_FR30_8_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 9 bit short offset
+into 8 bits.  */
+  BFD_RELOC_FR30_9_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 10 bit word offset
+into 8 bits.  */
+  BFD_RELOC_FR30_10_IN_8,
+
+/* This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
+short offset into 8 bits.  */
+  BFD_RELOC_FR30_9_PCREL,
+
+/* This is a 16 bit reloc for the FR30 that stores a 12 bit pc relative
+short offset into 11 bits.  */
+  BFD_RELOC_FR30_12_PCREL,
+
+/* Motorola Mcore relocations.  */
+  BFD_RELOC_MCORE_PCREL_IMM8BY4,
+  BFD_RELOC_MCORE_PCREL_IMM11BY2,
+  BFD_RELOC_MCORE_PCREL_IMM4BY2,
+  BFD_RELOC_MCORE_PCREL_32,
+  BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2,
+  BFD_RELOC_MCORE_RVA,
+
+/* Toshiba Media Processor Relocations.  */
+  BFD_RELOC_MEP_8,
+  BFD_RELOC_MEP_16,
+  BFD_RELOC_MEP_32,
+  BFD_RELOC_MEP_PCREL8A2,
+  BFD_RELOC_MEP_PCREL12A2,
+  BFD_RELOC_MEP_PCREL17A2,
+  BFD_RELOC_MEP_PCREL24A2,
+  BFD_RELOC_MEP_PCABS24A2,
+  BFD_RELOC_MEP_LOW16,
+  BFD_RELOC_MEP_HI16U,
+  BFD_RELOC_MEP_HI16S,
+  BFD_RELOC_MEP_GPREL,
+  BFD_RELOC_MEP_TPREL,
+  BFD_RELOC_MEP_TPREL7,
+  BFD_RELOC_MEP_TPREL7A2,
+  BFD_RELOC_MEP_TPREL7A4,
+  BFD_RELOC_MEP_UIMM24,
+  BFD_RELOC_MEP_ADDR24A4,
+  BFD_RELOC_MEP_GNU_VTINHERIT,
+  BFD_RELOC_MEP_GNU_VTENTRY,
+
+
+/* These are relocations for the GETA instruction.  */
+  BFD_RELOC_MMIX_GETA,
+  BFD_RELOC_MMIX_GETA_1,
+  BFD_RELOC_MMIX_GETA_2,
+  BFD_RELOC_MMIX_GETA_3,
+
+/* These are relocations for a conditional branch instruction.  */
+  BFD_RELOC_MMIX_CBRANCH,
+  BFD_RELOC_MMIX_CBRANCH_J,
+  BFD_RELOC_MMIX_CBRANCH_1,
+  BFD_RELOC_MMIX_CBRANCH_2,
+  BFD_RELOC_MMIX_CBRANCH_3,
+
+/* These are relocations for the PUSHJ instruction.  */
+  BFD_RELOC_MMIX_PUSHJ,
+  BFD_RELOC_MMIX_PUSHJ_1,
+  BFD_RELOC_MMIX_PUSHJ_2,
+  BFD_RELOC_MMIX_PUSHJ_3,
+  BFD_RELOC_MMIX_PUSHJ_STUBBABLE,
+
+/* These are relocations for the JMP instruction.  */
+  BFD_RELOC_MMIX_JMP,
+  BFD_RELOC_MMIX_JMP_1,
+  BFD_RELOC_MMIX_JMP_2,
+  BFD_RELOC_MMIX_JMP_3,
+
+/* This is a relocation for a relative address as in a GETA instruction or
+a branch.  */
+  BFD_RELOC_MMIX_ADDR19,
+
+/* This is a relocation for a relative address as in a JMP instruction.  */
+  BFD_RELOC_MMIX_ADDR27,
+
+/* This is a relocation for an instruction field that may be a general
+register or a value 0..255.  */
+  BFD_RELOC_MMIX_REG_OR_BYTE,
+
+/* This is a relocation for an instruction field that may be a general
+register.  */
+  BFD_RELOC_MMIX_REG,
+
+/* This is a relocation for two instruction fields holding a register and
+an offset, the equivalent of the relocation.  */
+  BFD_RELOC_MMIX_BASE_PLUS_OFFSET,
+
+/* This relocation is an assertion that the expression is not allocated as
+a global register.  It does not modify contents.  */
+  BFD_RELOC_MMIX_LOCAL,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit pc relative
+short offset into 7 bits.  */
+  BFD_RELOC_AVR_7_PCREL,
+
+/* This is a 16 bit reloc for the AVR that stores 13 bit pc relative
+short offset into 12 bits.  */
+  BFD_RELOC_AVR_13_PCREL,
+
+/* This is a 16 bit reloc for the AVR that stores 17 bit value (usually
+program memory address) into 16 bits.  */
+  BFD_RELOC_AVR_16_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
+data memory address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_LO8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of data memory address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HI8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of program memory address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HH8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of 32 bit value) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_MS8_LDI,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(usually data memory address) into 8 bit immediate value of SUBI insn.  */
+  BFD_RELOC_AVR_LO8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 8 bit of data memory address) into 8 bit immediate value of
+SUBI insn.  */
+  BFD_RELOC_AVR_HI8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(most high 8 bit of program memory address) into 8 bit immediate value
+of LDI or SUBI insn.  */
+  BFD_RELOC_AVR_HH8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value (msb
+of 32 bit value) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_MS8_LDI_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (usually
+command address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_LO8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value 
+(command address) into 8 bit immediate value of LDI insn. If the address
+is beyond the 128k boundary, the linker inserts a jump stub for this reloc
+in the lower 128k.  */
+  BFD_RELOC_AVR_LO8_LDI_GS,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of command address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HI8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of command address) into 8 bit immediate value of LDI insn.  If the address
+is beyond the 128k boundary, the linker inserts a jump stub for this reloc
+below 128k.  */
+  BFD_RELOC_AVR_HI8_LDI_GS,
+
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
+of command address) into 8 bit immediate value of LDI insn.  */
+  BFD_RELOC_AVR_HH8_LDI_PM,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(usually command address) into 8 bit immediate value of SUBI insn.  */
+  BFD_RELOC_AVR_LO8_LDI_PM_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 8 bit of 16 bit command address) into 8 bit immediate value
+of SUBI insn.  */
+  BFD_RELOC_AVR_HI8_LDI_PM_NEG,
+
+/* This is a 16 bit reloc for the AVR that stores negated 8 bit value
+(high 6 bit of 22 bit command address) into 8 bit immediate
+value of SUBI insn.  */
+  BFD_RELOC_AVR_HH8_LDI_PM_NEG,
+
+/* This is a 32 bit reloc for the AVR that stores 23 bit value
+into 22 bits.  */
+  BFD_RELOC_AVR_CALL,
+
+/* This is a 16 bit reloc for the AVR that stores all needed bits
+for absolute addressing with ldi with overflow check to linktime  */
+  BFD_RELOC_AVR_LDI,
+
+/* This is a 6 bit reloc for the AVR that stores offset for ldd/std
+instructions  */
+  BFD_RELOC_AVR_6,
+
+/* This is a 6 bit reloc for the AVR that stores offset for adiw/sbiw
+instructions  */
+  BFD_RELOC_AVR_6_ADIW,
+
+/* Direct 12 bit.  */
+  BFD_RELOC_390_12,
+
+/* 12 bit GOT offset.  */
+  BFD_RELOC_390_GOT12,
+
+/* 32 bit PC relative PLT address.  */
+  BFD_RELOC_390_PLT32,
+
+/* Copy symbol at runtime.  */
+  BFD_RELOC_390_COPY,
+
+/* Create GOT entry.  */
+  BFD_RELOC_390_GLOB_DAT,
+
+/* Create PLT entry.  */
+  BFD_RELOC_390_JMP_SLOT,
+
+/* Adjust by program base.  */
+  BFD_RELOC_390_RELATIVE,
+
+/* 32 bit PC relative offset to GOT.  */
+  BFD_RELOC_390_GOTPC,
+
+/* 16 bit GOT offset.  */
+  BFD_RELOC_390_GOT16,
+
+/* PC relative 16 bit shifted by 1.  */
+  BFD_RELOC_390_PC16DBL,
+
+/* 16 bit PC rel. PLT shifted by 1.  */
+  BFD_RELOC_390_PLT16DBL,
+
+/* PC relative 32 bit shifted by 1.  */
+  BFD_RELOC_390_PC32DBL,
+
+/* 32 bit PC rel. PLT shifted by 1.  */
+  BFD_RELOC_390_PLT32DBL,
+
+/* 32 bit PC rel. GOT shifted by 1.  */
+  BFD_RELOC_390_GOTPCDBL,
+
+/* 64 bit GOT offset.  */
+  BFD_RELOC_390_GOT64,
+
+/* 64 bit PC relative PLT address.  */
+  BFD_RELOC_390_PLT64,
+
+/* 32 bit rel. offset to GOT entry.  */
+  BFD_RELOC_390_GOTENT,
+
+/* 64 bit offset to GOT.  */
+  BFD_RELOC_390_GOTOFF64,
+
+/* 12-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT12,
+
+/* 16-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT16,
+
+/* 32-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT32,
+
+/* 64-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLT64,
+
+/* 32-bit rel. offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_390_GOTPLTENT,
+
+/* 16-bit rel. offset from the GOT to a PLT entry.  */
+  BFD_RELOC_390_PLTOFF16,
+
+/* 32-bit rel. offset from the GOT to a PLT entry.  */
+  BFD_RELOC_390_PLTOFF32,
+
+/* 64-bit rel. offset from the GOT to a PLT entry.  */
+  BFD_RELOC_390_PLTOFF64,
+
+/* s390 tls relocations.  */
+  BFD_RELOC_390_TLS_LOAD,
+  BFD_RELOC_390_TLS_GDCALL,
+  BFD_RELOC_390_TLS_LDCALL,
+  BFD_RELOC_390_TLS_GD32,
+  BFD_RELOC_390_TLS_GD64,
+  BFD_RELOC_390_TLS_GOTIE12,
+  BFD_RELOC_390_TLS_GOTIE32,
+  BFD_RELOC_390_TLS_GOTIE64,
+  BFD_RELOC_390_TLS_LDM32,
+  BFD_RELOC_390_TLS_LDM64,
+  BFD_RELOC_390_TLS_IE32,
+  BFD_RELOC_390_TLS_IE64,
+  BFD_RELOC_390_TLS_IEENT,
+  BFD_RELOC_390_TLS_LE32,
+  BFD_RELOC_390_TLS_LE64,
+  BFD_RELOC_390_TLS_LDO32,
+  BFD_RELOC_390_TLS_LDO64,
+  BFD_RELOC_390_TLS_DTPMOD,
+  BFD_RELOC_390_TLS_DTPOFF,
+  BFD_RELOC_390_TLS_TPOFF,
+
+/* Long displacement extension.  */
+  BFD_RELOC_390_20,
+  BFD_RELOC_390_GOT20,
+  BFD_RELOC_390_GOTPLT20,
+  BFD_RELOC_390_TLS_GOTIE20,
+
+/* Score relocations
+Low 16 bit for load/store  */
+  BFD_RELOC_SCORE_GPREL15,
+
+/* This is a 24-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE_DUMMY2,
+  BFD_RELOC_SCORE_JMP,
+
+/* This is a 19-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE_BRANCH,
+
+/* This is a 32-bit reloc for 48-bit instructions.  */
+  BFD_RELOC_SCORE_IMM30,
+
+/* This is a 32-bit reloc for 48-bit instructions.  */
+  BFD_RELOC_SCORE_IMM32,
+
+/* This is a 11-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE16_JMP,
+
+/* This is a 8-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE16_BRANCH,
+
+/* This is a 9-bit reloc with the right 1 bit assumed to be 0  */
+  BFD_RELOC_SCORE_BCMP,
+
+/* Undocumented Score relocs  */
+  BFD_RELOC_SCORE_GOT15,
+  BFD_RELOC_SCORE_GOT_LO16,
+  BFD_RELOC_SCORE_CALL15,
+  BFD_RELOC_SCORE_DUMMY_HI16,
+
+/* Scenix IP2K - 9-bit register number / data address  */
+  BFD_RELOC_IP2K_FR9,
+
+/* Scenix IP2K - 4-bit register/data bank number  */
+  BFD_RELOC_IP2K_BANK,
+
+/* Scenix IP2K - low 13 bits of instruction word address  */
+  BFD_RELOC_IP2K_ADDR16CJP,
+
+/* Scenix IP2K - high 3 bits of instruction word address  */
+  BFD_RELOC_IP2K_PAGE3,
+
+/* Scenix IP2K - ext/low/high 8 bits of data address  */
+  BFD_RELOC_IP2K_LO8DATA,
+  BFD_RELOC_IP2K_HI8DATA,
+  BFD_RELOC_IP2K_EX8DATA,
+
+/* Scenix IP2K - low/high 8 bits of instruction word address  */
+  BFD_RELOC_IP2K_LO8INSN,
+  BFD_RELOC_IP2K_HI8INSN,
+
+/* Scenix IP2K - even/odd PC modifier to modify snb pcl.0  */
+  BFD_RELOC_IP2K_PC_SKIP,
+
+/* Scenix IP2K - 16 bit word address in text section.  */
+  BFD_RELOC_IP2K_TEXT,
+
+/* Scenix IP2K - 7-bit sp or dp offset  */
+  BFD_RELOC_IP2K_FR_OFFSET,
+
+/* Scenix VPE4K coprocessor - data/insn-space addressing  */
+  BFD_RELOC_VPE4KMATH_DATA,
+  BFD_RELOC_VPE4KMATH_INSN,
+
+/* These two relocations are used by the linker to determine which of
+the entries in a C++ virtual function table are actually used.  When
+the --gc-sections option is given, the linker will zero out the entries
+that are not used, so that the code for those functions need not be
+included in the output.
+
+VTABLE_INHERIT is a zero-space relocation used to describe to the
+linker the inheritance tree of a C++ virtual function table.  The
+relocation's symbol should be the parent class' vtable, and the
+relocation should be located at the child vtable.
+
+VTABLE_ENTRY is a zero-space relocation that describes the use of a
+virtual function table entry.  The reloc's symbol should refer to the
+table of the class mentioned in the code.  Off of that base, an offset
+describes the entry that is being used.  For Rela hosts, this offset
+is stored in the reloc's addend.  For Rel hosts, we are forced to put
+this offset in the reloc's section offset.  */
+  BFD_RELOC_VTABLE_INHERIT,
+  BFD_RELOC_VTABLE_ENTRY,
+
+/* Intel IA64 Relocations.  */
+  BFD_RELOC_IA64_IMM14,
+  BFD_RELOC_IA64_IMM22,
+  BFD_RELOC_IA64_IMM64,
+  BFD_RELOC_IA64_DIR32MSB,
+  BFD_RELOC_IA64_DIR32LSB,
+  BFD_RELOC_IA64_DIR64MSB,
+  BFD_RELOC_IA64_DIR64LSB,
+  BFD_RELOC_IA64_GPREL22,
+  BFD_RELOC_IA64_GPREL64I,
+  BFD_RELOC_IA64_GPREL32MSB,
+  BFD_RELOC_IA64_GPREL32LSB,
+  BFD_RELOC_IA64_GPREL64MSB,
+  BFD_RELOC_IA64_GPREL64LSB,
+  BFD_RELOC_IA64_LTOFF22,
+  BFD_RELOC_IA64_LTOFF64I,
+  BFD_RELOC_IA64_PLTOFF22,
+  BFD_RELOC_IA64_PLTOFF64I,
+  BFD_RELOC_IA64_PLTOFF64MSB,
+  BFD_RELOC_IA64_PLTOFF64LSB,
+  BFD_RELOC_IA64_FPTR64I,
+  BFD_RELOC_IA64_FPTR32MSB,
+  BFD_RELOC_IA64_FPTR32LSB,
+  BFD_RELOC_IA64_FPTR64MSB,
+  BFD_RELOC_IA64_FPTR64LSB,
+  BFD_RELOC_IA64_PCREL21B,
+  BFD_RELOC_IA64_PCREL21BI,
+  BFD_RELOC_IA64_PCREL21M,
+  BFD_RELOC_IA64_PCREL21F,
+  BFD_RELOC_IA64_PCREL22,
+  BFD_RELOC_IA64_PCREL60B,
+  BFD_RELOC_IA64_PCREL64I,
+  BFD_RELOC_IA64_PCREL32MSB,
+  BFD_RELOC_IA64_PCREL32LSB,
+  BFD_RELOC_IA64_PCREL64MSB,
+  BFD_RELOC_IA64_PCREL64LSB,
+  BFD_RELOC_IA64_LTOFF_FPTR22,
+  BFD_RELOC_IA64_LTOFF_FPTR64I,
+  BFD_RELOC_IA64_LTOFF_FPTR32MSB,
+  BFD_RELOC_IA64_LTOFF_FPTR32LSB,
+  BFD_RELOC_IA64_LTOFF_FPTR64MSB,
+  BFD_RELOC_IA64_LTOFF_FPTR64LSB,
+  BFD_RELOC_IA64_SEGREL32MSB,
+  BFD_RELOC_IA64_SEGREL32LSB,
+  BFD_RELOC_IA64_SEGREL64MSB,
+  BFD_RELOC_IA64_SEGREL64LSB,
+  BFD_RELOC_IA64_SECREL32MSB,
+  BFD_RELOC_IA64_SECREL32LSB,
+  BFD_RELOC_IA64_SECREL64MSB,
+  BFD_RELOC_IA64_SECREL64LSB,
+  BFD_RELOC_IA64_REL32MSB,
+  BFD_RELOC_IA64_REL32LSB,
+  BFD_RELOC_IA64_REL64MSB,
+  BFD_RELOC_IA64_REL64LSB,
+  BFD_RELOC_IA64_LTV32MSB,
+  BFD_RELOC_IA64_LTV32LSB,
+  BFD_RELOC_IA64_LTV64MSB,
+  BFD_RELOC_IA64_LTV64LSB,
+  BFD_RELOC_IA64_IPLTMSB,
+  BFD_RELOC_IA64_IPLTLSB,
+  BFD_RELOC_IA64_COPY,
+  BFD_RELOC_IA64_LTOFF22X,
+  BFD_RELOC_IA64_LDXMOV,
+  BFD_RELOC_IA64_TPREL14,
+  BFD_RELOC_IA64_TPREL22,
+  BFD_RELOC_IA64_TPREL64I,
+  BFD_RELOC_IA64_TPREL64MSB,
+  BFD_RELOC_IA64_TPREL64LSB,
+  BFD_RELOC_IA64_LTOFF_TPREL22,
+  BFD_RELOC_IA64_DTPMOD64MSB,
+  BFD_RELOC_IA64_DTPMOD64LSB,
+  BFD_RELOC_IA64_LTOFF_DTPMOD22,
+  BFD_RELOC_IA64_DTPREL14,
+  BFD_RELOC_IA64_DTPREL22,
+  BFD_RELOC_IA64_DTPREL64I,
+  BFD_RELOC_IA64_DTPREL32MSB,
+  BFD_RELOC_IA64_DTPREL32LSB,
+  BFD_RELOC_IA64_DTPREL64MSB,
+  BFD_RELOC_IA64_DTPREL64LSB,
+  BFD_RELOC_IA64_LTOFF_DTPREL22,
+
+/* Motorola 68HC11 reloc.
+This is the 8 bit high part of an absolute address.  */
+  BFD_RELOC_M68HC11_HI8,
+
+/* Motorola 68HC11 reloc.
+This is the 8 bit low part of an absolute address.  */
+  BFD_RELOC_M68HC11_LO8,
+
+/* Motorola 68HC11 reloc.
+This is the 3 bit of a value.  */
+  BFD_RELOC_M68HC11_3B,
+
+/* Motorola 68HC11 reloc.
+This reloc marks the beginning of a jump/call instruction.
+It is used for linker relaxation to correctly identify beginning
+of instruction and change some branches to use PC-relative
+addressing mode.  */
+  BFD_RELOC_M68HC11_RL_JUMP,
+
+/* Motorola 68HC11 reloc.
+This reloc marks a group of several instructions that gcc generates
+and for which the linker relaxation pass can modify and/or remove
+some of them.  */
+  BFD_RELOC_M68HC11_RL_GROUP,
+
+/* Motorola 68HC11 reloc.
+This is the 16-bit lower part of an address.  It is used for 'call'
+instruction to specify the symbol address without any special
+transformation (due to memory bank window).  */
+  BFD_RELOC_M68HC11_LO16,
+
+/* Motorola 68HC11 reloc.
+This is a 8-bit reloc that specifies the page number of an address.
+It is used by 'call' instruction to specify the page number of
+the symbol.  */
+  BFD_RELOC_M68HC11_PAGE,
+
+/* Motorola 68HC11 reloc.
+This is a 24-bit reloc that represents the address with a 16-bit
+value and a 8-bit page number.  The symbol address is transformed
+to follow the 16K memory bank of 68HC12 (seen as mapped in the window).  */
+  BFD_RELOC_M68HC11_24,
+
+/* Motorola 68HC12 reloc.
+This is the 5 bits of a value.  */
+  BFD_RELOC_M68HC12_5B,
+
+/* NS CR16C Relocations.  */
+  BFD_RELOC_16C_NUM08,
+  BFD_RELOC_16C_NUM08_C,
+  BFD_RELOC_16C_NUM16,
+  BFD_RELOC_16C_NUM16_C,
+  BFD_RELOC_16C_NUM32,
+  BFD_RELOC_16C_NUM32_C,
+  BFD_RELOC_16C_DISP04,
+  BFD_RELOC_16C_DISP04_C,
+  BFD_RELOC_16C_DISP08,
+  BFD_RELOC_16C_DISP08_C,
+  BFD_RELOC_16C_DISP16,
+  BFD_RELOC_16C_DISP16_C,
+  BFD_RELOC_16C_DISP24,
+  BFD_RELOC_16C_DISP24_C,
+  BFD_RELOC_16C_DISP24a,
+  BFD_RELOC_16C_DISP24a_C,
+  BFD_RELOC_16C_REG04,
+  BFD_RELOC_16C_REG04_C,
+  BFD_RELOC_16C_REG04a,
+  BFD_RELOC_16C_REG04a_C,
+  BFD_RELOC_16C_REG14,
+  BFD_RELOC_16C_REG14_C,
+  BFD_RELOC_16C_REG16,
+  BFD_RELOC_16C_REG16_C,
+  BFD_RELOC_16C_REG20,
+  BFD_RELOC_16C_REG20_C,
+  BFD_RELOC_16C_ABS20,
+  BFD_RELOC_16C_ABS20_C,
+  BFD_RELOC_16C_ABS24,
+  BFD_RELOC_16C_ABS24_C,
+  BFD_RELOC_16C_IMM04,
+  BFD_RELOC_16C_IMM04_C,
+  BFD_RELOC_16C_IMM16,
+  BFD_RELOC_16C_IMM16_C,
+  BFD_RELOC_16C_IMM20,
+  BFD_RELOC_16C_IMM20_C,
+  BFD_RELOC_16C_IMM24,
+  BFD_RELOC_16C_IMM24_C,
+  BFD_RELOC_16C_IMM32,
+  BFD_RELOC_16C_IMM32_C,
+
+/* NS CR16 Relocations.  */
+  BFD_RELOC_CR16_NUM8,
+  BFD_RELOC_CR16_NUM16,
+  BFD_RELOC_CR16_NUM32,
+  BFD_RELOC_CR16_NUM32a,
+  BFD_RELOC_CR16_REGREL0,
+  BFD_RELOC_CR16_REGREL4,
+  BFD_RELOC_CR16_REGREL4a,
+  BFD_RELOC_CR16_REGREL14,
+  BFD_RELOC_CR16_REGREL14a,
+  BFD_RELOC_CR16_REGREL16,
+  BFD_RELOC_CR16_REGREL20,
+  BFD_RELOC_CR16_REGREL20a,
+  BFD_RELOC_CR16_ABS20,
+  BFD_RELOC_CR16_ABS24,
+  BFD_RELOC_CR16_IMM4,
+  BFD_RELOC_CR16_IMM8,
+  BFD_RELOC_CR16_IMM16,
+  BFD_RELOC_CR16_IMM20,
+  BFD_RELOC_CR16_IMM24,
+  BFD_RELOC_CR16_IMM32,
+  BFD_RELOC_CR16_IMM32a,
+  BFD_RELOC_CR16_DISP4,
+  BFD_RELOC_CR16_DISP8,
+  BFD_RELOC_CR16_DISP16,
+  BFD_RELOC_CR16_DISP20,
+  BFD_RELOC_CR16_DISP24,
+  BFD_RELOC_CR16_DISP24a,
+  BFD_RELOC_CR16_SWITCH8,
+  BFD_RELOC_CR16_SWITCH16,
+  BFD_RELOC_CR16_SWITCH32,
+  BFD_RELOC_CR16_GOT_REGREL20,
+  BFD_RELOC_CR16_GOTC_REGREL20,
+  BFD_RELOC_CR16_GLOB_DAT,
+
+/* NS CRX Relocations.  */
+  BFD_RELOC_CRX_REL4,
+  BFD_RELOC_CRX_REL8,
+  BFD_RELOC_CRX_REL8_CMP,
+  BFD_RELOC_CRX_REL16,
+  BFD_RELOC_CRX_REL24,
+  BFD_RELOC_CRX_REL32,
+  BFD_RELOC_CRX_REGREL12,
+  BFD_RELOC_CRX_REGREL22,
+  BFD_RELOC_CRX_REGREL28,
+  BFD_RELOC_CRX_REGREL32,
+  BFD_RELOC_CRX_ABS16,
+  BFD_RELOC_CRX_ABS32,
+  BFD_RELOC_CRX_NUM8,
+  BFD_RELOC_CRX_NUM16,
+  BFD_RELOC_CRX_NUM32,
+  BFD_RELOC_CRX_IMM16,
+  BFD_RELOC_CRX_IMM32,
+  BFD_RELOC_CRX_SWITCH8,
+  BFD_RELOC_CRX_SWITCH16,
+  BFD_RELOC_CRX_SWITCH32,
+
+/* These relocs are only used within the CRIS assembler.  They are not
+(at present) written to any object files.  */
+  BFD_RELOC_CRIS_BDISP8,
+  BFD_RELOC_CRIS_UNSIGNED_5,
+  BFD_RELOC_CRIS_SIGNED_6,
+  BFD_RELOC_CRIS_UNSIGNED_6,
+  BFD_RELOC_CRIS_SIGNED_8,
+  BFD_RELOC_CRIS_UNSIGNED_8,
+  BFD_RELOC_CRIS_SIGNED_16,
+  BFD_RELOC_CRIS_UNSIGNED_16,
+  BFD_RELOC_CRIS_LAPCQ_OFFSET,
+  BFD_RELOC_CRIS_UNSIGNED_4,
+
+/* Relocs used in ELF shared libraries for CRIS.  */
+  BFD_RELOC_CRIS_COPY,
+  BFD_RELOC_CRIS_GLOB_DAT,
+  BFD_RELOC_CRIS_JUMP_SLOT,
+  BFD_RELOC_CRIS_RELATIVE,
+
+/* 32-bit offset to symbol-entry within GOT.  */
+  BFD_RELOC_CRIS_32_GOT,
+
+/* 16-bit offset to symbol-entry within GOT.  */
+  BFD_RELOC_CRIS_16_GOT,
+
+/* 32-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_CRIS_32_GOTPLT,
+
+/* 16-bit offset to symbol-entry within GOT, with PLT handling.  */
+  BFD_RELOC_CRIS_16_GOTPLT,
+
+/* 32-bit offset to symbol, relative to GOT.  */
+  BFD_RELOC_CRIS_32_GOTREL,
+
+/* 32-bit offset to symbol with PLT entry, relative to GOT.  */
+  BFD_RELOC_CRIS_32_PLT_GOTREL,
+
+/* 32-bit offset to symbol with PLT entry, relative to this relocation.  */
+  BFD_RELOC_CRIS_32_PLT_PCREL,
+
+/* Relocs used in TLS code for CRIS.  */
+  BFD_RELOC_CRIS_32_GOT_GD,
+  BFD_RELOC_CRIS_16_GOT_GD,
+  BFD_RELOC_CRIS_32_GD,
+  BFD_RELOC_CRIS_DTP,
+  BFD_RELOC_CRIS_32_DTPREL,
+  BFD_RELOC_CRIS_16_DTPREL,
+  BFD_RELOC_CRIS_32_GOT_TPREL,
+  BFD_RELOC_CRIS_16_GOT_TPREL,
+  BFD_RELOC_CRIS_32_TPREL,
+  BFD_RELOC_CRIS_16_TPREL,
+  BFD_RELOC_CRIS_DTPMOD,
+  BFD_RELOC_CRIS_32_IE,
+
+/* Intel i860 Relocations.  */
+  BFD_RELOC_860_COPY,
+  BFD_RELOC_860_GLOB_DAT,
+  BFD_RELOC_860_JUMP_SLOT,
+  BFD_RELOC_860_RELATIVE,
+  BFD_RELOC_860_PC26,
+  BFD_RELOC_860_PLT26,
+  BFD_RELOC_860_PC16,
+  BFD_RELOC_860_LOW0,
+  BFD_RELOC_860_SPLIT0,
+  BFD_RELOC_860_LOW1,
+  BFD_RELOC_860_SPLIT1,
+  BFD_RELOC_860_LOW2,
+  BFD_RELOC_860_SPLIT2,
+  BFD_RELOC_860_LOW3,
+  BFD_RELOC_860_LOGOT0,
+  BFD_RELOC_860_SPGOT0,
+  BFD_RELOC_860_LOGOT1,
+  BFD_RELOC_860_SPGOT1,
+  BFD_RELOC_860_LOGOTOFF0,
+  BFD_RELOC_860_SPGOTOFF0,
+  BFD_RELOC_860_LOGOTOFF1,
+  BFD_RELOC_860_SPGOTOFF1,
+  BFD_RELOC_860_LOGOTOFF2,
+  BFD_RELOC_860_LOGOTOFF3,
+  BFD_RELOC_860_LOPC,
+  BFD_RELOC_860_HIGHADJ,
+  BFD_RELOC_860_HAGOT,
+  BFD_RELOC_860_HAGOTOFF,
+  BFD_RELOC_860_HAPC,
+  BFD_RELOC_860_HIGH,
+  BFD_RELOC_860_HIGOT,
+  BFD_RELOC_860_HIGOTOFF,
+
+/* OpenRISC Relocations.  */
+  BFD_RELOC_OPENRISC_ABS_26,
+  BFD_RELOC_OPENRISC_REL_26,
+
+/* H8 elf Relocations.  */
+  BFD_RELOC_H8_DIR16A8,
+  BFD_RELOC_H8_DIR16R8,
+  BFD_RELOC_H8_DIR24A8,
+  BFD_RELOC_H8_DIR24R8,
+  BFD_RELOC_H8_DIR32A16,
+
+/* Sony Xstormy16 Relocations.  */
+  BFD_RELOC_XSTORMY16_REL_12,
+  BFD_RELOC_XSTORMY16_12,
+  BFD_RELOC_XSTORMY16_24,
+  BFD_RELOC_XSTORMY16_FPTR16,
+
+/* Self-describing complex relocations.  */
+  BFD_RELOC_RELC,
+
+
+/* Infineon Relocations.  */
+  BFD_RELOC_XC16X_PAG,
+  BFD_RELOC_XC16X_POF,
+  BFD_RELOC_XC16X_SEG,
+  BFD_RELOC_XC16X_SOF,
+
+/* Relocations used by VAX ELF.  */
+  BFD_RELOC_VAX_GLOB_DAT,
+  BFD_RELOC_VAX_JMP_SLOT,
+  BFD_RELOC_VAX_RELATIVE,
+
+/* Morpho MT - 16 bit immediate relocation.  */
+  BFD_RELOC_MT_PC16,
+
+/* Morpho MT - Hi 16 bits of an address.  */
+  BFD_RELOC_MT_HI16,
+
+/* Morpho MT - Low 16 bits of an address.  */
+  BFD_RELOC_MT_LO16,
+
+/* Morpho MT - Used to tell the linker which vtable entries are used.  */
+  BFD_RELOC_MT_GNU_VTINHERIT,
+
+/* Morpho MT - Used to tell the linker which vtable entries are used.  */
+  BFD_RELOC_MT_GNU_VTENTRY,
+
+/* Morpho MT - 8 bit immediate relocation.  */
+  BFD_RELOC_MT_PCINSN8,
+
+/* msp430 specific relocation codes  */
+  BFD_RELOC_MSP430_10_PCREL,
+  BFD_RELOC_MSP430_16_PCREL,
+  BFD_RELOC_MSP430_16,
+  BFD_RELOC_MSP430_16_PCREL_BYTE,
+  BFD_RELOC_MSP430_16_BYTE,
+  BFD_RELOC_MSP430_2X_PCREL,
+  BFD_RELOC_MSP430_RL_PCREL,
+
+/* IQ2000 Relocations.  */
+  BFD_RELOC_IQ2000_OFFSET_16,
+  BFD_RELOC_IQ2000_OFFSET_21,
+  BFD_RELOC_IQ2000_UHI16,
+
+/* Special Xtensa relocation used only by PLT entries in ELF shared
+objects to indicate that the runtime linker should set the value
+to one of its own internal functions or data structures.  */
+  BFD_RELOC_XTENSA_RTLD,
+
+/* Xtensa relocations for ELF shared objects.  */
+  BFD_RELOC_XTENSA_GLOB_DAT,
+  BFD_RELOC_XTENSA_JMP_SLOT,
+  BFD_RELOC_XTENSA_RELATIVE,
+
+/* Xtensa relocation used in ELF object files for symbols that may require
+PLT entries.  Otherwise, this is just a generic 32-bit relocation.  */
+  BFD_RELOC_XTENSA_PLT,
+
+/* Xtensa relocations to mark the difference of two local symbols.
+These are only needed to support linker relaxation and can be ignored
+when not relaxing.  The field is set to the value of the difference
+assuming no relaxation.  The relocation encodes the position of the
+first symbol so the linker can determine whether to adjust the field
+value.  */
+  BFD_RELOC_XTENSA_DIFF8,
+  BFD_RELOC_XTENSA_DIFF16,
+  BFD_RELOC_XTENSA_DIFF32,
+
+/* Generic Xtensa relocations for instruction operands.  Only the slot
+number is encoded in the relocation.  The relocation applies to the
+last PC-relative immediate operand, or if there are no PC-relative
+immediates, to the last immediate operand.  */
+  BFD_RELOC_XTENSA_SLOT0_OP,
+  BFD_RELOC_XTENSA_SLOT1_OP,
+  BFD_RELOC_XTENSA_SLOT2_OP,
+  BFD_RELOC_XTENSA_SLOT3_OP,
+  BFD_RELOC_XTENSA_SLOT4_OP,
+  BFD_RELOC_XTENSA_SLOT5_OP,
+  BFD_RELOC_XTENSA_SLOT6_OP,
+  BFD_RELOC_XTENSA_SLOT7_OP,
+  BFD_RELOC_XTENSA_SLOT8_OP,
+  BFD_RELOC_XTENSA_SLOT9_OP,
+  BFD_RELOC_XTENSA_SLOT10_OP,
+  BFD_RELOC_XTENSA_SLOT11_OP,
+  BFD_RELOC_XTENSA_SLOT12_OP,
+  BFD_RELOC_XTENSA_SLOT13_OP,
+  BFD_RELOC_XTENSA_SLOT14_OP,
+
+/* Alternate Xtensa relocations.  Only the slot is encoded in the
+relocation.  The meaning of these relocations is opcode-specific.  */
+  BFD_RELOC_XTENSA_SLOT0_ALT,
+  BFD_RELOC_XTENSA_SLOT1_ALT,
+  BFD_RELOC_XTENSA_SLOT2_ALT,
+  BFD_RELOC_XTENSA_SLOT3_ALT,
+  BFD_RELOC_XTENSA_SLOT4_ALT,
+  BFD_RELOC_XTENSA_SLOT5_ALT,
+  BFD_RELOC_XTENSA_SLOT6_ALT,
+  BFD_RELOC_XTENSA_SLOT7_ALT,
+  BFD_RELOC_XTENSA_SLOT8_ALT,
+  BFD_RELOC_XTENSA_SLOT9_ALT,
+  BFD_RELOC_XTENSA_SLOT10_ALT,
+  BFD_RELOC_XTENSA_SLOT11_ALT,
+  BFD_RELOC_XTENSA_SLOT12_ALT,
+  BFD_RELOC_XTENSA_SLOT13_ALT,
+  BFD_RELOC_XTENSA_SLOT14_ALT,
+
+/* Xtensa relocations for backward compatibility.  These have all been
+replaced by BFD_RELOC_XTENSA_SLOT0_OP.  */
+  BFD_RELOC_XTENSA_OP0,
+  BFD_RELOC_XTENSA_OP1,
+  BFD_RELOC_XTENSA_OP2,
+
+/* Xtensa relocation to mark that the assembler expanded the
+instructions from an original target.  The expansion size is
+encoded in the reloc size.  */
+  BFD_RELOC_XTENSA_ASM_EXPAND,
+
+/* Xtensa relocation to mark that the linker should simplify
+assembler-expanded instructions.  This is commonly used
+internally by the linker after analysis of a
+BFD_RELOC_XTENSA_ASM_EXPAND.  */
+  BFD_RELOC_XTENSA_ASM_SIMPLIFY,
+
+/* Xtensa TLS relocations.  */
+  BFD_RELOC_XTENSA_TLSDESC_FN,
+  BFD_RELOC_XTENSA_TLSDESC_ARG,
+  BFD_RELOC_XTENSA_TLS_DTPOFF,
+  BFD_RELOC_XTENSA_TLS_TPOFF,
+  BFD_RELOC_XTENSA_TLS_FUNC,
+  BFD_RELOC_XTENSA_TLS_ARG,
+  BFD_RELOC_XTENSA_TLS_CALL,
+
+/* 8 bit signed offset in (ix+d) or (iy+d).  */
+  BFD_RELOC_Z80_DISP8,
+
+/* DJNZ offset.  */
+  BFD_RELOC_Z8K_DISP7,
+
+/* CALR offset.  */
+  BFD_RELOC_Z8K_CALLR,
+
+/* 4 bit value.  */
+  BFD_RELOC_Z8K_IMM4L,
+
+/* Lattice Mico32 relocations.  */
+  BFD_RELOC_LM32_CALL,
+  BFD_RELOC_LM32_BRANCH,
+  BFD_RELOC_LM32_16_GOT,
+  BFD_RELOC_LM32_GOTOFF_HI16,
+  BFD_RELOC_LM32_GOTOFF_LO16,
+  BFD_RELOC_LM32_COPY,
+  BFD_RELOC_LM32_GLOB_DAT,
+  BFD_RELOC_LM32_JMP_SLOT,
+  BFD_RELOC_LM32_RELATIVE,
+
+/* Difference between two section addreses.  Must be followed by a
+BFD_RELOC_MACH_O_PAIR.  */
+  BFD_RELOC_MACH_O_SECTDIFF,
+
+/* Mach-O generic relocations.  */
+  BFD_RELOC_MACH_O_PAIR,
+
+/* This is a 32 bit reloc for the microblaze that stores the 
+low 16 bits of a value  */
+  BFD_RELOC_MICROBLAZE_32_LO,
+
+/* This is a 32 bit pc-relative reloc for the microblaze that 
+stores the low 16 bits of a value  */
+  BFD_RELOC_MICROBLAZE_32_LO_PCREL,
+
+/* This is a 32 bit reloc for the microblaze that stores a 
+value relative to the read-only small data area anchor  */
+  BFD_RELOC_MICROBLAZE_32_ROSDA,
+
+/* This is a 32 bit reloc for the microblaze that stores a 
+value relative to the read-write small data area anchor  */
+  BFD_RELOC_MICROBLAZE_32_RWSDA,
+
+/* This is a 32 bit reloc for the microblaze to handle 
+expressions of the form "Symbol Op Symbol"  */
+  BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM,
+
+/* This is a 64 bit reloc that stores the 32 bit pc relative 
+value in two words (with an imm instruction).  No relocation is 
+done here - only used for relaxing  */
+  BFD_RELOC_MICROBLAZE_64_NONE,
+
+/* This is a 64 bit reloc that stores the 32 bit pc relative 
+value in two words (with an imm instruction).  The relocation is
+PC-relative GOT offset  */
+  BFD_RELOC_MICROBLAZE_64_GOTPC,
+
+/* This is a 64 bit reloc that stores the 32 bit pc relative 
+value in two words (with an imm instruction).  The relocation is
+GOT offset  */
+  BFD_RELOC_MICROBLAZE_64_GOT,
+
+/* This is a 64 bit reloc that stores the 32 bit pc relative 
+value in two words (with an imm instruction).  The relocation is
+PC-relative offset into PLT  */
+  BFD_RELOC_MICROBLAZE_64_PLT,
+
+/* This is a 64 bit reloc that stores the 32 bit GOT relative 
+value in two words (with an imm instruction).  The relocation is
+relative offset from _GLOBAL_OFFSET_TABLE_  */
+  BFD_RELOC_MICROBLAZE_64_GOTOFF,
+
+/* This is a 32 bit reloc that stores the 32 bit GOT relative 
+value in a word.  The relocation is relative offset from  */
+  BFD_RELOC_MICROBLAZE_32_GOTOFF,
+
+/* This is used to tell the dynamic linker to copy the value out of
+the dynamic object into the runtime process image.  */
+  BFD_RELOC_MICROBLAZE_COPY,
+  BFD_RELOC_UNUSED };
+typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
+reloc_howto_type *bfd_reloc_type_lookup
+   (bfd *abfd, bfd_reloc_code_real_type code);
+reloc_howto_type *bfd_reloc_name_lookup
+   (bfd *abfd, const char *reloc_name);
+
+const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);
+
+/* Extracted from syms.c.  */
+
+typedef struct bfd_symbol
+{
+  /* A pointer to the BFD which owns the symbol. This information
+     is necessary so that a back end can work out what additional
+     information (invisible to the application writer) is carried
+     with the symbol.
+
+     This field is *almost* redundant, since you can use section->owner
+     instead, except that some symbols point to the global sections
+     bfd_{abs,com,und}_section.  This could be fixed by making
+     these globals be per-bfd (or per-target-flavor).  FIXME.  */
+  struct bfd *the_bfd; /* Use bfd_asymbol_bfd(sym) to access this field.  */
+
+  /* The text of the symbol. The name is left alone, and not copied; the
+     application may not alter it.  */
+  const char *name;
+
+  /* The value of the symbol.  This really should be a union of a
+     numeric value with a pointer, since some flags indicate that
+     a pointer to another symbol is stored here.  */
+  symvalue value;
+
+  /* Attributes of a symbol.  */
+#define BSF_NO_FLAGS           0x00
+
+  /* The symbol has local scope; <<static>> in <<C>>. The value
+     is the offset into the section of the data.  */
+#define BSF_LOCAL              (1 << 0)
+
+  /* The symbol has global scope; initialized data in <<C>>. The
+     value is the offset into the section of the data.  */
+#define BSF_GLOBAL             (1 << 1)
+
+  /* The symbol has global scope and is exported. The value is
+     the offset into the section of the data.  */
+#define BSF_EXPORT     BSF_GLOBAL /* No real difference.  */
+
+  /* A normal C symbol would be one of:
+     <<BSF_LOCAL>>, <<BSF_COMMON>>,  <<BSF_UNDEFINED>> or
+     <<BSF_GLOBAL>>.  */
+
+  /* The symbol is a debugging record. The value has an arbitrary
+     meaning, unless BSF_DEBUGGING_RELOC is also set.  */
+#define BSF_DEBUGGING          (1 << 2)
+
+  /* The symbol denotes a function entry point.  Used in ELF,
+     perhaps others someday.  */
+#define BSF_FUNCTION           (1 << 3)
+
+  /* Used by the linker.  */
+#define BSF_KEEP               (1 << 5)
+#define BSF_KEEP_G             (1 << 6)
+
+  /* A weak global symbol, overridable without warnings by
+     a regular global symbol of the same name.  */
+#define BSF_WEAK               (1 << 7)
+
+  /* This symbol was created to point to a section, e.g. ELF's
+     STT_SECTION symbols.  */
+#define BSF_SECTION_SYM        (1 << 8)
+
+  /* The symbol used to be a common symbol, but now it is
+     allocated.  */
+#define BSF_OLD_COMMON         (1 << 9)
+
+  /* In some files the type of a symbol sometimes alters its
+     location in an output file - ie in coff a <<ISFCN>> symbol
+     which is also <<C_EXT>> symbol appears where it was
+     declared and not at the end of a section.  This bit is set
+     by the target BFD part to convey this information.  */
+#define BSF_NOT_AT_END         (1 << 10)
+
+  /* Signal that the symbol is the label of constructor section.  */
+#define BSF_CONSTRUCTOR        (1 << 11)
+
+  /* Signal that the symbol is a warning symbol.  The name is a
+     warning.  The name of the next symbol is the one to warn about;
+     if a reference is made to a symbol with the same name as the next
+     symbol, a warning is issued by the linker.  */
+#define BSF_WARNING            (1 << 12)
+
+  /* Signal that the symbol is indirect.  This symbol is an indirect
+     pointer to the symbol with the same name as the next symbol.  */
+#define BSF_INDIRECT           (1 << 13)
+
+  /* BSF_FILE marks symbols that contain a file name.  This is used
+     for ELF STT_FILE symbols.  */
+#define BSF_FILE               (1 << 14)
+
+  /* Symbol is from dynamic linking information.  */
+#define BSF_DYNAMIC            (1 << 15)
+
+  /* The symbol denotes a data object.  Used in ELF, and perhaps
+     others someday.  */
+#define BSF_OBJECT             (1 << 16)
+
+  /* This symbol is a debugging symbol.  The value is the offset
+     into the section of the data.  BSF_DEBUGGING should be set
+     as well.  */
+#define BSF_DEBUGGING_RELOC    (1 << 17)
+
+  /* This symbol is thread local.  Used in ELF.  */
+#define BSF_THREAD_LOCAL       (1 << 18)
+
+  /* This symbol represents a complex relocation expression,
+     with the expression tree serialized in the symbol name.  */
+#define BSF_RELC               (1 << 19)
+
+  /* This symbol represents a signed complex relocation expression,
+     with the expression tree serialized in the symbol name.  */
+#define BSF_SRELC              (1 << 20)
+
+  /* This symbol was created by bfd_get_synthetic_symtab.  */
+#define BSF_SYNTHETIC          (1 << 21)
+
+  /* This symbol is an indirect code object.  Unrelated to BSF_INDIRECT.
+     The dynamic linker will compute the value of this symbol by
+     calling the function that it points to.  BSF_FUNCTION must
+     also be also set.  */
+#define BSF_GNU_INDIRECT_FUNCTION (1 << 22)
+  /* This symbol is a globally unique data object.  The dynamic linker
+     will make sure that in the entire process there is just one symbol
+     with this name and type in use.  BSF_OBJECT must also be set.  */
+#define BSF_GNU_UNIQUE         (1 << 23)
+
+  flagword flags;
+
+  /* A pointer to the section to which this symbol is
+     relative.  This will always be non NULL, there are special
+     sections for undefined and absolute symbols.  */
+  struct bfd_section *section;
+
+  /* Back end special data.  */
+  union
+    {
+      void *p;
+      bfd_vma i;
+    }
+  udata;
+}
+asymbol;
+
+#define bfd_get_symtab_upper_bound(abfd) \
+     BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))
+
+bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);
+
+bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);
+
+#define bfd_is_local_label_name(abfd, name) \
+  BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))
+
+bfd_boolean bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);
+
+#define bfd_is_target_special_symbol(abfd, sym) \
+  BFD_SEND (abfd, _bfd_is_target_special_symbol, (abfd, sym))
+
+#define bfd_canonicalize_symtab(abfd, location) \
+  BFD_SEND (abfd, _bfd_canonicalize_symtab, (abfd, location))
+
+bfd_boolean bfd_set_symtab
+   (bfd *abfd, asymbol **location, unsigned int count);
+
+void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);
+
+#define bfd_make_empty_symbol(abfd) \
+  BFD_SEND (abfd, _bfd_make_empty_symbol, (abfd))
+
+asymbol *_bfd_generic_make_empty_symbol (bfd *);
+
+#define bfd_make_debug_symbol(abfd,ptr,size) \
+  BFD_SEND (abfd, _bfd_make_debug_symbol, (abfd, ptr, size))
+
+int bfd_decode_symclass (asymbol *symbol);
+
+bfd_boolean bfd_is_undefined_symclass (int symclass);
+
+void bfd_symbol_info (asymbol *symbol, symbol_info *ret);
+
+bfd_boolean bfd_copy_private_symbol_data
+   (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);
+
+#define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \
+  BFD_SEND (obfd, _bfd_copy_private_symbol_data, \
+            (ibfd, isymbol, obfd, osymbol))
+
+/* Extracted from bfd.c.  */
+enum bfd_direction
+  {
+    no_direction = 0,
+    read_direction = 1,
+    write_direction = 2,
+    both_direction = 3
+  };
+
+struct bfd
+{
+  /* A unique identifier of the BFD  */
+  unsigned int id;
+
+  /* The filename the application opened the BFD with.  */
+  const char *filename;
+
+  /* A pointer to the target jump table.  */
+  const struct bfd_target *xvec;
+
+  /* The IOSTREAM, and corresponding IO vector that provide access
+     to the file backing the BFD.  */
+  void *iostream;
+  const struct bfd_iovec *iovec;
+
+  /* The caching routines use these to maintain a
+     least-recently-used list of BFDs.  */
+  struct bfd *lru_prev, *lru_next;
+
+  /* When a file is closed by the caching routines, BFD retains
+     state information on the file here...  */
+  ufile_ptr where;
+
+  /* File modified time, if mtime_set is TRUE.  */
+  long mtime;
+
+  /* Reserved for an unimplemented file locking extension.  */
+  int ifd;
+
+  /* The format which belongs to the BFD. (object, core, etc.)  */
+  bfd_format format;
+
+  /* The direction with which the BFD was opened.  */
+  enum bfd_direction direction;
+
+  /* Format_specific flags.  */
+  flagword flags;
+
+  /* Values that may appear in the flags field of a BFD.  These also
+     appear in the object_flags field of the bfd_target structure, where
+     they indicate the set of flags used by that backend (not all flags
+     are meaningful for all object file formats) (FIXME: at the moment,
+     the object_flags values have mostly just been copied from backend
+     to another, and are not necessarily correct).  */
+
+#define BFD_NO_FLAGS   0x00
+
+  /* BFD contains relocation entries.  */
+#define HAS_RELOC      0x01
+
+  /* BFD is directly executable.  */
+#define EXEC_P         0x02
+
+  /* BFD has line number information (basically used for F_LNNO in a
+     COFF header).  */
+#define HAS_LINENO     0x04
+
+  /* BFD has debugging information.  */
+#define HAS_DEBUG      0x08
+
+  /* BFD has symbols.  */
+#define HAS_SYMS       0x10
+
+  /* BFD has local symbols (basically used for F_LSYMS in a COFF
+     header).  */
+#define HAS_LOCALS     0x20
+
+  /* BFD is a dynamic object.  */
+#define DYNAMIC        0x40
+
+  /* Text section is write protected (if D_PAGED is not set, this is
+     like an a.out NMAGIC file) (the linker sets this by default, but
+     clears it for -r or -N).  */
+#define WP_TEXT        0x80
+
+  /* BFD is dynamically paged (this is like an a.out ZMAGIC file) (the
+     linker sets this by default, but clears it for -r or -n or -N).  */
+#define D_PAGED        0x100
+
+  /* BFD is relaxable (this means that bfd_relax_section may be able to
+     do something) (sometimes bfd_relax_section can do something even if
+     this is not set).  */
+#define BFD_IS_RELAXABLE 0x200
+
+  /* This may be set before writing out a BFD to request using a
+     traditional format.  For example, this is used to request that when
+     writing out an a.out object the symbols not be hashed to eliminate
+     duplicates.  */
+#define BFD_TRADITIONAL_FORMAT 0x400
+
+  /* This flag indicates that the BFD contents are actually cached
+     in memory.  If this is set, iostream points to a bfd_in_memory
+     struct.  */
+#define BFD_IN_MEMORY 0x800
+
+  /* The sections in this BFD specify a memory page.  */
+#define HAS_LOAD_PAGE 0x1000
+
+  /* This BFD has been created by the linker and doesn't correspond
+     to any input file.  */
+#define BFD_LINKER_CREATED 0x2000
+
+  /* This may be set before writing out a BFD to request that it
+     be written using values for UIDs, GIDs, timestamps, etc. that
+     will be consistent from run to run.  */
+#define BFD_DETERMINISTIC_OUTPUT 0x4000
+
+  /* Currently my_archive is tested before adding origin to
+     anything. I believe that this can become always an add of
+     origin, with origin set to 0 for non archive files.  */
+  ufile_ptr origin;
+
+  /* The origin in the archive of the proxy entry.  This will
+     normally be the same as origin, except for thin archives,
+     when it will contain the current offset of the proxy in the
+     thin archive rather than the offset of the bfd in its actual
+     container.  */
+  ufile_ptr proxy_origin;
+
+  /* A hash table for section names.  */
+  struct bfd_hash_table section_htab;
+
+  /* Pointer to linked list of sections.  */
+  struct bfd_section *sections;
+
+  /* The last section on the section list.  */
+  struct bfd_section *section_last;
+
+  /* The number of sections.  */
+  unsigned int section_count;
+
+  /* Stuff only useful for object files:
+     The start address.  */
+  bfd_vma start_address;
+
+  /* Used for input and output.  */
+  unsigned int symcount;
+
+  /* Symbol table for output BFD (with symcount entries).
+     Also used by the linker to cache input BFD symbols.  */
+  struct bfd_symbol  **outsymbols;
+
+  /* Used for slurped dynamic symbol tables.  */
+  unsigned int dynsymcount;
+
+  /* Pointer to structure which contains architecture information.  */
+  const struct bfd_arch_info *arch_info;
+
+  /* Stuff only useful for archives.  */
+  void *arelt_data;
+  struct bfd *my_archive;      /* The containing archive BFD.  */
+  struct bfd *archive_next;    /* The next BFD in the archive.  */
+  struct bfd *archive_head;    /* The first BFD in the archive.  */
+  struct bfd *nested_archives; /* List of nested archive in a flattened
+                                  thin archive.  */
+
+  /* A chain of BFD structures involved in a link.  */
+  struct bfd *link_next;
+
+  /* A field used by _bfd_generic_link_add_archive_symbols.  This will
+     be used only for archive elements.  */
+  int archive_pass;
+
+  /* Used by the back end to hold private data.  */
+  union
+    {
+      struct aout_data_struct *aout_data;
+      struct artdata *aout_ar_data;
+      struct _oasys_data *oasys_obj_data;
+      struct _oasys_ar_data *oasys_ar_data;
+      struct coff_tdata *coff_obj_data;
+      struct pe_tdata *pe_obj_data;
+      struct xcoff_tdata *xcoff_obj_data;
+      struct ecoff_tdata *ecoff_obj_data;
+      struct ieee_data_struct *ieee_data;
+      struct ieee_ar_data_struct *ieee_ar_data;
+      struct srec_data_struct *srec_data;
+      struct verilog_data_struct *verilog_data;
+      struct ihex_data_struct *ihex_data;
+      struct tekhex_data_struct *tekhex_data;
+      struct elf_obj_tdata *elf_obj_data;
+      struct nlm_obj_tdata *nlm_obj_data;
+      struct bout_data_struct *bout_data;
+      struct mmo_data_struct *mmo_data;
+      struct sun_core_struct *sun_core_data;
+      struct sco5_core_struct *sco5_core_data;
+      struct trad_core_struct *trad_core_data;
+      struct som_data_struct *som_data;
+      struct hpux_core_struct *hpux_core_data;
+      struct hppabsd_core_struct *hppabsd_core_data;
+      struct sgi_core_struct *sgi_core_data;
+      struct lynx_core_struct *lynx_core_data;
+      struct osf_core_struct *osf_core_data;
+      struct cisco_core_struct *cisco_core_data;
+      struct versados_data_struct *versados_data;
+      struct netbsd_core_struct *netbsd_core_data;
+      struct mach_o_data_struct *mach_o_data;
+      struct mach_o_fat_data_struct *mach_o_fat_data;
+      struct plugin_data_struct *plugin_data;
+      struct bfd_pef_data_struct *pef_data;
+      struct bfd_pef_xlib_data_struct *pef_xlib_data;
+      struct bfd_sym_data_struct *sym_data;
+      void *any;
+    }
+  tdata;
+
+  /* Used by the application to hold private data.  */
+  void *usrdata;
+
+  /* Where all the allocated stuff under this BFD goes.  This is a
+     struct objalloc *, but we use void * to avoid requiring the inclusion
+     of objalloc.h.  */
+  void *memory;
+
+  /* Is the file descriptor being cached?  That is, can it be closed as
+     needed, and re-opened when accessed later?  */
+  unsigned int cacheable : 1;
+
+  /* Marks whether there was a default target specified when the
+     BFD was opened. This is used to select which matching algorithm
+     to use to choose the back end.  */
+  unsigned int target_defaulted : 1;
+
+  /* ... and here: (``once'' means at least once).  */
+  unsigned int opened_once : 1;
+
+  /* Set if we have a locally maintained mtime value, rather than
+     getting it from the file each time.  */
+  unsigned int mtime_set : 1;
+
+  /* Flag set if symbols from this BFD should not be exported.  */
+  unsigned int no_export : 1;
+
+  /* Remember when output has begun, to stop strange things
+     from happening.  */
+  unsigned int output_has_begun : 1;
+
+  /* Have archive map.  */
+  unsigned int has_armap : 1;
+
+  /* Set if this is a thin archive.  */
+  unsigned int is_thin_archive : 1;
+};
+
+typedef enum bfd_error
+{
+  bfd_error_no_error = 0,
+  bfd_error_system_call,
+  bfd_error_invalid_target,
+  bfd_error_wrong_format,
+  bfd_error_wrong_object_format,
+  bfd_error_invalid_operation,
+  bfd_error_no_memory,
+  bfd_error_no_symbols,
+  bfd_error_no_armap,
+  bfd_error_no_more_archived_files,
+  bfd_error_malformed_archive,
+  bfd_error_file_not_recognized,
+  bfd_error_file_ambiguously_recognized,
+  bfd_error_no_contents,
+  bfd_error_nonrepresentable_section,
+  bfd_error_no_debug_section,
+  bfd_error_bad_value,
+  bfd_error_file_truncated,
+  bfd_error_file_too_big,
+  bfd_error_on_input,
+  bfd_error_invalid_error_code
+}
+bfd_error_type;
+
+bfd_error_type bfd_get_error (void);
+
+void bfd_set_error (bfd_error_type error_tag, ...);
+
+const char *bfd_errmsg (bfd_error_type error_tag);
+
+void bfd_perror (const char *message);
+
+typedef void (*bfd_error_handler_type) (const char *, ...);
+
+bfd_error_handler_type bfd_set_error_handler (bfd_error_handler_type);
+
+void bfd_set_error_program_name (const char *);
+
+bfd_error_handler_type bfd_get_error_handler (void);
+
+long bfd_get_reloc_upper_bound (bfd *abfd, asection *sect);
+
+long bfd_canonicalize_reloc
+   (bfd *abfd, asection *sec, arelent **loc, asymbol **syms);
+
+void bfd_set_reloc
+   (bfd *abfd, asection *sec, arelent **rel, unsigned int count);
+
+bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);
+
+int bfd_get_arch_size (bfd *abfd);
+
+int bfd_get_sign_extend_vma (bfd *abfd);
+
+bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);
+
+unsigned int bfd_get_gp_size (bfd *abfd);
+
+void bfd_set_gp_size (bfd *abfd, unsigned int i);
+
+bfd_vma bfd_scan_vma (const char *string, const char **end, int base);
+
+bfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);
+
+#define bfd_copy_private_header_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_copy_private_header_data, \
+               (ibfd, obfd))
+bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);
+
+#define bfd_copy_private_bfd_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_copy_private_bfd_data, \
+               (ibfd, obfd))
+bfd_boolean bfd_merge_private_bfd_data (bfd *ibfd, bfd *obfd);
+
+#define bfd_merge_private_bfd_data(ibfd, obfd) \
+     BFD_SEND (obfd, _bfd_merge_private_bfd_data, \
+               (ibfd, obfd))
+bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);
+
+#define bfd_set_private_flags(abfd, flags) \
+     BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))
+#define bfd_sizeof_headers(abfd, info) \
+       BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, info))
+
+#define bfd_find_nearest_line(abfd, sec, syms, off, file, func, line) \
+       BFD_SEND (abfd, _bfd_find_nearest_line, \
+                 (abfd, sec, syms, off, file, func, line))
+
+#define bfd_find_line(abfd, syms, sym, file, line) \
+       BFD_SEND (abfd, _bfd_find_line, \
+                 (abfd, syms, sym, file, line))
+
+#define bfd_find_inliner_info(abfd, file, func, line) \
+       BFD_SEND (abfd, _bfd_find_inliner_info, \
+                 (abfd, file, func, line))
+
+#define bfd_debug_info_start(abfd) \
+       BFD_SEND (abfd, _bfd_debug_info_start, (abfd))
+
+#define bfd_debug_info_end(abfd) \
+       BFD_SEND (abfd, _bfd_debug_info_end, (abfd))
+
+#define bfd_debug_info_accumulate(abfd, section) \
+       BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section))
+
+#define bfd_stat_arch_elt(abfd, stat) \
+       BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat))
+
+#define bfd_update_armap_timestamp(abfd) \
+       BFD_SEND (abfd, _bfd_update_armap_timestamp, (abfd))
+
+#define bfd_set_arch_mach(abfd, arch, mach)\
+       BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach))
+
+#define bfd_relax_section(abfd, section, link_info, again) \
+       BFD_SEND (abfd, _bfd_relax_section, (abfd, section, link_info, again))
+
+#define bfd_gc_sections(abfd, link_info) \
+       BFD_SEND (abfd, _bfd_gc_sections, (abfd, link_info))
+
+#define bfd_merge_sections(abfd, link_info) \
+       BFD_SEND (abfd, _bfd_merge_sections, (abfd, link_info))
+
+#define bfd_is_group_section(abfd, sec) \
+       BFD_SEND (abfd, _bfd_is_group_section, (abfd, sec))
+
+#define bfd_discard_group(abfd, sec) \
+       BFD_SEND (abfd, _bfd_discard_group, (abfd, sec))
+
+#define bfd_link_hash_table_create(abfd) \
+       BFD_SEND (abfd, _bfd_link_hash_table_create, (abfd))
+
+#define bfd_link_hash_table_free(abfd, hash) \
+       BFD_SEND (abfd, _bfd_link_hash_table_free, (hash))
+
+#define bfd_link_add_symbols(abfd, info) \
+       BFD_SEND (abfd, _bfd_link_add_symbols, (abfd, info))
+
+#define bfd_link_just_syms(abfd, sec, info) \
+       BFD_SEND (abfd, _bfd_link_just_syms, (sec, info))
+
+#define bfd_final_link(abfd, info) \
+       BFD_SEND (abfd, _bfd_final_link, (abfd, info))
+
+#define bfd_free_cached_info(abfd) \
+       BFD_SEND (abfd, _bfd_free_cached_info, (abfd))
+
+#define bfd_get_dynamic_symtab_upper_bound(abfd) \
+       BFD_SEND (abfd, _bfd_get_dynamic_symtab_upper_bound, (abfd))
+
+#define bfd_print_private_bfd_data(abfd, file)\
+       BFD_SEND (abfd, _bfd_print_private_bfd_data, (abfd, file))
+
+#define bfd_canonicalize_dynamic_symtab(abfd, asymbols) \
+       BFD_SEND (abfd, _bfd_canonicalize_dynamic_symtab, (abfd, asymbols))
+
+#define bfd_get_synthetic_symtab(abfd, count, syms, dyncount, dynsyms, ret) \
+       BFD_SEND (abfd, _bfd_get_synthetic_symtab, (abfd, count, syms, \
+                                                   dyncount, dynsyms, ret))
+
+#define bfd_get_dynamic_reloc_upper_bound(abfd) \
+       BFD_SEND (abfd, _bfd_get_dynamic_reloc_upper_bound, (abfd))
+
+#define bfd_canonicalize_dynamic_reloc(abfd, arels, asyms) \
+       BFD_SEND (abfd, _bfd_canonicalize_dynamic_reloc, (abfd, arels, asyms))
+
+extern bfd_byte *bfd_get_relocated_section_contents
+  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,
+   bfd_boolean, asymbol **);
+
+bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);
+
+struct bfd_preserve
+{
+  void *marker;
+  void *tdata;
+  flagword flags;
+  const struct bfd_arch_info *arch_info;
+  struct bfd_section *sections;
+  struct bfd_section *section_last;
+  unsigned int section_count;
+  struct bfd_hash_table section_htab;
+};
+
+bfd_boolean bfd_preserve_save (bfd *, struct bfd_preserve *);
+
+void bfd_preserve_restore (bfd *, struct bfd_preserve *);
+
+void bfd_preserve_finish (bfd *, struct bfd_preserve *);
+
+bfd_vma bfd_emul_get_maxpagesize (const char *);
+
+void bfd_emul_set_maxpagesize (const char *, bfd_vma);
+
+bfd_vma bfd_emul_get_commonpagesize (const char *);
+
+void bfd_emul_set_commonpagesize (const char *, bfd_vma);
+
+char *bfd_demangle (bfd *, const char *, int);
+
+/* Extracted from archive.c.  */
+symindex bfd_get_next_mapent
+   (bfd *abfd, symindex previous, carsym **sym);
+
+bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);
+
+bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);
+
+/* Extracted from corefile.c.  */
+const char *bfd_core_file_failing_command (bfd *abfd);
+
+int bfd_core_file_failing_signal (bfd *abfd);
+
+bfd_boolean core_file_matches_executable_p
+   (bfd *core_bfd, bfd *exec_bfd);
+
+bfd_boolean generic_core_file_matches_executable_p
+   (bfd *core_bfd, bfd *exec_bfd);
+
+/* Extracted from targets.c.  */
+#define BFD_SEND(bfd, message, arglist) \
+  ((*((bfd)->xvec->message)) arglist)
+
+#ifdef DEBUG_BFD_SEND
+#undef BFD_SEND
+#define BFD_SEND(bfd, message, arglist) \
+  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+    ((*((bfd)->xvec->message)) arglist) : \
+    (bfd_assert (__FILE__,__LINE__), NULL))
+#endif
+#define BFD_SEND_FMT(bfd, message, arglist) \
+  (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
+
+#ifdef DEBUG_BFD_SEND
+#undef BFD_SEND_FMT
+#define BFD_SEND_FMT(bfd, message, arglist) \
+  (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
+   (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
+   (bfd_assert (__FILE__,__LINE__), NULL))
+#endif
+
+enum bfd_flavour
+{
+  bfd_target_unknown_flavour,
+  bfd_target_aout_flavour,
+  bfd_target_coff_flavour,
+  bfd_target_ecoff_flavour,
+  bfd_target_xcoff_flavour,
+  bfd_target_elf_flavour,
+  bfd_target_ieee_flavour,
+  bfd_target_nlm_flavour,
+  bfd_target_oasys_flavour,
+  bfd_target_tekhex_flavour,
+  bfd_target_srec_flavour,
+  bfd_target_verilog_flavour,
+  bfd_target_ihex_flavour,
+  bfd_target_som_flavour,
+  bfd_target_os9k_flavour,
+  bfd_target_versados_flavour,
+  bfd_target_msdos_flavour,
+  bfd_target_ovax_flavour,
+  bfd_target_evax_flavour,
+  bfd_target_mmo_flavour,
+  bfd_target_mach_o_flavour,
+  bfd_target_pef_flavour,
+  bfd_target_pef_xlib_flavour,
+  bfd_target_sym_flavour
+};
+
+enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };
+
+/* Forward declaration.  */
+typedef struct bfd_link_info _bfd_link_info;
+
+typedef struct bfd_target
+{
+  /* Identifies the kind of target, e.g., SunOS4, Ultrix, etc.  */
+  char *name;
+
+ /* The "flavour" of a back end is a general indication about
+    the contents of a file.  */
+  enum bfd_flavour flavour;
+
+  /* The order of bytes within the data area of a file.  */
+  enum bfd_endian byteorder;
+
+ /* The order of bytes within the header parts of a file.  */
+  enum bfd_endian header_byteorder;
+
+  /* A mask of all the flags which an executable may have set -
+     from the set <<BFD_NO_FLAGS>>, <<HAS_RELOC>>, ...<<D_PAGED>>.  */
+  flagword object_flags;
+
+ /* A mask of all the flags which a section may have set - from
+    the set <<SEC_NO_FLAGS>>, <<SEC_ALLOC>>, ...<<SET_NEVER_LOAD>>.  */
+  flagword section_flags;
+
+ /* The character normally found at the front of a symbol.
+    (if any), perhaps `_'.  */
+  char symbol_leading_char;
+
+ /* The pad character for file names within an archive header.  */
+  char ar_pad_char;
+
+  /* The maximum number of characters in an archive header.  */
+  unsigned short ar_max_namelen;
+
+  /* Entries for byte swapping for data. These are different from the
+     other entry points, since they don't take a BFD as the first argument.
+     Certain other handlers could do the same.  */
+  bfd_uint64_t   (*bfd_getx64) (const void *);
+  bfd_int64_t    (*bfd_getx_signed_64) (const void *);
+  void           (*bfd_putx64) (bfd_uint64_t, void *);
+  bfd_vma        (*bfd_getx32) (const void *);
+  bfd_signed_vma (*bfd_getx_signed_32) (const void *);
+  void           (*bfd_putx32) (bfd_vma, void *);
+  bfd_vma        (*bfd_getx16) (const void *);
+  bfd_signed_vma (*bfd_getx_signed_16) (const void *);
+  void           (*bfd_putx16) (bfd_vma, void *);
+
+  /* Byte swapping for the headers.  */
+  bfd_uint64_t   (*bfd_h_getx64) (const void *);
+  bfd_int64_t    (*bfd_h_getx_signed_64) (const void *);
+  void           (*bfd_h_putx64) (bfd_uint64_t, void *);
+  bfd_vma        (*bfd_h_getx32) (const void *);
+  bfd_signed_vma (*bfd_h_getx_signed_32) (const void *);
+  void           (*bfd_h_putx32) (bfd_vma, void *);
+  bfd_vma        (*bfd_h_getx16) (const void *);
+  bfd_signed_vma (*bfd_h_getx_signed_16) (const void *);
+  void           (*bfd_h_putx16) (bfd_vma, void *);
+
+  /* Format dependent routines: these are vectors of entry points
+     within the target vector structure, one for each format to check.  */
+
+  /* Check the format of a file being read.  Return a <<bfd_target *>> or zero.  */
+  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) (bfd *);
+
+  /* Set the format of a file being written.  */
+  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);
+
+  /* Write cached information into a file being written, at <<bfd_close>>.  */
+  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);
+
+
+  /* Generic entry points.  */
+#define BFD_JUMP_TABLE_GENERIC(NAME) \
+  NAME##_close_and_cleanup, \
+  NAME##_bfd_free_cached_info, \
+  NAME##_new_section_hook, \
+  NAME##_get_section_contents, \
+  NAME##_get_section_contents_in_window
+
+  /* Called when the BFD is being closed to do any necessary cleanup.  */
+  bfd_boolean (*_close_and_cleanup) (bfd *);
+  /* Ask the BFD to free all cached information.  */
+  bfd_boolean (*_bfd_free_cached_info) (bfd *);
+  /* Called when a new section is created.  */
+  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);
+  /* Read the contents of a section.  */
+  bfd_boolean (*_bfd_get_section_contents)
+    (bfd *, sec_ptr, void *, file_ptr, bfd_size_type);
+  bfd_boolean (*_bfd_get_section_contents_in_window)
+    (bfd *, sec_ptr, bfd_window *, file_ptr, bfd_size_type);
+
+  /* Entry points to copy private data.  */
+#define BFD_JUMP_TABLE_COPY(NAME) \
+  NAME##_bfd_copy_private_bfd_data, \
+  NAME##_bfd_merge_private_bfd_data, \
+  _bfd_generic_init_private_section_data, \
+  NAME##_bfd_copy_private_section_data, \
+  NAME##_bfd_copy_private_symbol_data, \
+  NAME##_bfd_copy_private_header_data, \
+  NAME##_bfd_set_private_flags, \
+  NAME##_bfd_print_private_bfd_data
+
+  /* Called to copy BFD general private data from one object file
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);
+  /* Called to merge BFD general private data from one object file
+     to a common output file when linking.  */
+  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, bfd *);
+  /* Called to initialize BFD private section data from one object file
+     to another.  */
+#define bfd_init_private_section_data(ibfd, isec, obfd, osec, link_info) \
+  BFD_SEND (obfd, _bfd_init_private_section_data, (ibfd, isec, obfd, osec, link_info))
+  bfd_boolean (*_bfd_init_private_section_data)
+    (bfd *, sec_ptr, bfd *, sec_ptr, struct bfd_link_info *);
+  /* Called to copy BFD private section data from one object file
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_section_data)
+    (bfd *, sec_ptr, bfd *, sec_ptr);
+  /* Called to copy BFD private symbol data from one symbol
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_symbol_data)
+    (bfd *, asymbol *, bfd *, asymbol *);
+  /* Called to copy BFD private header data from one object file
+     to another.  */
+  bfd_boolean (*_bfd_copy_private_header_data)
+    (bfd *, bfd *);
+  /* Called to set private backend flags.  */
+  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);
+
+  /* Called to print private BFD data.  */
+  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);
+
+  /* Core file entry points.  */
+#define BFD_JUMP_TABLE_CORE(NAME) \
+  NAME##_core_file_failing_command, \
+  NAME##_core_file_failing_signal, \
+  NAME##_core_file_matches_executable_p
+
+  char *      (*_core_file_failing_command) (bfd *);
+  int         (*_core_file_failing_signal) (bfd *);
+  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);
+
+  /* Archive entry points.  */
+#define BFD_JUMP_TABLE_ARCHIVE(NAME) \
+  NAME##_slurp_armap, \
+  NAME##_slurp_extended_name_table, \
+  NAME##_construct_extended_name_table, \
+  NAME##_truncate_arname, \
+  NAME##_write_armap, \
+  NAME##_read_ar_hdr, \
+  NAME##_openr_next_archived_file, \
+  NAME##_get_elt_at_index, \
+  NAME##_generic_stat_arch_elt, \
+  NAME##_update_armap_timestamp
+
+  bfd_boolean (*_bfd_slurp_armap) (bfd *);
+  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);
+  bfd_boolean (*_bfd_construct_extended_name_table)
+    (bfd *, char **, bfd_size_type *, const char **);
+  void        (*_bfd_truncate_arname) (bfd *, const char *, char *);
+  bfd_boolean (*write_armap)
+    (bfd *, unsigned int, struct orl *, unsigned int, int);
+  void *      (*_bfd_read_ar_hdr_fn) (bfd *);
+  bfd *       (*openr_next_archived_file) (bfd *, bfd *);
+#define bfd_get_elt_at_index(b,i) BFD_SEND (b, _bfd_get_elt_at_index, (b,i))
+  bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);
+  int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);
+  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);
+
+  /* Entry points used for symbols.  */
+#define BFD_JUMP_TABLE_SYMBOLS(NAME) \
+  NAME##_get_symtab_upper_bound, \
+  NAME##_canonicalize_symtab, \
+  NAME##_make_empty_symbol, \
+  NAME##_print_symbol, \
+  NAME##_get_symbol_info, \
+  NAME##_bfd_is_local_label_name, \
+  NAME##_bfd_is_target_special_symbol, \
+  NAME##_get_lineno, \
+  NAME##_find_nearest_line, \
+  _bfd_generic_find_line, \
+  NAME##_find_inliner_info, \
+  NAME##_bfd_make_debug_symbol, \
+  NAME##_read_minisymbols, \
+  NAME##_minisymbol_to_symbol
+
+  long        (*_bfd_get_symtab_upper_bound) (bfd *);
+  long        (*_bfd_canonicalize_symtab)
+    (bfd *, struct bfd_symbol **);
+  struct bfd_symbol *
+              (*_bfd_make_empty_symbol) (bfd *);
+  void        (*_bfd_print_symbol)
+    (bfd *, void *, struct bfd_symbol *, bfd_print_symbol_type);
+#define bfd_print_symbol(b,p,s,e) BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))
+  void        (*_bfd_get_symbol_info)
+    (bfd *, struct bfd_symbol *, symbol_info *);
+#define bfd_get_symbol_info(b,p,e) BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))
+  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);
+  bfd_boolean (*_bfd_is_target_special_symbol) (bfd *, asymbol *);
+  alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);
+  bfd_boolean (*_bfd_find_nearest_line)
+    (bfd *, struct bfd_section *, struct bfd_symbol **, bfd_vma,
+     const char **, const char **, unsigned int *);
+  bfd_boolean (*_bfd_find_line)
+    (bfd *, struct bfd_symbol **, struct bfd_symbol *,
+     const char **, unsigned int *);
+  bfd_boolean (*_bfd_find_inliner_info)
+    (bfd *, const char **, const char **, unsigned int *);
+ /* Back-door to allow format-aware applications to create debug symbols
+    while using BFD for everything else.  Currently used by the assembler
+    when creating COFF files.  */
+  asymbol *   (*_bfd_make_debug_symbol)
+    (bfd *, void *, unsigned long size);
+#define bfd_read_minisymbols(b, d, m, s) \
+  BFD_SEND (b, _read_minisymbols, (b, d, m, s))
+  long        (*_read_minisymbols)
+    (bfd *, bfd_boolean, void **, unsigned int *);
+#define bfd_minisymbol_to_symbol(b, d, m, f) \
+  BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
+  asymbol *   (*_minisymbol_to_symbol)
+    (bfd *, bfd_boolean, const void *, asymbol *);
+
+  /* Routines for relocs.  */
+#define BFD_JUMP_TABLE_RELOCS(NAME) \
+  NAME##_get_reloc_upper_bound, \
+  NAME##_canonicalize_reloc, \
+  NAME##_bfd_reloc_type_lookup, \
+  NAME##_bfd_reloc_name_lookup
+
+  long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);
+  long        (*_bfd_canonicalize_reloc)
+    (bfd *, sec_ptr, arelent **, struct bfd_symbol **);
+  /* See documentation on reloc types.  */
+  reloc_howto_type *
+              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);
+  reloc_howto_type *
+              (*reloc_name_lookup) (bfd *, const char *);
+
+
+  /* Routines used when writing an object file.  */
+#define BFD_JUMP_TABLE_WRITE(NAME) \
+  NAME##_set_arch_mach, \
+  NAME##_set_section_contents
+
+  bfd_boolean (*_bfd_set_arch_mach)
+    (bfd *, enum bfd_architecture, unsigned long);
+  bfd_boolean (*_bfd_set_section_contents)
+    (bfd *, sec_ptr, const void *, file_ptr, bfd_size_type);
+
+  /* Routines used by the linker.  */
+#define BFD_JUMP_TABLE_LINK(NAME) \
+  NAME##_sizeof_headers, \
+  NAME##_bfd_get_relocated_section_contents, \
+  NAME##_bfd_relax_section, \
+  NAME##_bfd_link_hash_table_create, \
+  NAME##_bfd_link_hash_table_free, \
+  NAME##_bfd_link_add_symbols, \
+  NAME##_bfd_link_just_syms, \
+  NAME##_bfd_final_link, \
+  NAME##_bfd_link_split_section, \
+  NAME##_bfd_gc_sections, \
+  NAME##_bfd_merge_sections, \
+  NAME##_bfd_is_group_section, \
+  NAME##_bfd_discard_group, \
+  NAME##_section_already_linked, \
+  NAME##_bfd_define_common_symbol
+
+  int         (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);
+  bfd_byte *  (*_bfd_get_relocated_section_contents)
+    (bfd *, struct bfd_link_info *, struct bfd_link_order *,
+     bfd_byte *, bfd_boolean, struct bfd_symbol **);
+
+  bfd_boolean (*_bfd_relax_section)
+    (bfd *, struct bfd_section *, struct bfd_link_info *, bfd_boolean *);
+
+  /* Create a hash table for the linker.  Different backends store
+     different information in this table.  */
+  struct bfd_link_hash_table *
+              (*_bfd_link_hash_table_create) (bfd *);
+
+  /* Release the memory associated with the linker hash table.  */
+  void        (*_bfd_link_hash_table_free) (struct bfd_link_hash_table *);
+
+  /* Add symbols from this object file into the hash table.  */
+  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);
+
+  /* Indicate that we are only retrieving symbol values from this section.  */
+  void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);
+
+  /* Do a link based on the link_order structures attached to each
+     section of the BFD.  */
+  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);
+
+  /* Should this section be split up into smaller pieces during linking.  */
+  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);
+
+  /* Remove sections that are not referenced from the output.  */
+  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);
+
+  /* Attempt to merge SEC_MERGE sections.  */
+  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);
+
+  /* Is this section a member of a group?  */
+  bfd_boolean (*_bfd_is_group_section) (bfd *, const struct bfd_section *);
+
+  /* Discard members of a group.  */
+  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);
+
+  /* Check if SEC has been already linked during a reloceatable or
+     final link.  */
+  void (*_section_already_linked) (bfd *, struct bfd_section *,
+                                   struct bfd_link_info *);
+
+  /* Define a common symbol.  */
+  bfd_boolean (*_bfd_define_common_symbol) (bfd *, struct bfd_link_info *,
+                                            struct bfd_link_hash_entry *);
+
+  /* Routines to handle dynamic symbols and relocs.  */
+#define BFD_JUMP_TABLE_DYNAMIC(NAME) \
+  NAME##_get_dynamic_symtab_upper_bound, \
+  NAME##_canonicalize_dynamic_symtab, \
+  NAME##_get_synthetic_symtab, \
+  NAME##_get_dynamic_reloc_upper_bound, \
+  NAME##_canonicalize_dynamic_reloc
+
+  /* Get the amount of memory required to hold the dynamic symbols.  */
+  long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);
+  /* Read in the dynamic symbols.  */
+  long        (*_bfd_canonicalize_dynamic_symtab)
+    (bfd *, struct bfd_symbol **);
+  /* Create synthetized symbols.  */
+  long        (*_bfd_get_synthetic_symtab)
+    (bfd *, long, struct bfd_symbol **, long, struct bfd_symbol **,
+     struct bfd_symbol **);
+  /* Get the amount of memory required to hold the dynamic relocs.  */
+  long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);
+  /* Read in the dynamic relocs.  */
+  long        (*_bfd_canonicalize_dynamic_reloc)
+    (bfd *, arelent **, struct bfd_symbol **);
+
+  /* Opposite endian version of this target.  */
+  const struct bfd_target * alternative_target;
+
+  /* Data for use by back-end routines, which isn't
+     generic enough to belong in this structure.  */
+  const void *backend_data;
+
+} bfd_target;
+
+bfd_boolean bfd_set_default_target (const char *name);
+
+const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);
+
+const char ** bfd_target_list (void);
+
+const bfd_target *bfd_search_for_target
+   (int (*search_func) (const bfd_target *, void *),
+    void *);
+
+/* Extracted from format.c.  */
+bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);
+
+bfd_boolean bfd_check_format_matches
+   (bfd *abfd, bfd_format format, char ***matching);
+
+bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);
+
+const char *bfd_format_string (bfd_format format);
+
+/* Extracted from linker.c.  */
+bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);
+
+#define bfd_link_split_section(abfd, sec) \
+       BFD_SEND (abfd, _bfd_link_split_section, (abfd, sec))
+
+void bfd_section_already_linked (bfd *abfd, asection *sec,
+    struct bfd_link_info *info);
+
+#define bfd_section_already_linked(abfd, sec, info) \
+       BFD_SEND (abfd, _section_already_linked, (abfd, sec, info))
+
+bfd_boolean bfd_generic_define_common_symbol
+   (bfd *output_bfd, struct bfd_link_info *info,
+    struct bfd_link_hash_entry *h);
+
+#define bfd_define_common_symbol(output_bfd, info, h) \
+       BFD_SEND (output_bfd, _bfd_define_common_symbol, (output_bfd, info, h))
+
+struct bfd_elf_version_tree * bfd_find_version_for_sym
+   (struct bfd_elf_version_tree *verdefs,
+    const char *sym_name, bfd_boolean *hide);
+
+/* Extracted from simple.c.  */
+bfd_byte *bfd_simple_get_relocated_section_contents
+   (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);
+
+/* Extracted from compress.c.  */
+bfd_boolean bfd_uncompress_section_contents
+   (bfd_byte **buffer, bfd_size_type *size);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -urN binutils-2.20.1.old/bfd/coff-avr.c binutils-2.20.1/bfd/coff-avr.c
--- binutils-2.20.1.old/bfd/coff-avr.c	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/bfd/coff-avr.c	2010-04-13 09:47:42.121446028 -0500
@@ -0,0 +1,613 @@
+/* BFD back-end for Atmel AVR COFF files.
+   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001, 2003
+   Free Software Foundation, Inc.
+   Created mostly by substituting "avr" for "i860" in coff-i860.c
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+
+#include "coff/avr.h"
+
+#include "coff/internal.h"
+
+#include "libcoff.h"
+
+static bfd_reloc_status_type coff_avr_reloc
+  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
+static reloc_howto_type *coff_avr_rtype_to_howto
+  PARAMS ((bfd *, asection *, struct internal_reloc *,
+	   struct coff_link_hash_entry *, struct internal_syment *,
+	   bfd_vma *));
+static const bfd_target * coff_avr_object_p PARAMS ((bfd *));
+
+#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (2)
+/* The page size is a guess based on ELF.  */
+
+#define COFF_PAGE_SIZE 0x1000
+
+/* For some reason when using avr COFF the value stored in the .text
+   section for a reference to a common symbol is the value itself plus
+   any desired offset.  Ian Taylor, Cygnus Support.  */
+
+/* If we are producing relocateable output, we need to do some
+   adjustments to the object file that are not done by the
+   bfd_perform_relocation function.  This function is called by every
+   reloc type to make any required adjustments.  */
+
+static bfd_reloc_status_type
+coff_avr_reloc (abfd, reloc_entry, symbol, data, input_section, output_bfd,
+		 error_message)
+     bfd *abfd;
+     arelent *reloc_entry;
+     asymbol *symbol;
+     PTR data;
+     asection *input_section ATTRIBUTE_UNUSED;
+     bfd *output_bfd;
+     char **error_message ATTRIBUTE_UNUSED;
+{
+  symvalue diff;
+
+  if (output_bfd == (bfd *) NULL)
+    return bfd_reloc_continue;
+
+  if (bfd_is_com_section (symbol->section))
+    {
+      /* We are relocating a common symbol.  The current value in the
+	 object file is ORIG + OFFSET, where ORIG is the value of the
+	 common symbol as seen by the object file when it was compiled
+	 (this may be zero if the symbol was undefined) and OFFSET is
+	 the offset into the common symbol (normally zero, but may be
+	 non-zero when referring to a field in a common structure).
+	 ORIG is the negative of reloc_entry->addend, which is set by
+	 the CALC_ADDEND macro below.  We want to replace the value in
+	 the object file with NEW + OFFSET, where NEW is the value of
+	 the common symbol which we are going to put in the final
+	 object file.  NEW is symbol->value.  */
+      diff = symbol->value + reloc_entry->addend;
+    }
+  else
+    {
+      /* For some reason bfd_perform_relocation always effectively
+	 ignores the addend for a COFF target when producing
+	 relocateable output.  This seems to be always wrong for 860
+	 COFF, so we handle the addend here instead.  */
+      diff = reloc_entry->addend;
+    }
+
+#define DOIT(x) \
+  x = ((x & ~howto->dst_mask) | (((x & howto->src_mask) + diff) & howto->dst_mask))
+
+    if (diff != 0)
+      {
+	reloc_howto_type *howto = reloc_entry->howto;
+	unsigned char *addr = (unsigned char *) data + reloc_entry->address;
+
+	switch (howto->size)
+	  {
+	  case 0:
+	    {
+	      char x = bfd_get_8 (abfd, addr);
+	      DOIT (x);
+	      bfd_put_8 (abfd, x, addr);
+	    }
+	    break;
+
+	  case 1:
+	    {
+	      short x = bfd_get_16 (abfd, addr);
+	      DOIT (x);
+	      bfd_put_16 (abfd, (bfd_vma) x, addr);
+	    }
+	    break;
+
+	  case 2:
+	    {
+	      long x = bfd_get_32 (abfd, addr);
+	      DOIT (x);
+	      bfd_put_32 (abfd, (bfd_vma) x, addr);
+	    }
+	    break;
+
+	  default:
+	    abort ();
+	  }
+      }
+
+  /* Now let bfd_perform_relocation finish everything up.  */
+  return bfd_reloc_continue;
+}
+
+#ifndef PCRELOFFSET
+#define PCRELOFFSET FALSE
+#endif
+
+static reloc_howto_type howto_table[] =
+{
+  EMPTY_HOWTO (0),
+  EMPTY_HOWTO (1),
+  EMPTY_HOWTO (2),
+  EMPTY_HOWTO (3),
+  EMPTY_HOWTO (4),
+  EMPTY_HOWTO (5),
+  HOWTO (R_DIR32,               /* type */
+	 0,	                /* rightshift */
+	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
+	 32,	                /* bitsize */
+	 FALSE,	                /* pc_relative */
+	 0,	                /* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_avr_reloc,       /* special_function */
+	 "dir32",               /* name */
+	 TRUE,	                /* partial_inplace */
+	 0xffffffff,            /* src_mask */
+	 0xffffffff,            /* dst_mask */
+	 TRUE),                /* pcrel_offset */
+  /* {7}, */
+  HOWTO (R_IMAGEBASE,            /* type */
+	 0,	                /* rightshift */
+	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
+	 32,	                /* bitsize */
+	 FALSE,	                /* pc_relative */
+	 0,	                /* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_avr_reloc,       /* special_function */
+	 "rva32",	           /* name */
+	 TRUE,	                /* partial_inplace */
+	 0xffffffff,            /* src_mask */
+	 0xffffffff,            /* dst_mask */
+	 FALSE),                /* pcrel_offset */
+  EMPTY_HOWTO (010),
+  EMPTY_HOWTO (011),
+  EMPTY_HOWTO (012),
+  EMPTY_HOWTO (013),
+  EMPTY_HOWTO (014),
+  EMPTY_HOWTO (015),
+  EMPTY_HOWTO (016),
+  HOWTO (R_RELBYTE,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_avr_reloc,	/* special_function */
+	 "8",			/* name */
+	 TRUE,			/* partial_inplace */
+	 0x000000ff,		/* src_mask */
+	 0x000000ff,		/* dst_mask */
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_RELWORD,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_avr_reloc,	/* special_function */
+	 "16",			/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_RELLONG,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_avr_reloc,	/* special_function */
+	 "32",			/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_PCRBYTE,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 coff_avr_reloc,	/* special_function */
+	 "DISP8",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x000000ff,		/* src_mask */
+	 0x000000ff,		/* dst_mask */
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_PCRWORD,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 coff_avr_reloc,	/* special_function */
+	 "DISP16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_PCRLONG,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 coff_avr_reloc,	/* special_function */
+	 "DISP32",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 PCRELOFFSET)		/* pcrel_offset */
+};
+
+/* Turn a howto into a reloc  nunmber */
+
+#define SELECT_RELOC(x,howto) { x.r_type = howto->type; }
+#define BADMAG(x) AVRBADMAG(x)
+#define AVR 1			/* Customize coffcode.h */
+
+#define RTYPE2HOWTO(cache_ptr, dst) \
+	    (cache_ptr)->howto = howto_table + (dst)->r_type;
+
+/* For AVR COFF a STYP_NOLOAD | STYP_BSS section is part of a shared
+   library.  On some other COFF targets STYP_BSS is normally
+   STYP_NOLOAD.  */
+#define BSS_NOLOAD_IS_SHARED_LIBRARY
+
+/* Compute the addend of a reloc.  If the reloc is to a common symbol,
+   the object file contains the value of the common symbol.  By the
+   time this is called, the linker may be using a different symbol
+   from a different object file with a different value.  Therefore, we
+   hack wildly to locate the original symbol from this file so that we
+   can make the correct adjustment.  This macro sets coffsym to the
+   symbol from the original file, and uses it to set the addend value
+   correctly.  If this is not a common symbol, the usual addend
+   calculation is done, except that an additional tweak is needed for
+   PC relative relocs.
+   FIXME: This macro refers to symbols and asect; these are from the
+   calling function, not the macro arguments.  */
+
+#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)		\
+  {								\
+    coff_symbol_type *coffsym = (coff_symbol_type *) NULL;	\
+    if (ptr && bfd_asymbol_bfd (ptr) != abfd)			\
+      coffsym = (obj_symbols (abfd)				\
+	         + (cache_ptr->sym_ptr_ptr - symbols));		\
+    else if (ptr)						\
+      coffsym = coff_symbol_from (abfd, ptr);			\
+    if (coffsym != (coff_symbol_type *) NULL			\
+	&& coffsym->native->u.syment.n_scnum == 0)		\
+      cache_ptr->addend = - coffsym->native->u.syment.n_value;	\
+    else if (ptr && bfd_asymbol_bfd (ptr) == abfd		\
+	     && ptr->section != (asection *) NULL)		\
+      cache_ptr->addend = - (ptr->section->vma + ptr->value);	\
+    else							\
+      cache_ptr->addend = 0;					\
+    if (ptr && howto_table[reloc.r_type].pc_relative)		\
+      cache_ptr->addend += asect->vma;				\
+  }
+
+/* We use the special COFF backend linker.  */
+#define coff_relocate_section _bfd_coff_generic_relocate_section
+
+static reloc_howto_type *
+coff_avr_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     asection *sec;
+     struct internal_reloc *rel;
+     struct coff_link_hash_entry *h;
+     struct internal_syment *sym;
+     bfd_vma *addendp;
+{
+
+  reloc_howto_type *howto;
+
+  howto = howto_table + rel->r_type;
+
+  if (howto->pc_relative)
+    *addendp += sec->vma;
+
+  if (sym != NULL && sym->n_scnum == 0 && sym->n_value != 0)
+    {
+      /* This is a common symbol.  The section contents include the
+	 size (sym->n_value) as an addend.  The relocate_section
+	 function will be adding in the final value of the symbol.  We
+	 need to subtract out the current size in order to get the
+	 correct result.  */
+
+      BFD_ASSERT (h != NULL);
+
+      /* I think we *do* want to bypass this.  If we don't, I have seen some data
+	 parameters get the wrong relcation address.  If I link two versions
+	 with and without this section bypassed and then do a binary comparison,
+	 the addresses which are different can be looked up in the map.  The
+	 case in which this section has been bypassed has addresses which correspond
+	 to values I can find in the map.  */
+      *addendp -= sym->n_value;
+    }
+
+  /* If the output symbol is common (in which case this must be a
+     relocateable link), we need to add in the final size of the
+     common symbol.  */
+  if (h != NULL && h->root.type == bfd_link_hash_common)
+    *addendp += h->root.u.c.size;
+
+  return howto;
+}
+
+#define coff_rtype_to_howto coff_avr_rtype_to_howto
+
+#ifndef bfd_pe_print_pdata
+#define bfd_pe_print_pdata	NULL
+#endif
+
+#include "coffcode.h"
+
+static const bfd_target *
+coff_avr_object_p(a)
+     bfd *a;
+{
+  return coff_object_p (a);
+}
+
+/* Handle all the abominations of AVR COFF:
+
+   Generic COFF always uses the D1 slot to indicate the "most
+   important" derived type, and the D2...Dn slots for decreasing
+   importance.  E. g., a function symbol will always have its DT_FCN
+   element in D1, an array its DT_ARY (its first DT_ARY in a
+   multi-dimensional array).  In contrast, AVR COFF expects this most
+   important derived type specifier in the upmost Dn slot that is
+   allocated at all (i. e. that is != 0).
+
+   Generic COFF says that "Any symbol that satisfies more than one
+   condition [... for AUX entries] should have a union format in its
+   auxiliary entry."  AVR COFF uses sepearate AUX entries for multiple
+   derived types, and in some cases (like the ISFCN one), even puts
+   the most important one into the last allocated AUX entry.  We
+   join/split them here at the border as well.  Note that when
+   generating AUX entries (where we need to split them), the n_numaux
+   field must already have been set up properly (e. g. in
+   binutils/wrcoff.c) since the entry renumbering and pointerization
+   would not work otherwise.  Thus, we only split the information into
+   multiple records if n_numaux > 1.  For similar reasons, we keep
+   n_numaux > 1 on input to keep the appropriate AUX entries
+   allocated, so a symbol can be reconstructed if it is being passed
+   through one of the GNU tools.
+
+   Note that this adjustment is called after the symbol itself has
+   been swapped in, but before the AUX entries are swapped in.  This
+   is the only hook available that could swap (or merge) AUX entries
+   at all, so we have to operate on the external AUX entries still. */
+
+void
+avr_coff_adjust_sym_in_post (abfd, ext, in)
+     bfd *abfd;
+     PTR ext;
+     PTR in;
+{
+  struct internal_syment *dst = (struct internal_syment *)in;
+  unsigned short dt, bt, ndt;
+  dt = dst->n_type & ~N_BTMASK;
+  bt = BTYPE (dst->n_type);
+
+  /* Some AVR COFF producers seem to violate the COFF specs, and
+     produce symbols for tag names that have the C_FOO filled in
+     properly, but T_NULL as the base type value.  Patch up here,
+     since some of our generic COFF tools (in particular
+     binutils/rdcoff.c) rely on the correct data. */
+  if (bt == T_NULL)
+    switch (dst->n_sclass)
+      {
+      case C_STRTAG:
+	bt = T_STRUCT;
+	break;
+
+      case C_UNTAG:
+	bt = T_UNION;
+	break;
+
+      case C_ENTAG:
+	bt = T_ENUM;
+	break;
+      }
+
+  /* Swap the derived type slots. */
+  if (dt != 0)
+    {
+      ndt = 0;
+      while (dt != 0)
+	{
+	  ndt = (ndt << N_TSHIFT) | (dt & (N_TMASK >> N_BTSHFT));
+	  dt >>= N_TSHIFT;
+	}
+      dst->n_type = (ndt << N_BTSHFT) | bt;
+    }
+  else
+    dst->n_type = bt;
+
+  /* If the derived type is function, and there is more than one AUX
+     entry, swap the first and the last AUX entry, so the most
+     interesting one will become the first.
+
+     If the fundamental type is a tagged type (struct/union/enum), try
+     to find the AUX entry describing the tagged type (the one that
+     has x_sym.x_tagndx filled in), and merge the tag index into the
+     first AUX entry.  Depending on the actual input file, there might
+     be further DT_PTR entries which we just ignore, since we could
+     not handle that information anyway. */
+  if (dst->n_numaux > 1 && dst->n_sclass != C_FILE)
+    {
+      AUXENT caux, *auxp1, *auxp2;
+      size_t symesz;
+      unsigned int i;
+
+      symesz = bfd_coff_symesz (abfd);
+      i = dst->n_numaux;
+
+      auxp1 = (AUXENT *)((char *)ext + symesz);
+      auxp2 = (AUXENT *)((char *)ext + i * symesz);
+
+      if (ISFCN (dst->n_type)
+	  || (ISPTR(dst->n_type)
+	      && (bt == T_STRUCT || bt == T_UNION || bt == T_ENUM)))
+	{
+	  caux = *auxp2;
+	  *auxp2 = *auxp1;
+	  *auxp1 = caux;
+	}
+      else
+	caux = *auxp1;
+
+      if ((ISFCN (dst->n_type) || ISARY (dst->n_type))
+	  && (bt == T_STRUCT || bt == T_UNION || bt == T_ENUM))
+	{
+	  while (i > 1)
+	    {
+	      auxp2 = (AUXENT *)((char *)ext + i * symesz);
+
+	      if (auxp2->x_sym.x_tagndx[0] != 0 || auxp2->x_sym.x_tagndx[1] != 0
+		  || auxp2->x_sym.x_tagndx[2] != 0 || auxp2->x_sym.x_tagndx[3] != 0)
+		{
+		  memcpy (caux.x_sym.x_tagndx, auxp2->x_sym.x_tagndx,
+			  4 * sizeof (char));
+		  break;
+		}
+	      i--;
+	    }
+	  if (i > 1)
+	    *auxp1 = caux;
+	}
+    }
+}
+
+/* When exporting an AVR COFF file, just undo all that has been done
+   above.  Again, we are called after the symbol itself has been
+   swapped out, but before the AUX entries are being written.
+   Unfortunately, we are only given a pointer to the symbol itself, so
+   we have to derive the pointer to the respective aux entries from
+   that address, which is a bit clumsy. */
+void
+avr_coff_adjust_sym_out_post (abfd, in, ext)
+     bfd *abfd;
+     PTR in;
+     PTR ext;
+{
+  struct internal_syment *src = (struct internal_syment *)(in);
+  struct external_syment *dst = (struct external_syment *)(ext);
+  unsigned short dt, bt, ndt;
+
+  dt = src->n_type & ~N_BTMASK;
+  bt = BTYPE (src->n_type);
+
+  if (dt != 0)
+    {
+      ndt = 0;
+      while (dt != 0)
+	{
+	  ndt = (ndt << N_TSHIFT) | (dt & (N_TMASK >> N_BTSHFT));
+	  dt >>= N_TSHIFT;
+	}
+      H_PUT_16 (abfd, (ndt << N_BTSHFT) | bt, dst->e_type);
+    }
+
+  if (src->n_numaux > 1 && src->n_sclass != C_FILE)
+    {
+      combined_entry_type *srce, *dste;
+      char *hackp;
+      unsigned int i;
+
+      /* Recover the original combinend_entry_type *. */
+      hackp = (char *)in;
+      hackp -= offsetof(combined_entry_type, u.syment);
+      srce = (combined_entry_type *)hackp;
+      srce++;
+
+      /* We simply duplicate the first AUX entry as many times as
+	 needed.  Since COFF itself normally uses just a single AUX
+	 entry for all the information, this will work -- each COFF
+	 consumer will then just pick the fields it is particularly
+	 interested in.  This would not work for the AVR COFF specific
+	 DT_PTR AUX entries, but we don't support them anyway. */
+      for (i = 1; i < src->n_numaux; i++)
+	{
+	  dste = srce + i;
+	  *dste = *srce;
+	}
+    }
+}
+
+const bfd_target
+#ifdef TARGET_SYM
+  TARGET_SYM =
+#else
+  avrcoff_vec =
+#endif
+{
+#ifdef TARGET_NAME
+  TARGET_NAME,
+#else
+  "coff-avr",			/* name */
+#endif
+  bfd_target_coff_flavour,
+  BFD_ENDIAN_LITTLE,		/* data byte order is little */
+  BFD_ENDIAN_LITTLE,		/* header byte order is little */
+
+  (HAS_RELOC | EXEC_P |		/* object flags */
+   HAS_LINENO | HAS_DEBUG |
+   HAS_SYMS | HAS_LOCALS | WP_TEXT),
+
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
+  0,				/* leading char */
+  '/',				/* ar_pad_char */
+  15,				/* ar_max_namelen */
+
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */
+
+/* Note that we allow an object file to be treated as a core file as well.  */
+    {_bfd_dummy_target, coff_avr_object_p, /* bfd_check_format */
+       bfd_generic_archive_p, coff_avr_object_p},
+    {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
+       bfd_false},
+    {bfd_false, coff_write_object_contents, /* bfd_write_contents */
+       _bfd_write_archive_contents, bfd_false},
+
+     BFD_JUMP_TABLE_GENERIC (coff),
+     BFD_JUMP_TABLE_COPY (coff),
+     BFD_JUMP_TABLE_CORE (_bfd_nocore),
+     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
+     BFD_JUMP_TABLE_SYMBOLS (coff),
+     BFD_JUMP_TABLE_RELOCS (coff),
+     BFD_JUMP_TABLE_WRITE (coff),
+     BFD_JUMP_TABLE_LINK (coff),
+     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
+
+  NULL,
+
+  COFF_SWAP_TABLE
+};
diff -urN binutils-2.20.1.old/bfd/coff-ext-avr.c binutils-2.20.1/bfd/coff-ext-avr.c
--- binutils-2.20.1.old/bfd/coff-ext-avr.c	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/bfd/coff-ext-avr.c	2010-04-13 09:47:42.121446028 -0500
@@ -0,0 +1,428 @@
+/* BFD back-end for Atmel AVR "extended" COFF files.
+   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000, 2001, 2003
+   Free Software Foundation, Inc.
+   This is mostly the same as avr-coff, except of the presence of the
+   COFF optional header.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+
+#define AVR_EXT_COFF 1
+#include "coff/avr.h"
+
+#include "coff/internal.h"
+
+#include "libcoff.h"
+
+static bfd_reloc_status_type coff_ext_avr_reloc
+  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
+static reloc_howto_type *coff_ext_avr_rtype_to_howto
+  PARAMS ((bfd *, asection *, struct internal_reloc *,
+	   struct coff_link_hash_entry *, struct internal_syment *,
+	   bfd_vma *));
+static const bfd_target * coff_ext_avr_object_p PARAMS ((bfd *));
+
+#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (2)
+/* The page size is a guess based on ELF.  */
+
+#define COFF_PAGE_SIZE 0x1000
+
+/* For some reason when using avr COFF the value stored in the .text
+   section for a reference to a common symbol is the value itself plus
+   any desired offset.  Ian Taylor, Cygnus Support.  */
+
+/* If we are producing relocateable output, we need to do some
+   adjustments to the object file that are not done by the
+   bfd_perform_relocation function.  This function is called by every
+   reloc type to make any required adjustments.  */
+
+static bfd_reloc_status_type
+coff_ext_avr_reloc (abfd, reloc_entry, symbol, data, input_section, output_bfd,
+		 error_message)
+     bfd *abfd;
+     arelent *reloc_entry;
+     asymbol *symbol;
+     PTR data;
+     asection *input_section ATTRIBUTE_UNUSED;
+     bfd *output_bfd;
+     char **error_message ATTRIBUTE_UNUSED;
+{
+  symvalue diff;
+
+  if (output_bfd == (bfd *) NULL)
+    return bfd_reloc_continue;
+
+  if (bfd_is_com_section (symbol->section))
+    {
+      /* We are relocating a common symbol.  The current value in the
+	 object file is ORIG + OFFSET, where ORIG is the value of the
+	 common symbol as seen by the object file when it was compiled
+	 (this may be zero if the symbol was undefined) and OFFSET is
+	 the offset into the common symbol (normally zero, but may be
+	 non-zero when referring to a field in a common structure).
+	 ORIG is the negative of reloc_entry->addend, which is set by
+	 the CALC_ADDEND macro below.  We want to replace the value in
+	 the object file with NEW + OFFSET, where NEW is the value of
+	 the common symbol which we are going to put in the final
+	 object file.  NEW is symbol->value.  */
+      diff = symbol->value + reloc_entry->addend;
+    }
+  else
+    {
+      /* For some reason bfd_perform_relocation always effectively
+	 ignores the addend for a COFF target when producing
+	 relocateable output.  This seems to be always wrong for 860
+	 COFF, so we handle the addend here instead.  */
+      diff = reloc_entry->addend;
+    }
+
+#define DOIT(x) \
+  x = ((x & ~howto->dst_mask) | (((x & howto->src_mask) + diff) & howto->dst_mask))
+
+    if (diff != 0)
+      {
+	reloc_howto_type *howto = reloc_entry->howto;
+	unsigned char *addr = (unsigned char *) data + reloc_entry->address;
+
+	switch (howto->size)
+	  {
+	  case 0:
+	    {
+	      char x = bfd_get_8 (abfd, addr);
+	      DOIT (x);
+	      bfd_put_8 (abfd, x, addr);
+	    }
+	    break;
+
+	  case 1:
+	    {
+	      short x = bfd_get_16 (abfd, addr);
+	      DOIT (x);
+	      bfd_put_16 (abfd, (bfd_vma) x, addr);
+	    }
+	    break;
+
+	  case 2:
+	    {
+	      long x = bfd_get_32 (abfd, addr);
+	      DOIT (x);
+	      bfd_put_32 (abfd, (bfd_vma) x, addr);
+	    }
+	    break;
+
+	  default:
+	    abort ();
+	  }
+      }
+
+  /* Now let bfd_perform_relocation finish everything up.  */
+  return bfd_reloc_continue;
+}
+
+#ifndef PCRELOFFSET
+#define PCRELOFFSET FALSE
+#endif
+
+static reloc_howto_type howto_table[] =
+{
+  EMPTY_HOWTO (0),
+  EMPTY_HOWTO (1),
+  EMPTY_HOWTO (2),
+  EMPTY_HOWTO (3),
+  EMPTY_HOWTO (4),
+  EMPTY_HOWTO (5),
+  HOWTO (R_DIR32,               /* type */
+	 0,	                /* rightshift */
+	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
+	 32,	                /* bitsize */
+	 FALSE,	                /* pc_relative */
+	 0,	                /* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_ext_avr_reloc,       /* special_function */
+	 "dir32",               /* name */
+	 TRUE,	                /* partial_inplace */
+	 0xffffffff,            /* src_mask */
+	 0xffffffff,            /* dst_mask */
+	 TRUE),                /* pcrel_offset */
+  /* {7}, */
+  HOWTO (R_IMAGEBASE,            /* type */
+	 0,	                /* rightshift */
+	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
+	 32,	                /* bitsize */
+	 FALSE,	                /* pc_relative */
+	 0,	                /* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_ext_avr_reloc,       /* special_function */
+	 "rva32",	           /* name */
+	 TRUE,	                /* partial_inplace */
+	 0xffffffff,            /* src_mask */
+	 0xffffffff,            /* dst_mask */
+	 FALSE),                /* pcrel_offset */
+  EMPTY_HOWTO (010),
+  EMPTY_HOWTO (011),
+  EMPTY_HOWTO (012),
+  EMPTY_HOWTO (013),
+  EMPTY_HOWTO (014),
+  EMPTY_HOWTO (015),
+  EMPTY_HOWTO (016),
+  HOWTO (R_RELBYTE,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_ext_avr_reloc,	/* special_function */
+	 "8",			/* name */
+	 TRUE,			/* partial_inplace */
+	 0x000000ff,		/* src_mask */
+	 0x000000ff,		/* dst_mask */
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_RELWORD,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_ext_avr_reloc,	/* special_function */
+	 "16",			/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_RELLONG,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 coff_ext_avr_reloc,	/* special_function */
+	 "32",			/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_PCRBYTE,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 coff_ext_avr_reloc,	/* special_function */
+	 "DISP8",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x000000ff,		/* src_mask */
+	 0x000000ff,		/* dst_mask */
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_PCRWORD,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 coff_ext_avr_reloc,	/* special_function */
+	 "DISP16",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0x0000ffff,		/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 PCRELOFFSET),		/* pcrel_offset */
+  HOWTO (R_PCRLONG,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 coff_ext_avr_reloc,	/* special_function */
+	 "DISP32",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 PCRELOFFSET)		/* pcrel_offset */
+};
+
+/* Turn a howto into a reloc  nunmber */
+
+#define SELECT_RELOC(x,howto) { x.r_type = howto->type; }
+#define BADMAG(x) AVRBADMAG(x)
+#define AVR 1			/* Customize coffcode.h */
+
+#define RTYPE2HOWTO(cache_ptr, dst) \
+	    (cache_ptr)->howto = howto_table + (dst)->r_type;
+
+/* For AVR COFF a STYP_NOLOAD | STYP_BSS section is part of a shared
+   library.  On some other COFF targets STYP_BSS is normally
+   STYP_NOLOAD.  */
+#define BSS_NOLOAD_IS_SHARED_LIBRARY
+
+/* Compute the addend of a reloc.  If the reloc is to a common symbol,
+   the object file contains the value of the common symbol.  By the
+   time this is called, the linker may be using a different symbol
+   from a different object file with a different value.  Therefore, we
+   hack wildly to locate the original symbol from this file so that we
+   can make the correct adjustment.  This macro sets coffsym to the
+   symbol from the original file, and uses it to set the addend value
+   correctly.  If this is not a common symbol, the usual addend
+   calculation is done, except that an additional tweak is needed for
+   PC relative relocs.
+   FIXME: This macro refers to symbols and asect; these are from the
+   calling function, not the macro arguments.  */
+
+#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)		\
+  {								\
+    coff_symbol_type *coffsym = (coff_symbol_type *) NULL;	\
+    if (ptr && bfd_asymbol_bfd (ptr) != abfd)			\
+      coffsym = (obj_symbols (abfd)				\
+	         + (cache_ptr->sym_ptr_ptr - symbols));		\
+    else if (ptr)						\
+      coffsym = coff_symbol_from (abfd, ptr);			\
+    if (coffsym != (coff_symbol_type *) NULL			\
+	&& coffsym->native->u.syment.n_scnum == 0)		\
+      cache_ptr->addend = - coffsym->native->u.syment.n_value;	\
+    else if (ptr && bfd_asymbol_bfd (ptr) == abfd		\
+	     && ptr->section != (asection *) NULL)		\
+      cache_ptr->addend = - (ptr->section->vma + ptr->value);	\
+    else							\
+      cache_ptr->addend = 0;					\
+    if (ptr && howto_table[reloc.r_type].pc_relative)		\
+      cache_ptr->addend += asect->vma;				\
+  }
+
+/* We use the special COFF backend linker.  */
+#define coff_relocate_section _bfd_coff_generic_relocate_section
+
+static reloc_howto_type *
+coff_ext_avr_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     asection *sec;
+     struct internal_reloc *rel;
+     struct coff_link_hash_entry *h;
+     struct internal_syment *sym;
+     bfd_vma *addendp;
+{
+
+  reloc_howto_type *howto;
+
+  howto = howto_table + rel->r_type;
+
+  if (howto->pc_relative)
+    *addendp += sec->vma;
+
+  if (sym != NULL && sym->n_scnum == 0 && sym->n_value != 0)
+    {
+      /* This is a common symbol.  The section contents include the
+	 size (sym->n_value) as an addend.  The relocate_section
+	 function will be adding in the final value of the symbol.  We
+	 need to subtract out the current size in order to get the
+	 correct result.  */
+
+      BFD_ASSERT (h != NULL);
+
+      /* I think we *do* want to bypass this.  If we don't, I have seen some data
+	 parameters get the wrong relcation address.  If I link two versions
+	 with and without this section bypassed and then do a binary comparison,
+	 the addresses which are different can be looked up in the map.  The
+	 case in which this section has been bypassed has addresses which correspond
+	 to values I can find in the map.  */
+      *addendp -= sym->n_value;
+    }
+
+  /* If the output symbol is common (in which case this must be a
+     relocateable link), we need to add in the final size of the
+     common symbol.  */
+  if (h != NULL && h->root.type == bfd_link_hash_common)
+    *addendp += h->root.u.c.size;
+
+  return howto;
+}
+
+#define coff_rtype_to_howto coff_ext_avr_rtype_to_howto
+
+#ifndef bfd_pe_print_pdata
+#define bfd_pe_print_pdata	NULL
+#endif
+
+#include "coffcode.h"
+
+static const bfd_target *
+coff_ext_avr_object_p(a)
+     bfd *a;
+{
+  return coff_object_p (a);
+}
+
+const bfd_target
+#ifdef TARGET_SYM
+  TARGET_SYM =
+#else
+  avrextcoff_vec =
+#endif
+{
+#ifdef TARGET_NAME
+  TARGET_NAME,
+#else
+  "coff-ext-avr",			/* name */
+#endif
+  bfd_target_coff_flavour,
+  BFD_ENDIAN_LITTLE,		/* data byte order is little */
+  BFD_ENDIAN_LITTLE,		/* header byte order is little */
+
+  (HAS_RELOC | EXEC_P |		/* object flags */
+   HAS_LINENO | HAS_DEBUG |
+   HAS_SYMS | HAS_LOCALS | WP_TEXT),
+
+  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
+  0,				/* leading char */
+  '/',				/* ar_pad_char */
+  15,				/* ar_max_namelen */
+
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */
+  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
+     bfd_getl32, bfd_getl_signed_32, bfd_putl32,
+     bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */
+
+/* Note that we allow an object file to be treated as a core file as well.  */
+    {_bfd_dummy_target, coff_ext_avr_object_p, /* bfd_check_format */
+       bfd_generic_archive_p, coff_ext_avr_object_p},
+    {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
+       bfd_false},
+    {bfd_false, coff_write_object_contents, /* bfd_write_contents */
+       _bfd_write_archive_contents, bfd_false},
+
+     BFD_JUMP_TABLE_GENERIC (coff),
+     BFD_JUMP_TABLE_COPY (coff),
+     BFD_JUMP_TABLE_CORE (_bfd_nocore),
+     BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
+     BFD_JUMP_TABLE_SYMBOLS (coff),
+     BFD_JUMP_TABLE_RELOCS (coff),
+     BFD_JUMP_TABLE_WRITE (coff),
+     BFD_JUMP_TABLE_LINK (coff),
+     BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
+
+  NULL,
+
+  COFF_SWAP_TABLE
+};
diff -urN binutils-2.20.1.old/bfd/cpu-avr.c binutils-2.20.1/bfd/cpu-avr.c
--- binutils-2.20.1.old/bfd/cpu-avr.c	2009-09-02 02:18:36.000000000 -0500
+++ binutils-2.20.1/bfd/cpu-avr.c	2010-04-13 09:49:42.337948099 -0500
@@ -133,7 +133,29 @@
   N (22, bfd_mach_avr51, "avr:51", FALSE, & arch_info_struct[9]),
 
   /* 3-Byte PC.  */
-  N (22, bfd_mach_avr6, "avr:6", FALSE, NULL)
+  N (22, bfd_mach_avr6, "avr:6", FALSE, & arch_info_struct[10]),
+  
+  /* Xmega 1 */
+  N (24, bfd_mach_avrxmega1, "avr:101", FALSE, & arch_info_struct[11]),
+
+  /* Xmega 2 */
+  N (24, bfd_mach_avrxmega2, "avr:102", FALSE, & arch_info_struct[12]),
+  
+  /* Xmega 3 */
+  N (24, bfd_mach_avrxmega3, "avr:103", FALSE, & arch_info_struct[13]),
+  
+  /* Xmega 4 */
+  N (24, bfd_mach_avrxmega4, "avr:104", FALSE, & arch_info_struct[14]),
+  
+  /* Xmega 5 */
+  N (24, bfd_mach_avrxmega5, "avr:105", FALSE, & arch_info_struct[15]),
+  
+  /* Xmega 6 */
+  N (24, bfd_mach_avrxmega6, "avr:106", FALSE, & arch_info_struct[16]),
+  
+  /* Xmega 7 */
+  N (24, bfd_mach_avrxmega7, "avr:107", FALSE, NULL)
+  
 };
 
 const bfd_arch_info_type bfd_avr_arch =
diff -urN binutils-2.20.1.old/bfd/cpu-avr.c.orig binutils-2.20.1/bfd/cpu-avr.c.orig
--- binutils-2.20.1.old/bfd/cpu-avr.c.orig	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/bfd/cpu-avr.c.orig	2009-09-02 02:18:36.000000000 -0500
@@ -0,0 +1,140 @@
+/* BFD library support routines for the AVR architecture.
+   Copyright 1999, 2000, 2002, 2005, 2006, 2007, 2008
+   Free Software Foundation, Inc.
+   Contributed by Denis Chertykov <denisc@overta.ru>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+/* This routine is provided two arch_infos and works out which AVR
+   machine which would be compatible with both and returns a pointer
+   to its info structure.  */
+
+static const bfd_arch_info_type *
+compatible (const bfd_arch_info_type * a,
+	    const bfd_arch_info_type * b)
+{
+  /* If a & b are for different architectures we can do nothing.  */
+  if (a->arch != b->arch)
+    return NULL;
+
+  if (a->mach == b->mach)
+    return a;
+
+  /* avr-6 is compatible only with itself as its call convention is not
+     compatible with other avr (the mcu saves the return address on 3 bytes
+     instead of 2).  */
+  if (a->mach == bfd_mach_avr6 || b->mach == bfd_mach_avr6)
+    return NULL;
+
+  if (a->mach < bfd_mach_avr6 && b->mach < bfd_mach_avr6)
+    {
+      /* Special case for ATmega[16]03 (avr:3) and ATmega83 (avr:4).  */
+      if ((a->mach == bfd_mach_avr3 && b->mach == bfd_mach_avr4)
+         || (a->mach == bfd_mach_avr4 && b->mach == bfd_mach_avr3))
+       return NULL;
+
+      if (a->mach <= b->mach)
+       return b;
+       
+      if (a->mach >= b->mach)
+       return a;
+    }
+
+  if (a->mach == bfd_mach_avr2 && b->mach == bfd_mach_avr25)
+    return a;
+  if (a->mach == bfd_mach_avr25 && b->mach == bfd_mach_avr2)
+    return b;
+    
+  if (a->mach == bfd_mach_avr3 && b->mach == bfd_mach_avr31)
+    return a;
+  if (a->mach == bfd_mach_avr31 && b->mach == bfd_mach_avr3)
+    return b;
+
+  if (a->mach == bfd_mach_avr3 && b->mach == bfd_mach_avr35)
+    return a;
+  if (a->mach == bfd_mach_avr35 && b->mach == bfd_mach_avr3)
+    return b;
+
+  if (a->mach == bfd_mach_avr5 && b->mach == bfd_mach_avr51)
+    return a;
+  if (a->mach == bfd_mach_avr51 && b->mach == bfd_mach_avr5)
+    return b;
+
+
+  return NULL;
+}
+
+#define N(addr_bits, machine, print, default, next)		\
+{								\
+  8,				/* 8 bits in a word.  */	\
+  addr_bits,			/* bits in an address.  */	\
+  8,				/* 8 bits in a byte.  */	\
+  bfd_arch_avr,							\
+  machine,			/* Machine number.  */		\
+  "avr",			/* Architecture name.   */	\
+  print,			/* Printable name.  */		\
+  1,				/* Section align power.  */	\
+  default,			/* Is this the default ?  */	\
+  compatible,							\
+  bfd_default_scan,						\
+  next								\
+}
+
+static const bfd_arch_info_type arch_info_struct[] =
+{
+  /* Assembler only.  */
+  N (16, bfd_mach_avr1, "avr:1", FALSE, & arch_info_struct[1]),
+
+  /* Classic, <= 8K.  */
+  N (16, bfd_mach_avr2, "avr:2", FALSE, & arch_info_struct[2]),
+
+  /* Classic + MOVW, <= 8K.  */
+  N (16, bfd_mach_avr25, "avr:25", FALSE, & arch_info_struct[3]),
+
+  /* Classic, > 8K, <= 64K.  */
+  /* TODO:  addr_bits should be 16, but set to 22 for some following 
+     version of GCC (from 4.3) for backward compatibility.  */
+  N (22, bfd_mach_avr3, "avr:3", FALSE, & arch_info_struct[4]),
+
+  /* Classic, == 128K.  */
+  N (22, bfd_mach_avr31, "avr:31", FALSE, & arch_info_struct[5]),
+
+  /* Classic + MOVW + JMP/CALL, > 8K, <= 64K. */
+  N (16, bfd_mach_avr35, "avr:35", FALSE, & arch_info_struct[6]),
+
+  /* Enhanced, <= 8K.  */
+  N (16, bfd_mach_avr4, "avr:4", FALSE, & arch_info_struct[7]),
+
+  /* Enhanced, > 8K, <= 64K.  */
+  /* TODO:  addr_bits should be 16, but set to 22 for some following 
+     version of GCC (from 4.3) for backward compatibility.  */
+  N (22, bfd_mach_avr5, "avr:5", FALSE, & arch_info_struct[8]),
+  
+  /* Enhanced, == 128K.  */
+  N (22, bfd_mach_avr51, "avr:51", FALSE, & arch_info_struct[9]),
+
+  /* 3-Byte PC.  */
+  N (22, bfd_mach_avr6, "avr:6", FALSE, NULL)
+};
+
+const bfd_arch_info_type bfd_avr_arch =
+  N (16, bfd_mach_avr2, "avr", TRUE, & arch_info_struct[0]);
diff -urN binutils-2.20.1.old/bfd/elf32-avr.c binutils-2.20.1/bfd/elf32-avr.c
--- binutils-2.20.1.old/bfd/elf32-avr.c	2009-09-02 02:18:36.000000000 -0500
+++ binutils-2.20.1/bfd/elf32-avr.c	2010-04-13 09:49:42.337948099 -0500
@@ -1328,6 +1328,34 @@
     case bfd_mach_avr6:
       val = E_AVR_MACH_AVR6;
       break;
+
+    case bfd_mach_avrxmega1:
+      val = E_AVR_MACH_XMEGA1;
+      break;
+
+    case bfd_mach_avrxmega2:
+      val = E_AVR_MACH_XMEGA2;
+      break;
+
+    case bfd_mach_avrxmega3:
+      val = E_AVR_MACH_XMEGA3;
+      break;
+
+    case bfd_mach_avrxmega4:
+      val = E_AVR_MACH_XMEGA4;
+      break;
+
+    case bfd_mach_avrxmega5:
+      val = E_AVR_MACH_XMEGA5;
+      break;
+
+    case bfd_mach_avrxmega6:
+      val = E_AVR_MACH_XMEGA6;
+      break;
+
+    case bfd_mach_avrxmega7:
+      val = E_AVR_MACH_XMEGA7;
+      break;
     }
 
   elf_elfheader (abfd)->e_machine = EM_AVR;
@@ -1390,6 +1418,34 @@
 	case E_AVR_MACH_AVR6:
 	  e_set = bfd_mach_avr6;
 	  break;
+
+	case E_AVR_MACH_XMEGA1:
+	  e_set = bfd_mach_avrxmega1;
+	  break;
+
+	case E_AVR_MACH_XMEGA2:
+	  e_set = bfd_mach_avrxmega2;
+	  break;
+
+	case E_AVR_MACH_XMEGA3:
+	  e_set = bfd_mach_avrxmega3;
+	  break;
+
+	case E_AVR_MACH_XMEGA4:
+	  e_set = bfd_mach_avrxmega4;
+	  break;
+
+	case E_AVR_MACH_XMEGA5:
+	  e_set = bfd_mach_avrxmega5;
+	  break;
+
+	case E_AVR_MACH_XMEGA6:
+	  e_set = bfd_mach_avrxmega6;
+	  break;
+
+	case E_AVR_MACH_XMEGA7:
+	  e_set = bfd_mach_avrxmega7;
+	  break;
 	}
     }
   return bfd_default_set_arch_mach (abfd, bfd_arch_avr,
diff -urN binutils-2.20.1.old/binutils/wrcoff.c binutils-2.20.1/binutils/wrcoff.c
--- binutils-2.20.1.old/binutils/wrcoff.c	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/binutils/wrcoff.c	2010-04-13 09:47:42.141946953 -0500
@@ -0,0 +1,3410 @@
+/* wrcoff.c -- Generate (AVR) COFF debugging information
+   Copyright 2003 Free Software Foundation, Inc.
+
+   Written by Joerg Wunsch.
+
+   This file is part of GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+/* This file contains code which writes out COFF debugging
+   information.  By now, this has only been tested on the AVR
+   platform, though any attempt has been made to keep the conversion
+   applicable to possible other COFF debugging consumers as well. */
+
+#include <stdio.h>
+#include <assert.h>
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "coff/internal.h"
+#include "bucomm.h"
+#include "libiberty.h"
+#include "safe-ctype.h"
+#include "debug.h"
+#include "budbg.h"
+
+/* Enabling COFF_DEBUG will trace the internal callback functions and
+   their parameters as debug_write() calls them. */
+//#define COFF_DEBUG 1
+
+#include "libcoff.h"
+
+#define N_TMASK (coff_data (info->abfd)->local_n_tmask)
+#define N_BTSHFT (coff_data (info->abfd)->local_n_btshft)
+#define N_BTMASK (coff_data (info->abfd)->local_n_btmask)
+#define N_TSHIFT (coff_data (info->abfd)->local_n_tshift)
+
+/* Structure of local symbols per compilation unit. */
+struct coff_compilation_unit
+{
+  const char *fname;
+  asymbol **syms;
+  long nsyms, totsyms;
+};
+
+enum ts_kind
+{
+  TS_EMPTY,
+  TS_VOID,
+  TS_INT,
+  TS_FLOAT,
+  TS_COMPLEX,
+  TS_ENUM,
+  TS_POINTER,
+  TS_FUNC,
+  TS_ARRAY,
+  TS_STRUCT,
+  TS_NONE = -1
+};
+
+/* Structure defining the pre-defined types. */
+struct coff_predef_type
+{
+  enum ts_kind kind;
+  unsigned int size;		/* in bytes */
+  bfd_boolean isunsigned;
+  int slot;
+};
+
+struct coff_type_stack;
+struct coff_hash_entry;
+
+struct coff_struct_fields
+{
+  const char *name;
+  bfd_vma bitpos;
+  bfd_vma bitsize;
+  enum debug_visibility visibility;
+  struct coff_type_stack *types;
+};
+
+/* Our type stack. */
+struct coff_type_stack
+{
+  struct coff_type_stack *next;
+  enum ts_kind tsk;
+  union
+  {
+    /* TS_INT */
+    struct
+    {
+      unsigned int size;
+      bfd_boolean isunsigned;
+    }
+    ts_int;
+
+    /* TS_FLOAT */
+    struct
+    {
+      unsigned int size;
+    }
+    ts_float;
+
+    /* TS_ENUM */
+    struct
+    {
+      union
+      {
+	const char *fixtag;
+	char *malloctag;
+      }
+      tag;
+      bfd_boolean tagismalloced;
+      const char **names;
+      bfd_signed_vma *vals;
+      struct coff_enum_hash_entry *ehash;
+    }
+    ts_enum;
+
+    /* TS_FUNC */
+    struct
+    {
+      struct coff_type_stack *savedts;
+    }
+    ts_func;
+
+    /* TS_ARRAY */
+    struct
+    {
+      bfd_signed_vma low;
+      bfd_signed_vma high;
+    }
+    ts_array;
+
+    /* TS_STRUCT */
+    struct
+    {
+      union
+      {
+	const char *fixtag;
+	char *malloctag;
+      }
+      tag;
+      bfd_boolean tagismalloced;
+      unsigned int id;
+      bfd_boolean isstruct;
+      unsigned int size;
+      long nfields;
+      struct coff_struct_fields *fields;
+      struct coff_type_stack *savedts;
+      struct coff_struct_hash_entry *shash;
+    }
+    ts_struct;
+  }
+  u;
+};
+
+struct coff_name_type_hash_table
+{
+  struct bfd_hash_table root;
+};
+
+struct coff_name_type_hash_entry
+{
+  struct bfd_hash_entry root;
+  /* Information for this name.  */
+  struct coff_type_stack *types;
+  bfd_boolean emitted;
+};
+
+struct coff_struct_hash_table
+{
+  struct bfd_hash_table root;
+};
+
+struct coff_struct_hash_entry
+{
+  struct bfd_hash_entry root;
+  /* Information for this name.  */
+  struct coff_type_stack *types;
+  bfd_boolean emitted;
+  combined_entry_type *native;
+  /* list of symbol indices that need fixing */
+  long *fixidxs;
+  unsigned nfixidxs;
+};
+
+struct coff_enum_hash_table
+{
+  struct bfd_hash_table root;
+};
+
+struct coff_enum_hash_entry
+{
+  struct bfd_hash_entry root;
+  /* Information for this name.  */
+  struct coff_type_stack *types;
+  bfd_boolean emitted;
+  combined_entry_type *native;
+  /* list of symbol indices that need fixing */
+  long *fixidxs;
+  unsigned nfixidxs;
+};
+
+/* COFF private symbol data.  Used as a cookie to pass data around
+   between various processing stages.  The generic COFF handling code
+   doesn't use any private data. */
+struct coff_private_symdata
+{
+  unsigned int size;		/* size of symbol, used in AVR register
+				   translation */
+  struct coff_struct_hash_entry *shash; /* TS_STRUCT hash for fixups */
+  struct coff_enum_hash_entry *ehash; /* TS_ENUM hash for fixups */
+};
+
+/* Stack of tags that need endndx fixing. */
+struct coff_fix_stack
+{
+  struct coff_fix_stack *next;
+  combined_entry_type *native;
+};
+
+/* This is the handle passed through debug_write.  */
+
+struct coff_write_handle
+{
+  /* The BFD.  */
+  bfd *abfd;
+  /* Pointers to .text and .data sections, can be used as defaults if
+     no other information is available. */
+  asection *textsect;
+  asection *datasect;
+  /* Some special flags. */
+  unsigned long flags;
+  /* Flags describing architecture options. */
+#define COFF_FL_AVR	0x0001	/* COFF is for AVR platform. */
+#define COFF_FL_EXT_AVR	0x0002	/* AVR "extended" COFF */
+  /* Flags describing internal status information. */
+#define COFF_FL_FIX_ENDNDX	0x10000	/* apply endndx fix at next symbol */
+#define COFF_FL_START_FCN	0x20000	/* begin of function pending */
+#define COFF_FL_FIX_BB		0x40000	/* fix last ".bb" symbol */
+  /* List of our compilation units, from input symbol table. */
+  struct coff_compilation_unit *units;
+  long nunits;
+  struct coff_compilation_unit *currentfile;
+  /* Global symbols from input symbol table. */
+  asymbol **globals;
+  long nglobals;
+  /* Section syms for named sections. */
+  coff_symbol_type **secsyms;
+  long nsecsyms;
+  /* Our COFF symbols. */
+  asymbol **syms;
+  long nsyms;
+  /* Total line number count. */
+  unsigned long totlnos;
+  /* Size of standard objects on this arch. */
+  unsigned int pointersize;
+  unsigned int enumsize;
+  /* Pending information when starting a function.  We have to defer
+     almost everything, some actions can be taken when seeing the
+     starting block of that function, some will even have to wait
+     until we see the end of the function. */
+  const char *funname;		/* name of function */
+  bfd_boolean funglobal;		/* global/local function? */
+  unsigned int lastlno;		/* last line number seen so far */
+  long funcindex;		/* index of ".func" symbol in syms */
+  unsigned int nlnos;		/* line numbers recorded for this function*/
+  bfd_vma endaddr;		/* last .eb address we have seen so far */
+  unsigned int funlno;		/* first line number in function */
+  coff_symbol_type **fargs;	/* function arguments */
+  unsigned int nfargs;
+  asection *funcsection;	/* section the current function is using */
+  /* Type information */
+  struct coff_type_stack *tstack;
+  struct coff_name_type_hash_table types;
+  struct coff_struct_hash_table structs;
+  struct coff_enum_hash_table enums;
+  unsigned nenums;		/* counter for anonymous enum tags */
+  /* Stack of pending endndx fixes, see coff_record_symbol(). */
+  struct coff_fix_stack *fixes;
+};
+
+/* Predefined types, default to usual 32-bit architectures.
+   Arch-dependant different byte sizes will be tuned upon entering
+   write_coff_debugging_info().  The table is looked up from front to
+   end, so we put `more popular' types that might have the same size
+   as other types first (e. g. "int" precedes "long" and "short"). */
+static struct coff_predef_type coff_predef_types[] =
+{
+  { TS_INT, 4, FALSE, 4 },	/* signed int */
+  { TS_INT, 1, FALSE, 2 },	/* signed char */
+  { TS_INT, 2, FALSE, 3 },	/* signed short */
+  { TS_INT, 4, FALSE, 5 },	/* long int */
+  { TS_FLOAT, 8, FALSE, 7 },	/* double */
+  { TS_FLOAT, 4, FALSE, 6 },	/* float */
+  { TS_INT, 4, TRUE, 14 },	/* unsigned int */
+  { TS_INT, 1, TRUE, 12 },	/* unsigned char */
+  { TS_INT, 2, TRUE, 13 },	/* unsigned short */
+  { TS_INT, 4, TRUE, 15 },	/* unsigned long */
+};
+
+static bfd_boolean coff_copy_symbols
+  PARAMS ((struct coff_write_handle *, long, asymbol **));
+static asymbol *coff_find_symbol
+  PARAMS ((struct coff_write_handle *, const char *, bfd_boolean, bfd_boolean));
+static void coff_record_symbol
+  PARAMS ((struct coff_write_handle *, coff_symbol_type *));
+static symvalue coff_fixup_avr_register PARAMS ((symvalue, int));
+static struct bfd_hash_entry *coff_name_type_newfunc
+  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
+static bfd_boolean coff_free_type_info
+  PARAMS ((struct coff_name_type_hash_entry *, PTR));
+static struct bfd_hash_entry *coff_struct_newfunc
+  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
+static bfd_boolean coff_free_struct_info
+  PARAMS ((struct coff_struct_hash_entry *, PTR));
+static struct bfd_hash_entry *coff_enum_newfunc
+  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
+static bfd_boolean coff_free_enum_info
+  PARAMS ((struct coff_enum_hash_entry *, PTR));
+static unsigned int coff_get_fundamental_type
+  PARAMS ((struct coff_write_handle *, struct coff_type_stack *));
+static bfd_boolean coff_make_typed_symbol
+  PARAMS ((struct coff_write_handle *, coff_symbol_type **, enum ts_kind));
+static bfd_boolean coff_emit_struct
+  PARAMS ((struct coff_write_handle *, struct coff_type_stack *,
+	   struct coff_struct_hash_entry *));
+static bfd_boolean coff_emit_enum
+  PARAMS ((struct coff_write_handle *, struct coff_type_stack *,
+	   struct coff_enum_hash_entry *));
+static bfd_boolean coff_emit_ndebug_sym
+  PARAMS ((struct coff_write_handle *, asymbol *, bfd_boolean));
+
+static bfd_boolean coff_start_compilation_unit PARAMS ((PTR, const char *));
+static bfd_boolean coff_start_source PARAMS ((PTR, const char *));
+static bfd_boolean coff_empty_type PARAMS ((PTR));
+static bfd_boolean coff_void_type PARAMS ((PTR));
+static bfd_boolean coff_int_type PARAMS ((PTR, unsigned int, bfd_boolean));
+static bfd_boolean coff_float_type PARAMS ((PTR, unsigned int));
+static bfd_boolean coff_complex_type PARAMS ((PTR, unsigned int));
+static bfd_boolean coff_bool_type PARAMS ((PTR, unsigned int));
+static bfd_boolean coff_enum_type
+  PARAMS ((PTR, const char *, const char **, bfd_signed_vma *));
+static bfd_boolean coff_pointer_type PARAMS ((PTR));
+static bfd_boolean coff_function_type PARAMS ((PTR, int, bfd_boolean));
+static bfd_boolean coff_reference_type PARAMS ((PTR));
+static bfd_boolean coff_range_type PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
+static bfd_boolean coff_array_type
+  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, bfd_boolean));
+static bfd_boolean coff_set_type PARAMS ((PTR, bfd_boolean));
+static bfd_boolean coff_offset_type PARAMS ((PTR));
+static bfd_boolean coff_method_type PARAMS ((PTR, bfd_boolean, int, bfd_boolean));
+static bfd_boolean coff_const_type PARAMS ((PTR));
+static bfd_boolean coff_volatile_type PARAMS ((PTR));
+static bfd_boolean coff_start_struct_type
+  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int));
+static bfd_boolean coff_struct_field
+  PARAMS ((PTR, const char *, bfd_vma, bfd_vma, enum debug_visibility));
+static bfd_boolean coff_end_struct_type PARAMS ((PTR));
+static bfd_boolean coff_start_class_type
+  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int, bfd_boolean,
+	   bfd_boolean));
+static bfd_boolean coff_class_static_member
+  PARAMS ((PTR, const char *, const char *, enum debug_visibility));
+static bfd_boolean coff_class_baseclass
+  PARAMS ((PTR, bfd_vma, bfd_boolean, enum debug_visibility));
+static bfd_boolean coff_class_start_method PARAMS ((PTR, const char *));
+static bfd_boolean coff_class_method_variant
+  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
+	   bfd_vma, bfd_boolean));
+static bfd_boolean coff_class_static_method_variant
+  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean, bfd_boolean));
+static bfd_boolean coff_class_end_method PARAMS ((PTR));
+static bfd_boolean coff_end_class_type PARAMS ((PTR));
+static bfd_boolean coff_typedef_type PARAMS ((PTR, const char *));
+static bfd_boolean coff_tag_type
+  PARAMS ((PTR, const char *, unsigned int, enum debug_type_kind));
+static bfd_boolean coff_typdef PARAMS ((PTR, const char *));
+static bfd_boolean coff_tag PARAMS ((PTR, const char *));
+static bfd_boolean coff_int_constant PARAMS ((PTR, const char *, bfd_vma));
+static bfd_boolean coff_float_constant PARAMS ((PTR, const char *, double));
+static bfd_boolean coff_typed_constant PARAMS ((PTR, const char *, bfd_vma));
+static bfd_boolean coff_variable
+  PARAMS ((PTR, const char *, enum debug_var_kind, bfd_vma));
+static bfd_boolean coff_start_function PARAMS ((PTR, const char *, bfd_boolean));
+static bfd_boolean coff_function_parameter
+  PARAMS ((PTR, const char *, enum debug_parm_kind, bfd_vma));
+static bfd_boolean coff_start_block PARAMS ((PTR, bfd_vma));
+static bfd_boolean coff_end_block PARAMS ((PTR, bfd_vma));
+static bfd_boolean coff_end_function PARAMS ((PTR));
+static bfd_boolean coff_lineno
+  PARAMS ((PTR, const char *, unsigned long, bfd_vma));
+
+static const struct debug_write_fns coff_fns =
+{
+  coff_start_compilation_unit,
+  coff_start_source,
+  coff_empty_type,
+  coff_void_type,
+  coff_int_type,
+  coff_float_type,
+  coff_complex_type,
+  coff_bool_type,
+  coff_enum_type,
+  coff_pointer_type,
+  coff_function_type,
+  coff_reference_type,
+  coff_range_type,
+  coff_array_type,
+  coff_set_type,
+  coff_offset_type,
+  coff_method_type,
+  coff_const_type,
+  coff_volatile_type,
+  coff_start_struct_type,
+  coff_struct_field,
+  coff_end_struct_type,
+  coff_start_class_type,
+  coff_class_static_member,
+  coff_class_baseclass,
+  coff_class_start_method,
+  coff_class_method_variant,
+  coff_class_static_method_variant,
+  coff_class_end_method,
+  coff_end_class_type,
+  coff_typedef_type,
+  coff_tag_type,
+  coff_typdef,
+  coff_tag,
+  coff_int_constant,
+  coff_float_constant,
+  coff_typed_constant,
+  coff_variable,
+  coff_start_function,
+  coff_function_parameter,
+  coff_start_block,
+  coff_end_block,
+  coff_end_function,
+  coff_lineno
+};
+
+/*
+ * Copy our input (non-debugging) symbols.  Local symbols will be
+ * maintained in one bucket per each compilation unit, global (and
+ * weak) symbols will be kept in a simple array.
+ */
+static bfd_boolean
+coff_copy_symbols (info, count, sympp)
+     struct coff_write_handle *info;
+     long count;
+     asymbol **sympp;
+{
+  asymbol *osym;
+  long i;
+  struct coff_compilation_unit *up;
+
+  up = NULL;
+
+  for (i = 0; i < count; i++)
+    {
+      osym = sympp[i];
+
+      /* Try to figure out the .text and .data sections from our input
+	 symbols as we walk them.  Unfortunately, this ought to be the
+	 /input/ section pointers, so their ->output_section is
+	 non-NULL.  That's why we can't simply walk through all the
+	 sections of our abfd since this is describing the output
+	 only. */
+      if (info->textsect == NULL && osym->section->flags & SEC_CODE)
+	/* Assume this to be our .text section. */
+	info->textsect = osym->section;
+      else if (info->datasect == NULL && osym->section->flags & SEC_DATA)
+	/* Assume this to be our .data section. */
+	info->datasect = osym->section;
+
+      if (osym->flags & BSF_FILE)
+	{
+	  /* New file name. */
+	  long l;
+
+	  up = NULL;
+
+	  /* Well, maybe an old one actually?  If so, append it there.
+	     This can happen for files that contribute to multiple
+	     (input) sections that were concatenated by the linker
+	     (like crt1.S). */
+	  for (l = 0; l < info->nunits; l++)
+	    {
+	      if (strcmp (info->units[l].fname, osym->name) == 0)
+		{
+		  up = info->units + l;
+		  break;
+		}
+	    }
+
+	  if (up == NULL)
+	    {
+	      info->units = (struct coff_compilation_unit *)
+		xrealloc (info->units,
+			  ++info->nunits * sizeof(struct coff_compilation_unit));
+	      up = info->units + (info->nunits - 1);
+	      up->fname = osym->name;
+	      up->syms = NULL;
+	      up->nsyms = up->totsyms = 0;
+	    }
+	}
+      else if (osym->flags & (BSF_GLOBAL | BSF_WEAK))
+	{
+	  /* Global (or weak) symbols are recorded outside compilation
+	     units. */
+	  info->globals = (asymbol **)
+	    xrealloc (info->globals, ++info->nglobals * sizeof(asymbol *));
+	  info->globals[info->nglobals - 1] = osym;
+	  continue;
+	}
+      else if (!bfd_is_const_section(osym->section))
+	{
+	  if (osym->flags & BSF_SECTION_SYM)
+	    {
+	      coff_symbol_type *csymp;
+	      /* Just record them by now, they'll be fixed up later. */
+
+	      if (info->nsyms == 0 && (info->flags & COFF_FL_AVR) == 0)
+		{
+		  /* Very first symbol, fake a compilation unit name
+		     for it.  Historical precedence seems to dictate
+		     this, but AVR COFF does not use that. */
+		  csymp = (coff_symbol_type *)
+		    coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+		  if (csymp == NULL)
+		    return FALSE;
+
+		  csymp->symbol.name = xstrdup ("<fake>");
+		  csymp->symbol.value = 0;
+		  csymp->symbol.udata.p = NULL;
+		  csymp->native->u.syment.n_sclass = C_FILE;
+		  /* force filename into aux entry */
+		  csymp->native->u.syment.n_numaux = 1;
+		  coff_record_symbol (info, csymp);
+		}
+
+	      /* convert to COFF native section symbol */
+	      csymp = (coff_symbol_type *)
+		coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+	      if (csymp == NULL)
+		return FALSE;
+
+	      csymp->symbol.name = xstrdup (osym->section->name);
+	      csymp->symbol.value = osym->section->output_section->vma;
+	      csymp->symbol.flags = BSF_DEBUGGING | BSF_SECTION_SYM;
+	      csymp->symbol.section = osym->section;
+	      csymp->symbol.udata.p = NULL;
+	      csymp->native->fix_scnlen = 1;
+	      csymp->native->u.syment.n_sclass = C_STAT;
+	      csymp->native->u.syment.n_type = T_NULL;
+	      csymp->native->u.syment.n_numaux = 1;
+
+	      coff_record_symbol (info, csymp);
+
+	      info->secsyms = (coff_symbol_type **)
+		xrealloc (info->secsyms,
+			  ++info->nsecsyms * sizeof(coff_symbol_type *));
+	      info->secsyms[info->nsecsyms - 1] = csymp;
+	    }
+	  else
+	    {
+	      /* Local symbol in a named section, will be recorded
+		 within the respective compilation unit. */
+	      if (up == NULL)
+		{
+		  fprintf (stderr,
+			   _("Discarding local symbol outside any compilation unit"));
+		  if (osym->name)
+		    fprintf (stderr, ": %s", osym->name);
+		  putc ('\n', stderr);
+		}
+	      else
+		{
+		  up->syms = (asymbol **)
+		    xrealloc (up->syms, ++up->nsyms * sizeof(asymbol *));
+		  up->syms[up->nsyms - 1] = osym;
+		  up->totsyms = up->nsyms;
+		  continue;
+		}
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+/* Find a name in the symbol table.  If found, the respective entry in
+   the symbol vector is zeroed, so after processing all debugging
+   symbols, only non-debugging symbols will remain. */
+static asymbol *
+coff_find_symbol (info, name, isfunction, global)
+     struct coff_write_handle *info;
+     const char *name;
+     bfd_boolean isfunction;
+     bfd_boolean global;
+{
+  asymbol *symp;
+  long i;
+  size_t namelen;
+
+  if (global)
+    {
+      for (i = 0; i < info->nglobals; i++)
+	{
+	  symp = info->globals[i];
+	  if (symp == NULL)
+	    continue;
+	  if (strcmp (name, symp->name) == 0
+	      && ((symp->flags & BSF_FUNCTION) != 0) == (isfunction == TRUE))
+	    {
+	      info->globals[i] = NULL;
+	      return symp;
+	    }
+	}
+      return NULL;
+    }
+
+  if (info->currentfile == NULL)
+    return NULL;
+
+  /* For local symbols, the match optionally stops at a dot in the
+     symtab symbol's name; this is used by gcc to indicate
+     function-scope static symbols (e. g. symbol "foo" will become
+     "foo.1" in function scope). */
+  namelen = strlen (name);
+  for (i = 0; i < info->currentfile->nsyms; i++)
+    {
+      symp = info->currentfile->syms[i];
+      if (symp == NULL)
+	continue;
+      if (strncmp (name, symp->name, namelen) == 0
+	  && (symp->name[namelen] == '\0' || symp->name[namelen] == '.')
+	  && ((symp->flags & BSF_FUNCTION) != 0) == (isfunction == TRUE))
+	{
+	  info->currentfile->syms[i] = NULL;
+	  info->currentfile->totsyms--;
+	  return symp;
+	}
+    }
+  return NULL;
+}
+
+static void
+coff_record_symbol (info, csymp)
+     struct coff_write_handle *info;
+     coff_symbol_type *csymp;
+{
+  struct coff_private_symdata *priv;
+
+  info->syms = (asymbol **) xrealloc (info->syms,
+				      ++info->nsyms * sizeof (asymbol *));
+  info->syms[info->nsyms - 1] = (asymbol *)csymp;
+
+  if ((priv = csymp->symbol.udata.p) != NULL)
+    {
+      if (priv->shash != NULL)
+	{
+	  struct coff_struct_hash_entry *shash = priv->shash;
+	  shash->fixidxs = (long *)
+	    xrealloc (shash->fixidxs, ++shash->nfixidxs * sizeof (long));
+	  shash->fixidxs[shash->nfixidxs - 1] = info->nsyms - 1;
+	}
+      if (priv->ehash != NULL)
+	{
+	  struct coff_enum_hash_entry *ehash = priv->ehash;
+	  ehash->fixidxs = (long *)
+	    xrealloc (ehash->fixidxs, ++ehash->nfixidxs * sizeof (long));
+	  ehash->fixidxs[ehash->nfixidxs - 1] = info->nsyms - 1;
+	}
+      free (priv);
+      csymp->symbol.udata.p = NULL;
+    }
+
+  /* If there are any pending endndx fixes, pop the last element from
+     that stack, and record the current symbol for fixing.  We need to
+     do this here since we need to record our current csymp->native
+     (where that csymp is completely unrelated to whatever symbol was
+     previously generated that requested the fixup).  The stack of
+     pending fixes is required since several endndx fixes could be
+     nested, e. g. the start of a function has a pending fix that
+     needs to point to the first symbol after the function, but there
+     could be an anonymous struct definition inside that function's
+     local variables where the endndx needs to point after the last
+     symbol of this struct.  Also, structs and unions could be nested.
+
+     Each call to coff_record_symbol() can fix at most one endndx
+     (even if more are pending in the stack), but that's OK.
+
+     Note that bfd/coffgen.c converts that csymp->native into a
+     symtable slot number after coff_renumber_symbols() has been
+     run. */
+  if (info->flags & COFF_FL_FIX_ENDNDX)
+    {
+      struct coff_fix_stack *fsp, *ofsp;
+      union internal_auxent *aux;
+
+      assert (info->fixes != NULL);
+
+      fsp = info->fixes;
+      ofsp = NULL;
+      while (fsp->next != NULL)
+	{
+	  ofsp = fsp;
+	  fsp = fsp->next;
+	}
+      if (ofsp == NULL)
+	info->fixes = NULL;
+      else
+	ofsp->next = NULL;
+
+      aux = &(fsp->native->u.auxent);
+      fsp->native->fix_end = 1;
+      aux->x_sym.x_fcnary.x_fcn.x_endndx.p = csymp->native;
+      free (fsp);
+
+      info->flags &= ~COFF_FL_FIX_ENDNDX;
+    }
+}
+
+/* Fixup AVR COFF register handling: they don't only mention the
+   starting register number, but all registers, each within one byte
+   of the value.  Unused register positions are filled up with
+   0xff. */
+static symvalue
+coff_fixup_avr_register (val, size)
+     symvalue val;
+     int size;
+{
+  union
+  {
+    unsigned char c[4];
+    symvalue v;
+  } u;
+
+  u.c[1] = u.c[2] = u.c[3] = 0xff;
+  u.c[0] = val;
+  if (size > 8)
+    u.c[1] = val + 1;
+  if (size > 16)
+    {
+      u.c[2] = val + 2;
+      u.c[3] = val + 3;
+    }
+
+  return u.v;
+}
+
+/* Initialize an entry in the hash tables.  */
+
+static struct bfd_hash_entry *
+coff_name_type_newfunc (entry, table, string)
+     struct bfd_hash_entry *entry;
+     struct bfd_hash_table *table;
+     const char *string;
+{
+  struct coff_name_type_hash_entry *ret =
+    (struct coff_name_type_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (ret == NULL)
+    ret = ((struct coff_name_type_hash_entry *)
+	   bfd_hash_allocate (table, sizeof *ret));
+  if (ret == NULL)
+    return NULL;
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct coff_name_type_hash_entry *)
+	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
+  if (ret)
+    {
+      /* Set local fields.  */
+      ret->types = NULL;
+      ret->emitted = FALSE;
+    }
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+static struct bfd_hash_entry *
+coff_struct_newfunc (entry, table, string)
+     struct bfd_hash_entry *entry;
+     struct bfd_hash_table *table;
+     const char *string;
+{
+  struct coff_struct_hash_entry *ret =
+    (struct coff_struct_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (ret == NULL)
+    ret = ((struct coff_struct_hash_entry *)
+	   bfd_hash_allocate (table, sizeof *ret));
+  if (ret == NULL)
+    return NULL;
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct coff_struct_hash_entry *)
+	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
+  if (ret)
+    {
+      /* Set local fields.  */
+      ret->types = NULL;
+      ret->emitted = FALSE;
+      ret->fixidxs = NULL;
+      ret->nfixidxs = 0;
+      ret->native = NULL;
+    }
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+static struct bfd_hash_entry *
+coff_enum_newfunc (entry, table, string)
+     struct bfd_hash_entry *entry;
+     struct bfd_hash_table *table;
+     const char *string;
+{
+  struct coff_enum_hash_entry *ret =
+    (struct coff_enum_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (ret == NULL)
+    ret = ((struct coff_enum_hash_entry *)
+	   bfd_hash_allocate (table, sizeof *ret));
+  if (ret == NULL)
+    return NULL;
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct coff_enum_hash_entry *)
+	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
+  if (ret)
+    {
+      /* Set local fields.  */
+      ret->types = NULL;
+      ret->emitted = FALSE;
+      ret->fixidxs = NULL;
+      ret->nfixidxs = 0;
+      ret->native = NULL;
+    }
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+/* Look up an entry in the hash tables.  */
+
+#define coff_name_type_hash_lookup(table, string, create, copy) \
+  ((struct coff_name_type_hash_entry *) \
+   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
+
+/* Traverse the hash table.  */
+
+#define coff_name_type_hash_traverse(table, func, info)			\
+  (bfd_hash_traverse							\
+   (&(table)->root,							\
+    (bfd_boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func),	\
+    (info)))
+
+#define coff_struct_hash_lookup(table, string, create, copy) \
+  ((struct coff_struct_hash_entry *) \
+   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
+
+/* Traverse the hash table.  */
+
+#define coff_struct_hash_traverse(table, func, info)			\
+  (bfd_hash_traverse							\
+   (&(table)->root,							\
+    (bfd_boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func),	\
+    (info)))
+
+#define coff_enum_hash_lookup(table, string, create, copy) \
+  ((struct coff_enum_hash_entry *) \
+   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
+
+/* Traverse the hash table.  */
+
+#define coff_enum_hash_traverse(table, func, info)			\
+  (bfd_hash_traverse							\
+   (&(table)->root,							\
+    (bfd_boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func),	\
+    (info)))
+
+#define coff_push_type(kind) \
+  tst = (struct coff_type_stack *) xmalloc (sizeof (struct coff_type_stack)); \
+  memset (tst, 0, sizeof (*tst)); \
+  tst->next = info->tstack; \
+  tst->tsk = kind; \
+  info->tstack = tst
+
+#define coff_pop_type() \
+  tst = info->tstack; \
+  if (tst == NULL) { \
+    fprintf (stderr, _("empty type stack in coff_pop_type()\n")); \
+    return FALSE; \
+  } \
+  info->tstack = tst->next; \
+  tst->next = NULL
+
+#define coff_complain_unsupp(s) \
+  fprintf (stderr, _("%s type not supported in %s\n"), \
+	   s, info->abfd->xvec->name); \
+  return FALSE
+
+/* These function is called via the hash traverse routine when freeing
+   a hash table (at the end of a translation unit). */
+static bfd_boolean
+coff_free_type_info (h, p)
+     struct coff_name_type_hash_entry *h;
+     PTR p ATTRIBUTE_UNUSED;
+{
+  struct coff_type_stack *tst, *otst;
+
+  for (tst = h->types; tst != NULL;)
+    {
+      otst = tst;
+      tst = tst->next;
+      free (otst);
+    }
+  return TRUE;
+}
+
+static bfd_boolean
+coff_free_struct_info (h, p)
+     struct coff_struct_hash_entry *h;
+     PTR p ATTRIBUTE_UNUSED;
+{
+  struct coff_type_stack *tst, *otst, *xtst, *xotst;
+  struct coff_struct_fields *fp;
+  long i;
+
+  for (tst = h->types; tst != NULL;)
+    {
+      otst = tst;
+      if (tst->u.ts_struct.tagismalloced)
+	free (tst->u.ts_struct.tag.malloctag);
+      for (i = 0, fp = tst->u.ts_struct.fields;
+	   i < tst->u.ts_struct.nfields;
+	   i++, fp++)
+	{
+	  xtst = fp->types;
+	  while (xtst != NULL)
+	    {
+	      xotst = xtst->next;
+	      free (xtst);
+	      xtst = xotst;
+	    }
+	}
+      free (tst->u.ts_struct.fields);
+      tst = tst->next;
+      free (otst);
+    }
+  return TRUE;
+}
+
+static bfd_boolean
+coff_free_enum_info (h, p)
+     struct coff_enum_hash_entry *h;
+     PTR p ATTRIBUTE_UNUSED;
+{
+  struct coff_type_stack *tst, *otst;
+
+  for (tst = h->types; tst != NULL;)
+    {
+      otst = tst;
+      if (tst->u.ts_enum.tagismalloced)
+	free (tst->u.ts_enum.tag.malloctag);
+      tst = tst->next;
+      free (otst);
+    }
+  return TRUE;
+}
+
+static unsigned int
+coff_get_fundamental_type (info, tst)
+     struct coff_write_handle *info ATTRIBUTE_UNUSED;
+     struct coff_type_stack *tst;
+{
+  size_t i;
+
+  /* See if one of our predefined types will fit. */
+  if (tst->tsk == TS_INT)
+    {
+      for (i = 0;
+	   i < sizeof coff_predef_types / sizeof (struct coff_predef_type);
+	   i++)
+	{
+	  if (coff_predef_types[i].kind == TS_INT
+	      && coff_predef_types[i].size == tst->u.ts_int.size
+	      && coff_predef_types[i].isunsigned == tst->u.ts_int.isunsigned)
+	    return coff_predef_types[i].slot;
+	}
+      fprintf (stderr,
+	       _("%ssigned %d-bit integer type not available in COFF\n"),
+	       tst->u.ts_int.isunsigned? "un": "", tst->u.ts_int.size * 8);
+    }
+  else
+    {
+      for (i = 0;
+	   i < sizeof coff_predef_types / sizeof (struct coff_predef_type);
+	   i++)
+	{
+	  if (coff_predef_types[i].kind == TS_FLOAT
+	      && coff_predef_types[i].size == tst->u.ts_float.size)
+	    return coff_predef_types[i].slot;
+	}
+      fprintf (stderr, _("%d-bit float type not available in COFF\n"),
+	       tst->u.ts_float.size * 8);
+    }
+
+  return T_NULL;
+}
+
+static bfd_boolean
+coff_make_typed_symbol (info, csympp, stopat)
+     struct coff_write_handle *info;
+     coff_symbol_type **csympp;
+     enum ts_kind stopat;
+{
+  struct coff_type_stack *tst;
+  union internal_auxent *aux;
+  struct coff_struct_hash_entry *shash;
+  struct coff_enum_hash_entry *ehash;
+  struct coff_private_symdata *priv;
+  unsigned int type, numaux, arydim, size, i, nele, nderived;
+  const char *name;
+  bfd_boolean oldavrcoff = (info->flags & (COFF_FL_AVR | COFF_FL_EXT_AVR))
+    == COFF_FL_AVR;
+
+  /* Synthesize a new internal COFF symbol. */
+  *csympp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+  if (*csympp == NULL)
+    return FALSE;
+
+  priv = (struct coff_private_symdata *) xmalloc (sizeof *priv);
+  memset (priv, 0, sizeof *priv);
+
+  type = arydim = size = nderived = 0;
+
+  aux = &(((*csympp)->native + 1)->u.auxent);
+
+  /* Now, walk the type stack, and see how we could convert the info
+     we've got to what COFF understands. */
+  for (;;)
+    {
+      if (info->tstack == NULL)
+	break;
+
+      /* If we have been advised to not pop the entire stack, stop
+	 here. */
+      if (info->tstack->tsk == stopat && info->tstack->next == NULL)
+	break;
+
+      coff_pop_type ();
+
+      switch (tst->tsk)
+	{
+	case TS_NONE:
+	  /* cannot happen */
+	  break;
+
+	case TS_EMPTY:
+	  if (info->tstack != NULL && info->tstack->tsk != stopat)
+	    fprintf (stderr, _("empty type not last on type stack\n"));
+	  /* type |= T_NULL; */
+	  break;
+
+	case TS_VOID:
+	  if (info->tstack != NULL && info->tstack->tsk != stopat)
+	    fprintf (stderr, _("void type not last on type stack\n"));
+	  type |= T_VOID;
+	  break;
+
+	case TS_INT:
+	  if (info->tstack != NULL && info->tstack->tsk != stopat)
+	    fprintf (stderr, _("int type not last on type stack\n"));
+	  type |= coff_get_fundamental_type (info, tst);
+	  if (size == 0)
+	    size = tst->u.ts_int.size;
+	  break;
+
+	case TS_FLOAT:
+	  if (info->tstack != NULL && info->tstack->tsk != stopat)
+	    fprintf (stderr, _("float type not last on type stack\n"));
+	  type |= coff_get_fundamental_type (info, tst);
+	  if (size == 0)
+	    size = tst->u.ts_float.size;
+	  break;
+
+	case TS_POINTER:
+	  nderived++;
+	  type = ((type & ~N_BTMASK) << N_TSHIFT) | (DT_PTR << N_BTSHFT);
+	  size = info->pointersize;
+	  break;
+
+	case TS_FUNC:
+	  nderived++;
+	  type = ((type & ~N_BTMASK) << N_TSHIFT) | (DT_FCN << N_BTSHFT);
+	  /* AUX entry for DT_FCN will be filled in elsewhere. */
+	  break;
+
+	case TS_ARRAY:
+	  /* We need to limit arydim so the assignment below won't
+	     overwrite random locations. */
+	  if (arydim >= DIMNUM)
+	    {
+	      fprintf (stderr,
+		       _("More than %d array dimensions, result is invalid.\n"),
+		       DIMNUM);
+	      arydim = DIMNUM - 1;
+	    }
+	  nderived++;
+	  type = ((type & ~N_BTMASK) << N_TSHIFT) | (DT_ARY << N_BTSHFT);
+	  aux->x_sym.x_fcnary.x_ary.x_dimen[arydim++] =
+	    tst->u.ts_array.high - tst->u.ts_array.low + 1;
+
+	  break;
+
+	case TS_COMPLEX:
+	  coff_complain_unsupp (_("complex"));
+
+	case TS_ENUM:
+	  type |= T_ENUM;
+	  if (size == 0)
+	    size = info->enumsize;
+
+	  if (tst->u.ts_enum.ehash != NULL)
+	    {
+	      /* enum tag will be fixed later. */
+	      priv->ehash = tst->u.ts_enum.ehash;
+	      break;
+	    }
+	  if (tst->u.ts_enum.tagismalloced)
+	    name = tst->u.ts_enum.tag.malloctag;
+	  else
+	    name = tst->u.ts_enum.tag.fixtag;
+	  ehash = coff_enum_hash_lookup (&info->enums, name,
+					 TRUE, tst->u.ts_enum.tagismalloced);
+	  if (ehash == NULL)
+	    return FALSE;
+	  if (!ehash->emitted)
+	    {
+	      if (ehash->types == NULL)
+		{
+		  ehash->types = (struct coff_type_stack *)
+		    xmalloc (sizeof (struct coff_type_stack));
+		  memcpy (ehash->types, tst, sizeof (struct coff_type_stack));
+		}
+	      ehash->emitted = TRUE;
+	      coff_emit_enum (info, tst, ehash);
+	      if (ehash->nfixidxs != 0)
+		{
+		  coff_symbol_type *symp;
+		  unsigned i;
+
+		  for (i = 0; i < ehash->nfixidxs; i++)
+		    {
+		      combined_entry_type *np;
+
+		      symp = (coff_symbol_type *) info->syms[ehash->fixidxs[i]];
+		      symp->native->u.syment.n_type &= ~N_BTMASK;
+		      symp->native->u.syment.n_type |= T_ENUM;
+
+		      if (oldavrcoff)
+			continue;
+
+		      np = symp->native + 1;
+		      np->fix_tag = 1;
+		      np->u.auxent.x_sym.x_tagndx.p = ehash->native;
+		      if (np->u.auxent.x_sym.x_misc.x_fsize == 0)
+			np->u.auxent.x_sym.x_misc.x_lnsz.x_size = size;
+		    }
+
+		  free (ehash->fixidxs);
+		  ehash->nfixidxs = 0;
+		}
+	    }
+	  if (!oldavrcoff)
+	    {
+	      ((*csympp)->native + 1)->fix_tag = 1;
+	      aux->x_sym.x_tagndx.p = ehash->native;
+	      if (aux->x_sym.x_misc.x_fsize == 0)
+		aux->x_sym.x_misc.x_lnsz.x_size = size;
+	    }
+	  break;
+
+	case TS_STRUCT:
+	  if (tst->u.ts_struct.isstruct)
+	    type |= T_STRUCT;
+	  else
+	    type |= T_UNION;
+	  if (size == 0)
+	    size = tst->u.ts_struct.size;
+
+	  if (tst->u.ts_struct.shash != NULL)
+	    {
+	      /* struct tag will be fixed later. */
+	      priv->shash = tst->u.ts_struct.shash;
+	      break;
+	    }
+	  if (tst->u.ts_struct.tagismalloced)
+	    name = tst->u.ts_struct.tag.malloctag;
+	  else
+	    name = tst->u.ts_struct.tag.fixtag;
+	  shash = coff_struct_hash_lookup (&info->structs, name,
+					   TRUE, tst->u.ts_struct.tagismalloced);
+	  if (shash == NULL)
+	    return FALSE;
+	  if (!shash->emitted)
+	    {
+	      if (shash->types == NULL)
+		{
+		  shash->types = (struct coff_type_stack *)
+		    xmalloc (sizeof (struct coff_type_stack));
+		  memcpy (shash->types, tst, sizeof (struct coff_type_stack));
+		}
+	      shash->emitted = TRUE;
+	      coff_emit_struct (info, tst, shash);
+	      if (shash->nfixidxs != 0)
+		{
+		  coff_symbol_type *symp;
+		  unsigned i;
+
+		  for (i = 0; i < shash->nfixidxs; i++)
+		    {
+		      combined_entry_type *np;
+
+		      symp = (coff_symbol_type *) info->syms[shash->fixidxs[i]];
+		      symp->native->u.syment.n_type &= ~N_BTMASK;
+		      if (tst->u.ts_struct.isstruct)
+			symp->native->u.syment.n_type |= T_STRUCT;
+		      else
+			symp->native->u.syment.n_type |= T_UNION;
+
+		      if (oldavrcoff)
+			continue;
+
+		      np = symp->native + 1;
+		      np->fix_tag = 1;
+		      np->u.auxent.x_sym.x_tagndx.p = shash->native;
+		      if (np->u.auxent.x_sym.x_misc.x_fsize == 0)
+			np->u.auxent.x_sym.x_misc.x_lnsz.x_size = size;
+		    }
+
+		  free (shash->fixidxs);
+		  shash->nfixidxs = 0;
+		}
+	    }
+	  if (!oldavrcoff)
+	    {
+	      ((*csympp)->native + 1)->fix_tag = 1;
+	      aux->x_sym.x_tagndx.p = shash->native;
+	      if (aux->x_sym.x_misc.x_fsize == 0)
+		aux->x_sym.x_misc.x_lnsz.x_size = size;
+	    }
+	  break;
+	}
+      free (tst);
+    }
+
+  if (nderived > 6)
+    fprintf (stderr,
+	     _("More than 6 derived type specifiers, result is invalid.\n"));
+
+  /* Our type computation so far used the reverse order for derived
+     type specifiers.  Fix this here if there was more than one
+     derived type specifier. */
+  if (nderived > 1)
+    {
+      unsigned int nty, bty;
+      bty = type & N_BTMASK;
+      type = type >> N_BTSHFT;
+      nty = 0;
+      while (nderived-- > 0)
+	{
+	  nty = (nty << N_TSHIFT) | (type & (N_TMASK >> N_BTSHFT));
+	  type >>= N_TSHIFT;
+	}
+      type = (nty << N_BTSHFT) | bty;
+    }
+
+  if (ISARY (type))
+    {
+      /* Compute size of entire array. */
+      for (i = 0, nele = 1; i < arydim; i++)
+	nele *= aux->x_sym.x_fcnary.x_ary.x_dimen[i];
+      aux->x_sym.x_misc.x_lnsz.x_size = size * nele;
+    }
+
+  numaux = 0;
+  if (ISARY (type) || ISFCN (type))
+    numaux++;
+  if ((BTYPE (type) == T_STRUCT || BTYPE (type) == T_UNION
+       || BTYPE (type) == T_ENUM)
+      && !oldavrcoff)
+    numaux++;
+  /* Only AVR COFF uses multiple AUX entries. */
+  if (numaux > 1 && (info->flags & COFF_FL_AVR) == 0)
+    numaux = 1;
+
+  priv->size = size;
+  (*csympp)->symbol.udata.p = priv;
+  (*csympp)->native->u.syment.n_type = type;
+  (*csympp)->native->u.syment.n_numaux = numaux;
+
+  /* If the fundamental type comes out as T_NULL, this means we don't
+     have any type information.  Just don't emit any aux entries in
+     that case, and drop any derived type information as well. */
+  if (BTYPE (type) == T_NULL)
+    {
+      printf ("coff_make_typed_symbol() -> T_NULL\n");
+      //(*csympp)->native->u.syment.n_type = T_NULL;
+      (*csympp)->native->u.syment.n_numaux = 0;
+    }
+
+  return TRUE;
+}
+
+static bfd_boolean coff_emit_struct (info, tst, shash)
+     struct coff_write_handle *info;
+     struct coff_type_stack *tst;
+     struct coff_struct_hash_entry *shash;
+{
+  coff_symbol_type *csymp, *scsymp, *ecsymp;
+  union internal_auxent *aux;
+  struct coff_fix_stack *fixp, *ofp;
+  bfd_boolean isstruct = tst->u.ts_struct.isstruct;
+  bfd_boolean isbitfield = FALSE;
+  struct coff_type_stack *savedtst;
+  struct coff_struct_fields *fp;
+  unsigned short sclass;
+  long i;
+
+  if ((info->flags & (COFF_FL_AVR | COFF_FL_EXT_AVR)) ==
+      COFF_FL_AVR)
+    /* old AVR COFF doesn't support struct debugging */
+    return TRUE;
+
+  /* Synthesize a new internal COFF symbol for the struct/union. */
+  scsymp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+  if (scsymp == NULL)
+    return FALSE;
+
+  if (tst->u.ts_struct.tagismalloced)
+    scsymp->symbol.name = xstrdup (tst->u.ts_struct.tag.malloctag);
+  else
+    scsymp->symbol.name = tst->u.ts_struct.tag.fixtag;
+  scsymp->symbol.flags = BSF_NOT_AT_END;
+  scsymp->symbol.section = bfd_und_section_ptr;
+  scsymp->native->u.syment.n_sclass = isstruct? C_STRTAG: C_UNTAG;
+  scsymp->native->u.syment.n_type = isstruct? T_STRUCT: T_UNION;
+  scsymp->native->u.syment.n_numaux = 1;
+  scsymp->symbol.udata.p = NULL;
+  scsymp->symbol.value = 0;
+
+  shash->native = scsymp->native;
+
+  /* Synthesize a new internal COFF symbol for the end of struct/union. */
+  ecsymp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+  if (ecsymp == NULL)
+    return FALSE;
+
+  ecsymp->symbol.name = ".eos";
+  ecsymp->symbol.flags = BSF_NOT_AT_END;
+  /* We need to use the com section here since bfd/coffgen.c
+     translates this into an N_UNDEF one without clobbering the
+     value. */
+  ecsymp->symbol.section = bfd_com_section_ptr;
+  ecsymp->native->u.syment.n_sclass = C_EOS;
+  ecsymp->symbol.udata.p = NULL;
+  ecsymp->symbol.value = tst->u.ts_struct.size;
+  ecsymp->native->u.syment.n_numaux = 1;
+  (ecsymp->native + 1)->fix_tag = 1;
+  aux = &((ecsymp->native + 1)->u.auxent);
+  aux->x_sym.x_tagndx.p = scsymp->native;
+  aux->x_sym.x_misc.x_lnsz.x_size = tst->u.ts_struct.size;
+
+  coff_record_symbol (info, scsymp);
+
+  savedtst = info->tstack;
+
+  if (isstruct)
+    {
+      /* First, make a quick walk along all the fields, and figure out
+       * whether we've got a genuine struct or a bitfield struct. */
+      for (i = 0, fp = tst->u.ts_struct.fields;
+	   i < tst->u.ts_struct.nfields;
+	   i++, fp++)
+	if (fp->bitsize % 8 != 0)
+	  {
+	    isbitfield = TRUE;
+	    break;
+	  }
+    }
+
+  sclass = isstruct? (isbitfield? C_FIELD: C_MOS): C_MOU;
+
+  for (i = 0, fp = tst->u.ts_struct.fields;
+       i < tst->u.ts_struct.nfields;
+       i++, fp++)
+    {
+      if (strlen (fp->name) == 0)
+	{
+	  /* empty name could happen inside bitfield */
+	  fp->types = NULL;
+	  continue;
+	}
+
+      info->tstack = fp->types;
+      if (!coff_make_typed_symbol (info, &csymp, TS_NONE))
+	return FALSE;
+
+      csymp->symbol.name = xstrdup (fp->name);
+      csymp->symbol.flags = BSF_NOT_AT_END;
+      csymp->symbol.section = bfd_com_section_ptr;
+      csymp->native->u.syment.n_sclass = sclass;
+      csymp->symbol.value = isbitfield? fp->bitpos: fp->bitpos / 8;
+      if (isbitfield)
+	{
+	  csymp->native->u.syment.n_numaux = 1;
+	  aux = &((csymp->native + 1)->u.auxent);
+	  aux->x_sym.x_misc.x_lnsz.x_size = fp->bitsize;
+	}
+
+      coff_record_symbol (info, csymp);
+
+      fp->types = NULL;
+    }
+
+  info->tstack = savedtst;
+
+  /* Record our endndx field for later fixing. */
+  fixp = (struct coff_fix_stack *) xmalloc (sizeof (struct coff_fix_stack));
+  fixp->native = scsymp->native + 1;	/* points to first AUX */
+  fixp->next = NULL;
+  if (info->fixes == NULL)
+    info->fixes = fixp;
+  else
+    {
+      for (ofp = info->fixes; ofp->next != NULL;)
+	ofp = ofp->next;
+      ofp->next = fixp;
+    }
+
+  coff_record_symbol (info, ecsymp);
+  info->flags |= COFF_FL_FIX_ENDNDX;
+
+  return TRUE;
+}
+
+static bfd_boolean coff_emit_enum (info, tst, ehash)
+     struct coff_write_handle *info;
+     struct coff_type_stack *tst;
+     struct coff_enum_hash_entry *ehash;
+{
+  coff_symbol_type *csymp, *scsymp, *ecsymp;
+  union internal_auxent *aux;
+  struct coff_fix_stack *fixp, *ofp;
+  int i;
+
+  if ((info->flags & (COFF_FL_AVR | COFF_FL_EXT_AVR)) ==
+      COFF_FL_AVR)
+    /* old AVR COFF doesn't support enum debugging */
+    return TRUE;
+
+  /* Synthesize a new internal COFF symbol for the enum. */
+  scsymp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+  if (scsymp == NULL)
+    return FALSE;
+
+  if (tst->u.ts_enum.tagismalloced)
+    scsymp->symbol.name = xstrdup (tst->u.ts_enum.tag.malloctag);
+  else
+    scsymp->symbol.name = tst->u.ts_enum.tag.fixtag;
+  scsymp->symbol.flags = BSF_NOT_AT_END;
+  scsymp->symbol.section = bfd_und_section_ptr;
+  scsymp->native->u.syment.n_sclass = C_ENTAG;
+  scsymp->native->u.syment.n_type = T_ENUM;
+  scsymp->native->u.syment.n_numaux = 1;
+  scsymp->symbol.udata.p = NULL;
+  scsymp->symbol.value = 0;
+
+  ehash->native = scsymp->native;
+
+  /* Synthesize a new internal COFF symbol for the end of struct/union. */
+  ecsymp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+  if (ecsymp == NULL)
+    return FALSE;
+
+  ecsymp->symbol.name = ".eos";
+  ecsymp->symbol.flags = BSF_NOT_AT_END;
+  /* We need to use the com section here since bfd/coffgen.c
+     translates this into an N_UNDEF one without clobbering the
+     value. */
+  ecsymp->symbol.section = bfd_com_section_ptr;
+  ecsymp->native->u.syment.n_sclass = C_EOS;
+  ecsymp->symbol.udata.p = NULL;
+  ecsymp->symbol.value = info->enumsize;
+  ecsymp->native->u.syment.n_numaux = 1;
+  (ecsymp->native + 1)->fix_tag = 1;
+  aux = &((ecsymp->native + 1)->u.auxent);
+  aux->x_sym.x_tagndx.p = scsymp->native;
+  aux->x_sym.x_misc.x_lnsz.x_size = info->enumsize;
+
+  coff_record_symbol (info, scsymp);
+
+  for (i = 0;; i++)
+    {
+      const char *name = tst->u.ts_enum.names[i];
+      if (name == NULL)
+	break;
+
+      /* Synthesize a new internal COFF symbol for the enum. */
+      csymp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+      if (csymp == NULL)
+	return FALSE;
+
+      csymp->symbol.name = xstrdup (name);
+      csymp->symbol.flags = BSF_NOT_AT_END;
+      csymp->symbol.section = bfd_com_section_ptr;
+      csymp->native->u.syment.n_sclass = C_MOE;
+      csymp->symbol.udata.p = NULL;
+      csymp->symbol.value = tst->u.ts_enum.vals[i];
+
+      coff_record_symbol (info, csymp);
+    }
+
+  /* Record our endndx field for later fixing. */
+  fixp = (struct coff_fix_stack *) xmalloc (sizeof (struct coff_fix_stack));
+  fixp->native = scsymp->native + 1;	/* points to first AUX */
+  fixp->next = NULL;
+  if (info->fixes == NULL)
+    info->fixes = fixp;
+  else
+    {
+      for (ofp = info->fixes; ofp->next != NULL;)
+	ofp = ofp->next;
+      ofp->next = fixp;
+    }
+
+  coff_record_symbol (info, ecsymp);
+  info->flags |= COFF_FL_FIX_ENDNDX;
+
+  return TRUE;
+}
+
+/* Emit a non-debugging symbol that came from the input symbol table,
+   and has not been claimed by one of the debugging symbols. */
+static bfd_boolean
+coff_emit_ndebug_sym (info, osymp, localp)
+     struct coff_write_handle *info;
+     asymbol *osymp;
+     bfd_boolean localp;
+{
+  coff_symbol_type *csymp;
+
+  /* Create new COFF symbol. */
+  csymp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+  if (csymp == NULL)
+    return FALSE;
+
+  csymp->symbol.name = xstrdup (osymp->name);
+  csymp->symbol.value = osymp->value;
+  csymp->symbol.flags = localp? BSF_LOCAL: BSF_GLOBAL;
+  csymp->symbol.section = osymp->section;
+  csymp->symbol.udata.p = NULL;
+  csymp->native->u.syment.n_sclass = localp? C_STAT: C_EXT;
+  csymp->native->u.syment.n_type = T_NULL;
+
+  coff_record_symbol (info, csymp);
+
+  return TRUE;
+}
+
+/* The general routine to write out COFF debugging information.  This
+   synthesizes and accumulates the COFF symbols.  Actual symbol table
+   output is performed later on by the BFD functions.  ABFD is the BFD
+   and DHANDLE is the handle for the debugging information.  symcountp
+   and symppp point to the incoming (parsed) symbol list on entry, and
+   will be updated to point to the new symbol table's values upon
+   exit. */
+
+bfd_boolean
+write_coff_debugging_info (abfd, dhandle, symcountp, symppp)
+     bfd *abfd;
+     PTR dhandle;
+     long *symcountp;
+     asymbol ***symppp;
+{
+  struct coff_write_handle info;
+  long i, l;
+  asymbol *symp;
+  struct coff_compilation_unit *up;
+  coff_symbol_type *csymp;
+
+  memset ((void *)&info, 0, sizeof info);
+
+  info.abfd = abfd;
+
+  info.pointersize = info.enumsize = 4;
+
+  switch (bfd_get_arch (abfd))
+    {
+    case bfd_arch_avr:
+      info.flags |= COFF_FL_AVR;
+      if (strcmp (abfd->xvec->name, "coff-ext-avr") == 0)
+	info.flags |= COFF_FL_EXT_AVR;
+      /* Fix the builtin type sizes. */
+      coff_predef_types[0].size = 2;	/* sizeof(int) == 2 */
+      coff_predef_types[4].size = 4;	/* sizeof(double) == 4 */
+      coff_predef_types[6].size = 2;	/* sizeof(unsigned int) == 2 */
+      info.pointersize = info.enumsize = 2;
+      break;
+
+    default:
+      ;
+    }
+
+  coff_copy_symbols(&info, *symcountp, *symppp);
+
+  if (info.textsect == NULL)
+    {
+      fprintf (stderr, _("Warning: no \"text\" section found in output file\n"));
+      info.textsect = bfd_abs_section_ptr;
+    }
+  if (info.datasect == NULL)
+    {
+      fprintf (stderr, _("Warning: no \"data\" section found in output file\n"));
+      info.datasect = bfd_abs_section_ptr;
+    }
+
+  if (! bfd_hash_table_init (&info.types.root, coff_name_type_newfunc,
+			     sizeof(struct coff_name_type_hash_entry)))
+    return FALSE;
+
+  if (! bfd_hash_table_init (&info.structs.root, coff_struct_newfunc,
+			     sizeof(struct coff_struct_hash_entry)))
+    return FALSE;
+
+  if (! bfd_hash_table_init (&info.enums.root, coff_enum_newfunc,
+			     sizeof(struct coff_enum_hash_entry)))
+    return FALSE;
+
+  if (! debug_write (dhandle, &coff_fns, (PTR) &info))
+    return FALSE;
+
+  /* If there is an old compilation unit that has got any local
+     non-debugging symbols left over, send them out now. */
+  if (info.currentfile != NULL && info.currentfile->totsyms != 0)
+    for (i = 0; i < info.currentfile->nsyms; i++)
+      {
+	up = info.currentfile;
+
+	if (up->syms[i] != NULL)
+	  {
+	    coff_emit_ndebug_sym (&info, up->syms[i], TRUE);
+	    up->syms[i] = NULL;
+	    up->totsyms--;
+	  }
+      }
+
+  /* See whether there are any non-debugging symbols left from the
+     input symbol table.  First look at all local symbols which must
+     be from entire compilation units we didn't see yet in the
+     debugging information, because anything else has already been
+     handled at the end of each compilation unit (like in the loop
+     immediately above).  Any compilation unit that has already been
+     processed that way is supposed to have its "totsyms" counted down
+     to 0 now, so we can skip them.
+
+     Finally, put out all remaining global non-debugging symbols. */
+  for (l = 0; l < info.nunits; l++)
+    {
+      const char *bn;
+
+      up = info.units + l;
+      if (up->totsyms == 0)
+	continue;
+
+      /* Create COFF symbol for this compilation unit. */
+      csymp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info.abfd, 0, 0);
+      if (csymp == NULL)
+	return FALSE;
+
+      bn = bu_basename (up->fname);
+
+      if (bfd_coff_long_filenames (info.abfd))
+	csymp->symbol.name = up->fname;
+      else
+	csymp->symbol.name = bn;
+
+      csymp->symbol.value = 0;
+      csymp->symbol.udata.p = NULL;
+      csymp->native->u.syment.n_sclass = C_FILE;
+      csymp->native->u.syment.n_numaux = 1; /* force filename into aux entry */
+      coff_record_symbol (&info, csymp);
+
+      for (i = 0; i < up->nsyms; i++)
+	{
+	  symp = up->syms[i];
+	  if (symp == NULL)
+	    continue;
+
+	  coff_emit_ndebug_sym (&info, symp, TRUE);
+	}
+    }
+
+  for (i = 0; i < info.nglobals; i++)
+    {
+      symp = info.globals[i];
+      if (symp == NULL)
+	continue;
+
+      coff_emit_ndebug_sym (&info, symp, FALSE);
+    }
+
+  /* Fixup the AUX entries for the section symbols we have emitted
+     earlier (so they are guaranteed to be at the beginning of the
+     symbol table).  In particular, the line number count (which we
+     only have for the text section) is known right now. */
+  for (i = 0; i < info.nsecsyms; i++)
+    {
+      union internal_auxent *aux;
+
+      csymp = info.secsyms[i];
+
+      aux = &((csymp->native + 1)->u.auxent);
+      aux->x_scn.x_scnlen = csymp->symbol.section->output_section->rawsize;
+      aux->x_scn.x_nreloc = csymp->symbol.section->reloc_count;
+      if (csymp->symbol.section == info.textsect)
+	aux->x_scn.x_nlinno = info.totlnos;
+    }
+  free (info.secsyms);
+
+  coff_name_type_hash_traverse (&info.types, coff_free_type_info, NULL);
+  bfd_hash_table_free (&info.types.root);
+
+  coff_struct_hash_traverse (&info.structs, coff_free_struct_info, NULL);
+  bfd_hash_table_free (&info.structs.root);
+
+  coff_enum_hash_traverse (&info.enums, coff_free_enum_info, NULL);
+  bfd_hash_table_free (&info.enums.root);
+
+  /* FIXME: free all the other stuff remembered in "info". */
+
+  free (*symppp);
+
+  *symcountp = info.nsyms;
+  *symppp = (asymbol **)info.syms;
+
+  return TRUE;
+}
+
+/* Start writing out information for a compilation unit.  */
+
+static bfd_boolean
+coff_start_compilation_unit (p, filename)
+     PTR p;
+     const char *filename;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  long i;
+  const char *bn;
+  bfd_boolean found;
+  coff_symbol_type *csymp;
+
+#if COFF_DEBUG
+  printf ("coff_start_compilation_unit(%s)\n", filename);
+#endif
+
+  /* If there is an old compilation unit that has got any local
+     non-debugging symbols left over, send them out now. */
+  if (info->currentfile != NULL && info->currentfile->totsyms != 0)
+    for (i = 0; i < info->currentfile->nsyms; i++)
+      {
+	struct coff_compilation_unit *up = info->currentfile;
+
+	if (up->syms[i] != NULL)
+	  {
+	    coff_emit_ndebug_sym (info, up->syms[i], TRUE);
+	    up->syms[i] = NULL;
+	    up->totsyms--;
+	  }
+      }
+
+  /* symtab (and thus COFF debugging) symbols can only transfer the
+     basename of the file, so strip the dirname */
+  bn = bu_basename (filename);
+
+  for (i = 0, found = FALSE; i < info->nunits; i++)
+    {
+      if (strcmp (info->units[i].fname, bn) == 0)
+	{
+	  info->currentfile = info->units + i;
+	  found = TRUE;
+	  break;
+	}
+    }
+  if (!found)
+    {
+      fprintf(stderr,
+	      _("Warning: file %s not found in symbol table, ignoring\n"),
+	      filename);
+      info->currentfile = NULL;
+      return TRUE;
+    }
+
+  /* Synthesize a new internal COFF symbol. */
+  csymp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+  if (csymp == NULL)
+    return FALSE;
+
+  /* Note that coff_fix_symbol_name() [coffgen.c] will fix this for
+     us: the symbol name will be replaced by ".file", and the filename
+     will be moved to the aux entries.  We use the long name obtained
+     from the debugging information (that includes the full path) if
+     our COFF format supports long filenames, otherwise we only use
+     the basename of the file. */
+  if (bfd_coff_long_filenames (info->abfd))
+    csymp->symbol.name = filename;
+  else
+    csymp->symbol.name = bn;
+  csymp->symbol.value = 0;
+  csymp->symbol.udata.p = NULL;
+  csymp->native->u.syment.n_sclass = C_FILE;
+  csymp->native->u.syment.n_numaux = 1;	/* force filename into aux entry */
+  coff_record_symbol (info, csymp);
+
+  return TRUE;
+}
+
+/* Start writing out information for a particular source file.  */
+
+static bfd_boolean
+coff_start_source (p, filename)
+     PTR p ATTRIBUTE_UNUSED;
+     const char *filename ATTRIBUTE_UNUSED;
+{
+
+#if COFF_DEBUG
+  printf ("coff_start_source(%s)\n", filename);
+#endif
+
+  /* COFF cannot handle include filenames. */
+
+  return TRUE;
+}
+
+/* Push an empty type.  This shouldn't normally happen.  */
+
+static bfd_boolean
+coff_empty_type (p)
+     PTR p;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst;
+
+#if COFF_DEBUG
+  printf ("coff_empty_type()\n");
+#endif
+
+  coff_push_type (TS_EMPTY);
+
+  return TRUE;
+}
+
+/* Push a void type.  */
+
+static bfd_boolean
+coff_void_type (p)
+     PTR p;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst;
+
+#if COFF_DEBUG
+  printf ("coff_void_type()\n");
+#endif
+
+  coff_push_type (TS_VOID);
+
+  return TRUE;
+}
+
+/* Push an integer type.  */
+
+static bfd_boolean
+coff_int_type (p, size, unsignedp)
+     PTR p;
+     unsigned int size;
+     bfd_boolean unsignedp;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst;
+
+#if COFF_DEBUG
+  printf ("coff_int_type(%d, %d)\n", size, unsignedp);
+#endif
+
+  coff_push_type (TS_INT);
+  tst->u.ts_int.size = size;
+  tst->u.ts_int.isunsigned = unsignedp;
+
+  return TRUE;
+}
+
+/* Push a floating point type.  */
+
+static bfd_boolean
+coff_float_type (p, size)
+     PTR p;
+     unsigned int size;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst;
+
+#if COFF_DEBUG
+  printf ("coff_float_type(%d)\n", size);
+#endif
+
+  coff_push_type (TS_FLOAT);
+  tst->u.ts_float.size = size;
+
+  return TRUE;
+}
+
+/* Push a complex type.  */
+
+static bfd_boolean
+coff_complex_type (p, size)
+     PTR p;
+     unsigned int size ATTRIBUTE_UNUSED;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst;
+
+#if COFF_DEBUG
+  printf ("coff_complex_type(%d)\n", size);
+#endif
+
+  coff_push_type (TS_COMPLEX);
+
+  return TRUE;
+}
+
+/* Push a bfd_boolean type. */
+
+static bfd_boolean
+coff_bool_type (p, size)
+     PTR p;
+     unsigned int size;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst;
+
+#if COFF_DEBUG
+  printf ("coff_bool_type(%d)\n", size);
+#endif
+
+  coff_push_type (TS_INT);
+  tst->u.ts_int.size = size;
+  tst->u.ts_int.isunsigned = TRUE;
+
+  return TRUE;
+}
+
+/* Push an enum type.  */
+
+static bfd_boolean
+coff_enum_type (p, tag, names, vals)
+     PTR p;
+     const char *tag;
+     const char **names;
+     bfd_signed_vma *vals;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst;
+  char buf[20];
+
+#if COFF_DEBUG
+  int idx;
+  printf ("coff_enum_type(%s [", tag);
+  for (idx = 0; names[idx] != NULL; idx++)
+    printf ("%s -> %d, ", names[idx], (int)vals[idx]);
+  printf ("])\n");
+#endif
+
+  coff_push_type (TS_ENUM);
+
+  if (tag == NULL)
+    {
+      sprintf(buf, ".%dfake", info->nenums++);
+      tst->u.ts_enum.tag.malloctag = xstrdup (buf);
+      tst->u.ts_enum.tagismalloced = TRUE;
+    }
+  else
+    tst->u.ts_enum.tag.fixtag = tag;
+  tst->u.ts_enum.names = names;
+  tst->u.ts_enum.vals = vals;
+
+  return TRUE;
+}
+
+/* Push a pointer type.  */
+
+static bfd_boolean
+coff_pointer_type (p)
+     PTR p;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst;
+
+#if COFF_DEBUG
+  printf ("coff_pointer_type()\n");
+#endif
+
+  coff_push_type (TS_POINTER);
+
+  return TRUE;
+}
+
+/* Push a function type.  */
+
+static bfd_boolean
+coff_function_type (p, argcount, varargs)
+     PTR p;
+     int argcount;
+     bfd_boolean varargs ATTRIBUTE_UNUSED;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst;
+
+#if COFF_DEBUG
+  printf ("coff_function_type(%d, %d)\n", argcount, varargs);
+#endif
+
+  coff_push_type (TS_FUNC);
+
+  /* FIXME should properly discard function arguments */
+  if (argcount > -1)
+    {
+      fprintf (stderr,
+	       _("coff_function_type() called with positive argcount\n"));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* Push a reference type.  */
+
+static bfd_boolean
+coff_reference_type (p)
+     PTR p;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+
+#if COFF_DEBUG
+  printf ("coff_reference_type()\n");
+#endif
+
+  coff_complain_unsupp (_("reference"));
+
+  return TRUE;
+}
+
+/* Push a range type.  */
+
+static bfd_boolean
+coff_range_type (p, low, high)
+     PTR p;
+     bfd_signed_vma low ATTRIBUTE_UNUSED;
+     bfd_signed_vma high ATTRIBUTE_UNUSED;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+
+#if COFF_DEBUG
+  printf ("coff_range_type([%d..%d)\n", (int)low, (int)high);
+#endif
+
+  coff_complain_unsupp (_("range"));
+
+  return TRUE;
+}
+
+/* Push an array type.  */
+
+static bfd_boolean
+coff_array_type (p, low, high, stringp)
+     PTR p;
+     bfd_signed_vma low;
+     bfd_signed_vma high;
+     bfd_boolean stringp;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst;
+
+#if COFF_DEBUG
+  printf ("coff_array_type([%d..%d], %d)\n",
+	  (int)low, (int)high, stringp);
+#endif
+
+  /* Pop the range type, but ignore it.  COFF doesn't use it. */
+  coff_pop_type ();
+
+  /* FIXME  What to do here? */
+  if (stringp)
+    {
+      fprintf(stderr, _("coff_array_type(): stringp == TRUE\n"));
+      return FALSE;
+    }
+
+  coff_push_type (TS_ARRAY);
+  tst->u.ts_array.low = low;
+  tst->u.ts_array.high = high;
+
+  return TRUE;
+}
+
+/* Push a set type.  */
+
+static bfd_boolean
+coff_set_type (p, bitstringp)
+     PTR p;
+     bfd_boolean bitstringp ATTRIBUTE_UNUSED;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+
+#if COFF_DEBUG
+  printf ("coff_set_type(%d)\n", bitstringp);
+#endif
+
+  coff_complain_unsupp (_("set"));
+
+  return TRUE;
+}
+
+/* Push an offset type.  */
+
+static bfd_boolean
+coff_offset_type (p)
+     PTR p;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+
+#if COFF_DEBUG
+  printf ("coff_offset_type()\n");
+#endif
+
+  coff_complain_unsupp (_("offset"));
+
+  return TRUE;
+}
+
+/* Push a method type.  */
+
+static bfd_boolean
+coff_method_type (p, domainp, argcount, varargs)
+     PTR p;
+     bfd_boolean domainp ATTRIBUTE_UNUSED;
+     int argcount ATTRIBUTE_UNUSED;
+     bfd_boolean varargs ATTRIBUTE_UNUSED;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+
+#if COFF_DEBUG
+  printf ("coff_method_type(%d, %d, %d)\n",
+	  domainp, argcount, varargs);
+#endif
+
+  coff_complain_unsupp (_("method"));
+
+  return TRUE;
+}
+
+/* Push a const version of a type.  */
+
+static bfd_boolean
+coff_const_type (p)
+     PTR p ATTRIBUTE_UNUSED;
+{
+
+#if COFF_DEBUG
+  printf ("coff_const_type()\n");
+#endif
+
+  /* const modifier is ignored by COFF */
+
+  return TRUE;
+}
+
+/* Push a volatile version of a type.  */
+
+static bfd_boolean
+coff_volatile_type (p)
+     PTR p ATTRIBUTE_UNUSED;
+{
+
+#if COFF_DEBUG
+  printf ("coff_volatile_type()\n");
+#endif
+
+  /* volatile modifier is ignored by COFF */
+
+  return TRUE;
+}
+
+/* Start outputting a struct.  */
+
+static bfd_boolean
+coff_start_struct_type (p, tag, id, structp, size)
+     PTR p;
+     const char *tag;
+     unsigned int id;
+     bfd_boolean structp;
+     unsigned int size;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst, *savedts;
+  struct coff_struct_hash_entry *shash;
+  char buf[20];
+  const char *name;
+
+#if COFF_DEBUG
+  printf ("coff_start_struct_type(%s, %d, %d, %d)\n",
+	  tag, id, structp, size);
+#endif
+
+  savedts = info->tstack;
+  info->tstack = NULL;
+
+  coff_push_type (TS_STRUCT);
+
+  if (tag == NULL)
+    {
+      sprintf(buf, ".%dfake", id);
+      name = tst->u.ts_struct.tag.malloctag = xstrdup (buf);
+      tst->u.ts_struct.tagismalloced = TRUE;
+    }
+  else
+    name = tst->u.ts_struct.tag.fixtag = tag;
+  tst->u.ts_struct.id = id;
+  tst->u.ts_struct.isstruct = structp;
+  tst->u.ts_struct.size = size;
+  tst->u.ts_struct.savedts = savedts;
+
+  shash = coff_struct_hash_lookup (&info->structs, name, FALSE, FALSE);
+  if (shash != NULL && shash->types != NULL)
+    {
+#if COFF_DEBUG
+      printf ("new %s definition for %s\n",
+	      tst->u.ts_struct.isstruct? "struct": "union", name);
+#endif
+      coff_free_struct_info (shash, NULL);
+      shash->types = NULL;
+      shash->emitted = FALSE;
+    }
+  else
+    (void)coff_struct_hash_lookup (&info->structs, name,
+			     TRUE, tst->u.ts_struct.tagismalloced);
+
+  return TRUE;
+}
+
+/* Add a field to a struct.  */
+
+static bfd_boolean
+coff_struct_field (p, name, bitpos, bitsize, visibility)
+     PTR p;
+     const char *name;
+     bfd_vma bitpos;
+     bfd_vma bitsize;
+     enum debug_visibility visibility;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst, *otst;
+  struct coff_struct_fields *fp;
+  struct coff_struct_hash_entry *shash;
+  struct coff_enum_hash_entry *ehash;
+  const char *tag;
+
+#if COFF_DEBUG
+  printf ("coff_struct_field(%s, %d, %d, %d)\n",
+	  name, (int)bitpos, (int)bitsize, (int)visibility);
+#endif
+
+  /* Find the last element on the type stack. */
+  assert (info->tstack != NULL);
+  for (tst = info->tstack, otst = NULL; tst->next != NULL;)
+    {
+      otst = tst;
+      tst = tst->next;
+    }
+  if (otst != NULL)
+    otst->next = NULL;
+
+  if (tst->tsk != TS_STRUCT)
+    {
+      fprintf (stderr, "coff_struct_field() not within structure definition\n");
+      return FALSE;
+    }
+  tst->u.ts_struct.fields = (struct coff_struct_fields *)
+    xrealloc (tst->u.ts_struct.fields,
+	      ++tst->u.ts_struct.nfields * sizeof (struct coff_struct_fields));
+  fp = tst->u.ts_struct.fields + (tst->u.ts_struct.nfields - 1);
+  fp->name = name;
+  fp->bitpos = bitpos;
+  fp->bitsize = bitsize;
+  fp->visibility = visibility;
+  otst = fp->types = info->tstack;
+  while (otst->next != NULL)
+    otst = otst->next;
+  if (otst->tsk == TS_STRUCT && otst->u.ts_struct.shash == NULL)
+    {
+      if (otst->u.ts_struct.tagismalloced)
+	tag = otst->u.ts_struct.tag.malloctag;
+      else
+	tag = otst->u.ts_struct.tag.fixtag;
+      shash = coff_struct_hash_lookup (&info->structs, tag, FALSE, FALSE);
+      assert (shash != NULL);
+      if (!shash->emitted)
+	{
+	  if (shash->types == NULL)
+	    {
+	      shash->types = (struct coff_type_stack *)
+		xmalloc (sizeof (struct coff_type_stack));
+	      memcpy (shash->types, otst, sizeof (struct coff_type_stack));
+	    }
+	  shash->emitted = TRUE;
+	  coff_emit_struct (info, otst, shash);
+	}
+    }
+  else if (otst->tsk == TS_ENUM)
+    {
+      if (otst->u.ts_enum.tagismalloced)
+	tag = otst->u.ts_enum.tag.malloctag;
+      else
+	tag = otst->u.ts_enum.tag.fixtag;
+      ehash = coff_enum_hash_lookup (&info->enums, tag, TRUE, FALSE);
+      assert (ehash != NULL);
+      if (!ehash->emitted)
+	{
+	  if (ehash->types == NULL)
+	    {
+	      ehash->types = (struct coff_type_stack *)
+		xmalloc (sizeof (struct coff_type_stack));
+	      memcpy (ehash->types, otst, sizeof (struct coff_type_stack));
+	    }
+	  ehash->emitted = TRUE;
+	  coff_emit_enum (info, otst, ehash);
+	}
+    }
+
+  info->tstack = tst;
+
+  return TRUE;
+}
+
+/* Finish up a struct.  */
+
+static bfd_boolean
+coff_end_struct_type (p)
+     PTR p;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst, *savedts;
+
+#if COFF_DEBUG
+  printf ("coff_end_struct_type()\n");
+#endif
+
+  /* Our struct definition should be the only type stack element by
+     now. */
+  assert (info->tstack != NULL);
+  tst = info->tstack;
+  if (tst->tsk != TS_STRUCT || tst->next != NULL)
+    {
+      fprintf (stderr, "coff_struct_field() not within structure definition\n");
+      return FALSE;
+    }
+
+  /* Restore saved type stack, and push our now complete struct
+     definition on top. */
+  savedts = tst->u.ts_struct.savedts;
+  tst->u.ts_struct.savedts = info->tstack;
+  info->tstack = savedts;
+  tst->next = info->tstack;
+  info->tstack = tst;
+
+  return TRUE;
+}
+
+/* Start outputting a class.  */
+
+static bfd_boolean
+coff_start_class_type (p, tag, id, structp, size, vptr, ownvptr)
+     PTR p;
+     const char *tag ATTRIBUTE_UNUSED;
+     unsigned int id ATTRIBUTE_UNUSED;
+     bfd_boolean structp ATTRIBUTE_UNUSED;
+     unsigned int size ATTRIBUTE_UNUSED;
+     bfd_boolean vptr ATTRIBUTE_UNUSED;
+     bfd_boolean ownvptr ATTRIBUTE_UNUSED;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+
+#if COFF_DEBUG
+  printf ("coff_start_class_type(%s, %d, %d, %d, %d, %d)\n",
+	  tag, id, structp, size, vptr, ownvptr);
+#endif
+
+  coff_complain_unsupp (_("class"));
+
+  return TRUE;
+}
+
+/* Add a static member to the class on the type stack.  */
+
+static bfd_boolean
+coff_class_static_member (p, name, physname, visibility)
+     PTR p ATTRIBUTE_UNUSED;
+     const char *name ATTRIBUTE_UNUSED;
+     const char *physname ATTRIBUTE_UNUSED;
+     enum debug_visibility visibility ATTRIBUTE_UNUSED;
+{
+
+#if COFF_DEBUG
+  printf ("coff_class_static_member(%s, %s, %d)\n",
+	  name, physname, (int)visibility);
+#endif
+
+  return TRUE;
+}
+
+/* Add a base class to the class on the type stack.  */
+
+static bfd_boolean
+coff_class_baseclass (p, bitpos, virtual, visibility)
+     PTR p ATTRIBUTE_UNUSED;
+     bfd_vma bitpos ATTRIBUTE_UNUSED;
+     bfd_boolean virtual ATTRIBUTE_UNUSED;
+     enum debug_visibility visibility ATTRIBUTE_UNUSED;
+{
+
+#if COFF_DEBUG
+  printf ("coff_class_baseclass(%d, %d, %d)\n",
+	  (int)bitpos, virtual, (int)visibility);
+#endif
+
+  return TRUE;
+}
+
+/* Start adding a method to the class on the type stack.  */
+
+static bfd_boolean
+coff_class_start_method (p, name)
+     PTR p ATTRIBUTE_UNUSED;
+     const char *name ATTRIBUTE_UNUSED;
+{
+
+#if COFF_DEBUG
+  printf ("coff_class_start_method(%s)\n", name);
+#endif
+
+  return TRUE;
+}
+
+/* Add a variant to the current method.  */
+
+static bfd_boolean
+coff_class_method_variant (p, physname, visibility, constp, volatilep,
+			   voffset, contextp)
+     PTR p ATTRIBUTE_UNUSED;
+     const char *physname ATTRIBUTE_UNUSED;
+     enum debug_visibility visibility ATTRIBUTE_UNUSED;
+     bfd_boolean constp ATTRIBUTE_UNUSED;
+     bfd_boolean volatilep ATTRIBUTE_UNUSED;
+     bfd_vma voffset ATTRIBUTE_UNUSED;
+     bfd_boolean contextp ATTRIBUTE_UNUSED;
+{
+
+#if COFF_DEBUG
+  printf ("coff_class_method_variant(%s, %d, %d, %d, %d, %d)\n",
+	  physname, (int)visibility, constp, volatilep,
+	  (int)voffset, contextp);
+#endif
+
+  return TRUE;
+}
+
+/* Add a static variant to the current method.  */
+
+static bfd_boolean
+coff_class_static_method_variant (p, physname, visibility, constp, volatilep)
+     PTR p ATTRIBUTE_UNUSED;
+     const char *physname ATTRIBUTE_UNUSED;
+     enum debug_visibility visibility ATTRIBUTE_UNUSED;
+     bfd_boolean constp ATTRIBUTE_UNUSED;
+     bfd_boolean volatilep ATTRIBUTE_UNUSED;
+{
+
+#if COFF_DEBUG
+  printf ("coff_class_static_method_variant(%s, %d, %d, %d)\n",
+	  physname, (int)visibility, constp, volatilep);
+#endif
+
+  return TRUE;
+}
+
+/* Finish up a method.  */
+
+static bfd_boolean
+coff_class_end_method (p)
+     PTR p ATTRIBUTE_UNUSED;
+{
+
+#if COFF_DEBUG
+  printf ("coff_class_end_method()\n");
+#endif
+
+  return TRUE;
+}
+
+/* Finish up a class.  */
+
+static bfd_boolean
+coff_end_class_type (p)
+     PTR p ATTRIBUTE_UNUSED;
+{
+
+#if COFF_DEBUG
+  printf ("coff_end_class_type()\n");
+#endif
+
+  return TRUE;
+}
+
+/* Push a typedef which was previously defined.  */
+
+static bfd_boolean
+coff_typedef_type (p, name)
+     PTR p;
+     const char *name;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_name_type_hash_entry *nthash;
+  struct coff_type_stack *tst, *newchain, *newst, *temp;
+
+#if COFF_DEBUG
+  printf ("coff_typedef_type(%s)\n", name);
+#endif
+
+  nthash = coff_name_type_hash_lookup (&info->types, name, FALSE, FALSE);
+
+  /* nthash should never be NULL, since that would imply that the
+     generic debugging code has asked for a typedef which it has not
+     yet defined.  */
+  assert (nthash != NULL);
+
+  /* Just push the entire type stack snapshot we've got on top of the
+     existing typestack.  See coff_typdef() below for how this
+     works.  We need to copy over each element however, since anybody
+     popping elements off the typestack is supposed to free() each of
+     them. */
+
+  for (tst = nthash->types, temp = newst = newchain = NULL; tst != NULL;)
+    {
+      temp = newst;
+      newst = (struct coff_type_stack *) xmalloc (sizeof (*newst));
+      if (newchain == NULL)
+	newchain = newst;
+      memcpy (newst, tst, sizeof (*newst));
+      if (temp != NULL)
+	temp->next = newst;
+
+      tst = tst->next;
+    }
+  newst->next = info->tstack;
+  info->tstack = newchain;
+
+  return TRUE;
+}
+
+/* Push a struct, union or class tag.  */
+
+static bfd_boolean
+coff_tag_type (p, name, id, kind)
+     PTR p;
+     const char *name;
+     unsigned int id ATTRIBUTE_UNUSED;
+     enum debug_type_kind kind;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst, *newchain, *newst, *temp;
+  struct coff_struct_hash_entry *shash;
+  struct coff_enum_hash_entry *ehash;
+  char buf[20];
+  bfd_boolean needcopy = FALSE;
+  bfd_boolean isstruct = TRUE;
+
+#if COFF_DEBUG
+  printf ("coff_tag_type(%s, %d, %d)\n",
+	  name, id, kind);
+#endif
+
+  if (name == NULL)
+    {
+      sprintf(buf, ".%dfake", id);
+      needcopy = TRUE;
+    }
+
+  switch (kind)
+    {
+    case DEBUG_KIND_UNION:
+    case DEBUG_KIND_UNION_CLASS:
+      isstruct = FALSE;
+      /* FALLTHROUGH */
+    case DEBUG_KIND_STRUCT:
+    case DEBUG_KIND_CLASS:
+      shash = coff_struct_hash_lookup (&info->structs,
+				       name == NULL? buf: name, TRUE, needcopy);
+      assert (shash != NULL);
+      tst = shash->types;
+      if (tst == NULL)
+	{
+	  /* This is a reference to a tag that has not yet been
+	     defined (i. e., a forward reference).  Synthesize a
+	     ts_struct entry by now, and mark it for later fixup. */
+	  tst = (struct coff_type_stack *) xmalloc (sizeof *tst);
+	  memset (tst, 0, sizeof *tst);
+	  tst->tsk = TS_STRUCT;
+	  tst->u.ts_struct.isstruct = isstruct;
+	  tst->u.ts_struct.shash = shash;
+	}
+    docopystack:
+      /* Just push the entire type stack snapshot we've got on top of the
+	 existing typestack.  See coff_typdef() below for how this
+	 works.  We need to copy over each element however, since anybody
+	 popping elements off the typestack is supposed to free() each of
+	 them. */
+      for (temp = newst = newchain = NULL; tst != NULL;)
+	{
+	  temp = newst;
+	  newst = (struct coff_type_stack *) xmalloc (sizeof (*newst));
+	  if (newchain == NULL)
+	    newchain = newst;
+	  memcpy (newst, tst, sizeof (*newst));
+	  if (temp != NULL)
+	    temp->next = newst;
+
+	  tst = tst->next;
+	}
+      if (newst)
+	{
+	  newst->next = info->tstack;
+	  info->tstack = newchain;
+	}
+      break;
+
+    case DEBUG_KIND_ENUM:
+      ehash = coff_enum_hash_lookup (&info->enums,
+				     name == NULL? buf: name, TRUE, needcopy);
+      assert (ehash != NULL);
+      tst = ehash->types;
+      if (tst == NULL)
+	{
+	  /* This is a reference to a tag that has not yet been
+	     defined (i. e., a forward reference).  Synthesize a
+	     ts_enum entry by now, and mark it for later fixup. */
+	  tst = (struct coff_type_stack *) xmalloc (sizeof *tst);
+	  memset (tst, 0, sizeof *tst);
+	  tst->tsk = TS_ENUM;
+	  tst->u.ts_enum.ehash = ehash;
+	}
+      goto docopystack;
+
+    default:
+      fprintf (stderr, _("illegal kind %d in coff_tag_type()\n"),
+	       (int)kind);
+      return FALSE;
+    }
+  return TRUE;
+}
+
+/* Define a typedef.  */
+
+static bfd_boolean
+coff_typdef (p, name)
+     PTR p;
+     const char *name;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_name_type_hash_entry *nthash;
+
+#if COFF_DEBUG
+  printf ("coff_typdef(%s)\n", name);
+#endif
+
+  /* COFF cannot really handle typedefs.  While there is the option to
+     mark a symbol using the storage class C_TPDEF (so the COFF reader
+     will know that name), there is no way to place a reference to
+     that typedef into the just 16 bits COFF reserves for all of its
+     type information.  Thus, any use of the typedef must always fully
+     dereference the typedef again.  We do this by "snapshotting" the
+     current type stack under the name of our typedef, and later on,
+     when BFD debugging tells us to make use of the typedef (in
+     coff_typedef_type()), we just look it up, and push all we've got
+     completely onto the type stack again. */
+
+  if (info->tstack == NULL)
+    {
+      fprintf (stderr, _("coff_typdef() on an empty type stack\n"));
+      return FALSE;
+    }
+
+  nthash = coff_name_type_hash_lookup (&info->types, name, FALSE, FALSE);
+  if (nthash != NULL)
+    {
+#if COFF_DEBUG
+      printf ("new typedef for %s\n", name);
+#endif
+      coff_free_type_info (nthash, NULL);
+    }
+  else
+    nthash = coff_name_type_hash_lookup (&info->types, name, TRUE, FALSE);
+  if (nthash == NULL)
+    return FALSE;
+  nthash->types = info->tstack;
+
+  /* If the typestack is "sufficiently complex", emit a C_TPDEF symbol
+     for it.  We assume it to be sufficiently complex if there are
+     either at least two derived types, or one derived type where the
+     base type is not a simple scalar one. */
+  if (!nthash->emitted
+      && info->tstack->next != NULL
+      && (info->tstack->next->next != NULL || info->tstack->next->tsk >= TS_ENUM))
+    {
+      struct coff_type_stack *newchain, *otst, *tst, *ntst;
+      coff_symbol_type *csymp;
+
+      nthash->emitted = TRUE;
+
+      for (tst = info->tstack, newchain = otst = NULL;
+	   tst != NULL;
+	   tst = tst->next)
+	{
+	  ntst = (struct coff_type_stack *)
+	    xmalloc (sizeof (struct coff_type_stack));
+	  memcpy (ntst, tst, sizeof (struct coff_type_stack));
+	  if (otst == NULL)
+	    newchain = ntst;
+	  else
+	    otst->next = ntst;
+	  otst = ntst;
+	}
+      info->tstack = newchain;
+      if (!coff_make_typed_symbol (info, &csymp, TS_NONE))
+	return FALSE;
+
+      csymp->symbol.name = xstrdup (name);
+      csymp->symbol.flags = BSF_NOT_AT_END;
+      csymp->symbol.section = bfd_com_section_ptr;
+      csymp->native->u.syment.n_sclass = C_TPDEF;
+      csymp->symbol.value = 0;
+
+      coff_record_symbol (info, csymp);
+    }
+  info->tstack = NULL;
+
+  return TRUE;
+}
+
+/* Define a tag.  */
+
+static bfd_boolean
+coff_tag (p, tag)
+     PTR p;
+     const char *tag;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst = NULL;
+  struct coff_struct_hash_entry *shash;
+  struct coff_enum_hash_entry *ehash;
+
+
+#if COFF_DEBUG
+  printf ("coff_tag(%s)\n", tag);
+#endif
+
+  if (info->tstack == NULL)
+    {
+      fprintf (stderr, _("coff_tag() called on an empty typestack\n"));
+      return FALSE;
+    }
+
+  switch (info->tstack->tsk)
+    {
+    case TS_STRUCT:
+      shash = coff_struct_hash_lookup (&info->structs, tag, FALSE, FALSE);
+      assert (shash != NULL);
+      shash->types = info->tstack;
+      info->tstack = NULL;
+      break;
+
+    case TS_ENUM:
+      ehash = coff_enum_hash_lookup (&info->enums, tag, FALSE, FALSE);
+      if (ehash != NULL && ehash->types != NULL)
+	{
+#if COFF_DEBUG
+	  printf ("new enum definition for %s\n", tag);
+#endif
+	  coff_free_enum_info (ehash, NULL);
+	}
+      else
+	ehash = coff_enum_hash_lookup (&info->enums, tag, TRUE, FALSE);
+      if (ehash == NULL)
+	return FALSE;
+      ehash->types = info->tstack;
+      info->tstack = NULL;
+      break;
+
+    default:
+      fprintf (stderr, _("Illegal typestack (%d) in coff_tag()\n"), tst->tsk);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/* Define an integer constant.  */
+
+static bfd_boolean
+coff_int_constant (p, name, val)
+     PTR p;
+     const char *name ATTRIBUTE_UNUSED;
+     bfd_vma val ATTRIBUTE_UNUSED;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+
+#if COFF_DEBUG
+  printf ("coff_int_constant(%s, %d)\n", name, (int)val);
+#endif
+
+  coff_complain_unsupp (_("int constant"));
+
+  return TRUE;
+}
+
+/* Define a floating point constant.  */
+
+static bfd_boolean
+coff_float_constant (p, name, val)
+     PTR p;
+     const char *name ATTRIBUTE_UNUSED;
+     double val ATTRIBUTE_UNUSED;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+
+#if COFF_DEBUG
+  printf ("coff_float_constant(%s, %g)\n", name, val);
+#endif
+
+  coff_complain_unsupp (_("float constant"));
+
+  return TRUE;
+}
+
+/* Define a typed constant.  */
+
+static bfd_boolean
+coff_typed_constant (p, name, val)
+     PTR p;
+     const char *name ATTRIBUTE_UNUSED;
+     bfd_vma val ATTRIBUTE_UNUSED;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+
+#if COFF_DEBUG
+  printf ("coff_typed_constant(%s, %d)\n", name, (int)val);
+#endif
+
+  coff_complain_unsupp (_("typed constant"));
+
+  return TRUE;
+}
+
+/* Record a variable.  */
+
+static bfd_boolean
+coff_variable (p, name, kind, val)
+     PTR p;
+     const char *name;
+     enum debug_var_kind kind;
+     bfd_vma val;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  unsigned char class;
+  asymbol *symp = NULL;
+  coff_symbol_type *csymp;
+  bfd_boolean global = FALSE;
+  flagword flags = BSF_LOCAL;
+  bfd_vma vmadiff = 0;
+
+#if COFF_DEBUG
+  printf ("coff_variable(%s, %d, %d)\n",
+	  name, (int)kind, (int)val);
+#endif
+
+  switch (kind)
+    {
+    default:
+      abort ();
+
+    case DEBUG_GLOBAL:
+      flags = BSF_GLOBAL;
+      global = TRUE;
+      /* AVR COFF historically used C_EXTDEF for global variables, and
+	 C_EXT for global functions.  Since some AVR COFF consumers
+	 apparently depend on this, we mimic this behaviour as
+	 well. */
+      class = info->flags & COFF_FL_AVR? C_EXTDEF: C_EXT;
+      break;
+
+    case DEBUG_STATIC:
+    case DEBUG_LOCAL_STATIC:
+      class = C_STAT;
+      break;
+
+    case DEBUG_LOCAL:
+      class = C_AUTO;
+      break;
+
+    case DEBUG_REGISTER:
+      class = C_REG;
+      break;
+    }
+
+  if (!coff_make_typed_symbol (info, &csymp, TS_NONE))
+    return FALSE;
+
+  if (class == C_REG && (info->flags & COFF_FL_AVR) != 0)
+    {
+      struct coff_private_symdata *priv = (struct coff_private_symdata *)
+	csymp->symbol.udata.p;
+      val = coff_fixup_avr_register (val, priv->size * 8);
+    }
+
+  csymp->symbol.name = name;
+  csymp->symbol.flags = flags;	/* Note: this clears BSF_DEBUGGING. */
+
+  /* Match the debugging symbol against the input symtab symbols.  If
+     we found one, use the section information from it.  Otherwise, we
+     are lost here and just use the absolute section that was
+     predeclared by coff_bfd_make_debug_symbol().  C_REG and C_AUTO
+     symbols (which we do not attempt to lookup in the symtab symbols
+     at all) go into the ABS section anyway. */
+  if (class != C_REG && class != C_AUTO)
+    {
+      symp = coff_find_symbol (info, name, FALSE, global);
+      if (symp)
+	{
+	  csymp->symbol.section = symp->section;
+	  vmadiff = symp->section->vma;
+	}
+    }
+
+  /* Symbols are relative to section vma. */
+  csymp->symbol.value = val - vmadiff;
+  csymp->native->u.syment.n_sclass = class;
+  coff_record_symbol (info, csymp);
+
+  return TRUE;
+}
+
+/* Start outputting a function.  */
+
+static bfd_boolean
+coff_start_function (p, name, globalp)
+     PTR p;
+     const char *name;
+     bfd_boolean globalp;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst, *savedts;
+
+#if COFF_DEBUG
+  printf ("coff_start_function(%s, %d)\n",
+	  name, globalp);
+#endif
+
+  savedts = info->tstack;
+  info->tstack = NULL;
+
+  coff_push_type (TS_FUNC);
+
+  if (info->funname != NULL)
+    {
+      fprintf (stderr,
+	       _("coff_start_function() called twice, pending %s, new %s\n"),
+	       info->funname, name);
+      return FALSE;
+    }
+  info->funname = name;
+  info->funglobal = globalp;
+  info->flags |= COFF_FL_START_FCN;
+  tst->u.ts_func.savedts = savedts;
+
+  return TRUE;
+}
+
+/* Output a function parameter.  */
+
+static bfd_boolean
+coff_function_parameter (p, name, kind, val)
+     PTR p;
+     const char *name;
+     enum debug_parm_kind kind;
+     bfd_vma val;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  coff_symbol_type *csymp;
+  unsigned char class;
+
+#if COFF_DEBUG
+  printf ("coff_function_parameter(%s, %d, %d)\n",
+	  name, (int)kind, (int)val);
+#endif
+
+  switch (kind)
+    {
+    default:
+      abort ();
+
+    case DEBUG_PARM_STACK:
+      class = C_ARG;
+      break;
+
+    case DEBUG_PARM_REG:
+      class = C_REGPARM;
+      break;
+
+    case DEBUG_PARM_REFERENCE:
+    case DEBUG_PARM_REF_REG:
+      fprintf (stderr, _("Reference parameters not available in COFF\n"));
+      return TRUE;
+    }
+
+  if (!coff_make_typed_symbol (info, &csymp, TS_FUNC))
+    return FALSE;
+
+  if (class == C_REGPARM && (info->flags & COFF_FL_AVR) != 0)
+    {
+      struct coff_private_symdata *priv = (struct coff_private_symdata *)
+	csymp->symbol.udata.p;
+      val = coff_fixup_avr_register (val, priv->size * 8);
+    }
+
+  csymp->symbol.name = name;
+  csymp->symbol.value = val;
+  csymp->symbol.flags |= BSF_LOCAL;
+  csymp->native->u.syment.n_sclass = class;
+
+  /* Since function parameters precede the actual function definition,
+     defer their output until the function has been created. */
+  info->fargs = (coff_symbol_type **)
+    xrealloc (info->fargs, ++info->nfargs * sizeof (coff_symbol_type *));
+  info->fargs[info->nfargs - 1] = csymp;
+
+  return TRUE;
+}
+
+/* Start a block.  */
+
+static bfd_boolean
+coff_start_block (p, addr)
+     PTR p;
+     bfd_vma addr;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  struct coff_type_stack *tst, *otst;
+  struct coff_fix_stack *fixp, *ofp;
+  asymbol *symp;
+  coff_symbol_type *csymp;
+  unsigned int i;
+  bfd_boolean is_start_fcn;
+
+#if COFF_DEBUG
+  printf ("coff_start_block(%#x)\n", (int)addr);
+#endif
+
+  is_start_fcn = info->flags & COFF_FL_START_FCN;
+
+  if (is_start_fcn)
+    {
+      /* This is the starting block of a function.  We are going to
+         write three symbols here, one for the function itself, one
+         ".bf" symbol to indicate the begin of the function, and
+         finally one ".bb" for the first block inside the function. */
+      info->flags &= ~COFF_FL_START_FCN;
+
+      /* Our function definition should be the only type stack element
+	 by now. */
+      assert (info->tstack != NULL);
+      tst = info->tstack;
+      if (tst->tsk != TS_FUNC || tst->next != NULL)
+	{
+	  fprintf (stderr,
+		   _("coff_start_block() not within function definition\n"));
+	  return FALSE;
+	}
+
+      /* Restore saved type stack, and push our now complete function
+	 definition on top. */
+      info->tstack = tst->u.ts_func.savedts;
+      tst->next = info->tstack;
+      info->tstack = tst;
+
+      if (info->currentfile == NULL)
+	{
+	  fprintf (stderr,
+		   _("Warning: ignoring function %s() outside any compilation unit\n"),
+		   info->funname);
+	  for (tst = info->tstack, otst = NULL; tst != NULL;)
+	    {
+	      otst = tst;
+	      tst = otst->next;
+	      if (otst->tsk == TS_ENUM &&
+		  otst->u.ts_enum.tagismalloced)
+		free (otst->u.ts_enum.tag.malloctag);
+	      else if (otst->tsk == TS_STRUCT &&
+		       otst->u.ts_struct.tagismalloced)
+		free (otst->u.ts_struct.tag.malloctag);
+	      free (otst);
+	    }
+	  info->tstack = NULL;
+	  info->funname = NULL;
+
+	  return TRUE;
+	}
+
+      if (!coff_make_typed_symbol (info, &csymp, TS_NONE))
+	return FALSE;
+
+      csymp->symbol.name = info->funname;
+      csymp->symbol.flags = BSF_FUNCTION |
+	(info->funglobal? BSF_GLOBAL: BSF_LOCAL);
+      symp = coff_find_symbol (info, info->funname, TRUE, info->funglobal);
+      if (symp == NULL)
+	{
+	  fprintf (stderr,
+		   _("function %s not found in symbol table, defaulting to \"text\" section\n"),
+		   info->funname);
+	  csymp->symbol.section = info->funcsection = info->textsect;
+	}
+      else
+	csymp->symbol.section = info->funcsection = symp->section;
+
+      /* Symbol addresses are relative to section vma. */
+      csymp->symbol.value = addr - info->funcsection->vma;
+      csymp->native->u.syment.n_sclass = info->funglobal? C_EXT: C_STAT;
+      /* Create two initial line number entries.  The first one holds
+	 the function symbol, the second one is the trailing record
+	 that is required by coffgen.c::coff_write_native_symbol() to
+	 have a line number of zero. */
+      csymp->lineno = (alent *) xmalloc (2 * sizeof (alent));
+      memset (csymp->lineno, 0, 2 * sizeof (alent));
+      info->nlnos = 2;
+      info->totlnos++;
+      csymp->lineno[0].u.sym = (asymbol *)csymp;
+      coff_record_symbol (info, csymp);
+      info->funcindex = info->nsyms - 1; /* remember for later */
+      /* Record our endndx field for later fixing. */
+      fixp = (struct coff_fix_stack *) xmalloc (sizeof (struct coff_fix_stack));
+      fixp->native = csymp->native + 1;	/* points to first AUX */
+      fixp->next = NULL;
+      if (info->fixes == NULL)
+	info->fixes = fixp;
+      else
+	{
+	  for (ofp = info->fixes; ofp->next != NULL;)
+	    ofp = ofp->next;
+	  ofp->next = fixp;
+	}
+
+      csymp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+      if (csymp == NULL)
+	return FALSE;
+
+      csymp->symbol.name = ".bf";
+      csymp->native->u.syment.n_sclass = C_FCN;
+      csymp->native->u.syment.n_numaux = 1;
+      csymp->symbol.value = addr - info->funcsection->vma;
+      csymp->symbol.section = info->funcsection;
+      csymp->symbol.udata.p = NULL;
+      coff_record_symbol (info, csymp);
+    }
+
+  if (info->funname == NULL)
+    return TRUE;
+
+  csymp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+  if (csymp == NULL)
+    return FALSE;
+
+  csymp->symbol.name = ".bb";
+  csymp->native->u.syment.n_sclass = C_BLOCK;
+  csymp->native->u.syment.n_numaux = 1;
+  csymp->symbol.value = addr - info->funcsection->vma;
+  csymp->symbol.section = info->funcsection;
+  csymp->symbol.udata.p = NULL;
+  coff_record_symbol (info, csymp);
+
+  info->flags |= COFF_FL_FIX_BB;
+
+  /* Output any pending function parameters, if any. */
+  if (is_start_fcn && info->nfargs)
+    {
+      for (i = 0; i < info->nfargs; i++)
+	coff_record_symbol (info, info->fargs[i]);
+
+      free (info->fargs);
+      info->fargs = NULL;
+      info->nfargs = 0;
+    }
+
+  return TRUE;
+}
+
+/* End a block.  */
+
+static bfd_boolean
+coff_end_block (p, addr)
+     PTR p;
+     bfd_vma addr;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  coff_symbol_type *csymp;
+  union internal_auxent *aux;
+
+#if COFF_DEBUG
+  printf ("coff_end_block(%#x)\n", (int)addr);
+#endif
+
+  if (info->funname == NULL)
+    return TRUE;
+
+  csymp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+  if (csymp == NULL)
+    return FALSE;
+
+  csymp->symbol.name = ".eb";
+  csymp->symbol.value = addr - info->funcsection->vma;
+  csymp->native->u.syment.n_sclass = C_BLOCK;
+  csymp->native->u.syment.n_numaux = 1;
+  csymp->symbol.udata.p = NULL;
+  csymp->symbol.section = info->funcsection;
+  aux = &((csymp->native + 1)->u.auxent);
+  aux->x_sym.x_misc.x_lnsz.x_lnno = info->lastlno;
+  coff_record_symbol (info, csymp);
+
+  info->endaddr = addr;
+
+  return TRUE;
+}
+
+/* End a function.  */
+
+static bfd_boolean
+coff_end_function (p)
+     PTR p;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  coff_symbol_type *csymp;
+  union internal_auxent *aux;
+
+#if COFF_DEBUG
+  printf ("coff_end_function()\n");
+#endif
+
+  if (info->funname == NULL)
+    return TRUE;
+
+  csymp = (coff_symbol_type *) coff_bfd_make_debug_symbol (info->abfd, 0, 0);
+  if (csymp == NULL)
+    return FALSE;
+
+  csymp->symbol.name = ".ef";
+  csymp->symbol.value = info->endaddr - info->funcsection->vma;
+  csymp->native->u.syment.n_sclass = C_FCN;
+  csymp->native->u.syment.n_numaux = 1;
+  csymp->symbol.udata.p = NULL;
+  csymp->symbol.section = info->funcsection;
+  aux = &((csymp->native + 1)->u.auxent);
+  aux->x_sym.x_misc.x_lnsz.x_lnno = info->lastlno;
+
+  coff_record_symbol (info, csymp);
+
+  csymp = (coff_symbol_type *) info->syms[info->funcindex];
+  aux = &((csymp->native + 1)->u.auxent);
+  aux->x_sym.x_misc.x_fsize = info->endaddr - csymp->symbol.value;
+
+  info->flags |= COFF_FL_FIX_ENDNDX;
+  info->funname = NULL;
+
+  return TRUE;
+}
+
+/* Output a line number.  */
+
+static bfd_boolean
+coff_lineno (p, file, lineno, addr)
+     PTR p;
+     const char *file ATTRIBUTE_UNUSED;
+     unsigned long lineno;
+     bfd_vma addr;
+{
+  struct coff_write_handle *info = (struct coff_write_handle *) p;
+  coff_symbol_type *csymp;
+  union internal_auxent *aux;
+  long i;
+
+#if COFF_DEBUG
+  printf ("coff_lineno(%s, %ld, %d)\n",
+	  file, lineno, (int)addr);
+#endif
+
+  /* COFF can inherently only handle line numbers inside of functions.
+     If we are not inside a function, punt. */
+  if (info->funname == NULL)
+    return TRUE;
+
+  if (info->nlnos == 2)
+    {
+      /* This is the first line number of this function.  Fix the line
+	 number for the .bf symbol immediately following the start of
+	 function.  We also have to remember the starting line number
+	 of our function since all line number entries are relative to
+	 it in COFF.  Since regular line numbers must always be
+	 non-zero, we artificially force the function to start one
+	 line earlier. */
+      csymp = (coff_symbol_type *) info->syms[info->funcindex + 1];
+      aux = &((csymp->native + 1)->u.auxent);
+      aux->x_sym.x_misc.x_lnsz.x_lnno = lineno;
+      info->funlno = lineno - 1;
+    }
+
+  if (info->flags & COFF_FL_FIX_BB)
+    {
+      /* This is the first line number after one (or more) .bb
+	 symbols.  Fix them.  In order to cope with multiple blocks
+	 starting at the same line number, we walk back the list of
+	 symbols until we find a C_BLOCK one that had already been
+	 fixed, or until we find a C_FCN symbol (presumably, the start
+	 of our current function). */
+      info->flags &= ~COFF_FL_FIX_BB;
+
+      for (i = info->nsyms - 1; i >= 0; i--)
+	{
+	  csymp = (coff_symbol_type *) info->syms[i];
+	  if (csymp->native->u.syment.n_sclass == C_FCN)
+	    break;
+	  if (csymp->native->u.syment.n_sclass == C_BLOCK)
+	    {
+	      aux = &((csymp->native + 1)->u.auxent);
+	      if (aux->x_sym.x_misc.x_lnsz.x_lnno != 0)
+		/* already set up properly */
+		break;
+	      aux->x_sym.x_misc.x_lnsz.x_lnno = lineno;
+	    }
+	}
+    }
+
+  csymp = (coff_symbol_type *) info->syms[info->funcindex];
+  csymp->lineno = (alent *) xrealloc (csymp->lineno,
+				      ++info->nlnos * sizeof (alent));
+  memset (csymp->lineno + info->nlnos - 1, 0, sizeof (alent));
+  if (lineno > info->funlno)
+    csymp->lineno[info->nlnos - 2].line_number = lineno - info->funlno;
+  else
+    /* Line number unreasonable.  Can e. g. happen for a line number
+       from an include file, which we cannot process in COFF.  Just
+       set it to the first line, to avoid generating a large unsigned
+       short (~ 65000) line number. */
+    csymp->lineno[info->nlnos - 2].line_number = 1;
+  csymp->lineno[info->nlnos - 2].u.offset = addr;
+
+  info->lastlno = lineno;
+  info->totlnos++;
+
+  return TRUE;
+}
diff -urN binutils-2.20.1.old/gas/config/tc-avr.c binutils-2.20.1/gas/config/tc-avr.c
--- binutils-2.20.1.old/gas/config/tc-avr.c	2009-09-09 03:13:29.000000000 -0500
+++ binutils-2.20.1/gas/config/tc-avr.c	2010-04-13 09:49:42.341947494 -0500
@@ -27,20 +27,21 @@
 
 struct avr_opcodes_s
 {
-  char *        name;
-  char *        constraints;
-  int           insn_size;		/* In words.  */
-  int           isa;
+  char *name;
+  char *constraints;
+  char *opcode;
+  int insn_size;		/* In words.  */
+  int isa;
   unsigned int  bin_opcode;
 };
 
 #define AVR_INSN(NAME, CONSTR, OPCODE, SIZE, ISA, BIN) \
-{#NAME, CONSTR, SIZE, ISA, BIN},
+{#NAME, CONSTR, OPCODE, SIZE, ISA, BIN},
 
 struct avr_opcodes_s avr_opcodes[] =
 {
   #include "opcode/avr.h"
-  {NULL, NULL, 0, 0, 0}
+  {NULL, NULL, NULL, 0, 0, 0}
 };
 
 const char comment_chars[] = ";";
@@ -79,6 +80,13 @@
   {"avr5",       AVR_ISA_AVR51,   bfd_mach_avr5},
   {"avr51",      AVR_ISA_AVR51,   bfd_mach_avr51},
   {"avr6",       AVR_ISA_AVR6,    bfd_mach_avr6},
+  {"avrxmega1",  AVR_ISA_XMEGA,   bfd_mach_avrxmega1},
+  {"avrxmega2",  AVR_ISA_XMEGA,   bfd_mach_avrxmega2},
+  {"avrxmega3",  AVR_ISA_XMEGA,   bfd_mach_avrxmega3},
+  {"avrxmega4",  AVR_ISA_XMEGA,   bfd_mach_avrxmega4},
+  {"avrxmega5",  AVR_ISA_XMEGA,   bfd_mach_avrxmega5},
+  {"avrxmega6",  AVR_ISA_XMEGA,   bfd_mach_avrxmega6},
+  {"avrxmega7",  AVR_ISA_XMEGA,   bfd_mach_avrxmega7},
   {"at90s1200",  AVR_ISA_1200,    bfd_mach_avr1},
   {"attiny11",   AVR_ISA_AVR1,    bfd_mach_avr1},
   {"attiny12",   AVR_ISA_AVR1,    bfd_mach_avr1},
@@ -215,6 +223,21 @@
   {"m3001b",     AVR_ISA_AVR51,   bfd_mach_avr51},
   {"atmega2560", AVR_ISA_AVR6,    bfd_mach_avr6},
   {"atmega2561", AVR_ISA_AVR6,    bfd_mach_avr6},
+  {"atxmega16a4", AVR_ISA_XMEGA,  bfd_mach_avrxmega2},
+  {"atxmega16d4", AVR_ISA_XMEGA,  bfd_mach_avrxmega2},
+  {"atxmega32d4", AVR_ISA_XMEGA,  bfd_mach_avrxmega2},
+  {"atxmega32a4", AVR_ISA_XMEGA,  bfd_mach_avrxmega3},
+  {"atxmega64a3", AVR_ISA_XMEGA,  bfd_mach_avrxmega4},
+  {"atxmega64d3", AVR_ISA_XMEGA,  bfd_mach_avrxmega4},
+  {"atxmega64a1", AVR_ISA_XMEGA,  bfd_mach_avrxmega5},
+  {"atxmega128a3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
+  {"atxmega128d3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
+  {"atxmega192a3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
+  {"atxmega192d3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
+  {"atxmega256a3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
+  {"atxmega256a3b",AVR_ISA_XMEGA, bfd_mach_avrxmega6},
+  {"atxmega256d3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
+  {"atxmega128a1", AVR_ISA_XMEGA, bfd_mach_avrxmega7},
   {NULL, 0, 0}
 };
 
@@ -392,6 +415,11 @@
 	"                   avr5  - enhanced AVR core with up to 64K program memory\n"
 	"                   avr51 - enhanced AVR core with up to 128K program memory\n"
 	"                   avr6  - enhanced AVR core with up to 256K program memory\n"
+	"                   avrxmega3 - XMEGA, > 8K, <= 64K FLASH, > 64K RAM\n"
+	"                   avrxmega4 - XMEGA, > 64K, <= 128K FLASH, <= 64K RAM\n"
+	"                   avrxmega5 - XMEGA, > 64K, <= 128K FLASH, > 64K RAM\n"
+	"                   avrxmega6 - XMEGA, > 128K, <= 256K FLASH, <= 64K RAM\n"
+	"                   avrxmega7 - XMEGA, > 128K, <= 256K FLASH, > 64K RAM\n"
 	"                   or immediate microcontroller name.\n"));
   fprintf (stream,
       _("  -mall-opcodes    accept all AVR opcodes, even if not supported by MCU\n"
@@ -819,7 +847,12 @@
       if (*str == '+')
 	{
 	  ++str;
-	  op_mask |= 1;
+          char *s;
+          for (s = opcode->opcode; *s; ++s)
+            {
+              if (*s == '+')
+                op_mask |= (1 << (15 - (s - opcode->opcode)));
+            }
 	}
 
       /* attiny26 can do "lpm" and "lpm r,Z" but not "lpm r,Z+".  */
@@ -936,6 +969,16 @@
       }
       break;
 
+    case 'E':
+      {
+	unsigned int x;
+
+	x = avr_get_constant (str, 15);
+	str = input_line_pointer;
+	op_mask |= (x << 4);
+      }
+      break;
+    
     case '?':
       break;
 
diff -urN binutils-2.20.1.old/gas/config/tc-avr.c.orig binutils-2.20.1/gas/config/tc-avr.c.orig
--- binutils-2.20.1.old/gas/config/tc-avr.c.orig	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/gas/config/tc-avr.c.orig	2009-09-09 03:13:29.000000000 -0500
@@ -0,0 +1,1460 @@
+/* tc-avr.c -- Assembler code for the ATMEL AVR
+
+   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009
+   Free Software Foundation, Inc.
+   Contributed by Denis Chertykov <denisc@overta.ru>
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "as.h"
+#include "safe-ctype.h"
+#include "subsegs.h"
+
+struct avr_opcodes_s
+{
+  char *        name;
+  char *        constraints;
+  int           insn_size;		/* In words.  */
+  int           isa;
+  unsigned int  bin_opcode;
+};
+
+#define AVR_INSN(NAME, CONSTR, OPCODE, SIZE, ISA, BIN) \
+{#NAME, CONSTR, SIZE, ISA, BIN},
+
+struct avr_opcodes_s avr_opcodes[] =
+{
+  #include "opcode/avr.h"
+  {NULL, NULL, 0, 0, 0}
+};
+
+const char comment_chars[] = ";";
+const char line_comment_chars[] = "#";
+const char line_separator_chars[] = "$";
+
+const char *md_shortopts = "m:";
+struct mcu_type_s
+{
+  char *name;
+  int isa;
+  int mach;
+};
+
+/* XXX - devices that don't seem to exist (renamed, replaced with larger
+   ones, or planned but never produced), left here for compatibility.  */
+
+static struct mcu_type_s mcu_types[] =
+{
+  {"avr1",       AVR_ISA_AVR1,    bfd_mach_avr1},
+/* TODO: insruction set for avr2 architecture should be AVR_ISA_AVR2,
+ but set to AVR_ISA_AVR25 for some following version 
+ of GCC (from 4.3) for backward compatibility.  */  
+  {"avr2",       AVR_ISA_AVR25,   bfd_mach_avr2},
+  {"avr25",      AVR_ISA_AVR25,   bfd_mach_avr25},
+/* TODO: insruction set for avr3 architecture should be AVR_ISA_AVR3, 
+ but set to AVR_ISA_AVR3_ALL for some following version 
+ of GCC (from 4.3) for backward compatibility.  */
+  {"avr3",       AVR_ISA_AVR3_ALL, bfd_mach_avr3},
+  {"avr31",      AVR_ISA_AVR31,   bfd_mach_avr31},
+  {"avr35",      AVR_ISA_AVR35,   bfd_mach_avr35},
+  {"avr4",       AVR_ISA_AVR4,    bfd_mach_avr4},
+/* TODO: insruction set for avr5 architecture should be AVR_ISA_AVR5, 
+ but set to AVR_ISA_AVR51 for some following version 
+ of GCC (from 4.3) for backward compatibility.  */
+  {"avr5",       AVR_ISA_AVR51,   bfd_mach_avr5},
+  {"avr51",      AVR_ISA_AVR51,   bfd_mach_avr51},
+  {"avr6",       AVR_ISA_AVR6,    bfd_mach_avr6},
+  {"at90s1200",  AVR_ISA_1200,    bfd_mach_avr1},
+  {"attiny11",   AVR_ISA_AVR1,    bfd_mach_avr1},
+  {"attiny12",   AVR_ISA_AVR1,    bfd_mach_avr1},
+  {"attiny15",   AVR_ISA_AVR1,    bfd_mach_avr1},
+  {"attiny28",   AVR_ISA_AVR1,    bfd_mach_avr1},
+  {"at90s2313",  AVR_ISA_AVR2,    bfd_mach_avr2},
+  {"at90s2323",  AVR_ISA_AVR2,    bfd_mach_avr2},
+  {"at90s2333",  AVR_ISA_AVR2,    bfd_mach_avr2}, /* XXX -> 4433 */
+  {"at90s2343",  AVR_ISA_AVR2,    bfd_mach_avr2},
+  {"attiny22",   AVR_ISA_AVR2,    bfd_mach_avr2}, /* XXX -> 2343 */
+  {"attiny26",   AVR_ISA_2xxe,    bfd_mach_avr2},
+  {"at90s4414",  AVR_ISA_AVR2,    bfd_mach_avr2}, /* XXX -> 8515 */
+  {"at90s4433",  AVR_ISA_AVR2,    bfd_mach_avr2},
+  {"at90s4434",  AVR_ISA_AVR2,    bfd_mach_avr2}, /* XXX -> 8535 */
+  {"at90s8515",  AVR_ISA_AVR2,    bfd_mach_avr2},
+  {"at90c8534",  AVR_ISA_AVR2,    bfd_mach_avr2},
+  {"at90s8535",  AVR_ISA_AVR2,    bfd_mach_avr2},
+  {"attiny13",   AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny13a",  AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny2313", AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny2313a",AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny24",   AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny24a",  AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny4313", AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny44",   AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny44a",  AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny84",   AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny25",   AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny45",   AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny85",   AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny261",  AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny261a", AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny461",  AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny861",  AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny861a", AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny87",   AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny43u",  AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny48",   AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"attiny88",   AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"at86rf401",  AVR_ISA_RF401,   bfd_mach_avr25},
+  {"ata6289",    AVR_ISA_AVR25,   bfd_mach_avr25},
+  {"at43usb355", AVR_ISA_AVR3,    bfd_mach_avr3},
+  {"at76c711",   AVR_ISA_AVR3,    bfd_mach_avr3},
+  {"atmega103",  AVR_ISA_AVR31,   bfd_mach_avr31},
+  {"at43usb320", AVR_ISA_AVR31,   bfd_mach_avr31},
+  {"attiny167",  AVR_ISA_AVR35,   bfd_mach_avr35},
+  {"attiny327",  AVR_ISA_AVR35,   bfd_mach_avr35},
+  {"at90usb82",  AVR_ISA_AVR35,   bfd_mach_avr35},
+  {"at90usb162", AVR_ISA_AVR35,   bfd_mach_avr35},
+  {"atmega8u2",  AVR_ISA_AVR35,   bfd_mach_avr35},
+  {"atmega16u2", AVR_ISA_AVR35,   bfd_mach_avr35},
+  {"atmega32u2", AVR_ISA_AVR35,   bfd_mach_avr35},
+  {"atmega8",    AVR_ISA_M8,      bfd_mach_avr4},
+  {"atmega48",   AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"atmega48p",  AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"atmega88",   AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"atmega88p",  AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"atmega8515", AVR_ISA_M8,      bfd_mach_avr4},
+  {"atmega8535", AVR_ISA_M8,      bfd_mach_avr4},
+  {"atmega8hva", AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"atmega4hvd", AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"atmega8hvd", AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"atmega8c1",  AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"atmega8m1",  AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"at90pwm1",   AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"at90pwm2",   AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"at90pwm2b",  AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"at90pwm3",   AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"at90pwm3b",  AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"at90pwm81",  AVR_ISA_AVR4,    bfd_mach_avr4},
+  {"atmega16",   AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega161",  AVR_ISA_M161,    bfd_mach_avr5},
+  {"atmega162",  AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega163",  AVR_ISA_M161,    bfd_mach_avr5},
+  {"atmega164p", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega165",  AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega165p", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega168",  AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega168p", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega169",  AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega169p", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega16c1", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega32",   AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega323",  AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega324p", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega325",  AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega325p", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega3250", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega3250p",AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega328p", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega329",  AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega329p", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega3290", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega3290p",AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega406",  AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega64",   AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega640",  AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega644",  AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega644p", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega644pa",AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega645",  AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega649",  AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega6450", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega6490", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega16hva",AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega16hvb",AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega32hvb",AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"at90can32" , AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"at90can64" , AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"at90pwm216", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"at90pwm316", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega32c1", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega64c1", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega16m1", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega32m1", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega64m1", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega16u4", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega32u4", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"atmega32u6", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"at90usb646", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"at90usb647", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"at90scr100", AVR_ISA_AVR5,    bfd_mach_avr5},
+  {"at94k",      AVR_ISA_94K,     bfd_mach_avr5},
+  {"atmega128",  AVR_ISA_AVR51,   bfd_mach_avr51},
+  {"atmega1280", AVR_ISA_AVR51,   bfd_mach_avr51},
+  {"atmega1281", AVR_ISA_AVR51,   bfd_mach_avr51},
+  {"atmega1284p",AVR_ISA_AVR51,   bfd_mach_avr51},
+  {"atmega128rfa1",AVR_ISA_AVR51, bfd_mach_avr51},
+  {"at90can128", AVR_ISA_AVR51,   bfd_mach_avr51},
+  {"at90usb1286",AVR_ISA_AVR51,   bfd_mach_avr51},
+  {"at90usb1287",AVR_ISA_AVR51,   bfd_mach_avr51},
+  {"m3000f",     AVR_ISA_AVR51,   bfd_mach_avr51},
+  {"m3000s",     AVR_ISA_AVR51,   bfd_mach_avr51},
+  {"m3001b",     AVR_ISA_AVR51,   bfd_mach_avr51},
+  {"atmega2560", AVR_ISA_AVR6,    bfd_mach_avr6},
+  {"atmega2561", AVR_ISA_AVR6,    bfd_mach_avr6},
+  {NULL, 0, 0}
+};
+
+/* Current MCU type.  */
+static struct mcu_type_s   default_mcu = {"avr2", AVR_ISA_AVR2, bfd_mach_avr2};
+static struct mcu_type_s * avr_mcu = & default_mcu;
+
+/* AVR target-specific switches.  */
+struct avr_opt_s
+{
+  int all_opcodes;  /* -mall-opcodes: accept all known AVR opcodes.  */
+  int no_skip_bug;  /* -mno-skip-bug: no warnings for skipping 2-word insns.  */
+  int no_wrap;      /* -mno-wrap: reject rjmp/rcall with 8K wrap-around.  */
+};
+
+static struct avr_opt_s avr_opt = { 0, 0, 0 };
+
+const char EXP_CHARS[] = "eE";
+const char FLT_CHARS[] = "dD";
+
+static void avr_set_arch (int);
+
+/* The target specific pseudo-ops which we support.  */
+const pseudo_typeS md_pseudo_table[] =
+{
+  {"arch", avr_set_arch,	0},
+  { NULL,	NULL,		0}
+};
+
+#define LDI_IMMEDIATE(x) (((x) & 0xf) | (((x) << 4) & 0xf00))
+
+#define EXP_MOD_NAME(i)       exp_mod[i].name
+#define EXP_MOD_RELOC(i)      exp_mod[i].reloc
+#define EXP_MOD_NEG_RELOC(i)  exp_mod[i].neg_reloc
+#define HAVE_PM_P(i)          exp_mod[i].have_pm
+
+struct exp_mod_s
+{
+  char *                    name;
+  bfd_reloc_code_real_type  reloc;
+  bfd_reloc_code_real_type  neg_reloc;
+  int                       have_pm;
+};
+
+static struct exp_mod_s exp_mod[] =
+{
+  {"hh8",    BFD_RELOC_AVR_HH8_LDI,    BFD_RELOC_AVR_HH8_LDI_NEG,    1},
+  {"pm_hh8", BFD_RELOC_AVR_HH8_LDI_PM, BFD_RELOC_AVR_HH8_LDI_PM_NEG, 0},
+  {"hi8",    BFD_RELOC_AVR_HI8_LDI,    BFD_RELOC_AVR_HI8_LDI_NEG,    1},
+  {"pm_hi8", BFD_RELOC_AVR_HI8_LDI_PM, BFD_RELOC_AVR_HI8_LDI_PM_NEG, 0},
+  {"lo8",    BFD_RELOC_AVR_LO8_LDI,    BFD_RELOC_AVR_LO8_LDI_NEG,    1},
+  {"pm_lo8", BFD_RELOC_AVR_LO8_LDI_PM, BFD_RELOC_AVR_LO8_LDI_PM_NEG, 0},
+  {"hlo8",   BFD_RELOC_AVR_HH8_LDI,    BFD_RELOC_AVR_HH8_LDI_NEG,    0},
+  {"hhi8",   BFD_RELOC_AVR_MS8_LDI,    BFD_RELOC_AVR_MS8_LDI_NEG,    0},
+};
+
+/* A union used to store indicies into the exp_mod[] array
+   in a hash table which expects void * data types.  */
+typedef union
+{
+  void * ptr;
+  int    index;
+} mod_index;
+
+/* Opcode hash table.  */
+static struct hash_control *avr_hash;
+
+/* Reloc modifiers hash control (hh8,hi8,lo8,pm_xx).  */
+static struct hash_control *avr_mod_hash;
+
+#define OPTION_MMCU 'm'
+enum options
+{
+  OPTION_ALL_OPCODES = OPTION_MD_BASE + 1,
+  OPTION_NO_SKIP_BUG,
+  OPTION_NO_WRAP
+};
+
+struct option md_longopts[] =
+{
+  { "mmcu",   required_argument, NULL, OPTION_MMCU        },
+  { "mall-opcodes", no_argument, NULL, OPTION_ALL_OPCODES },
+  { "mno-skip-bug", no_argument, NULL, OPTION_NO_SKIP_BUG },
+  { "mno-wrap",     no_argument, NULL, OPTION_NO_WRAP     },
+  { NULL, no_argument, NULL, 0 }
+};
+
+size_t md_longopts_size = sizeof (md_longopts);
+
+/* Display nicely formatted list of known MCU names.  */
+
+static void
+show_mcu_list (FILE *stream)
+{
+  int i, x;
+
+  fprintf (stream, _("Known MCU names:"));
+  x = 1000;
+
+  for (i = 0; mcu_types[i].name; i++)
+    {
+      int len = strlen (mcu_types[i].name);
+
+      x += len + 1;
+
+      if (x < 75)
+	fprintf (stream, " %s", mcu_types[i].name);
+      else
+	{
+	  fprintf (stream, "\n  %s", mcu_types[i].name);
+	  x = len + 2;
+	}
+    }
+
+  fprintf (stream, "\n");
+}
+
+static inline char *
+skip_space (char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    ++s;
+  return s;
+}
+
+/* Extract one word from FROM and copy it to TO.  */
+
+static char *
+extract_word (char *from, char *to, int limit)
+{
+  char *op_start;
+  char *op_end;
+  int size = 0;
+
+  /* Drop leading whitespace.  */
+  from = skip_space (from);
+  *to = 0;
+
+  /* Find the op code end.  */
+  for (op_start = op_end = from; *op_end != 0 && is_part_of_name (*op_end);)
+    {
+      to[size++] = *op_end++;
+      if (size + 1 >= limit)
+	break;
+    }
+
+  to[size] = 0;
+  return op_end;
+}
+
+int
+md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
+			       asection *seg ATTRIBUTE_UNUSED)
+{
+  abort ();
+  return 0;
+}
+
+void
+md_show_usage (FILE *stream)
+{
+  fprintf (stream,
+      _("AVR options:\n"
+	"  -mmcu=[avr-name] select microcontroller variant\n"
+	"                   [avr-name] can be:\n"
+	"                   avr1  - classic AVR core without data RAM\n"
+	"                   avr2  - classic AVR core with up to 8K program memory\n"
+	"                   avr25 - classic AVR core with up to 8K program memory\n"
+	"                           plus the MOVW instruction\n"
+	"                   avr3  - classic AVR core with up to 64K program memory\n"
+	"                   avr31 - classic AVR core with up to 128K program memory\n"
+	"                   avr35 - classic AVR core with up to 64K program memory\n"
+	"                           plus the MOVW instruction\n"
+	"                   avr4  - enhanced AVR core with up to 8K program memory\n"
+	"                   avr5  - enhanced AVR core with up to 64K program memory\n"
+	"                   avr51 - enhanced AVR core with up to 128K program memory\n"
+	"                   avr6  - enhanced AVR core with up to 256K program memory\n"
+	"                   or immediate microcontroller name.\n"));
+  fprintf (stream,
+      _("  -mall-opcodes    accept all AVR opcodes, even if not supported by MCU\n"
+	"  -mno-skip-bug    disable warnings for skipping two-word instructions\n"
+	"                   (default for avr4, avr5)\n"
+	"  -mno-wrap        reject rjmp/rcall instructions with 8K wrap-around\n"
+	"                   (default for avr3, avr5)\n"));
+  show_mcu_list (stream);
+}
+
+static void
+avr_set_arch (int dummy ATTRIBUTE_UNUSED)
+{
+  char str[20];
+
+  input_line_pointer = extract_word (input_line_pointer, str, 20);
+  md_parse_option (OPTION_MMCU, str);
+  bfd_set_arch_mach (stdoutput, TARGET_ARCH, avr_mcu->mach);
+}
+
+int
+md_parse_option (int c, char *arg)
+{
+  switch (c)
+    {
+    case OPTION_MMCU:
+      {
+	int i;
+	char *s = alloca (strlen (arg) + 1);
+
+	{
+	  char *t = s;
+	  char *arg1 = arg;
+
+	  do
+	    *t = TOLOWER (*arg1++);
+	  while (*t++);
+	}
+
+	for (i = 0; mcu_types[i].name; ++i)
+	  if (strcmp (mcu_types[i].name, s) == 0)
+	    break;
+
+	if (!mcu_types[i].name)
+	  {
+	    show_mcu_list (stderr);
+	    as_fatal (_("unknown MCU: %s\n"), arg);
+	  }
+
+	/* It is OK to redefine mcu type within the same avr[1-5] bfd machine
+	   type - this for allows passing -mmcu=... via gcc ASM_SPEC as well
+	   as .arch ... in the asm output at the same time.  */
+	if (avr_mcu == &default_mcu || avr_mcu->mach == mcu_types[i].mach)
+	  avr_mcu = &mcu_types[i];
+	else
+	  as_fatal (_("redefinition of mcu type `%s' to `%s'"),
+		    avr_mcu->name, mcu_types[i].name);
+	return 1;
+      }
+    case OPTION_ALL_OPCODES:
+      avr_opt.all_opcodes = 1;
+      return 1;
+    case OPTION_NO_SKIP_BUG:
+      avr_opt.no_skip_bug = 1;
+      return 1;
+    case OPTION_NO_WRAP:
+      avr_opt.no_wrap = 1;
+      return 1;
+    }
+
+  return 0;
+}
+
+symbolS *
+md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
+{
+  return NULL;
+}
+
+char *
+md_atof (int type, char *litP, int *sizeP)
+{
+  return ieee_md_atof (type, litP, sizeP, FALSE);
+}
+
+void
+md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
+		 asection *sec ATTRIBUTE_UNUSED,
+		 fragS *fragP ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+md_begin (void)
+{
+  unsigned int i;
+  struct avr_opcodes_s *opcode;
+
+  avr_hash = hash_new ();
+
+  /* Insert unique names into hash table.  This hash table then provides a
+     quick index to the first opcode with a particular name in the opcode
+     table.  */
+  for (opcode = avr_opcodes; opcode->name; opcode++)
+    hash_insert (avr_hash, opcode->name, (char *) opcode);
+
+  avr_mod_hash = hash_new ();
+
+  for (i = 0; i < ARRAY_SIZE (exp_mod); ++i)
+    {
+      mod_index m;
+
+      m.index = i + 10;
+      hash_insert (avr_mod_hash, EXP_MOD_NAME (i), m.ptr);
+    }
+
+  bfd_set_arch_mach (stdoutput, TARGET_ARCH, avr_mcu->mach);
+}
+
+/* Resolve STR as a constant expression and return the result.
+   If result greater than MAX then error.  */
+
+static unsigned int
+avr_get_constant (char *str, int max)
+{
+  expressionS ex;
+
+  str = skip_space (str);
+  input_line_pointer = str;
+  expression (& ex);
+
+  if (ex.X_op != O_constant)
+    as_bad (_("constant value required"));
+
+  if (ex.X_add_number > max || ex.X_add_number < 0)
+    as_bad (_("number must be positive and less than %d"), max + 1);
+
+  return ex.X_add_number;
+}
+
+/* Parse for ldd/std offset.  */
+
+static void
+avr_offset_expression (expressionS *exp)
+{
+  char *str = input_line_pointer;
+  char *tmp;
+  char op[8];
+
+  tmp = str;
+  str = extract_word (str, op, sizeof (op));
+
+  input_line_pointer = tmp;
+  expression (exp);
+
+  /* Warn about expressions that fail to use lo8 ().  */
+  if (exp->X_op == O_constant)
+    {
+      int x = exp->X_add_number;
+
+      if (x < -255 || x > 255)
+	as_warn (_("constant out of 8-bit range: %d"), x);
+    }
+}
+
+/* Parse ordinary expression.  */
+
+static char *
+parse_exp (char *s, expressionS *op)
+{
+  input_line_pointer = s;
+  expression (op);
+  if (op->X_op == O_absent)
+    as_bad (_("missing operand"));
+  return input_line_pointer;
+}
+
+/* Parse special expressions (needed for LDI command):
+   xx8 (address)
+   xx8 (-address)
+   pm_xx8 (address)
+   pm_xx8 (-address)
+   where xx is: hh, hi, lo.  */
+
+static bfd_reloc_code_real_type
+avr_ldi_expression (expressionS *exp)
+{
+  char *str = input_line_pointer;
+  char *tmp;
+  char op[8];
+  int mod;
+  int linker_stubs_should_be_generated = 0;
+
+  tmp = str;
+
+  str = extract_word (str, op, sizeof (op));
+
+  if (op[0])
+    {
+      mod_index m;
+
+      m.ptr = hash_find (avr_mod_hash, op);
+      mod = m.index;
+
+      if (mod)
+	{
+	  int closes = 0;
+
+	  mod -= 10;
+	  str = skip_space (str);
+
+	  if (*str == '(')
+	    {
+	      bfd_reloc_code_real_type  reloc_to_return;
+	      int neg_p = 0;
+
+	      ++str;
+
+	      if (strncmp ("pm(", str, 3) == 0
+                  || strncmp ("gs(",str,3) == 0
+                  || strncmp ("-(gs(",str,5) == 0
+		  || strncmp ("-(pm(", str, 5) == 0)
+		{
+		  if (HAVE_PM_P (mod))
+		    {
+		      ++mod;
+		      ++closes;
+		    }
+		  else
+		    as_bad (_("illegal expression"));
+
+                  if (str[0] == 'g' || str[2] == 'g')
+                    linker_stubs_should_be_generated = 1;
+
+		  if (*str == '-')
+		    {
+		      neg_p = 1;
+		      ++closes;
+		      str += 5;
+		    }
+		  else
+		    str += 3;
+		}
+
+	      if (*str == '-' && *(str + 1) == '(')
+		{
+		  neg_p ^= 1;
+		  ++closes;
+		  str += 2;
+		}
+
+	      input_line_pointer = str;
+	      expression (exp);
+
+	      do
+		{
+		  if (*input_line_pointer != ')')
+		    {
+		      as_bad (_("`)' required"));
+		      break;
+		    }
+		  input_line_pointer++;
+		}
+	      while (closes--);
+
+	      reloc_to_return =
+		neg_p ? EXP_MOD_NEG_RELOC (mod) : EXP_MOD_RELOC (mod);
+	      if (linker_stubs_should_be_generated)
+		{
+		  switch (reloc_to_return)
+		    {
+		    case BFD_RELOC_AVR_LO8_LDI_PM:
+		      reloc_to_return = BFD_RELOC_AVR_LO8_LDI_GS;
+		      break;
+		    case BFD_RELOC_AVR_HI8_LDI_PM:
+		      reloc_to_return = BFD_RELOC_AVR_HI8_LDI_GS;
+		      break;
+
+		    default:
+		      /* PR 5523: Do not generate a warning here,
+			 legitimate code can trigger this case.  */
+		      break;
+		    }
+		}
+	      return reloc_to_return;
+	    }
+	}
+    }
+
+  input_line_pointer = tmp;
+  expression (exp);
+
+  /* Warn about expressions that fail to use lo8 ().  */
+  if (exp->X_op == O_constant)
+    {
+      int x = exp->X_add_number;
+
+      if (x < -255 || x > 255)
+	as_warn (_("constant out of 8-bit range: %d"), x);
+    }
+
+  return BFD_RELOC_AVR_LDI;
+}
+
+/* Parse one instruction operand.
+   Return operand bitmask.  Also fixups can be generated.  */
+
+static unsigned int
+avr_operand (struct avr_opcodes_s *opcode,
+	     int where,
+	     char *op,
+	     char **line)
+{
+  expressionS op_expr;
+  unsigned int op_mask = 0;
+  char *str = skip_space (*line);
+
+  switch (*op)
+    {
+      /* Any register operand.  */
+    case 'w':
+    case 'd':
+    case 'r':
+    case 'a':
+    case 'v':
+      if (*str == 'r' || *str == 'R')
+	{
+	  char r_name[20];
+
+	  str = extract_word (str, r_name, sizeof (r_name));
+	  op_mask = 0xff;
+	  if (ISDIGIT (r_name[1]))
+	    {
+	      if (r_name[2] == '\0')
+		op_mask = r_name[1] - '0';
+	      else if (r_name[1] != '0'
+		       && ISDIGIT (r_name[2])
+		       && r_name[3] == '\0')
+		op_mask = (r_name[1] - '0') * 10 + r_name[2] - '0';
+	    }
+	}
+      else
+	{
+	  op_mask = avr_get_constant (str, 31);
+	  str = input_line_pointer;
+	}
+
+      if (op_mask <= 31)
+	{
+	  switch (*op)
+	    {
+	    case 'a':
+	      if (op_mask < 16 || op_mask > 23)
+		as_bad (_("register r16-r23 required"));
+	      op_mask -= 16;
+	      break;
+
+	    case 'd':
+	      if (op_mask < 16)
+		as_bad (_("register number above 15 required"));
+	      op_mask -= 16;
+	      break;
+
+	    case 'v':
+	      if (op_mask & 1)
+		as_bad (_("even register number required"));
+	      op_mask >>= 1;
+	      break;
+
+	    case 'w':
+	      if ((op_mask & 1) || op_mask < 24)
+		as_bad (_("register r24, r26, r28 or r30 required"));
+	      op_mask = (op_mask - 24) >> 1;
+	      break;
+	    }
+	  break;
+	}
+      as_bad (_("register name or number from 0 to 31 required"));
+      break;
+
+    case 'e':
+      {
+	char c;
+
+	if (*str == '-')
+	  {
+	    str = skip_space (str + 1);
+	    op_mask = 0x1002;
+	  }
+	c = TOLOWER (*str);
+	if (c == 'x')
+	  op_mask |= 0x100c;
+	else if (c == 'y')
+	  op_mask |= 0x8;
+	else if (c != 'z')
+	  as_bad (_("pointer register (X, Y or Z) required"));
+
+	str = skip_space (str + 1);
+	if (*str == '+')
+	  {
+	    ++str;
+	    if (op_mask & 2)
+	      as_bad (_("cannot both predecrement and postincrement"));
+	    op_mask |= 0x1001;
+	  }
+
+	/* avr1 can do "ld r,Z" and "st Z,r" but no other pointer
+	   registers, no predecrement, no postincrement.  */
+	if (!avr_opt.all_opcodes && (op_mask & 0x100F)
+	    && !(avr_mcu->isa & AVR_ISA_SRAM))
+	  as_bad (_("addressing mode not supported"));
+      }
+      break;
+
+    case 'z':
+      if (*str == '-')
+	as_bad (_("can't predecrement"));
+
+      if (! (*str == 'z' || *str == 'Z'))
+	as_bad (_("pointer register Z required"));
+
+      str = skip_space (str + 1);
+
+      if (*str == '+')
+	{
+	  ++str;
+	  op_mask |= 1;
+	}
+
+      /* attiny26 can do "lpm" and "lpm r,Z" but not "lpm r,Z+".  */
+      if (!avr_opt.all_opcodes
+	  && (op_mask & 0x0001)
+	  && !(avr_mcu->isa & AVR_ISA_MOVW))
+	as_bad (_("postincrement not supported"));
+      break;
+
+    case 'b':
+      {
+	char c = TOLOWER (*str++);
+
+	if (c == 'y')
+	  op_mask |= 0x8;
+	else if (c != 'z')
+	  as_bad (_("pointer register (Y or Z) required"));
+	str = skip_space (str);
+	if (*str++ == '+')
+	  {
+	    input_line_pointer = str;
+	    avr_offset_expression (& op_expr);
+	    str = input_line_pointer;
+	    fix_new_exp (frag_now, where, 3,
+			 &op_expr, FALSE, BFD_RELOC_AVR_6);
+	  }
+      }
+      break;
+
+    case 'h':
+      str = parse_exp (str, &op_expr);
+      fix_new_exp (frag_now, where, opcode->insn_size * 2,
+		   &op_expr, FALSE, BFD_RELOC_AVR_CALL);
+      break;
+
+    case 'L':
+      str = parse_exp (str, &op_expr);
+      fix_new_exp (frag_now, where, opcode->insn_size * 2,
+		   &op_expr, TRUE, BFD_RELOC_AVR_13_PCREL);
+      break;
+
+    case 'l':
+      str = parse_exp (str, &op_expr);
+      fix_new_exp (frag_now, where, opcode->insn_size * 2,
+		   &op_expr, TRUE, BFD_RELOC_AVR_7_PCREL);
+      break;
+
+    case 'i':
+      str = parse_exp (str, &op_expr);
+      fix_new_exp (frag_now, where + 2, opcode->insn_size * 2,
+		   &op_expr, FALSE, BFD_RELOC_16);
+      break;
+
+    case 'M':
+      {
+	bfd_reloc_code_real_type r_type;
+
+	input_line_pointer = str;
+	r_type = avr_ldi_expression (&op_expr);
+	str = input_line_pointer;
+	fix_new_exp (frag_now, where, 3,
+		     &op_expr, FALSE, r_type);
+      }
+      break;
+
+    case 'n':
+      {
+	unsigned int x;
+
+	x = ~avr_get_constant (str, 255);
+	str = input_line_pointer;
+	op_mask |= (x & 0xf) | ((x << 4) & 0xf00);
+      }
+      break;
+
+    case 'K':
+      input_line_pointer = str;
+      avr_offset_expression (& op_expr);
+      str = input_line_pointer;
+      fix_new_exp (frag_now, where, 3,
+		   & op_expr, FALSE, BFD_RELOC_AVR_6_ADIW);
+      break;
+
+    case 'S':
+    case 's':
+      {
+	unsigned int x;
+
+	x = avr_get_constant (str, 7);
+	str = input_line_pointer;
+	if (*op == 'S')
+	  x <<= 4;
+	op_mask |= x;
+      }
+      break;
+
+    case 'P':
+      {
+	unsigned int x;
+
+	x = avr_get_constant (str, 63);
+	str = input_line_pointer;
+	op_mask |= (x & 0xf) | ((x & 0x30) << 5);
+      }
+      break;
+
+    case 'p':
+      {
+	unsigned int x;
+
+	x = avr_get_constant (str, 31);
+	str = input_line_pointer;
+	op_mask |= x << 3;
+      }
+      break;
+
+    case '?':
+      break;
+
+    default:
+      as_bad (_("unknown constraint `%c'"), *op);
+    }
+
+  *line = str;
+  return op_mask;
+}
+
+/* Parse instruction operands.
+   Return binary opcode.  */
+
+static unsigned int
+avr_operands (struct avr_opcodes_s *opcode, char **line)
+{
+  char *op = opcode->constraints;
+  unsigned int bin = opcode->bin_opcode;
+  char *frag = frag_more (opcode->insn_size * 2);
+  char *str = *line;
+  int where = frag - frag_now->fr_literal;
+  static unsigned int prev = 0;  /* Previous opcode.  */
+
+  /* Opcode have operands.  */
+  if (*op)
+    {
+      unsigned int reg1 = 0;
+      unsigned int reg2 = 0;
+      int reg1_present = 0;
+      int reg2_present = 0;
+
+      /* Parse first operand.  */
+      if (REGISTER_P (*op))
+	reg1_present = 1;
+      reg1 = avr_operand (opcode, where, op, &str);
+      ++op;
+
+      /* Parse second operand.  */
+      if (*op)
+	{
+	  if (*op == ',')
+	    ++op;
+
+	  if (*op == '=')
+	    {
+	      reg2 = reg1;
+	      reg2_present = 1;
+	    }
+	  else
+	    {
+	      if (REGISTER_P (*op))
+		reg2_present = 1;
+
+	      str = skip_space (str);
+	      if (*str++ != ',')
+		as_bad (_("`,' required"));
+	      str = skip_space (str);
+
+	      reg2 = avr_operand (opcode, where, op, &str);
+	    }
+
+	  if (reg1_present && reg2_present)
+	    reg2 = (reg2 & 0xf) | ((reg2 << 5) & 0x200);
+	  else if (reg2_present)
+	    reg2 <<= 4;
+	}
+      if (reg1_present)
+	reg1 <<= 4;
+      bin |= reg1 | reg2;
+    }
+
+  /* Detect undefined combinations (like ld r31,Z+).  */
+  if (!avr_opt.all_opcodes && AVR_UNDEF_P (bin))
+    as_warn (_("undefined combination of operands"));
+
+  if (opcode->insn_size == 2)
+    {
+      /* Warn if the previous opcode was cpse/sbic/sbis/sbrc/sbrs
+         (AVR core bug, fixed in the newer devices).  */
+      if (!(avr_opt.no_skip_bug ||
+            (avr_mcu->isa & (AVR_ISA_MUL | AVR_ISA_MOVW)))
+	  && AVR_SKIP_P (prev))
+	as_warn (_("skipping two-word instruction"));
+
+      bfd_putl32 ((bfd_vma) bin, frag);
+    }
+  else
+    bfd_putl16 ((bfd_vma) bin, frag);
+
+  prev = bin;
+  *line = str;
+  return bin;
+}
+
+/* GAS will call this function for each section at the end of the assembly,
+   to permit the CPU backend to adjust the alignment of a section.  */
+
+valueT
+md_section_align (asection *seg, valueT addr)
+{
+  int align = bfd_get_section_alignment (stdoutput, seg);
+  return ((addr + (1 << align) - 1) & (-1 << align));
+}
+
+/* If you define this macro, it should return the offset between the
+   address of a PC relative fixup and the position from which the PC
+   relative adjustment should be made.  On many processors, the base
+   of a PC relative instruction is the next instruction, so this
+   macro would return the length of an instruction.  */
+
+long
+md_pcrel_from_section (fixS *fixp, segT sec)
+{
+  if (fixp->fx_addsy != (symbolS *) NULL
+      && (!S_IS_DEFINED (fixp->fx_addsy)
+	  || (S_GET_SEGMENT (fixp->fx_addsy) != sec)))
+    return 0;
+
+  return fixp->fx_frag->fr_address + fixp->fx_where;
+}
+
+/* GAS will call this for each fixup.  It should store the correct
+   value in the object file.  */
+
+void
+md_apply_fix (fixS *fixP, valueT * valP, segT seg)
+{
+  unsigned char *where;
+  unsigned long insn;
+  long value = *valP;
+
+  if (fixP->fx_addsy == (symbolS *) NULL)
+    fixP->fx_done = 1;
+
+  else if (fixP->fx_pcrel)
+    {
+      segT s = S_GET_SEGMENT (fixP->fx_addsy);
+
+      if (s == seg || s == absolute_section)
+	{
+	  value += S_GET_VALUE (fixP->fx_addsy);
+	  fixP->fx_done = 1;
+	}
+    }
+
+  /* We don't actually support subtracting a symbol.  */
+  if (fixP->fx_subsy != (symbolS *) NULL)
+    as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));
+
+  switch (fixP->fx_r_type)
+    {
+    default:
+      fixP->fx_no_overflow = 1;
+      break;
+    case BFD_RELOC_AVR_7_PCREL:
+    case BFD_RELOC_AVR_13_PCREL:
+    case BFD_RELOC_32:
+    case BFD_RELOC_16:
+    case BFD_RELOC_AVR_CALL:
+      break;
+    }
+
+  if (fixP->fx_done)
+    {
+      /* Fetch the instruction, insert the fully resolved operand
+	 value, and stuff the instruction back again.  */
+      where = (unsigned char *) fixP->fx_frag->fr_literal + fixP->fx_where;
+      insn = bfd_getl16 (where);
+
+      switch (fixP->fx_r_type)
+	{
+	case BFD_RELOC_AVR_7_PCREL:
+	  if (value & 1)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("odd address operand: %ld"), value);
+
+	  /* Instruction addresses are always right-shifted by 1.  */
+	  value >>= 1;
+	  --value;			/* Correct PC.  */
+
+	  if (value < -64 || value > 63)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("operand out of range: %ld"), value);
+	  value = (value << 3) & 0x3f8;
+	  bfd_putl16 ((bfd_vma) (value | insn), where);
+	  break;
+
+	case BFD_RELOC_AVR_13_PCREL:
+	  if (value & 1)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("odd address operand: %ld"), value);
+
+	  /* Instruction addresses are always right-shifted by 1.  */
+	  value >>= 1;
+	  --value;			/* Correct PC.  */
+
+	  if (value < -2048 || value > 2047)
+	    {
+	      /* No wrap for devices with >8K of program memory.  */
+	      if ((avr_mcu->isa & AVR_ISA_MEGA) || avr_opt.no_wrap)
+		as_bad_where (fixP->fx_file, fixP->fx_line,
+			      _("operand out of range: %ld"), value);
+	    }
+
+	  value &= 0xfff;
+	  bfd_putl16 ((bfd_vma) (value | insn), where);
+	  break;
+
+	case BFD_RELOC_32:
+	  bfd_putl16 ((bfd_vma) value, where);
+	  break;
+
+	case BFD_RELOC_16:
+	  bfd_putl16 ((bfd_vma) value, where);
+	  break;
+
+	case BFD_RELOC_AVR_16_PM:
+	  bfd_putl16 ((bfd_vma) (value >> 1), where);
+	  break;
+
+	case BFD_RELOC_AVR_LDI:
+	  if (value > 255)
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("operand out of range: %ld"), value);
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value), where);
+	  break;
+
+	case BFD_RELOC_AVR_6:
+	  if ((value > 63) || (value < 0))
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("operand out of range: %ld"), value);
+	  bfd_putl16 ((bfd_vma) insn | ((value & 7) | ((value & (3 << 3)) << 7) | ((value & (1 << 5)) << 8)), where);
+	  break;
+
+	case BFD_RELOC_AVR_6_ADIW:
+	  if ((value > 63) || (value < 0))
+	    as_bad_where (fixP->fx_file, fixP->fx_line,
+			  _("operand out of range: %ld"), value);
+	  bfd_putl16 ((bfd_vma) insn | (value & 0xf) | ((value & 0x30) << 2), where);
+	  break;
+
+	case BFD_RELOC_AVR_LO8_LDI:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value), where);
+	  break;
+
+	case BFD_RELOC_AVR_HI8_LDI:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 8), where);
+	  break;
+
+	case BFD_RELOC_AVR_MS8_LDI:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 24), where);
+	  break;
+
+	case BFD_RELOC_AVR_HH8_LDI:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 16), where);
+	  break;
+
+	case BFD_RELOC_AVR_LO8_LDI_NEG:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value), where);
+	  break;
+
+	case BFD_RELOC_AVR_HI8_LDI_NEG:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 8), where);
+	  break;
+
+	case BFD_RELOC_AVR_MS8_LDI_NEG:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 24), where);
+	  break;
+
+	case BFD_RELOC_AVR_HH8_LDI_NEG:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 16), where);
+	  break;
+
+	case BFD_RELOC_AVR_LO8_LDI_PM:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 1), where);
+	  break;
+
+	case BFD_RELOC_AVR_HI8_LDI_PM:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 9), where);
+	  break;
+
+	case BFD_RELOC_AVR_HH8_LDI_PM:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value >> 17), where);
+	  break;
+
+	case BFD_RELOC_AVR_LO8_LDI_PM_NEG:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 1), where);
+	  break;
+
+	case BFD_RELOC_AVR_HI8_LDI_PM_NEG:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 9), where);
+	  break;
+
+	case BFD_RELOC_AVR_HH8_LDI_PM_NEG:
+	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (-value >> 17), where);
+	  break;
+
+	case BFD_RELOC_AVR_CALL:
+	  {
+	    unsigned long x;
+
+	    x = bfd_getl16 (where);
+	    if (value & 1)
+	      as_bad_where (fixP->fx_file, fixP->fx_line,
+			    _("odd address operand: %ld"), value);
+	    value >>= 1;
+	    x |= ((value & 0x10000) | ((value << 3) & 0x1f00000)) >> 16;
+	    bfd_putl16 ((bfd_vma) x, where);
+	    bfd_putl16 ((bfd_vma) (value & 0xffff), where + 2);
+	  }
+	  break;
+
+	default:
+	  as_fatal (_("line %d: unknown relocation type: 0x%x"),
+		    fixP->fx_line, fixP->fx_r_type);
+	  break;
+	}
+    }
+  else
+    {
+      switch ((int) fixP->fx_r_type)
+	{
+	case -BFD_RELOC_AVR_HI8_LDI_NEG:
+	case -BFD_RELOC_AVR_HI8_LDI:
+	case -BFD_RELOC_AVR_LO8_LDI_NEG:
+	case -BFD_RELOC_AVR_LO8_LDI:
+	  as_bad_where (fixP->fx_file, fixP->fx_line,
+			_("only constant expression allowed"));
+	  fixP->fx_done = 1;
+	  break;
+	default:
+	  break;
+	}
+    }
+}
+
+/* GAS will call this to generate a reloc, passing the resulting reloc
+   to `bfd_install_relocation'.  This currently works poorly, as
+   `bfd_install_relocation' often does the wrong thing, and instances of
+   `tc_gen_reloc' have been written to work around the problems, which
+   in turns makes it difficult to fix `bfd_install_relocation'.  */
+
+/* If while processing a fixup, a reloc really needs to be created
+   then it is done here.  */
+
+arelent *
+tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED,
+	      fixS *fixp)
+{
+  arelent *reloc;
+
+  if (fixp->fx_addsy && fixp->fx_subsy)
+    {
+      long value = 0;
+
+      if ((S_GET_SEGMENT (fixp->fx_addsy) != S_GET_SEGMENT (fixp->fx_subsy))
+          || S_GET_SEGMENT (fixp->fx_addsy) == undefined_section)
+        {
+          as_bad_where (fixp->fx_file, fixp->fx_line,
+              "Difference of symbols in different sections is not supported");
+          return NULL;
+        }
+
+      /* We are dealing with two symbols defined in the same section.
+         Let us fix-up them here.  */
+      value += S_GET_VALUE (fixp->fx_addsy);
+      value -= S_GET_VALUE (fixp->fx_subsy);
+
+      /* When fx_addsy and fx_subsy both are zero, md_apply_fix
+         only takes it's second operands for the fixup value.  */
+      fixp->fx_addsy = NULL;
+      fixp->fx_subsy = NULL;
+      md_apply_fix (fixp, (valueT *) &value, NULL);
+
+      return NULL;
+    }
+
+  reloc = xmalloc (sizeof (arelent));
+
+  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+
+  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+  if (reloc->howto == (reloc_howto_type *) NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+		    _("reloc %d not supported by object file format"),
+		    (int) fixp->fx_r_type);
+      return NULL;
+    }
+
+  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    reloc->address = fixp->fx_offset;
+
+  reloc->addend = fixp->fx_offset;
+
+  return reloc;
+}
+
+void
+md_assemble (char *str)
+{
+  struct avr_opcodes_s *opcode;
+  char op[11];
+
+  str = skip_space (extract_word (str, op, sizeof (op)));
+
+  if (!op[0])
+    as_bad (_("can't find opcode "));
+
+  opcode = (struct avr_opcodes_s *) hash_find (avr_hash, op);
+
+  if (opcode == NULL)
+    {
+      as_bad (_("unknown opcode `%s'"), op);
+      return;
+    }
+
+  /* Special case for opcodes with optional operands (lpm, elpm) -
+     version with operands exists in avr_opcodes[] in the next entry.  */
+
+  if (*str && *opcode->constraints == '?')
+    ++opcode;
+
+  if (!avr_opt.all_opcodes && (opcode->isa & avr_mcu->isa) != opcode->isa)
+    as_bad (_("illegal opcode %s for mcu %s"), opcode->name, avr_mcu->name);
+
+  dwarf2_emit_insn (0);
+
+  /* We used to set input_line_pointer to the result of get_operands,
+     but that is wrong.  Our caller assumes we don't change it.  */
+  {
+    char *t = input_line_pointer;
+
+    avr_operands (opcode, &str);
+    if (*skip_space (str))
+      as_bad (_("garbage at end of line"));
+    input_line_pointer = t;
+  }
+}
+
+/* Flag to pass `pm' mode between `avr_parse_cons_expression' and
+   `avr_cons_fix_new'.  */
+static int exp_mod_pm = 0;
+
+/* Parse special CONS expression: pm (expression)
+   or alternatively: gs (expression).
+   These are used for addressing program memory.
+   Relocation: BFD_RELOC_AVR_16_PM.  */
+
+void
+avr_parse_cons_expression (expressionS *exp, int nbytes)
+{
+  char *tmp;
+
+  exp_mod_pm = 0;
+
+  tmp = input_line_pointer = skip_space (input_line_pointer);
+
+  if (nbytes == 2)
+    {
+      char *pm_name1 = "pm";
+      char *pm_name2 = "gs";
+      int len = strlen (pm_name1);
+      /* len must be the same for both pm identifiers.  */
+
+      if (strncasecmp (input_line_pointer, pm_name1, len) == 0
+          || strncasecmp (input_line_pointer, pm_name2, len) == 0)
+	{
+	  input_line_pointer = skip_space (input_line_pointer + len);
+
+	  if (*input_line_pointer == '(')
+	    {
+	      input_line_pointer = skip_space (input_line_pointer + 1);
+	      exp_mod_pm = 1;
+	      expression (exp);
+
+	      if (*input_line_pointer == ')')
+		++input_line_pointer;
+	      else
+		{
+		  as_bad (_("`)' required"));
+		  exp_mod_pm = 0;
+		}
+
+	      return;
+	    }
+
+	  input_line_pointer = tmp;
+	}
+    }
+
+  expression (exp);
+}
+
+void
+avr_cons_fix_new (fragS *frag,
+		  int where,
+		  int nbytes,
+		  expressionS *exp)
+{
+  if (exp_mod_pm == 0)
+    {
+      if (nbytes == 2)
+	fix_new_exp (frag, where, nbytes, exp, FALSE, BFD_RELOC_16);
+      else if (nbytes == 4)
+	fix_new_exp (frag, where, nbytes, exp, FALSE, BFD_RELOC_32);
+      else
+	as_bad (_("illegal %srelocation size: %d"), "", nbytes);
+    }
+  else
+    {
+      if (nbytes == 2)
+	fix_new_exp (frag, where, nbytes, exp, FALSE, BFD_RELOC_AVR_16_PM);
+      else
+	as_bad (_("illegal %srelocation size: %d"), "`pm' ", nbytes);
+      exp_mod_pm = 0;
+    }
+}
diff -urN binutils-2.20.1.old/gas/doc/c-avr.texi binutils-2.20.1/gas/doc/c-avr.texi
--- binutils-2.20.1.old/gas/doc/c-avr.texi	2009-09-02 02:24:21.000000000 -0500
+++ binutils-2.20.1/gas/doc/c-avr.texi	2010-04-13 09:49:42.341947494 -0500
@@ -80,6 +80,27 @@
 Instruction set avr6 is for the enhanced AVR core with a 3-byte PC (MCU types:
 atmega2560, atmega2561).
 
+Instruction set avrxmega2 is for the XMEGA AVR core with 8K to 64K program
+memory space and less than 64K data space (MCU types: atxmega16a4, atxmega16d4,
+atxmega32d4).
+
+Instruction set avrxmega3 is for the XMEGA AVR core with 8K to 64K program
+memory space and greater than 64K data space (MCU types: atxmega32a4).
+
+Instruction set avrxmega4 is for the XMEGA AVR core with up to 64K program
+memory space and less than 64K data space (MCU types: atxmega64a3, atxmega64d3).
+
+Instruction set avrxmega5 is for the XMEGA AVR core with up to 64K program 
+memory space and greater than 64K data space (MCU types: atxmega64a1).
+
+Instruction set avrxmega6 is for the XMEGA AVR core with up to 256K program
+memory space and less than 64K data space (MCU types: atxmega128a3,
+atxmega128d3, atxmega192a3, atxmega192d3, atxmega256a3, atxmega256a3b,
+atxmega192d3).
+
+Instruction set avrxmega7 is for the XMEGA AVR core with up to 256K program
+memory space and greater than 64K data space (MCU types: atxmega128a1).
+
 @cindex @code{-mall-opcodes} command line option, AVR
 @item -mall-opcodes
 Accept all AVR opcodes, even if not supported by @code{-mmcu}.
diff -urN binutils-2.20.1.old/gas/doc/c-avr.texi.orig binutils-2.20.1/gas/doc/c-avr.texi.orig
--- binutils-2.20.1.old/gas/doc/c-avr.texi.orig	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/gas/doc/c-avr.texi.orig	2009-09-02 02:24:21.000000000 -0500
@@ -0,0 +1,380 @@
+@c Copyright 2006, 2007, 2008, 2009
+@c Free Software Foundation, Inc.
+@c This is part of the GAS manual.
+@c For copying conditions, see the file as.texinfo.
+
+@ifset GENERIC
+@page
+@node AVR-Dependent
+@chapter AVR Dependent Features
+@end ifset
+
+@ifclear GENERIC
+@node Machine Dependencies
+@chapter AVR Dependent Features
+@end ifclear
+
+@cindex AVR support
+@menu
+* AVR Options::              Options
+* AVR Syntax::               Syntax
+* AVR Opcodes::              Opcodes
+@end menu
+
+@node AVR Options
+@section Options
+@cindex AVR options (none)
+@cindex options for AVR (none)
+
+@table @code
+
+@cindex @code{-mmcu=} command line option, AVR
+@item -mmcu=@var{mcu}
+Specify ATMEL AVR instruction set or MCU type.
+
+Instruction set avr1 is for the minimal AVR core, not supported by the C
+compiler, only for assembler programs (MCU types: at90s1200,
+attiny11, attiny12, attiny15, attiny28).
+
+Instruction set avr2 (default) is for the classic AVR core with up to
+8K program memory space (MCU types: at90s2313, at90s2323, at90s2333, at90s2343,
+attiny22, attiny26, at90s4414, at90s4433, at90s4434, at90s8515, at90c8534,
+at90s8535).
+
+Instruction set avr25 is for the classic AVR core with up to 8K program memory
+space plus the MOVW instruction (MCU types: attiny13, attiny13a, attiny2313,
+attiny2313a, attiny24, attiny24a, attiny4313, attiny44, attiny44a, attiny84,
+attiny25, attiny45, attiny85, attiny261, attiny261a, attiny461, attiny861,
+attiny861a, attiny87, attiny43u, attiny48, attiny88, at86rf401, ata6289).
+
+Instruction set avr3 is for the classic AVR core with up to 128K program
+memory space (MCU types: at43usb355, at76c711).
+
+Instruction set avr31 is for the classic AVR core with exactly 128K program
+memory space (MCU types: atmega103, at43usb320).
+
+Instruction set avr35 is for classic AVR core plus MOVW, CALL, and JMP
+instructions (MCU types: attiny167, attiny327, at90usb82, at90usb162, atmega8u2,
+atmega16u2, atmega32u2).
+
+Instruction set avr4 is for the enhanced AVR core with up to 8K program
+memory space (MCU types: atmega48, atmega48p,atmega8, atmega88, atmega88p,
+atmega8515, atmega8535, atmega8hva, atmega4hvd, atmega8hvd, at90pwm1,
+at90pwm2, at90pwm2b, at90pwm3, at90pwm3b, at90pwm81, atmega8m1, atmega8c1).
+
+Instruction set avr5 is for the enhanced AVR core with up to 128K program
+memory space (MCU types: atmega16, atmega161, atmega162, atmega163, atmega164p,
+atmega165, atmega165p, atmega168, atmega168p, atmega169, atmega169p, atmega16c1,
+atmega32, atmega323, atmega324p, atmega325, atmega325p, atmega3250, atmega3250p,
+atmega328p, atmega329, atmega329p, atmega3290, atmega3290p, atmega406, atmega64,
+atmega640, atmega644, atmega644p, atmega644pa, atmega645, atmega6450, atmega649,
+atmega6490, atmega16hva, atmega16hvb, atmega32hvb, at90can32, at90can64,
+at90pwm216, at90pwm316, atmega32c1, atmega64c1, atmega16m1, atmega32m1,
+atmega64m1, atmega16u4, atmega32u4, atmega32u6, at90usb646, at90usb647, at94k,
+at90scr100).
+
+Instruction set avr51 is for the enhanced AVR core with exactly 128K program
+memory space (MCU types: atmega128, atmega1280, atmega1281, atmega1284p,
+atmega128rfa1, at90can128, at90usb1286, at90usb1287, m3000f, m3000s, m3001b).
+
+Instruction set avr6 is for the enhanced AVR core with a 3-byte PC (MCU types:
+atmega2560, atmega2561).
+
+@cindex @code{-mall-opcodes} command line option, AVR
+@item -mall-opcodes
+Accept all AVR opcodes, even if not supported by @code{-mmcu}.
+
+@cindex @code{-mno-skip-bug} command line option, AVR
+@item -mno-skip-bug
+This option disable warnings for skipping two-word instructions.
+
+@cindex @code{-mno-wrap} command line option, AVR
+@item -mno-wrap
+This option reject @code{rjmp/rcall} instructions with 8K wrap-around.
+
+@end table
+
+
+@node AVR Syntax
+@section Syntax
+@menu
+* AVR-Chars::                Special Characters
+* AVR-Regs::                 Register Names
+* AVR-Modifiers::            Relocatable Expression Modifiers
+@end menu
+
+@node AVR-Chars
+@subsection Special Characters
+
+@cindex line comment character, AVR
+@cindex AVR line comment character
+
+The presence of a @samp{;} on a line indicates the start of a comment
+that extends to the end of the current line.  If a @samp{#} appears as
+the first character of a line, the whole line is treated as a comment.
+
+@cindex line separator, AVR
+@cindex statement separator, AVR
+@cindex AVR line separator
+
+The @samp{$} character can be used instead of a newline to separate
+statements.
+
+@node AVR-Regs
+@subsection Register Names
+
+@cindex AVR register names
+@cindex register names, AVR
+
+The AVR has 32 x 8-bit general purpose working registers @samp{r0},
+@samp{r1}, ... @samp{r31}.
+Six of the 32 registers can be used as three 16-bit indirect address
+register pointers for Data Space addressing. One of the these address
+pointers can also be used as an address pointer for look up tables in
+Flash program memory. These added function registers are the 16-bit
+@samp{X}, @samp{Y} and @samp{Z} - registers.
+
+@smallexample
+X = @r{r26:r27}
+Y = @r{r28:r29}
+Z = @r{r30:r31}
+@end smallexample
+
+@node AVR-Modifiers
+@subsection Relocatable Expression Modifiers
+
+@cindex AVR modifiers
+@cindex syntax, AVR
+
+The assembler supports several modifiers when using relocatable addresses
+in AVR instruction operands.  The general syntax is the following:
+
+@smallexample
+modifier(relocatable-expression)
+@end smallexample
+
+@table @code
+@cindex symbol modifiers
+
+@item lo8
+
+This modifier allows you to use bits 0 through 7 of
+an address expression as 8 bit relocatable expression.
+
+@item hi8
+
+This modifier allows you to use bits 7 through 15 of an address expression
+as 8 bit relocatable expression.  This is useful with, for example, the
+AVR @samp{ldi} instruction and @samp{lo8} modifier.
+
+For example
+
+@smallexample
+ldi r26, lo8(sym+10)
+ldi r27, hi8(sym+10)
+@end smallexample
+
+@item hh8
+
+This modifier allows you to use bits 16 through 23 of
+an address expression as 8 bit relocatable expression.
+Also, can be useful for loading 32 bit constants.
+
+@item hlo8
+
+Synonym of @samp{hh8}.
+
+@item hhi8
+
+This modifier allows you to use bits 24 through 31 of
+an expression as 8 bit expression. This is useful with, for example, the
+AVR @samp{ldi} instruction and @samp{lo8}, @samp{hi8}, @samp{hlo8},
+@samp{hhi8}, modifier.
+
+For example
+
+@smallexample
+ldi r26, lo8(285774925)
+ldi r27, hi8(285774925)
+ldi r28, hlo8(285774925)
+ldi r29, hhi8(285774925)
+; r29,r28,r27,r26 = 285774925
+@end smallexample
+
+@item pm_lo8
+
+This modifier allows you to use bits 0 through 7 of
+an address expression as 8 bit relocatable expression.
+This modifier useful for addressing data or code from
+Flash/Program memory. The using of @samp{pm_lo8} similar
+to @samp{lo8}.
+
+@item pm_hi8
+
+This modifier allows you to use bits 8 through 15 of
+an address expression as 8 bit relocatable expression.
+This modifier useful for addressing data or code from
+Flash/Program memory.
+
+@item pm_hh8
+
+This modifier allows you to use bits 15 through 23 of
+an address expression as 8 bit relocatable expression.
+This modifier useful for addressing data or code from
+Flash/Program memory.
+
+@end table
+
+@node AVR Opcodes
+@section Opcodes
+
+@cindex AVR opcode summary
+@cindex opcode summary, AVR
+@cindex mnemonics, AVR
+@cindex instruction summary, AVR
+For detailed information on the AVR machine instruction set, see
+@url{www.atmel.com/products/AVR}.
+
+@code{@value{AS}} implements all the standard AVR opcodes.
+The following table summarizes the AVR opcodes, and their arguments.
+
+@smallexample
+@i{Legend:}
+   r   @r{any register}
+   d   @r{`ldi' register (r16-r31)}
+   v   @r{`movw' even register (r0, r2, ..., r28, r30)}
+   a   @r{`fmul' register (r16-r23)}
+   w   @r{`adiw' register (r24,r26,r28,r30)}
+   e   @r{pointer registers (X,Y,Z)}
+   b   @r{base pointer register and displacement ([YZ]+disp)}
+   z   @r{Z pointer register (for [e]lpm Rd,Z[+])}
+   M   @r{immediate value from 0 to 255}
+   n   @r{immediate value from 0 to 255 ( n = ~M ). Relocation impossible}
+   s   @r{immediate value from 0 to 7}
+   P   @r{Port address value from 0 to 63. (in, out)}
+   p   @r{Port address value from 0 to 31. (cbi, sbi, sbic, sbis)}
+   K   @r{immediate value from 0 to 63 (used in `adiw', `sbiw')}
+   i   @r{immediate value}
+   l   @r{signed pc relative offset from -64 to 63}
+   L   @r{signed pc relative offset from -2048 to 2047}
+   h   @r{absolute code address (call, jmp)}
+   S   @r{immediate value from 0 to 7 (S = s << 4)}
+   ?   @r{use this opcode entry if no parameters, else use next opcode entry}
+
+1001010010001000   clc  
+1001010011011000   clh  
+1001010011111000   cli  
+1001010010101000   cln  
+1001010011001000   cls  
+1001010011101000   clt  
+1001010010111000   clv  
+1001010010011000   clz  
+1001010000001000   sec  
+1001010001011000   seh  
+1001010001111000   sei  
+1001010000101000   sen  
+1001010001001000   ses  
+1001010001101000   set  
+1001010000111000   sev  
+1001010000011000   sez  
+100101001SSS1000   bclr    S
+100101000SSS1000   bset    S
+1001010100001001   icall
+1001010000001001   ijmp 
+1001010111001000   lpm     ?
+1001000ddddd010+   lpm     r,z
+1001010111011000   elpm    ?
+1001000ddddd011+   elpm    r,z
+0000000000000000   nop  
+1001010100001000   ret  
+1001010100011000   reti 
+1001010110001000   sleep
+1001010110011000   break
+1001010110101000   wdr  
+1001010111101000   spm  
+000111rdddddrrrr   adc     r,r
+000011rdddddrrrr   add     r,r
+001000rdddddrrrr   and     r,r
+000101rdddddrrrr   cp      r,r
+000001rdddddrrrr   cpc     r,r
+000100rdddddrrrr   cpse    r,r
+001001rdddddrrrr   eor     r,r
+001011rdddddrrrr   mov     r,r
+100111rdddddrrrr   mul     r,r
+001010rdddddrrrr   or      r,r
+000010rdddddrrrr   sbc     r,r
+000110rdddddrrrr   sub     r,r
+001001rdddddrrrr   clr     r
+000011rdddddrrrr   lsl     r
+000111rdddddrrrr   rol     r
+001000rdddddrrrr   tst     r
+0111KKKKddddKKKK   andi    d,M
+0111KKKKddddKKKK   cbr     d,n
+1110KKKKddddKKKK   ldi     d,M
+11101111dddd1111   ser     d
+0110KKKKddddKKKK   ori     d,M
+0110KKKKddddKKKK   sbr     d,M
+0011KKKKddddKKKK   cpi     d,M
+0100KKKKddddKKKK   sbci    d,M
+0101KKKKddddKKKK   subi    d,M
+1111110rrrrr0sss   sbrc    r,s
+1111111rrrrr0sss   sbrs    r,s
+1111100ddddd0sss   bld     r,s
+1111101ddddd0sss   bst     r,s
+10110PPdddddPPPP   in      r,P
+10111PPrrrrrPPPP   out     P,r
+10010110KKddKKKK   adiw    w,K
+10010111KKddKKKK   sbiw    w,K
+10011000pppppsss   cbi     p,s
+10011010pppppsss   sbi     p,s
+10011001pppppsss   sbic    p,s
+10011011pppppsss   sbis    p,s
+111101lllllll000   brcc    l
+111100lllllll000   brcs    l
+111100lllllll001   breq    l
+111101lllllll100   brge    l
+111101lllllll101   brhc    l
+111100lllllll101   brhs    l
+111101lllllll111   brid    l
+111100lllllll111   brie    l
+111100lllllll000   brlo    l
+111100lllllll100   brlt    l
+111100lllllll010   brmi    l
+111101lllllll001   brne    l
+111101lllllll010   brpl    l
+111101lllllll000   brsh    l
+111101lllllll110   brtc    l
+111100lllllll110   brts    l
+111101lllllll011   brvc    l
+111100lllllll011   brvs    l
+111101lllllllsss   brbc    s,l
+111100lllllllsss   brbs    s,l
+1101LLLLLLLLLLLL   rcall   L
+1100LLLLLLLLLLLL   rjmp    L
+1001010hhhhh111h   call    h
+1001010hhhhh110h   jmp     h
+1001010rrrrr0101   asr     r
+1001010rrrrr0000   com     r
+1001010rrrrr1010   dec     r
+1001010rrrrr0011   inc     r
+1001010rrrrr0110   lsr     r
+1001010rrrrr0001   neg     r
+1001000rrrrr1111   pop     r
+1001001rrrrr1111   push    r
+1001010rrrrr0111   ror     r
+1001010rrrrr0010   swap    r
+00000001ddddrrrr   movw    v,v
+00000010ddddrrrr   muls    d,d
+000000110ddd0rrr   mulsu   a,a
+000000110ddd1rrr   fmul    a,a
+000000111ddd0rrr   fmuls   a,a
+000000111ddd1rrr   fmulsu  a,a
+1001001ddddd0000   sts     i,r
+1001000ddddd0000   lds     r,i
+10o0oo0dddddbooo   ldd     r,b
+100!000dddddee-+   ld      r,e
+10o0oo1rrrrrbooo   std     b,r
+100!001rrrrree-+   st      e,r
+1001010100011001   eicall  
+1001010000011001   eijmp   
+@end smallexample
diff -urN binutils-2.20.1.old/gas/dwarf2dbg.c.orig binutils-2.20.1/gas/dwarf2dbg.c.orig
--- binutils-2.20.1.old/gas/dwarf2dbg.c.orig	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/gas/dwarf2dbg.c.orig	2009-09-14 06:43:26.000000000 -0500
@@ -0,0 +1,1790 @@
+/* dwarf2dbg.c - DWARF2 debug support
+   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   Free Software Foundation, Inc.
+   Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+/* Logical line numbers can be controlled by the compiler via the
+   following directives:
+
+	.file FILENO "file.c"
+	.loc  FILENO LINENO [COLUMN] [basic_block] [prologue_end] \
+	      [epilogue_begin] [is_stmt VALUE] [isa VALUE] \
+	      [discriminator VALUE]
+*/
+
+#include "as.h"
+#include "safe-ctype.h"
+
+#ifdef HAVE_LIMITS_H
+#include <limits.h>
+#else
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#ifndef INT_MAX
+#define INT_MAX (int) (((unsigned) (-1)) >> 1)
+#endif
+#endif
+
+#include "dwarf2dbg.h"
+#include <filenames.h>
+
+#ifdef HAVE_DOS_BASED_FILE_SYSTEM
+/* We need to decide which character to use as a directory separator.
+   Just because HAVE_DOS_BASED_FILE_SYSTEM is defined, it does not
+   necessarily mean that the backslash character is the one to use.
+   Some environments, eg Cygwin, can support both naming conventions.
+   So we use the heuristic that we only need to use the backslash if
+   the path is an absolute path starting with a DOS style drive
+   selector.  eg C: or D:  */
+# define INSERT_DIR_SEPARATOR(string, offset) \
+  do \
+    { \
+      if (offset > 1 \
+	  && string[0] != 0 \
+	  && string[1] == ':') \
+       string [offset] = '\\'; \
+      else \
+       string [offset] = '/'; \
+    } \
+  while (0)
+#else
+# define INSERT_DIR_SEPARATOR(string, offset) string[offset] = '/'
+#endif
+
+#ifndef DWARF2_FORMAT
+# define DWARF2_FORMAT(SEC) dwarf2_format_32bit
+#endif
+
+#ifndef DWARF2_ADDR_SIZE
+# define DWARF2_ADDR_SIZE(bfd) (bfd_arch_bits_per_address (bfd) / 8)
+#endif
+
+#ifndef DWARF2_FILE_NAME
+#define DWARF2_FILE_NAME(FILENAME, DIRNAME) FILENAME
+#endif
+
+#ifndef DWARF2_FILE_TIME_NAME
+#define DWARF2_FILE_TIME_NAME(FILENAME,DIRNAME) 0
+#endif
+
+#ifndef DWARF2_FILE_SIZE_NAME
+#define DWARF2_FILE_SIZE_NAME(FILENAME,DIRNAME) 0
+#endif
+
+#include "subsegs.h"
+
+#include "dwarf2.h"
+
+/* Since we can't generate the prolog until the body is complete, we
+   use three different subsegments for .debug_line: one holding the
+   prolog, one for the directory and filename info, and one for the
+   body ("statement program").  */
+#define DL_PROLOG	0
+#define DL_FILES	1
+#define DL_BODY		2
+
+/* If linker relaxation might change offsets in the code, the DWARF special
+   opcodes and variable-length operands cannot be used.  If this macro is
+   nonzero, use the DW_LNS_fixed_advance_pc opcode instead.  */
+#ifndef DWARF2_USE_FIXED_ADVANCE_PC
+# define DWARF2_USE_FIXED_ADVANCE_PC	0
+#endif
+
+/* First special line opcde - leave room for the standard opcodes.
+   Note: If you want to change this, you'll have to update the
+   "standard_opcode_lengths" table that is emitted below in
+   out_debug_line().  */
+#define DWARF2_LINE_OPCODE_BASE		13
+
+#ifndef DWARF2_LINE_BASE
+  /* Minimum line offset in a special line info. opcode.  This value
+     was chosen to give a reasonable range of values.  */
+# define DWARF2_LINE_BASE		-5
+#endif
+
+/* Range of line offsets in a special line info. opcode.  */
+#ifndef DWARF2_LINE_RANGE
+# define DWARF2_LINE_RANGE		14
+#endif
+
+#ifndef DWARF2_LINE_MIN_INSN_LENGTH
+  /* Define the architecture-dependent minimum instruction length (in
+     bytes).  This value should be rather too small than too big.  */
+# define DWARF2_LINE_MIN_INSN_LENGTH	1
+#endif
+
+/* Flag that indicates the initial value of the is_stmt_start flag.  */
+#define	DWARF2_LINE_DEFAULT_IS_STMT	1
+
+/* Given a special op, return the line skip amount.  */
+#define SPECIAL_LINE(op) \
+	(((op) - DWARF2_LINE_OPCODE_BASE)%DWARF2_LINE_RANGE + DWARF2_LINE_BASE)
+
+/* Given a special op, return the address skip amount (in units of
+   DWARF2_LINE_MIN_INSN_LENGTH.  */
+#define SPECIAL_ADDR(op) (((op) - DWARF2_LINE_OPCODE_BASE)/DWARF2_LINE_RANGE)
+
+/* The maximum address skip amount that can be encoded with a special op.  */
+#define MAX_SPECIAL_ADDR_DELTA		SPECIAL_ADDR(255)
+
+struct line_entry {
+  struct line_entry *next;
+  symbolS *label;
+  struct dwarf2_line_info loc;
+};
+
+struct line_subseg {
+  struct line_subseg *next;
+  subsegT subseg;
+  struct line_entry *head;
+  struct line_entry **ptail;
+};
+
+struct line_seg {
+  struct line_seg *next;
+  segT seg;
+  struct line_subseg *head;
+  symbolS *text_start;
+  symbolS *text_end;
+};
+
+/* Collects data for all line table entries during assembly.  */
+static struct line_seg *all_segs;
+
+struct file_entry {
+  const char *filename;
+  unsigned int dir;
+};
+
+/* Table of files used by .debug_line.  */
+static struct file_entry *files;
+static unsigned int files_in_use;
+static unsigned int files_allocated;
+
+/* Table of directories used by .debug_line.  */
+static char **dirs;
+static unsigned int dirs_in_use;
+static unsigned int dirs_allocated;
+
+/* TRUE when we've seen a .loc directive recently.  Used to avoid
+   doing work when there's nothing to do.  */
+bfd_boolean dwarf2_loc_directive_seen;
+
+/* TRUE when we're supposed to set the basic block mark whenever a
+   label is seen.  */
+bfd_boolean dwarf2_loc_mark_labels;
+
+/* Current location as indicated by the most recent .loc directive.  */
+static struct dwarf2_line_info current = {
+  1, 1, 0, 0,
+  DWARF2_LINE_DEFAULT_IS_STMT ? DWARF2_FLAG_IS_STMT : 0,
+  0
+};
+
+/* The size of an address on the target.  */
+static unsigned int sizeof_address;
+
+static unsigned int get_filenum (const char *, unsigned int);
+
+#ifndef TC_DWARF2_EMIT_OFFSET
+#define TC_DWARF2_EMIT_OFFSET  generic_dwarf2_emit_offset
+
+/* Create an offset to .dwarf2_*.  */
+
+static void
+generic_dwarf2_emit_offset (symbolS *symbol, unsigned int size)
+{
+  expressionS expr;
+
+  expr.X_op = O_symbol;
+  expr.X_add_symbol = symbol;
+  expr.X_add_number = 0;
+  emit_expr (&expr, size);
+}
+#endif
+
+/* Find or create an entry for SEG+SUBSEG in ALL_SEGS.  */
+
+static struct line_subseg *
+get_line_subseg (segT seg, subsegT subseg)
+{
+  static segT last_seg;
+  static subsegT last_subseg;
+  static struct line_subseg *last_line_subseg;
+
+  struct line_seg **ps, *s;
+  struct line_subseg **pss, *ss;
+
+  if (seg == last_seg && subseg == last_subseg)
+    return last_line_subseg;
+
+  for (ps = &all_segs; (s = *ps) != NULL; ps = &s->next)
+    if (s->seg == seg)
+      goto found_seg;
+
+  s = (struct line_seg *) xmalloc (sizeof (*s));
+  s->next = NULL;
+  s->seg = seg;
+  s->head = NULL;
+  *ps = s;
+
+ found_seg:
+  for (pss = &s->head; (ss = *pss) != NULL ; pss = &ss->next)
+    {
+      if (ss->subseg == subseg)
+	goto found_subseg;
+      if (ss->subseg > subseg)
+	break;
+    }
+
+  ss = (struct line_subseg *) xmalloc (sizeof (*ss));
+  ss->next = *pss;
+  ss->subseg = subseg;
+  ss->head = NULL;
+  ss->ptail = &ss->head;
+  *pss = ss;
+
+ found_subseg:
+  last_seg = seg;
+  last_subseg = subseg;
+  last_line_subseg = ss;
+
+  return ss;
+}
+
+/* Record an entry for LOC occurring at LABEL.  */
+
+static void
+dwarf2_gen_line_info_1 (symbolS *label, struct dwarf2_line_info *loc)
+{
+  struct line_subseg *ss;
+  struct line_entry *e;
+
+  e = (struct line_entry *) xmalloc (sizeof (*e));
+  e->next = NULL;
+  e->label = label;
+  e->loc = *loc;
+
+  ss = get_line_subseg (now_seg, now_subseg);
+  *ss->ptail = e;
+  ss->ptail = &e->next;
+}
+
+/* Record an entry for LOC occurring at OFS within the current fragment.  */
+
+void
+dwarf2_gen_line_info (addressT ofs, struct dwarf2_line_info *loc)
+{
+  static unsigned int line = -1;
+  static unsigned int filenum = -1;
+
+  symbolS *sym;
+
+  /* Early out for as-yet incomplete location information.  */
+  if (loc->filenum == 0 || loc->line == 0)
+    return;
+
+  /* Don't emit sequences of line symbols for the same line when the
+     symbols apply to assembler code.  It is necessary to emit
+     duplicate line symbols when a compiler asks for them, because GDB
+     uses them to determine the end of the prologue.  */
+  if (debug_type == DEBUG_DWARF2
+      && line == loc->line && filenum == loc->filenum)
+    return;
+
+  line = loc->line;
+  filenum = loc->filenum;
+
+  sym = symbol_temp_new (now_seg, ofs, frag_now);
+  dwarf2_gen_line_info_1 (sym, loc);
+}
+
+/* Returns the current source information.  If .file directives have
+   been encountered, the info for the corresponding source file is
+   returned.  Otherwise, the info for the assembly source file is
+   returned.  */
+
+void
+dwarf2_where (struct dwarf2_line_info *line)
+{
+  if (debug_type == DEBUG_DWARF2)
+    {
+      char *filename;
+      as_where (&filename, &line->line);
+      line->filenum = get_filenum (filename, 0);
+      line->column = 0;
+      line->flags = DWARF2_FLAG_IS_STMT;
+      line->isa = current.isa;
+      line->discriminator = current.discriminator;
+    }
+  else
+    *line = current;
+}
+
+/* A hook to allow the target backend to inform the line number state
+   machine of isa changes when assembler debug info is enabled.  */
+
+void
+dwarf2_set_isa (unsigned int isa)
+{
+  current.isa = isa;
+}
+
+/* Called for each machine instruction, or relatively atomic group of
+   machine instructions (ie built-in macro).  The instruction or group
+   is SIZE bytes in length.  If dwarf2 line number generation is called
+   for, emit a line statement appropriately.  */
+
+void
+dwarf2_emit_insn (int size)
+{
+  struct dwarf2_line_info loc;
+
+  if (!dwarf2_loc_directive_seen && debug_type != DEBUG_DWARF2)
+    return;
+
+  dwarf2_where (&loc);
+
+  dwarf2_gen_line_info (frag_now_fix () - size, &loc);
+  dwarf2_consume_line_info ();
+}
+
+/* Called after the current line information has been either used with
+   dwarf2_gen_line_info or saved with a machine instruction for later use.
+   This resets the state of the line number information to reflect that
+   it has been used.  */
+
+void
+dwarf2_consume_line_info (void)
+{
+  /* Unless we generate DWARF2 debugging information for each
+     assembler line, we only emit one line symbol for one LOC.  */
+  dwarf2_loc_directive_seen = FALSE;
+
+  current.flags &= ~(DWARF2_FLAG_BASIC_BLOCK
+		     | DWARF2_FLAG_PROLOGUE_END
+		     | DWARF2_FLAG_EPILOGUE_BEGIN);
+  current.discriminator = 0;
+}
+
+/* Called for each (preferably code) label.  If dwarf2_loc_mark_labels
+   is enabled, emit a basic block marker.  */
+
+void
+dwarf2_emit_label (symbolS *label)
+{
+  struct dwarf2_line_info loc;
+
+  if (!dwarf2_loc_mark_labels)
+    return;
+  if (S_GET_SEGMENT (label) != now_seg)
+    return;
+  if (!(bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE))
+    return;
+  if (files_in_use == 0 && debug_type != DEBUG_DWARF2)
+    return;
+
+  dwarf2_where (&loc);
+
+  loc.flags |= DWARF2_FLAG_BASIC_BLOCK;
+
+  dwarf2_gen_line_info_1 (label, &loc);
+  dwarf2_consume_line_info ();
+}
+
+/* Get a .debug_line file number for FILENAME.  If NUM is nonzero,
+   allocate it on that file table slot, otherwise return the first
+   empty one.  */
+
+static unsigned int
+get_filenum (const char *filename, unsigned int num)
+{
+  static unsigned int last_used, last_used_dir_len;
+  const char *file;
+  size_t dir_len;
+  unsigned int i, dir;
+
+  if (num == 0 && last_used)
+    {
+      if (! files[last_used].dir
+	  && strcmp (filename, files[last_used].filename) == 0)
+	return last_used;
+      if (files[last_used].dir
+	  && strncmp (filename, dirs[files[last_used].dir],
+		      last_used_dir_len) == 0
+	  && IS_DIR_SEPARATOR (filename [last_used_dir_len])
+	  && strcmp (filename + last_used_dir_len + 1,
+		     files[last_used].filename) == 0)
+	return last_used;
+    }
+
+  file = lbasename (filename);
+  /* Don't make empty string from / or A: from A:/ .  */
+#ifdef HAVE_DOS_BASED_FILE_SYSTEM
+  if (file <= filename + 3)
+    file = filename;
+#else
+  if (file == filename + 1)
+    file = filename;
+#endif
+  dir_len = file - filename;
+
+  dir = 0;
+  if (dir_len)
+    {
+#ifndef DWARF2_DIR_SHOULD_END_WITH_SEPARATOR
+      --dir_len;
+#endif
+      for (dir = 1; dir < dirs_in_use; ++dir)
+	if (strncmp (filename, dirs[dir], dir_len) == 0
+	    && dirs[dir][dir_len] == '\0')
+	  break;
+
+      if (dir >= dirs_in_use)
+	{
+	  if (dir >= dirs_allocated)
+	    {
+	      dirs_allocated = dir + 32;
+	      dirs = (char **)
+		     xrealloc (dirs, (dir + 32) * sizeof (const char *));
+	    }
+
+	  dirs[dir] = (char *) xmalloc (dir_len + 1);
+	  memcpy (dirs[dir], filename, dir_len);
+	  dirs[dir][dir_len] = '\0';
+	  dirs_in_use = dir + 1;
+	}
+    }
+
+  if (num == 0)
+    {
+      for (i = 1; i < files_in_use; ++i)
+	if (files[i].dir == dir
+	    && files[i].filename
+	    && strcmp (file, files[i].filename) == 0)
+	  {
+	    last_used = i;
+	    last_used_dir_len = dir_len;
+	    return i;
+	  }
+    }
+  else
+    i = num;
+
+  if (i >= files_allocated)
+    {
+      unsigned int old = files_allocated;
+
+      files_allocated = i + 32;
+      files = (struct file_entry *)
+	xrealloc (files, (i + 32) * sizeof (struct file_entry));
+
+      memset (files + old, 0, (i + 32 - old) * sizeof (struct file_entry));
+    }
+
+  files[i].filename = num ? file : xstrdup (file);
+  files[i].dir = dir;
+  if (files_in_use < i + 1)
+    files_in_use = i + 1;
+  last_used = i;
+  last_used_dir_len = dir_len;
+
+  return i;
+}
+
+/* Handle two forms of .file directive:
+   - Pass .file "source.c" to s_app_file
+   - Handle .file 1 "source.c" by adding an entry to the DWARF-2 file table
+
+   If an entry is added to the file table, return a pointer to the filename. */
+
+char *
+dwarf2_directive_file (int dummy ATTRIBUTE_UNUSED)
+{
+  offsetT num;
+  char *filename;
+  int filename_len;
+
+  /* Continue to accept a bare string and pass it off.  */
+  SKIP_WHITESPACE ();
+  if (*input_line_pointer == '"')
+    {
+      s_app_file (0);
+      return NULL;
+    }
+
+  num = get_absolute_expression ();
+  filename = demand_copy_C_string (&filename_len);
+  if (filename == NULL)
+    return NULL;
+  demand_empty_rest_of_line ();
+
+  if (num < 1)
+    {
+      as_bad (_("file number less than one"));
+      return NULL;
+    }
+
+  /* A .file directive implies compiler generated debug information is
+     being supplied.  Turn off gas generated debug info.  */
+  debug_type = DEBUG_NONE;
+
+  if (num < (int) files_in_use && files[num].filename != 0)
+    {
+      as_bad (_("file number %ld already allocated"), (long) num);
+      return NULL;
+    }
+
+  get_filenum (filename, num);
+
+  return filename;
+}
+
+void
+dwarf2_directive_loc (int dummy ATTRIBUTE_UNUSED)
+{
+  offsetT filenum, line;
+
+  /* If we see two .loc directives in a row, force the first one to be
+     output now.  */
+  if (dwarf2_loc_directive_seen)
+    dwarf2_emit_insn (0);
+
+  filenum = get_absolute_expression ();
+  SKIP_WHITESPACE ();
+  line = get_absolute_expression ();
+
+  if (filenum < 1)
+    {
+      as_bad (_("file number less than one"));
+      return;
+    }
+  if (filenum >= (int) files_in_use || files[filenum].filename == 0)
+    {
+      as_bad (_("unassigned file number %ld"), (long) filenum);
+      return;
+    }
+
+  current.filenum = filenum;
+  current.line = line;
+  current.discriminator = 0;
+
+#ifndef NO_LISTING
+  if (listing)
+    {
+      if (files[filenum].dir)
+	{
+	  size_t dir_len = strlen (dirs[files[filenum].dir]);
+	  size_t file_len = strlen (files[filenum].filename);
+	  char *cp = (char *) alloca (dir_len + 1 + file_len + 1);
+
+	  memcpy (cp, dirs[files[filenum].dir], dir_len);
+	  INSERT_DIR_SEPARATOR (cp, dir_len);
+	  memcpy (cp + dir_len + 1, files[filenum].filename, file_len);
+	  cp[dir_len + file_len + 1] = '\0';
+	  listing_source_file (cp);
+	}
+      else
+	listing_source_file (files[filenum].filename);
+      listing_source_line (line);
+    }
+#endif
+
+  SKIP_WHITESPACE ();
+  if (ISDIGIT (*input_line_pointer))
+    {
+      current.column = get_absolute_expression ();
+      SKIP_WHITESPACE ();
+    }
+
+  while (ISALPHA (*input_line_pointer))
+    {
+      char *p, c;
+      offsetT value;
+
+      p = input_line_pointer;
+      c = get_symbol_end ();
+
+      if (strcmp (p, "basic_block") == 0)
+	{
+	  current.flags |= DWARF2_FLAG_BASIC_BLOCK;
+	  *input_line_pointer = c;
+	}
+      else if (strcmp (p, "prologue_end") == 0)
+	{
+	  current.flags |= DWARF2_FLAG_PROLOGUE_END;
+	  *input_line_pointer = c;
+	}
+      else if (strcmp (p, "epilogue_begin") == 0)
+	{
+	  current.flags |= DWARF2_FLAG_EPILOGUE_BEGIN;
+	  *input_line_pointer = c;
+	}
+      else if (strcmp (p, "is_stmt") == 0)
+	{
+	  *input_line_pointer = c;
+	  value = get_absolute_expression ();
+	  if (value == 0)
+	    current.flags &= ~DWARF2_FLAG_IS_STMT;
+	  else if (value == 1)
+	    current.flags |= DWARF2_FLAG_IS_STMT;
+	  else
+	    {
+	      as_bad (_("is_stmt value not 0 or 1"));
+	      return;
+	    }
+	}
+      else if (strcmp (p, "isa") == 0)
+	{
+	  *input_line_pointer = c;
+	  value = get_absolute_expression ();
+	  if (value >= 0)
+	    current.isa = value;
+	  else
+	    {
+	      as_bad (_("isa number less than zero"));
+	      return;
+	    }
+	}
+      else if (strcmp (p, "discriminator") == 0)
+	{
+	  *input_line_pointer = c;
+	  value = get_absolute_expression ();
+	  if (value >= 0)
+	    current.discriminator = value;
+	  else
+	    {
+	      as_bad (_("discriminator less than zero"));
+	      return;
+	    }
+	}
+      else
+	{
+	  as_bad (_("unknown .loc sub-directive `%s'"), p);
+	  *input_line_pointer = c;
+	  return;
+	}
+
+      SKIP_WHITESPACE ();
+    }
+
+  demand_empty_rest_of_line ();
+  dwarf2_loc_directive_seen = TRUE;
+  debug_type = DEBUG_NONE;
+}
+
+void
+dwarf2_directive_loc_mark_labels (int dummy ATTRIBUTE_UNUSED)
+{
+  offsetT value = get_absolute_expression ();
+
+  if (value != 0 && value != 1)
+    {
+      as_bad (_("expected 0 or 1"));
+      ignore_rest_of_line ();
+    }
+  else
+    {
+      dwarf2_loc_mark_labels = value != 0;
+      demand_empty_rest_of_line ();
+    }
+}
+
+static struct frag *
+first_frag_for_seg (segT seg)
+{
+  return seg_info (seg)->frchainP->frch_root;
+}
+
+static struct frag *
+last_frag_for_seg (segT seg)
+{
+  frchainS *f = seg_info (seg)->frchainP;
+
+  while (f->frch_next != NULL)
+    f = f->frch_next;
+
+  return f->frch_last;
+}
+
+/* Emit a single byte into the current segment.  */
+
+static inline void
+out_byte (int byte)
+{
+  FRAG_APPEND_1_CHAR (byte);
+}
+
+/* Emit a statement program opcode into the current segment.  */
+
+static inline void
+out_opcode (int opc)
+{
+  out_byte (opc);
+}
+
+/* Emit a two-byte word into the current segment.  */
+
+static inline void
+out_two (int data)
+{
+  md_number_to_chars (frag_more (2), data, 2);
+}
+
+/* Emit a four byte word into the current segment.  */
+
+static inline void
+out_four (int data)
+{
+  md_number_to_chars (frag_more (4), data, 4);
+}
+
+/* Emit an unsigned "little-endian base 128" number.  */
+
+static void
+out_uleb128 (addressT value)
+{
+  output_leb128 (frag_more (sizeof_leb128 (value, 0)), value, 0);
+}
+
+/* Emit a signed "little-endian base 128" number.  */
+
+static void
+out_leb128 (addressT value)
+{
+  output_leb128 (frag_more (sizeof_leb128 (value, 1)), value, 1);
+}
+
+/* Emit a tuple for .debug_abbrev.  */
+
+static inline void
+out_abbrev (int name, int form)
+{
+  out_uleb128 (name);
+  out_uleb128 (form);
+}
+
+/* Get the size of a fragment.  */
+
+static offsetT
+get_frag_fix (fragS *frag, segT seg)
+{
+  frchainS *fr;
+
+  if (frag->fr_next)
+    return frag->fr_fix;
+
+  /* If a fragment is the last in the chain, special measures must be
+     taken to find its size before relaxation, since it may be pending
+     on some subsegment chain.  */
+  for (fr = seg_info (seg)->frchainP; fr; fr = fr->frch_next)
+    if (fr->frch_last == frag)
+      return (char *) obstack_next_free (&fr->frch_obstack) - frag->fr_literal;
+
+  abort ();
+}
+
+/* Set an absolute address (may result in a relocation entry).  */
+
+static void
+out_set_addr (symbolS *sym)
+{
+  expressionS expr;
+
+  out_opcode (DW_LNS_extended_op);
+  out_uleb128 (sizeof_address + 1);
+
+  out_opcode (DW_LNE_set_address);
+  expr.X_op = O_symbol;
+  expr.X_add_symbol = sym;
+  expr.X_add_number = 0;
+  emit_expr (&expr, sizeof_address);
+}
+
+#if DWARF2_LINE_MIN_INSN_LENGTH > 1
+static void scale_addr_delta (addressT *);
+
+static void
+scale_addr_delta (addressT *addr_delta)
+{
+  static int printed_this = 0;
+  if (*addr_delta % DWARF2_LINE_MIN_INSN_LENGTH != 0)
+    {
+      if (!printed_this)
+	as_bad("unaligned opcodes detected in executable segment");
+      printed_this = 1;
+    }
+  *addr_delta /= DWARF2_LINE_MIN_INSN_LENGTH;
+}
+#else
+#define scale_addr_delta(A)
+#endif
+
+/* Encode a pair of line and address skips as efficiently as possible.
+   Note that the line skip is signed, whereas the address skip is unsigned.
+
+   The following two routines *must* be kept in sync.  This is
+   enforced by making emit_inc_line_addr abort if we do not emit
+   exactly the expected number of bytes.  */
+
+static int
+size_inc_line_addr (int line_delta, addressT addr_delta)
+{
+  unsigned int tmp, opcode;
+  int len = 0;
+
+  /* Scale the address delta by the minimum instruction length.  */
+  scale_addr_delta (&addr_delta);
+
+  /* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.
+     We cannot use special opcodes here, since we want the end_sequence
+     to emit the matrix entry.  */
+  if (line_delta == INT_MAX)
+    {
+      if (addr_delta == MAX_SPECIAL_ADDR_DELTA)
+	len = 1;
+      else
+	len = 1 + sizeof_leb128 (addr_delta, 0);
+      return len + 3;
+    }
+
+  /* Bias the line delta by the base.  */
+  tmp = line_delta - DWARF2_LINE_BASE;
+
+  /* If the line increment is out of range of a special opcode, we
+     must encode it with DW_LNS_advance_line.  */
+  if (tmp >= DWARF2_LINE_RANGE)
+    {
+      len = 1 + sizeof_leb128 (line_delta, 1);
+      line_delta = 0;
+      tmp = 0 - DWARF2_LINE_BASE;
+    }
+
+  /* Bias the opcode by the special opcode base.  */
+  tmp += DWARF2_LINE_OPCODE_BASE;
+
+  /* Avoid overflow when addr_delta is large.  */
+  if (addr_delta < 256 + MAX_SPECIAL_ADDR_DELTA)
+    {
+      /* Try using a special opcode.  */
+      opcode = tmp + addr_delta * DWARF2_LINE_RANGE;
+      if (opcode <= 255)
+	return len + 1;
+
+      /* Try using DW_LNS_const_add_pc followed by special op.  */
+      opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA) * DWARF2_LINE_RANGE;
+      if (opcode <= 255)
+	return len + 2;
+    }
+
+  /* Otherwise use DW_LNS_advance_pc.  */
+  len += 1 + sizeof_leb128 (addr_delta, 0);
+
+  /* DW_LNS_copy or special opcode.  */
+  len += 1;
+
+  return len;
+}
+
+static void
+emit_inc_line_addr (int line_delta, addressT addr_delta, char *p, int len)
+{
+  unsigned int tmp, opcode;
+  int need_copy = 0;
+  char *end = p + len;
+
+  /* Line number sequences cannot go backward in addresses.  This means
+     we've incorrectly ordered the statements in the sequence.  */
+  gas_assert ((offsetT) addr_delta >= 0);
+
+  /* Scale the address delta by the minimum instruction length.  */
+  scale_addr_delta (&addr_delta);
+
+  /* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.
+     We cannot use special opcodes here, since we want the end_sequence
+     to emit the matrix entry.  */
+  if (line_delta == INT_MAX)
+    {
+      if (addr_delta == MAX_SPECIAL_ADDR_DELTA)
+	*p++ = DW_LNS_const_add_pc;
+      else
+	{
+	  *p++ = DW_LNS_advance_pc;
+	  p += output_leb128 (p, addr_delta, 0);
+	}
+
+      *p++ = DW_LNS_extended_op;
+      *p++ = 1;
+      *p++ = DW_LNE_end_sequence;
+      goto done;
+    }
+
+  /* Bias the line delta by the base.  */
+  tmp = line_delta - DWARF2_LINE_BASE;
+
+  /* If the line increment is out of range of a special opcode, we
+     must encode it with DW_LNS_advance_line.  */
+  if (tmp >= DWARF2_LINE_RANGE)
+    {
+      *p++ = DW_LNS_advance_line;
+      p += output_leb128 (p, line_delta, 1);
+
+      line_delta = 0;
+      tmp = 0 - DWARF2_LINE_BASE;
+      need_copy = 1;
+    }
+
+  /* Prettier, I think, to use DW_LNS_copy instead of a "line +0, addr +0"
+     special opcode.  */
+  if (line_delta == 0 && addr_delta == 0)
+    {
+      *p++ = DW_LNS_copy;
+      goto done;
+    }
+
+  /* Bias the opcode by the special opcode base.  */
+  tmp += DWARF2_LINE_OPCODE_BASE;
+
+  /* Avoid overflow when addr_delta is large.  */
+  if (addr_delta < 256 + MAX_SPECIAL_ADDR_DELTA)
+    {
+      /* Try using a special opcode.  */
+      opcode = tmp + addr_delta * DWARF2_LINE_RANGE;
+      if (opcode <= 255)
+	{
+	  *p++ = opcode;
+	  goto done;
+	}
+
+      /* Try using DW_LNS_const_add_pc followed by special op.  */
+      opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA) * DWARF2_LINE_RANGE;
+      if (opcode <= 255)
+	{
+	  *p++ = DW_LNS_const_add_pc;
+	  *p++ = opcode;
+	  goto done;
+	}
+    }
+
+  /* Otherwise use DW_LNS_advance_pc.  */
+  *p++ = DW_LNS_advance_pc;
+  p += output_leb128 (p, addr_delta, 0);
+
+  if (need_copy)
+    *p++ = DW_LNS_copy;
+  else
+    *p++ = tmp;
+
+ done:
+  gas_assert (p == end);
+}
+
+/* Handy routine to combine calls to the above two routines.  */
+
+static void
+out_inc_line_addr (int line_delta, addressT addr_delta)
+{
+  int len = size_inc_line_addr (line_delta, addr_delta);
+  emit_inc_line_addr (line_delta, addr_delta, frag_more (len), len);
+}
+
+/* Write out an alternative form of line and address skips using
+   DW_LNS_fixed_advance_pc opcodes.  This uses more space than the default
+   line and address information, but it is required if linker relaxation
+   could change the code offsets.  The following two routines *must* be
+   kept in sync.  */
+
+static int
+size_fixed_inc_line_addr (int line_delta, addressT addr_delta)
+{
+  int len = 0;
+
+  /* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.  */
+  if (line_delta != INT_MAX)
+    len = 1 + sizeof_leb128 (line_delta, 1);
+
+  if (addr_delta > 50000)
+    {
+      /* DW_LNS_extended_op */
+      len += 1 + sizeof_leb128 (sizeof_address + 1, 0);
+      /* DW_LNE_set_address */
+      len += 1 + sizeof_address;
+    }
+  else
+    /* DW_LNS_fixed_advance_pc */
+    len += 3;
+
+  if (line_delta == INT_MAX)
+    /* DW_LNS_extended_op + DW_LNE_end_sequence */
+    len += 3;
+  else
+    /* DW_LNS_copy */
+    len += 1;
+
+  return len;
+}
+
+static void
+emit_fixed_inc_line_addr (int line_delta, addressT addr_delta, fragS *frag,
+			  char *p, int len)
+{
+  expressionS *exp;
+  segT line_seg;
+  char *end = p + len;
+
+  /* Line number sequences cannot go backward in addresses.  This means
+     we've incorrectly ordered the statements in the sequence.  */
+  gas_assert ((offsetT) addr_delta >= 0);
+
+  /* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.  */
+  if (line_delta != INT_MAX)
+    {
+      *p++ = DW_LNS_advance_line;
+      p += output_leb128 (p, line_delta, 1);
+    }
+
+  exp = symbol_get_value_expression (frag->fr_symbol);
+  line_seg = subseg_get (".debug_line", 0);
+
+  /* The DW_LNS_fixed_advance_pc opcode has a 2-byte operand so it can
+     advance the address by at most 64K.  Linker relaxation (without
+     which this function would not be used) could change the operand by
+     an unknown amount.  If the address increment is getting close to
+     the limit, just reset the address.  */
+  if (addr_delta > 50000)
+    {
+      symbolS *to_sym;
+      expressionS expr;
+
+      gas_assert (exp->X_op = O_subtract);
+      to_sym = exp->X_add_symbol;
+
+      *p++ = DW_LNS_extended_op;
+      p += output_leb128 (p, sizeof_address + 1, 0);
+      *p++ = DW_LNE_set_address;
+      expr.X_op = O_symbol;
+      expr.X_add_symbol = to_sym;
+      expr.X_add_number = 0;
+      subseg_change (line_seg, 0);
+      emit_expr_fix (&expr, sizeof_address, frag, p);
+      p += sizeof_address;
+    }
+  else
+    {
+      *p++ = DW_LNS_fixed_advance_pc;
+      subseg_change (line_seg, 0);
+      emit_expr_fix (exp, 2, frag, p);
+      p += 2;
+    }
+
+  if (line_delta == INT_MAX)
+    {
+      *p++ = DW_LNS_extended_op;
+      *p++ = 1;
+      *p++ = DW_LNE_end_sequence;
+    }
+  else
+    *p++ = DW_LNS_copy;
+
+  gas_assert (p == end);
+}
+
+/* Generate a variant frag that we can use to relax address/line
+   increments between fragments of the target segment.  */
+
+static void
+relax_inc_line_addr (int line_delta, symbolS *to_sym, symbolS *from_sym)
+{
+  expressionS expr;
+  int max_chars;
+
+  expr.X_op = O_subtract;
+  expr.X_add_symbol = to_sym;
+  expr.X_op_symbol = from_sym;
+  expr.X_add_number = 0;
+
+  /* The maximum size of the frag is the line delta with a maximum
+     sized address delta.  */
+  if (DWARF2_USE_FIXED_ADVANCE_PC)
+    max_chars = size_fixed_inc_line_addr (line_delta,
+					  -DWARF2_LINE_MIN_INSN_LENGTH);
+  else
+    max_chars = size_inc_line_addr (line_delta, -DWARF2_LINE_MIN_INSN_LENGTH);
+
+  frag_var (rs_dwarf2dbg, max_chars, max_chars, 1,
+	    make_expr_symbol (&expr), line_delta, NULL);
+}
+
+/* The function estimates the size of a rs_dwarf2dbg variant frag
+   based on the current values of the symbols.  It is called before
+   the relaxation loop.  We set fr_subtype to the expected length.  */
+
+int
+dwarf2dbg_estimate_size_before_relax (fragS *frag)
+{
+  offsetT addr_delta;
+  int size;
+
+  addr_delta = resolve_symbol_value (frag->fr_symbol);
+  if (DWARF2_USE_FIXED_ADVANCE_PC)
+    size = size_fixed_inc_line_addr (frag->fr_offset, addr_delta);
+  else
+    size = size_inc_line_addr (frag->fr_offset, addr_delta);
+
+  frag->fr_subtype = size;
+
+  return size;
+}
+
+/* This function relaxes a rs_dwarf2dbg variant frag based on the
+   current values of the symbols.  fr_subtype is the current length
+   of the frag.  This returns the change in frag length.  */
+
+int
+dwarf2dbg_relax_frag (fragS *frag)
+{
+  int old_size, new_size;
+
+  old_size = frag->fr_subtype;
+  new_size = dwarf2dbg_estimate_size_before_relax (frag);
+
+  return new_size - old_size;
+}
+
+/* This function converts a rs_dwarf2dbg variant frag into a normal
+   fill frag.  This is called after all relaxation has been done.
+   fr_subtype will be the desired length of the frag.  */
+
+void
+dwarf2dbg_convert_frag (fragS *frag)
+{
+  offsetT addr_diff;
+
+  addr_diff = resolve_symbol_value (frag->fr_symbol);
+
+  /* fr_var carries the max_chars that we created the fragment with.
+     fr_subtype carries the current expected length.  We must, of
+     course, have allocated enough memory earlier.  */
+  gas_assert (frag->fr_var >= (int) frag->fr_subtype);
+
+  if (DWARF2_USE_FIXED_ADVANCE_PC)
+    emit_fixed_inc_line_addr (frag->fr_offset, addr_diff, frag,
+			      frag->fr_literal + frag->fr_fix,
+			      frag->fr_subtype);
+  else
+    emit_inc_line_addr (frag->fr_offset, addr_diff,
+			frag->fr_literal + frag->fr_fix, frag->fr_subtype);
+
+  frag->fr_fix += frag->fr_subtype;
+  frag->fr_type = rs_fill;
+  frag->fr_var = 0;
+  frag->fr_offset = 0;
+}
+
+/* Generate .debug_line content for the chain of line number entries
+   beginning at E, for segment SEG.  */
+
+static void
+process_entries (segT seg, struct line_entry *e)
+{
+  unsigned filenum = 1;
+  unsigned line = 1;
+  unsigned column = 0;
+  unsigned isa = 0;
+  unsigned flags = DWARF2_LINE_DEFAULT_IS_STMT ? DWARF2_FLAG_IS_STMT : 0;
+  fragS *last_frag = NULL, *frag;
+  addressT last_frag_ofs = 0, frag_ofs;
+  symbolS *last_lab = NULL, *lab;
+  struct line_entry *next;
+
+  do
+    {
+      int line_delta;
+
+      if (filenum != e->loc.filenum)
+	{
+	  filenum = e->loc.filenum;
+	  out_opcode (DW_LNS_set_file);
+	  out_uleb128 (filenum);
+	}
+
+      if (column != e->loc.column)
+	{
+	  column = e->loc.column;
+	  out_opcode (DW_LNS_set_column);
+	  out_uleb128 (column);
+	}
+
+      if (e->loc.discriminator != 0)
+	{
+	  out_opcode (DW_LNS_extended_op);
+	  out_leb128 (1 + sizeof_leb128 (e->loc.discriminator, 0));
+	  out_opcode (DW_LNE_set_discriminator);
+	  out_uleb128 (e->loc.discriminator);
+	}
+
+      if (isa != e->loc.isa)
+	{
+	  isa = e->loc.isa;
+	  out_opcode (DW_LNS_set_isa);
+	  out_uleb128 (isa);
+	}
+
+      if ((e->loc.flags ^ flags) & DWARF2_FLAG_IS_STMT)
+	{
+	  flags = e->loc.flags;
+	  out_opcode (DW_LNS_negate_stmt);
+	}
+
+      if (e->loc.flags & DWARF2_FLAG_BASIC_BLOCK)
+	out_opcode (DW_LNS_set_basic_block);
+
+      if (e->loc.flags & DWARF2_FLAG_PROLOGUE_END)
+	out_opcode (DW_LNS_set_prologue_end);
+
+      if (e->loc.flags & DWARF2_FLAG_EPILOGUE_BEGIN)
+	out_opcode (DW_LNS_set_epilogue_begin);
+
+      /* Don't try to optimize away redundant entries; gdb wants two
+	 entries for a function where the code starts on the same line as
+	 the {, and there's no way to identify that case here.  Trust gcc
+	 to optimize appropriately.  */
+      line_delta = e->loc.line - line;
+      lab = e->label;
+      frag = symbol_get_frag (lab);
+      frag_ofs = S_GET_VALUE (lab);
+
+      if (last_frag == NULL)
+	{
+	  out_set_addr (lab);
+	  out_inc_line_addr (line_delta, 0);
+	}
+      else if (frag == last_frag && ! DWARF2_USE_FIXED_ADVANCE_PC)
+	out_inc_line_addr (line_delta, frag_ofs - last_frag_ofs);
+      else
+	relax_inc_line_addr (line_delta, lab, last_lab);
+
+      line = e->loc.line;
+      last_lab = lab;
+      last_frag = frag;
+      last_frag_ofs = frag_ofs;
+
+      next = e->next;
+      free (e);
+      e = next;
+    }
+  while (e);
+
+  /* Emit a DW_LNE_end_sequence for the end of the section.  */
+  frag = last_frag_for_seg (seg);
+  frag_ofs = get_frag_fix (frag, seg);
+  if (frag == last_frag && ! DWARF2_USE_FIXED_ADVANCE_PC)
+    out_inc_line_addr (INT_MAX, frag_ofs - last_frag_ofs);
+  else
+    {
+      lab = symbol_temp_new (seg, frag_ofs, frag);
+      relax_inc_line_addr (INT_MAX, lab, last_lab);
+    }
+}
+
+/* Emit the directory and file tables for .debug_line.  */
+
+static void
+out_file_list (void)
+{
+  size_t size;
+  const char *dir;
+  char *cp;
+  unsigned int i;
+
+  /* Emit directory list.  */
+  for (i = 1; i < dirs_in_use; ++i)
+    {
+      dir = remap_debug_filename (dirs[i]);
+      size = strlen (dir) + 1;
+      cp = frag_more (size);
+      memcpy (cp, dir, size);
+    }
+  /* Terminate it.  */
+  out_byte ('\0');
+
+  for (i = 1; i < files_in_use; ++i)
+    {
+      const char *fullfilename;
+
+      if (files[i].filename == NULL)
+	{
+	  as_bad (_("unassigned file number %ld"), (long) i);
+	  /* Prevent a crash later, particularly for file 1.  */
+	  files[i].filename = "";
+	  continue;
+	}
+
+      fullfilename = DWARF2_FILE_NAME (files[i].filename,
+				       files[i].dir ? dirs [files [i].dir] : "");
+      size = strlen (fullfilename) + 1;
+      cp = frag_more (size);
+      memcpy (cp, fullfilename, size);
+
+      out_uleb128 (files[i].dir);	/* directory number */
+      /* Output the last modification timestamp.  */
+      out_uleb128 (DWARF2_FILE_TIME_NAME (files[i].filename,
+				          files[i].dir ? dirs [files [i].dir] : ""));
+      /* Output the filesize.  */
+      out_uleb128 (DWARF2_FILE_SIZE_NAME (files[i].filename,
+				          files[i].dir ? dirs [files [i].dir] : ""));
+    }
+
+  /* Terminate filename list.  */
+  out_byte (0);
+}
+
+/* Switch to SEC and output a header length field.  Return the size of
+   offsets used in SEC.  The caller must set EXPR->X_add_symbol value
+   to the end of the section.  */
+
+static int
+out_header (asection *sec, expressionS *expr)
+{
+  symbolS *start_sym;
+  symbolS *end_sym;
+
+  subseg_set (sec, 0);
+  start_sym = symbol_temp_new_now ();;
+  end_sym = symbol_temp_make ();
+
+  /* Total length of the information.  */
+  expr->X_op = O_subtract;
+  expr->X_add_symbol = end_sym;
+  expr->X_op_symbol = start_sym;
+
+  switch (DWARF2_FORMAT (sec))
+    {
+    case dwarf2_format_32bit:
+      expr->X_add_number = -4;
+      emit_expr (expr, 4);
+      return 4;
+
+    case dwarf2_format_64bit:
+      expr->X_add_number = -12;
+      out_four (-1);
+      emit_expr (expr, 8);
+      return 8;
+
+    case dwarf2_format_64bit_irix:
+      expr->X_add_number = -8;
+      emit_expr (expr, 8);
+      return 8;
+    }
+
+  as_fatal (_("internal error: unknown dwarf2 format"));
+  return 0;
+}
+
+/* Emit the collected .debug_line data.  */
+
+static void
+out_debug_line (segT line_seg)
+{
+  expressionS expr;
+  symbolS *prologue_end;
+  symbolS *line_end;
+  struct line_seg *s;
+  int sizeof_offset;
+
+  sizeof_offset = out_header (line_seg, &expr);
+  line_end = expr.X_add_symbol;
+
+  /* Version.  */
+  out_two (2);
+
+  /* Length of the prologue following this length.  */
+  prologue_end = symbol_temp_make ();
+  expr.X_add_symbol = prologue_end;
+  expr.X_add_number = - (4 + 2 + 4);
+  emit_expr (&expr, sizeof_offset);
+
+  /* Parameters of the state machine.  */
+  out_byte (DWARF2_LINE_MIN_INSN_LENGTH);
+  out_byte (DWARF2_LINE_DEFAULT_IS_STMT);
+  out_byte (DWARF2_LINE_BASE);
+  out_byte (DWARF2_LINE_RANGE);
+  out_byte (DWARF2_LINE_OPCODE_BASE);
+
+  /* Standard opcode lengths.  */
+  out_byte (0);			/* DW_LNS_copy */
+  out_byte (1);			/* DW_LNS_advance_pc */
+  out_byte (1);			/* DW_LNS_advance_line */
+  out_byte (1);			/* DW_LNS_set_file */
+  out_byte (1);			/* DW_LNS_set_column */
+  out_byte (0);			/* DW_LNS_negate_stmt */
+  out_byte (0);			/* DW_LNS_set_basic_block */
+  out_byte (0);			/* DW_LNS_const_add_pc */
+  out_byte (1);			/* DW_LNS_fixed_advance_pc */
+  out_byte (0);			/* DW_LNS_set_prologue_end */
+  out_byte (0);			/* DW_LNS_set_epilogue_begin */
+  out_byte (1);			/* DW_LNS_set_isa */
+
+  out_file_list ();
+
+  symbol_set_value_now (prologue_end);
+
+  /* For each section, emit a statement program.  */
+  for (s = all_segs; s; s = s->next)
+    process_entries (s->seg, s->head->head);
+
+  symbol_set_value_now (line_end);
+}
+
+static void
+out_debug_ranges (segT ranges_seg)
+{
+  unsigned int addr_size = sizeof_address;
+  struct line_seg *s;
+  expressionS expr;
+  unsigned int i;
+
+  subseg_set (ranges_seg, 0);
+
+  /* Base Address Entry.  */
+  for (i = 0; i < addr_size; i++)
+    out_byte (0xff);
+  for (i = 0; i < addr_size; i++)
+    out_byte (0);
+
+  /* Range List Entry.  */
+  for (s = all_segs; s; s = s->next)
+    {
+      fragS *frag;
+      symbolS *beg, *end;
+
+      frag = first_frag_for_seg (s->seg);
+      beg = symbol_temp_new (s->seg, 0, frag);
+      s->text_start = beg;
+
+      frag = last_frag_for_seg (s->seg);
+      end = symbol_temp_new (s->seg, get_frag_fix (frag, s->seg), frag);
+      s->text_end = end;
+
+      expr.X_op = O_symbol;
+      expr.X_add_symbol = beg;
+      expr.X_add_number = 0;
+      emit_expr (&expr, addr_size);
+
+      expr.X_op = O_symbol;
+      expr.X_add_symbol = end;
+      expr.X_add_number = 0;
+      emit_expr (&expr, addr_size);
+    }
+
+  /* End of Range Entry.   */
+  for (i = 0; i < addr_size; i++)
+    out_byte (0);
+  for (i = 0; i < addr_size; i++)
+    out_byte (0);
+}
+
+/* Emit data for .debug_aranges.  */
+
+static void
+out_debug_aranges (segT aranges_seg, segT info_seg)
+{
+  unsigned int addr_size = sizeof_address;
+  struct line_seg *s;
+  expressionS expr;
+  symbolS *aranges_end;
+  char *p;
+  int sizeof_offset;
+
+  sizeof_offset = out_header (aranges_seg, &expr);
+  aranges_end = expr.X_add_symbol;
+
+  /* Version.  */
+  out_two (2);
+
+  /* Offset to .debug_info.  */
+  TC_DWARF2_EMIT_OFFSET (section_symbol (info_seg), sizeof_offset);
+
+  /* Size of an address (offset portion).  */
+  out_byte (addr_size);
+
+  /* Size of a segment descriptor.  */
+  out_byte (0);
+
+  /* Align the header.  */
+  frag_align (ffs (2 * addr_size) - 1, 0, 0);
+
+  for (s = all_segs; s; s = s->next)
+    {
+      fragS *frag;
+      symbolS *beg, *end;
+
+      frag = first_frag_for_seg (s->seg);
+      beg = symbol_temp_new (s->seg, 0, frag);
+      s->text_start = beg;
+
+      frag = last_frag_for_seg (s->seg);
+      end = symbol_temp_new (s->seg, get_frag_fix (frag, s->seg), frag);
+      s->text_end = end;
+
+      expr.X_op = O_symbol;
+      expr.X_add_symbol = beg;
+      expr.X_add_number = 0;
+      emit_expr (&expr, addr_size);
+
+      expr.X_op = O_subtract;
+      expr.X_add_symbol = end;
+      expr.X_op_symbol = beg;
+      expr.X_add_number = 0;
+      emit_expr (&expr, addr_size);
+    }
+
+  p = frag_more (2 * addr_size);
+  md_number_to_chars (p, 0, addr_size);
+  md_number_to_chars (p + addr_size, 0, addr_size);
+
+  symbol_set_value_now (aranges_end);
+}
+
+/* Emit data for .debug_abbrev.  Note that this must be kept in
+   sync with out_debug_info below.  */
+
+static void
+out_debug_abbrev (segT abbrev_seg,
+		  segT info_seg ATTRIBUTE_UNUSED,
+		  segT line_seg ATTRIBUTE_UNUSED)
+{
+  subseg_set (abbrev_seg, 0);
+
+  out_uleb128 (1);
+  out_uleb128 (DW_TAG_compile_unit);
+  out_byte (DW_CHILDREN_no);
+  if (DWARF2_FORMAT (line_seg) == dwarf2_format_32bit)
+    out_abbrev (DW_AT_stmt_list, DW_FORM_data4);
+  else
+    out_abbrev (DW_AT_stmt_list, DW_FORM_data8);
+  if (all_segs->next == NULL)
+    {
+      out_abbrev (DW_AT_low_pc, DW_FORM_addr);
+      out_abbrev (DW_AT_high_pc, DW_FORM_addr);
+    }
+  else
+    {
+      if (DWARF2_FORMAT (info_seg) == dwarf2_format_32bit)
+	out_abbrev (DW_AT_ranges, DW_FORM_data4);
+      else
+	out_abbrev (DW_AT_ranges, DW_FORM_data8);
+    }
+  out_abbrev (DW_AT_name, DW_FORM_string);
+  out_abbrev (DW_AT_comp_dir, DW_FORM_string);
+  out_abbrev (DW_AT_producer, DW_FORM_string);
+  out_abbrev (DW_AT_language, DW_FORM_data2);
+  out_abbrev (0, 0);
+
+  /* Terminate the abbreviations for this compilation unit.  */
+  out_byte (0);
+}
+
+/* Emit a description of this compilation unit for .debug_info.  */
+
+static void
+out_debug_info (segT info_seg, segT abbrev_seg, segT line_seg, segT ranges_seg)
+{
+  char producer[128];
+  const char *comp_dir;
+  const char *dirname;
+  expressionS expr;
+  symbolS *info_end;
+  char *p;
+  int len;
+  int sizeof_offset;
+
+  sizeof_offset = out_header (info_seg, &expr);
+  info_end = expr.X_add_symbol;
+
+  /* DWARF version.  */
+  out_two (2);
+
+  /* .debug_abbrev offset */
+  TC_DWARF2_EMIT_OFFSET (section_symbol (abbrev_seg), sizeof_offset);
+
+  /* Target address size.  */
+  out_byte (sizeof_address);
+
+  /* DW_TAG_compile_unit DIE abbrev */
+  out_uleb128 (1);
+
+  /* DW_AT_stmt_list */
+  TC_DWARF2_EMIT_OFFSET (section_symbol (line_seg),
+			 (DWARF2_FORMAT (line_seg) == dwarf2_format_32bit
+			  ? 4 : 8));
+
+  /* These two attributes are emitted if all of the code is contiguous.  */
+  if (all_segs->next == NULL)
+    {
+      /* DW_AT_low_pc */
+      expr.X_op = O_symbol;
+      expr.X_add_symbol = all_segs->text_start;
+      expr.X_add_number = 0;
+      emit_expr (&expr, sizeof_address);
+
+      /* DW_AT_high_pc */
+      expr.X_op = O_symbol;
+      expr.X_add_symbol = all_segs->text_end;
+      expr.X_add_number = 0;
+      emit_expr (&expr, sizeof_address);
+    }
+  else
+    {
+      /* This attribute is emitted if the code is disjoint.  */
+      /* DW_AT_ranges.  */
+      TC_DWARF2_EMIT_OFFSET (section_symbol (ranges_seg), sizeof_offset);
+    }
+
+  /* DW_AT_name.  We don't have the actual file name that was present
+     on the command line, so assume files[1] is the main input file.
+     We're not supposed to get called unless at least one line number
+     entry was emitted, so this should always be defined.  */
+  if (files_in_use == 0)
+    abort ();
+  if (files[1].dir)
+    {
+      dirname = remap_debug_filename (dirs[files[1].dir]);
+      len = strlen (dirname);
+#ifdef TE_VMS
+      /* Already has trailing slash.  */
+      p = frag_more (len);
+      memcpy (p, dirname, len);
+#else
+      p = frag_more (len + 1);
+      memcpy (p, dirname, len);
+      INSERT_DIR_SEPARATOR (p, len);
+#endif
+    }
+  len = strlen (files[1].filename) + 1;
+  p = frag_more (len);
+  memcpy (p, files[1].filename, len);
+
+  /* DW_AT_comp_dir */
+  comp_dir = remap_debug_filename (getpwd ());
+  len = strlen (comp_dir) + 1;
+  p = frag_more (len);
+  memcpy (p, comp_dir, len);
+
+  /* DW_AT_producer */
+  sprintf (producer, "GNU AS %s", VERSION);
+  len = strlen (producer) + 1;
+  p = frag_more (len);
+  memcpy (p, producer, len);
+
+  /* DW_AT_language.  Yes, this is probably not really MIPS, but the
+     dwarf2 draft has no standard code for assembler.  */
+  out_two (DW_LANG_Mips_Assembler);
+
+  symbol_set_value_now (info_end);
+}
+
+/* Finish the dwarf2 debug sections.  We emit .debug.line if there
+   were any .file/.loc directives, or --gdwarf2 was given, or if the
+   file has a non-empty .debug_info section.  If we emit .debug_line,
+   and the .debug_info section is empty, we also emit .debug_info,
+   .debug_aranges and .debug_abbrev.  ALL_SEGS will be non-null if
+   there were any .file/.loc directives, or --gdwarf2 was given and
+   there were any located instructions emitted.  */
+
+void
+dwarf2_finish (void)
+{
+  segT line_seg;
+  struct line_seg *s;
+  segT info_seg;
+  int emit_other_sections = 0;
+
+  info_seg = bfd_get_section_by_name (stdoutput, ".debug_info");
+  emit_other_sections = info_seg == NULL || !seg_not_empty_p (info_seg);
+
+  if (!all_segs && emit_other_sections)
+    /* There is no line information and no non-empty .debug_info
+       section.  */
+    return;
+
+  /* Calculate the size of an address for the target machine.  */
+  sizeof_address = DWARF2_ADDR_SIZE (stdoutput);
+
+  /* Create and switch to the line number section.  */
+  line_seg = subseg_new (".debug_line", 0);
+  bfd_set_section_flags (stdoutput, line_seg, SEC_READONLY | SEC_DEBUGGING);
+
+  /* For each subsection, chain the debug entries together.  */
+  for (s = all_segs; s; s = s->next)
+    {
+      struct line_subseg *ss = s->head;
+      struct line_entry **ptail = ss->ptail;
+
+      while ((ss = ss->next) != NULL)
+	{
+	  *ptail = ss->head;
+	  ptail = ss->ptail;
+	}
+    }
+
+  out_debug_line (line_seg);
+
+  /* If this is assembler generated line info, and there is no
+     debug_info already, we need .debug_info and .debug_abbrev
+     sections as well.  */
+  if (emit_other_sections)
+    {
+      segT abbrev_seg;
+      segT aranges_seg;
+      segT ranges_seg;
+
+      gas_assert (all_segs);
+
+      info_seg = subseg_new (".debug_info", 0);
+      abbrev_seg = subseg_new (".debug_abbrev", 0);
+      aranges_seg = subseg_new (".debug_aranges", 0);
+
+      bfd_set_section_flags (stdoutput, info_seg,
+			     SEC_READONLY | SEC_DEBUGGING);
+      bfd_set_section_flags (stdoutput, abbrev_seg,
+			     SEC_READONLY | SEC_DEBUGGING);
+      bfd_set_section_flags (stdoutput, aranges_seg,
+			     SEC_READONLY | SEC_DEBUGGING);
+
+      record_alignment (aranges_seg, ffs (2 * sizeof_address) - 1);
+
+      if (all_segs->next == NULL)
+	ranges_seg = NULL;
+      else
+	{
+	  ranges_seg = subseg_new (".debug_ranges", 0);
+	  bfd_set_section_flags (stdoutput, ranges_seg,
+				 SEC_READONLY | SEC_DEBUGGING);
+	  record_alignment (ranges_seg, ffs (2 * sizeof_address) - 1);
+	  out_debug_ranges (ranges_seg);
+	}
+
+      out_debug_aranges (aranges_seg, info_seg);
+      out_debug_abbrev (abbrev_seg, info_seg, line_seg);
+      out_debug_info (info_seg, abbrev_seg, line_seg, ranges_seg);
+    }
+}
diff -urN binutils-2.20.1.old/include/coff/avr.h binutils-2.20.1/include/coff/avr.h
--- binutils-2.20.1.old/include/coff/avr.h	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/include/coff/avr.h	2010-04-13 09:47:42.141946953 -0500
@@ -0,0 +1,110 @@
+/* coff information for Atmel AVR.
+   
+   Copyright 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* This file was hacked from i860.h */
+
+#define L_LNNO_SIZE 2
+#include "coff/external.h"
+
+/* Bits for f_flags:
+ 	F_RELFLG	relocation info stripped from file
+ 	F_EXEC		file is executable (no unresolved external references)
+ 	F_LNNO		line numbers stripped from file
+ 	F_LSYMS		local symbols stripped from file  */
+
+#define F_RELFLG	(0x0001)
+#define F_EXEC		(0x0002)
+#define F_LNNO		(0x0004)
+#define F_LSYMS		(0x0008)
+/* Upper nibble of flags always needs to be set.  This used to be
+ * undocumented, recent information from Atmel says that bit 7 used to
+ * differentiate between an old vendor-specific deviation of the
+ * format and the current format. */
+#define F_JUNK		(0x00f0)
+#define F_UNUSED	(0xff00)
+
+#define	AVRMAGIC	0xa12
+
+#undef AOUTSZ
+#ifdef AVR_EXT_COFF
+
+/* AVR "extended" COFF format.  This uses the optional header ("a.out"
+   header) to inform the consumer about some additional features that
+   are supported. */
+#define COFF_LONG_FILENAMES yes	/* long filenames supported in consecutive aux entries */
+#define AOUTSZ		28	/* size of optional header in "extended" COFF */
+
+/* Flags in the optional header; they are stored in the vstamp field. */
+#define F_FULLPATHS	0x0001	/* long filenames supported */
+#define F_STRUCTINFO	0x0002	/* structure information contained */
+#define F_PTRINFO	0x0004	/* inter-segment pointers supported */
+
+#else /* old AVR COFF */
+
+#define AOUTSZ		0	/* no a.out for AVR */
+#endif
+
+/* #define AVRAOUTMAGIC	0x406 */ /* "general" magic number of optional header */
+/*
+ * The following magic number causes AVR Studio 4.x to recognize
+ * avr-gcc/GNU binutils produced AVR extended COFF files.  By now,
+ * the only special treatment for them is that the contents of .data
+ * will be appended after .text in the simulator flash.
+ *
+ * 0x9cc has been chosen since it resembles "gcc". ;-)
+ */
+#define AVRAOUTMAGIC	0x9cc	/* "gcc" magic number */
+
+/* By matching not only the magic number, but also the size of the
+   optional a.out header, we can differentiate between both
+   formats. */
+#define AVRBADMAG(x)   ((x).f_magic != AVRMAGIC || (x).f_opthdr != AOUTSZ)
+
+/* AVR COFF has several anomalities in the way the handle the derived
+   type information, and AUX entries, mainly because they apparently
+   didn't bother to learn how COFF is supposed to work before they
+   started.  We fix many of them at the export/import boundary, so all
+   the internal generic COFF handling will work mostly as designed. */
+
+/* NB: these functions are only defined in bfd/coff-avr.c, but also
+   used in coff-ext-avr.c, so the latter can only be configured if the
+   former is also present.  This is certainly always the case
+   anyway. */
+extern void avr_coff_adjust_sym_in_post
+  PARAMS((bfd *, PTR, PTR));
+
+extern void avr_coff_adjust_sym_out_post
+  PARAMS((bfd *, PTR, PTR));
+
+#define COFF_ADJUST_SYM_IN_POST(ABFD, EXT, INT) \
+	avr_coff_adjust_sym_in_post (ABFD, EXT, INT)
+
+#define COFF_ADJUST_SYM_OUT_POST(ABFD, INT, EXT) \
+	avr_coff_adjust_sym_out_post (ABFD, INT, EXT)
+
+/********************** RELOCATION DIRECTIVES **********************/
+
+struct external_reloc
+{
+  char r_vaddr[4];
+  char r_symndx[4];
+  char r_type[2];
+};
+
+#define RELOC struct external_reloc
+#define RELSZ 10
diff -urN binutils-2.20.1.old/include/elf/avr.h binutils-2.20.1/include/elf/avr.h
--- binutils-2.20.1.old/include/elf/avr.h	2008-08-09 00:35:13.000000000 -0500
+++ binutils-2.20.1/include/elf/avr.h	2010-04-13 09:49:42.341947494 -0500
@@ -40,6 +40,13 @@
 #define E_AVR_MACH_AVR5 5
 #define E_AVR_MACH_AVR51 51
 #define E_AVR_MACH_AVR6 6 
+#define E_AVR_MACH_XMEGA1 101
+#define E_AVR_MACH_XMEGA2 102
+#define E_AVR_MACH_XMEGA3 103
+#define E_AVR_MACH_XMEGA4 104
+#define E_AVR_MACH_XMEGA5 105
+#define E_AVR_MACH_XMEGA6 106
+#define E_AVR_MACH_XMEGA7 107
 
 /* Relocations.  */
 START_RELOC_NUMBERS (elf_avr_reloc_type)
diff -urN binutils-2.20.1.old/include/opcode/avr.h binutils-2.20.1/include/opcode/avr.h
--- binutils-2.20.1.old/include/opcode/avr.h	2008-08-09 00:35:13.000000000 -0500
+++ binutils-2.20.1/include/opcode/avr.h	2010-04-13 09:49:42.341947494 -0500
@@ -30,6 +30,8 @@
 #define AVR_ISA_BRK   0x0400 /* device has BREAK (on-chip debug) */
 #define AVR_ISA_EIND  0x0800 /* device has >128K program memory (none yet) */
 #define AVR_ISA_MOVW  0x1000 /* device has MOVW */
+#define AVR_ISA_SPMX  0x2000 /* device has SPM Z[+] */
+#define AVR_ISA_DES   0x4000 /* device has DES */
 
 #define AVR_ISA_TINY1 (AVR_ISA_1200 | AVR_ISA_LPM)
 #define AVR_ISA_2xxx  (AVR_ISA_TINY1 | AVR_ISA_SRAM)
@@ -48,6 +50,8 @@
 #define AVR_ISA_94K   (AVR_ISA_M603 | AVR_ISA_MUL | AVR_ISA_MOVW | AVR_ISA_LPMX)
 #define AVR_ISA_M323  (AVR_ISA_M161 | AVR_ISA_BRK)
 #define AVR_ISA_M128  (AVR_ISA_M323 | AVR_ISA_ELPM | AVR_ISA_ELPMX)
+#define AVR_ISA_M256  (AVR_ISA_M128 | AVR_ISA_EIND)
+#define AVR_ISA_XMEGA (AVR_ISA_M256 | AVR_ISA_SPMX | AVR_ISA_DES)
 
 #define AVR_ISA_AVR1   AVR_ISA_TINY1
 #define AVR_ISA_AVR2   AVR_ISA_2xxx
@@ -108,6 +112,7 @@
    L - signed pc relative offset from -2048 to 2047
    h - absolute code address (call, jmp)
    S - immediate value from 0 to 7 (S = s << 4)
+   E - immediate value from 0 to 15, shifted left by 4 (des)
    ? - use this opcode entry if no parameters, else use next opcode entry
 
    Order is important - some binary opcodes have more than one name,
@@ -168,7 +173,8 @@
 AVR_INSN (sleep,"",    "1001010110001000", 1, AVR_ISA_1200, 0x9588)
 AVR_INSN (break,"",    "1001010110011000", 1, AVR_ISA_BRK,  0x9598)
 AVR_INSN (wdr,  "",    "1001010110101000", 1, AVR_ISA_1200, 0x95a8)
-AVR_INSN (spm,  "",    "1001010111101000", 1, AVR_ISA_SPM,  0x95e8)
+AVR_INSN (spm,  "?",   "1001010111101000", 1, AVR_ISA_SPM,  0x95e8)
+AVR_INSN (spm,  "z",   "10010101111+1000", 1, AVR_ISA_SPMX, 0x95e8)
 
 AVR_INSN (adc,  "r,r", "000111rdddddrrrr", 1, AVR_ISA_1200, 0x1c00)
 AVR_INSN (add,  "r,r", "000011rdddddrrrr", 1, AVR_ISA_1200, 0x0c00)
@@ -282,3 +288,6 @@
 AVR_INSN (eicall, "",  "1001010100011001", 1, AVR_ISA_EIND, 0x9519)
 AVR_INSN (eijmp, "",   "1001010000011001", 1, AVR_ISA_EIND, 0x9419)
 
+/* DES instruction for encryption and decryption */
+AVR_INSN (des,  "E",   "10010100EEEE1011", 1, AVR_ISA_DES,  0x940B)
+
diff -urN binutils-2.20.1.old/ld/Makefile.am binutils-2.20.1/ld/Makefile.am
--- binutils-2.20.1.old/ld/Makefile.am	2010-02-22 02:07:01.000000000 -0600
+++ binutils-2.20.1/ld/Makefile.am	2010-04-13 09:49:42.341947494 -0500
@@ -148,6 +148,13 @@
 	eavr5.o \
 	eavr51.o \
 	eavr6.o \
+	eavrxmega1.o \
+	eavrxmega2.o \
+	eavrxmega3.o \
+	eavrxmega4.o \
+	eavrxmega5.o \
+	eavrxmega6.o \
+	eavrxmega7.o \
 	ecoff_i860.o \
 	ecoff_sparc.o \
 	eelf32_spu.o \
@@ -727,6 +734,34 @@
   $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} avr6 "$(tdir_avr2)"
+eavrxmega1.c: $(srcdir)/emulparams/avrxmega1.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega1 "$(tdir_avr2)"
+eavrxmega2.c: $(srcdir)/emulparams/avrxmega2.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega2 "$(tdir_avr2)"
+eavrxmega3.c: $(srcdir)/emulparams/avrxmega3.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega3 "$(tdir_avr2)"
+eavrxmega4.c: $(srcdir)/emulparams/avrxmega4.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega4 "$(tdir_avr2)"
+eavrxmega5.c: $(srcdir)/emulparams/avrxmega5.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega5 "$(tdir_avr2)"
+eavrxmega6.c: $(srcdir)/emulparams/avrxmega6.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega6 "$(tdir_avr2)"
+eavrxmega7.c: $(srcdir)/emulparams/avrxmega7.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega7 "$(tdir_avr2)"
 ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} coff_i860 "$(tdir_coff_i860)"
diff -urN binutils-2.20.1.old/ld/Makefile.am.orig binutils-2.20.1/ld/Makefile.am.orig
--- binutils-2.20.1.old/ld/Makefile.am.orig	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/ld/Makefile.am.orig	2010-02-22 02:07:01.000000000 -0600
@@ -0,0 +1,1995 @@
+## Process this file with automake to generate Makefile.in
+
+AUTOMAKE_OPTIONS = dejagnu no-texinfo.tex no-dist foreign
+ACLOCAL_AMFLAGS = -I .. -I ../config -I ../bfd
+TEXINFO_TEX = $(top_srcdir)/../texinfo/texinfo.tex
+
+SUBDIRS = po
+
+tooldir = $(exec_prefix)/$(target_alias)
+
+YACC = `if [ -f ../bison/bison ]; then echo ../bison/bison -y -L$(srcdir)/../bison/; else echo @YACC@; fi`
+YFLAGS = -d
+LEX = `if [ -f ../flex/flex ]; then echo ../flex/flex; else echo @LEX@; fi`
+
+# Automake 1.10+ disables lex and yacc output file regeneration if
+# maintainer mode is disabled.  Avoid this.
+am__skiplex =
+am__skipyacc =
+
+WARN_CFLAGS = @WARN_CFLAGS@
+NO_WERROR = @NO_WERROR@
+AM_CFLAGS = $(WARN_CFLAGS)
+
+# We put the scripts in the directory $(scriptdir)/ldscripts.
+# We can't put the scripts in $(datadir) because the SEARCH_DIR
+# directives need to be different for native and cross linkers.
+scriptdir = $(tooldir)/lib
+
+EMUL = @EMUL@
+EMULATION_OFILES = @EMULATION_OFILES@
+EMUL_EXTRA_OFILES = @EMUL_EXTRA_OFILES@
+
+# Search path to override the default search path for -lfoo libraries.
+# If LIB_PATH is empty, the ones in the script (if any) are left alone.
+# (The default is usually /lib:/usr/lib:/usr/local/lib, unless building
+# a cross-linker, in which case the default is empty.  See genscripts.sh.)
+# Otherwise, they are replaced with the ones given in LIB_PATH,
+# which may have the form: LIB_PATH=/lib:/usr/local/lib.  This can be set
+# when the linker is configured via the --with-lib-path configure switch.
+LIB_PATH = @LIB_PATH@
+
+BASEDIR = $(srcdir)/..
+BFDDIR = $(BASEDIR)/bfd
+INCDIR	= $(BASEDIR)/include
+
+# What version of the manual to build
+DOCVER = gen
+
+# Options to extract the man page from ld.texinfo
+MANCONF = -Dman
+
+TEXI2POD = perl $(BASEDIR)/etc/texi2pod.pl $(AM_MAKEINFOFLAGS)
+
+POD2MAN = pod2man --center="GNU Development Tools" \
+	--release="binutils-$(VERSION)" --section=1
+
+#stuff for self hosting (can be overridden in config file).
+HOSTING_CRT0 = @HOSTING_CRT0@
+HOSTING_LIBS = @HOSTING_LIBS@
+HOSTING_EMU = -m $(EMUL)
+
+# Setup the testing framework, if you have one
+EXPECT = expect
+RUNTEST = runtest
+RUNTESTFLAGS =
+
+CC_FOR_TARGET = ` \
+  if [ -f $$r/../gcc/xgcc ] ; then \
+    if [ -f $$r/../newlib/Makefile ] ; then \
+      echo $$r/../gcc/xgcc -B$$r/../gcc/ -idirafter $$r/../newlib/targ-include -idirafter $${srcroot}/../newlib/libc/include -nostdinc; \
+    else \
+      echo $$r/../gcc/xgcc -B$$r/../gcc/; \
+    fi; \
+  else \
+    if [ "@host@" = "@target@" ] ; then \
+      echo $(CC); \
+    else \
+      echo gcc | sed '$(transform)'; \
+    fi; \
+  fi`
+
+CXX = g++
+CXX_FOR_TARGET = ` \
+  if [ -f $$r/../gcc/g++ ] ; then \
+    if [ -f $$r/../newlib/Makefile ] ; then \
+      echo $$r/../gcc/g++ -B$$r/../gcc/ -idirafter $$r/../newlib/targ-include -idirafter $${srcroot}/../newlib/libc/include -nostdinc; \
+    else \
+      echo $$r/../gcc/g++ -B$$r/../gcc/; \
+    fi; \
+  else \
+    if [ "@host@" = "@target@" ] ; then \
+      echo $(CXX); \
+    else \
+      echo g++ | sed '$(transform)'; \
+    fi; \
+  fi`
+
+transform = s/^ld-new$$/ld/;@program_transform_name@
+bin_PROGRAMS = ld-new
+info_TEXINFOS = ld.texinfo
+ld_TEXINFOS = configdoc.texi
+noinst_TEXINFOS = ldint.texinfo
+man_MANS = ld.1
+
+AM_MAKEINFOFLAGS = -I $(srcdir) -I $(BFDDIR)/doc -I ../bfd/doc \
+		   -I $(top_srcdir)/../libiberty
+TEXI2DVI = texi2dvi -I $(srcdir) -I $(BFDDIR)/doc -I ../bfd/doc \
+		    -I $(top_srcdir)/../libiberty
+
+AM_CPPFLAGS = -I. -I$(srcdir) -I../bfd -I$(BFDDIR) -I$(INCDIR) \
+	@INCINTL@ $(HDEFINES) $(CFLAGS) \
+	-DLOCALEDIR="\"$(datadir)/locale\""
+
+BFDLIB = ../bfd/libbfd.la
+LIBIBERTY = ../libiberty/libiberty.a
+
+ALL_EMULATIONS = \
+	eaixppc.o \
+	eaixrs6.o \
+	ealpha.o \
+	earcelf.o \
+	earm_epoc_pe.o \
+	earm_wince_pe.o \
+	earmaoutb.o \
+	earmaoutl.o \
+	earmcoff.o \
+	earmelf.o \
+	earmelfb.o \
+	earmelf_fbsd.o \
+	earmelf_linux.o \
+	earmelf_linux_eabi.o \
+	earmelfb_linux.o \
+	earmelfb_linux_eabi.o \
+	earmelf_nbsd.o \
+	earmelfb_nbsd.o \
+	earmelf_vxworks.o \
+	earmnto.o \
+	earmnbsd.o \
+	earmpe.o \
+	earmsymbian.o \
+	eavr2.o \
+	eavr1.o \
+	eavr25.o \
+	eavr3.o \
+	eavr31.o \
+	eavr35.o \
+	eavr4.o \
+	eavr5.o \
+	eavr51.o \
+	eavr6.o \
+	ecoff_i860.o \
+	ecoff_sparc.o \
+	eelf32_spu.o \
+	ecrisaout.o \
+	ecriself.o \
+	ecrislinux.o \
+	ed10velf.o \
+	ed30v_e.o \
+	ed30v_o.o \
+	ed30velf.o \
+	edelta68.o \
+	eelf32_dlx.o \
+	eelf32_i960.o \
+	eelf32_i860.o \
+	eelf32_sparc.o \
+	eelf32_sparc_vxworks.o \
+	eelf32b4300.o \
+	eelf32bfin.o \
+	eelf32bfinfd.o \
+	eelf32cr16.o \
+	eelf32cr16c.o \
+	eelf32bmip.o \
+	eelf32bmipn32.o \
+	eelf32btsmip.o \
+	eelf32crx.o \
+	eelf32btsmipn32.o \
+	eelf32ltsmip.o \
+	eelf32ltsmipn32.o \
+	eelf32ebmip.o \
+	eelf32ebmipvxworks.o \
+	eelf32elmip.o \
+	eelf32elmipvxworks.o \
+	eelf32fr30.o \
+	eelf32frv.o \
+	eelf32moxie.o \
+	eelf32i370.o \
+	eelf32ip2k.o \
+	eelf32iq2000.o \
+	eelf32iq10.o \
+	eelf32lm32.o \
+	eelf32lm32fd.o \
+	eelf32l4300.o \
+	eelf32lmip.o \
+	eelf32lppc.o \
+	eelf32lppcnto.o \
+	eelf32lppcsim.o \
+	eelf32m32c.o \
+	eelf32mcore.o \
+	eelf32mep.o \
+	eelf32mb_linux.o \
+ 	eelf32microblaze.o \
+	eelf32mipswindiss.o \
+	eelf32mt.o \
+	eelf32openrisc.o \
+	eelf32ppc.o \
+	eelf32ppc_fbsd.o \
+	eelf32ppclinux.o \
+	eelf32ppcnto.o \
+	eelf32ppcsim.o \
+	eelf32ppcwindiss.o \
+	eelf32ppcvxworks.o \
+	eelf32vax.o \
+        eelf32xc16x.o \
+        eelf32xc16xl.o \
+        eelf32xc16xs.o \
+	eelf32xstormy16.o \
+	eelf32xtensa.o \
+	eelf_i386.o \
+	eelf_i386_be.o \
+	eelf_i386_chaos.o \
+	eelf_i386_fbsd.o \
+	eelf_i386_ldso.o \
+	eelf_i386_vxworks.o \
+	eelf_s390.o \
+	egld960.o \
+	egld960coff.o \
+	eh8300.o \
+	eh8300h.o \
+	eh8300s.o \
+	eh8300elf.o \
+	eh8300hn.o \
+	eh8300sn.o \
+	eh8300sx.o \
+	eh8300helf.o \
+	eh8300self.o \
+	eh8300hnelf.o \
+	eh8300snelf.o \
+	eh8300sxelf.o \
+	eh8300sxn.o \
+	eh8300sxnelf.o \
+	eh8500.o \
+	eh8500b.o \
+	eh8500c.o \
+	eh8500m.o \
+	eh8500s.o \
+	ehp300bsd.o \
+	ehp3hpux.o \
+	ehppaelf.o \
+	ehppalinux.o \
+	ehppanbsd.o \
+	ehppaobsd.o \
+	ei386aout.o \
+	ei386beos.o \
+	ei386bsd.o \
+	ei386coff.o \
+	ei386go32.o \
+	ei386linux.o \
+	ei386lynx.o \
+	ei386mach.o \
+	ei386moss.o \
+	ei386msdos.o \
+	ei386nbsd.o \
+	ei386nto.o \
+	ei386nw.o \
+	ei386pe.o \
+	ei386pe_posix.o \
+	ei386pep.o \
+	elnk960.o \
+	em32relf.o \
+	em32rlelf.o \
+	em32relf_linux.o \
+	em32rlelf_linux.o \
+	em68hc11elf.o \
+	em68hc11elfb.o \
+	em68hc12elf.o \
+	em68hc12elfb.o \
+	em68k4knbsd.o \
+	em68kaout.o \
+	em68kaux.o \
+	em68kcoff.o \
+	em68kelf.o \
+	em68kelfnbsd.o \
+	em68klinux.o \
+	em68knbsd.o \
+	em68kpsos.o \
+	em88kbcs.o \
+	emaxqcoff.o \
+	emcorepe.o \
+	emipsbig.o \
+	emipsbsd.o \
+	emipsidt.o \
+	emipsidtl.o \
+	emipslit.o \
+	emipslnews.o \
+	emipspe.o \
+	emsp430x110.o \
+	emsp430x112.o \
+	emsp430x1101.o \
+	emsp430x1111.o \
+	emsp430x1121.o \
+	emsp430x1122.o \
+	emsp430x1132.o \
+	emsp430x122.o \
+	emsp430x123.o \
+	emsp430x1222.o \
+	emsp430x1232.o \
+	emsp430x133.o \
+	emsp430x135.o \
+	emsp430x1331.o \
+	emsp430x1351.o \
+	emsp430x147.o \
+	emsp430x148.o \
+	emsp430x149.o \
+	emsp430x155.o \
+	emsp430x156.o \
+	emsp430x157.o \
+	emsp430x167.o \
+	emsp430x168.o \
+	emsp430x169.o \
+	emsp430x1610.o \
+	emsp430x1611.o \
+	emsp430x1612.o \
+	emsp430x2101.o \
+	emsp430x2111.o \
+	emsp430x2121.o \
+	emsp430x2131.o \
+	emsp430x311.o \
+	emsp430x312.o \
+	emsp430x313.o \
+	emsp430x314.o \
+	emsp430x315.o \
+	emsp430x323.o \
+	emsp430x325.o \
+	emsp430x336.o \
+	emsp430x337.o \
+	emsp430x412.o \
+	emsp430x413.o \
+	emsp430x415.o \
+	emsp430x417.o \
+	emsp430xE423.o \
+	emsp430xE425.o \
+	emsp430xE427.o \
+	emsp430xW423.o \
+	emsp430xW425.o \
+	emsp430xW427.o \
+	emsp430xG437.o \
+	emsp430xG438.o \
+	emsp430xG439.o \
+	emsp430x435.o \
+	emsp430x436.o \
+	emsp430x437.o \
+	emsp430x447.o \
+	emsp430x448.o \
+	emsp430x449.o \
+	enews.o \
+	ens32knbsd.o \
+	eor32.o \
+	eor32elf.o \
+	epc532macha.o \
+	epdp11.o \
+	epjelf.o \
+	epjlelf.o \
+	eppcmacos.o \
+	eppcnw.o \
+	eppcpe.o \
+	eppclynx.o \
+	eriscix.o \
+	escore3_elf.o \
+	escore7_elf.o \
+	esh.o \
+	eshelf32.o \
+	eshlelf32.o \
+	eshelf32_linux.o \
+	eshlelf32_linux.o \
+	eshelf32_nbsd.o \
+	eshlelf32_nbsd.o \
+	eshelf.o \
+	eshelf_linux.o \
+	eshlelf_linux.o \
+	eshelf_nbsd.o \
+	eshlelf_nbsd.o \
+	eshelf_nto.o \
+	eshlelf_nto.o \
+	eshelf_uclinux.o \
+	eshelf_vxworks.o \
+	eshlelf_vxworks.o \
+	eshl.o \
+	eshlelf.o \
+	eshlsymbian.o \
+	eshpe.o \
+	esparcaout.o \
+	esparclinux.o \
+	esparcnbsd.o \
+	est2000.o \
+	esun3.o \
+	esun4.o \
+	etic30aout.o \
+	etic30coff.o \
+	etic3xcoff.o \
+	etic3xcoff_onchip.o \
+	etic4xcoff.o \
+	etic54xcoff.o \
+	etic80coff.o \
+	evanilla.o \
+	evax.o \
+	evaxnbsd.o \
+	evsta.o \
+	ew65.o \
+	ez8001.o \
+	eelf32frvfd.o \
+	ez80.o \
+	ez8002.o
+
+ALL_64_EMULATIONS = \
+	eelf64_aix.o \
+	eelf64_ia64.o \
+	eelf64_ia64_fbsd.o \
+	eshelf64.o \
+	eshlelf64.o \
+	eshelf64_nbsd.o \
+	eshlelf64_nbsd.o \
+	eelf_x86_64.o \
+	eelf_x86_64_fbsd.o \
+	eelf_l1om.o \
+	eelf_l1om_fbsd.o \
+	eelf64_s390.o \
+	eelf64_sparc.o \
+	eelf64_sparc_fbsd.o \
+	eelf64alpha.o \
+	eelf64alpha_fbsd.o \
+	eelf64alpha_nbsd.o \
+	eelf64bmip.o \
+	eelf64btsmip.o \
+	eelf64ltsmip.o \
+	eelf64hppa.o \
+	eelf64mmix.o \
+	emmo.o \
+	eelf64ppc.o \
+	eelf64lppc.o \
+	ehppa64linux.o
+
+ALL_EMUL_EXTRA_OFILES = \
+	deffilep.o \
+	pe-dll.o \
+	pep-dll.o
+
+CFILES = ldctor.c ldemul.c ldexp.c ldfile.c ldlang.c \
+	ldmain.c ldmisc.c ldver.c ldwrite.c lexsup.c \
+	mri.c ldcref.c pe-dll.c pep-dll.c ldlex-wrapper.c
+
+HFILES = ld.h ldctor.h ldemul.h ldexp.h ldfile.h \
+	ldlang.h ldlex.h ldmain.h ldmisc.h ldver.h \
+	ldwrite.h mri.h deffile.h pe-dll.h pep-dll.h elf-hints-local.h
+
+GENERATED_CFILES = ldgram.c ldlex.c deffilep.c
+GENERATED_HFILES = ldgram.h ldemul-list.h deffilep.h
+
+# Require an early dependency on the generated headers, as the dependency
+# tracking will not cause them to be built beforehand.
+BUILT_SOURCES = $(GENERATED_HFILES)
+
+OFILES = ldgram.o ldlex-wrapper.o lexsup.o ldlang.o mri.o ldctor.o ldmain.o \
+	ldwrite.o ldexp.o  ldemul.o ldver.o ldmisc.o \
+	ldfile.o ldcref.o ${EMULATION_OFILES} ${EMUL_EXTRA_OFILES}
+
+STAGESTUFF = *.o ldscripts/* e*.c
+
+# Disable -Werror, if it has been enabled, since old versions of bison/
+# yacc will produce working code which contain compile time warnings.
+ldgram.o: ldgram.c
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `test -f ldgram.c || echo $(srcdir)/`ldgram.c $(NO_WERROR)
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='ldgram.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c `test -f ldgram.c || echo $(srcdir)/`ldgram.c $(NO_WERROR)
+endif
+
+ldlex-wrapper.o: ldlex-wrapper.c ldlex.c
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $(srcdir)/ldlex-wrapper.c $(NO_WERROR)
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='ldlex-wrapper.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c $(srcdir)/ldlex-wrapper.c $(NO_WERROR)
+endif
+
+deffilep.o: deffilep.c
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `test -f deffilep.c || echo $(srcdir)/`deffilep.c $(NO_WERROR)
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='deffilep.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c `test -f deffilep.c || echo $(srcdir)/`deffilep.c $(NO_WERROR)
+endif
+
+# At the moment this is just a list of those emulation template files
+# that contain internationalised strings.
+EMULATION_FILES = emultempl/pe.em emultempl/armcoff.em
+
+POTFILES = $(CFILES) $(HFILES) $(EMULATION_FILES)
+
+po/POTFILES.in: @MAINT@ Makefile
+	for f in $(POTFILES); do echo $$f; done | LC_ALL=C sort > tmp \
+	  && mv tmp $(srcdir)/po/POTFILES.in
+
+ldmain.o: ldmain.c config.status
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ \
+	  -DDEFAULT_EMULATION='"$(EMUL)"' \
+	  -DBINDIR='"$(bindir)"' -DTOOLBINDIR='"$(tooldir)/bin"' \
+	  -DTARGET='"@target@"' @TARGET_SYSTEM_ROOT_DEFINE@ \
+	  $(srcdir)/ldmain.c
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='ldmain.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c -DDEFAULT_EMULATION='"$(EMUL)"' \
+	  -DBINDIR='"$(bindir)"' -DTOOLBINDIR='"$(tooldir)/bin"' \
+	  -DTARGET='"@target@"' @TARGET_SYSTEM_ROOT_DEFINE@ \
+	  $(srcdir)/ldmain.c
+endif
+
+ldfile.o: ldfile.c config.status
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ \
+	-DSCRIPTDIR='"$(scriptdir)"' -DBINDIR='"$(bindir)"' -DTOOLBINDIR='"$(tooldir)/bin"' \
+	 $(srcdir)/ldfile.c
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='ldfile.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c -DSCRIPTDIR='"$(scriptdir)"' -DBINDIR='"$(bindir)"' \
+	  -DTOOLBINDIR='"$(tooldir)/bin"' \
+	  $(srcdir)/ldfile.c
+endif
+
+eelf32_spu.o: eelf32_spu.c
+if am__fastdepCC
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ \
+	  -DEMBEDSPU="\"`echo embedspu | sed '$(transform)'`\"" eelf32_spu.c
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+else
+if AMDEP
+	source='eelf32_spu.c' object='$@' libtool=no @AMDEPBACKSLASH@
+	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+endif
+	$(COMPILE) -c -DEMBEDSPU="\"`echo embedspu | sed '$(transform)'`\"" \
+	  eelf32_spu.c
+endif
+
+ldemul-list.h: Makefile
+	(echo "/* This file is automatically generated.  DO NOT EDIT! */";\
+	for f in `echo " " ${EMULATION_OFILES} "" \
+	 | sed -e 's/ e/ ld/g' -e 's/ ld/ /g' -e 's/[.]o//g'`; do \
+	    echo "extern ld_emulation_xfer_type ld_$${f}_emulation;"; \
+	done;\
+	echo "";\
+	echo "#define EMULATION_LIST \\";\
+	for f in `echo " " ${EMULATION_OFILES} "" \
+	 | sed -e 's/ e/ ld/g' -e 's/ ld/ /g' -e 's/[.]o//g'`; do \
+	    echo "  &ld_$${f}_emulation, \\"; \
+	done;\
+	echo "  0") >ldemul-tmp.h
+	mv ldemul-tmp.h ldemul-list.h
+
+stringify.sed: ${srcdir}/emultempl/$(STRINGIFY)
+	  cp ${srcdir}/emultempl/$(STRINGIFY) stringify.sed
+
+# These all start with e so 'make clean' can find them.
+
+GENSCRIPTS = LIB_PATH='${LIB_PATH}' $(SHELL) $(srcdir)/genscripts.sh "${srcdir}" "${libdir}" "${prefix}" "${exec_prefix}" @host@ @target@ @target_alias@ "@EMULATION_LIBPATH@" "@NATIVE_LIB_DIRS@" @use_sysroot@
+GEN_DEPENDS = $(srcdir)/genscripts.sh stringify.sed
+ELF_DEPS = $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/elf-generic.em
+ELF_GEN_DEPS = $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/elf-generic.em $(srcdir)/emultempl/genelf.em
+
+@TDIRS@
+
+eaix5ppc.c: $(srcdir)/emulparams/aix5ppc.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} aix5ppc "$(tdir_aixppc)"
+eaix5rs6.c: $(srcdir)/emulparams/aix5rs6.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} aix5rs6 "$(tdir_aixrs6)"
+eaixppc.c: $(srcdir)/emulparams/aixppc.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} aixppc "$(tdir_aixppc)"
+eaixrs6.c: $(srcdir)/emulparams/aixrs6.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} aixrs6 "$(tdir_aixrs6)"
+ealpha.c: $(srcdir)/emulparams/alpha.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/alpha.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} alpha "$(tdir_alpha)"
+earcelf.c: $(srcdir)/emulparams/arcelf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} arcelf "$(tdir_arcelf)"
+earmelf.c: $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf "$(tdir_armelf)"
+earmelfb.c: $(srcdir)/emulparams/armelfb.sh $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelfb "$(tdir_armelfb)"
+earmelf_fbsd.c: $(srcdir)/emulparams/armelf_fbsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf_fbsd "$(tdir_armelf_fbsd)"
+earmelf_linux.c: $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf_linux "$(tdir_armelf_linux)"
+earmelf_linux_eabi.c: $(srcdir)/emulparams/armelf_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf_linux_eabi "$(tdir_armelf_linux_abi)"
+earmelfb_linux.c: $(srcdir)/emulparams/armelfb_linux.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelfb_linux "$(tdir_armelfb_linux)"
+earmelfb_linux_eabi.c: $(srcdir)/emulparams/armelfb_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelfb_linux_eabi "$(tdir_armelfb_linux_abi)"
+earmelf_nbsd.c: $(srcdir)/emulparams/armelf_nbsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf_nbsd "$(tdir_armelf_nbsd)"
+earmelfb_nbsd.c: $(srcdir)/emulparams/armelfb_nbsd.sh \
+  $(srcdir)/emulparams/armelf_nbsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelfb_nbsd "$(tdir_armelfb_nbsd)"
+earmelf_vxworks.c: $(srcdir)/emulparams/armelf_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/vxworks.em \
+  $(srcdir)/emultempl/armelf.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf_vxworks "$(tdir_armelf)"
+earmaoutb.c:	$(srcdir)/emulparams/armaoutb.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armaoutb "$(tdir_armaoutb)"
+earmaoutl.c:	$(srcdir)/emulparams/armaoutl.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armaoutl "$(tdir_armaoutl)"
+earmcoff.c:	$(srcdir)/emulparams/armcoff.sh \
+  $(srcdir)/emultempl/armcoff.em $(srcdir)/scripttempl/armcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armcoff "$(tdir_armcoff)"
+earmnbsd.c:	$(srcdir)/emulparams/armnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armnbsd "$(tdir_armnbsd)"
+earmnto.c: $(srcdir)/emulparams/armnto.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armnto "$(tdir_armnto)"
+earm_epoc_pe.c: $(srcdir)/emulparams/arm_epoc_pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/epocpe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} arm_epoc_pe "$(tdir_armpe)"
+earm_wince_pe.c: $(srcdir)/emulparams/arm_wince_pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} arm_wince_pe "$(tdir_armpe)"
+earmpe.c: $(srcdir)/emulparams/armpe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armpe "$(tdir_armpe)"
+earmsymbian.c: $(srcdir)/emulparams/armsymbian.sh \
+  $(srcdir)/emulparams/armelf.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/armelf.em $(srcdir)/scripttempl/armbpabi.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} armsymbian "$(tdir_armelf)"
+eavr2.c: $(srcdir)/emulparams/avr2.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr2 "$(tdir_avr2)"
+eavr1.c: $(srcdir)/emulparams/avr1.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr1 "$(tdir_avr2)"
+eavr25.c: $(srcdir)/emulparams/avr25.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr25 "$(tdir_avr2)"
+eavr3.c: $(srcdir)/emulparams/avr3.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr3 "$(tdir_avr2)"
+eavr31.c: $(srcdir)/emulparams/avr31.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr31 "$(tdir_avr2)"
+eavr35.c: $(srcdir)/emulparams/avr35.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr35 "$(tdir_avr2)"
+eavr4.c: $(srcdir)/emulparams/avr4.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr4 "$(tdir_avr2)"
+eavr5.c: $(srcdir)/emulparams/avr5.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr5 "$(tdir_avr2)"
+eavr51.c: $(srcdir)/emulparams/avr51.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr51 "$(tdir_avr2)"
+eavr6.c: $(srcdir)/emulparams/avr6.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr6 "$(tdir_avr2)"
+ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} coff_i860 "$(tdir_coff_i860)"
+ecoff_sparc.c: $(srcdir)/emulparams/coff_sparc.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/sparccoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} coff_sparc "$(tdir_coff_sparc)"
+ecrisaout.c: $(srcdir)/emulparams/crisaout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/crisaout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} crisaout "$(tdir_cris)"
+ecriself.c: $(srcdir)/emulparams/criself.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} criself "$(tdir_cris)"
+ecrislinux.c: $(srcdir)/emulparams/crislinux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} crislinux "$(tdir_cris)"
+ed10velf.c: $(srcdir)/emulparams/d10velf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfd10v.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} d10velf "$(tdir_d10v)"
+ed30velf.c: $(srcdir)/emulparams/d30velf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elfd30v.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} d30velf "$(tdir_d30v)"
+ed30v_o.c: $(srcdir)/emulparams/d30v_o.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elfd30v.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} d30v_o "$(tdir_d30v)"
+ed30v_e.c: $(srcdir)/emulparams/d30v_e.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elfd30v.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} d30v_e "$(tdir_d30v)"
+edelta68.c: $(srcdir)/emulparams/delta68.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/delta68.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} delta68 "$(tdir_delta68)"
+eelf32bfin.c: $(srcdir)/emulparams/bfin.sh \
+  $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32bfin "$(tdir_elf32bfin)" bfin
+eelf32bfinfd.c: $(srcdir)/emulparams/elf32bfinfd.sh $(srcdir)/emulparams/bfin.sh \
+  $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32bfinfd "$(tdir_elf32bfinfd)" elf32bfinfd
+eelf32_dlx.c: $(srcdir)/emulparams/elf32_dlx.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/dlx.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_dlx "$(tdir_elf32_dlx)"
+eelf32xc16x.c: $(srcdir)/emulparams/elf32xc16x.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32xc16x "$(tdir_xc16x)"
+eelf32xc16xl.c: $(srcdir)/emulparams/elf32xc16xl.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32xc16xl "$(tdir_xc16xl)"
+eelf32xc16xs.c: $(srcdir)/emulparams/elf32xc16xs.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32xc16xs "$(tdir_xc16xs)"
+eelf32xstormy16.c: $(srcdir)/emulparams/elf32xstormy16.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/xstormy16.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32xstormy16 "$(tdir_xstormy16)"
+eelf32am33lin.c: $(srcdir)/emulparams/elf32am33lin.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32am33lin "$(tdir_mn10300)"
+eelf32vax.c: $(srcdir)/emulparams/elf32vax.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32vax "$(tdir_elf32vax)"
+eelf32xtensa.c: $(srcdir)/emulparams/elf32xtensa.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/xtensaelf.em $(INCDIR)/xtensa-config.h \
+  $(BFDDIR)/elf-bfd.h $(BFDDIR)/libbfd.h $(INCDIR)/elf/xtensa.h \
+  $(srcdir)/scripttempl/elfxtensa.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32xtensa "$(tdir_elf32xtensa)"
+eelf32fr30.c: $(srcdir)/emulparams/elf32fr30.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32fr30 "$(tdir_fr30)"
+eelf32frv.c: $(srcdir)/emulparams/elf32frv.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32frv "$(tdir_frv)"
+eelf32frvfd.c: $(srcdir)/emulparams/elf32frvfd.sh \
+  $(srcdir)/emulparams/elf32frv.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32frvfd "$(tdir_frv)"
+eelf32moxie.c: $(srcdir)/emulparams/elf32moxie.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32moxie "$(tdir_moxie)"
+eelf32mcore.c: $(srcdir)/emulparams/elf32mcore.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32mcore "$(tdir_mcore)"
+eelf32mep.c: $(srcdir)/emulparams/elf32mep.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/mep.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32mep "$(tdir_mep)"
+em32relf.c: $(srcdir)/emulparams/m32relf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m32relf "$(tdir_m32r)"
+em32rlelf.c: $(srcdir)/emulparams/m32rlelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m32rlelf "$(tdir_m32rlelf)"
+em32relf_linux.c: $(srcdir)/emulparams/m32relf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m32relf_linux "$(tdir_m32relf_linux)"
+em32rlelf_linux.c: $(srcdir)/emulparams/m32rlelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m32rlelf_linux "$(tdir_m32rlelf_linux)"
+eelf32_sparc.c: $(srcdir)/emulparams/elf32_sparc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_sparc "$(tdir_elf32_sparc)"
+eelf32_sparc_vxworks.c: $(srcdir)/emulparams/elf32_sparc_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(srcdir)/emulparams/elf32_sparc.sh \
+  $(srcdir)/emultempl/vxworks.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_sparc_vxworks "$(tdir_elf32_sparc_vxworks)"
+eelf32_spu.c: $(srcdir)/emulparams/elf32_spu.sh $(srcdir)/emultempl/spuelf.em \
+  $(srcdir)/emultempl/spu_ovl.o_c $(srcdir)/emultempl/spu_icache.o_c \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_spu "$(tdir_elf32_spu)"
+$(srcdir)/emultempl/spu_ovl.o_c: @MAINT@ $(srcdir)/emultempl/spu_ovl.S
+	if ../gas/as-new --version \
+		| grep 'target.*spu' >/dev/null 2>/dev/null; then \
+	  cpp -DOVLY_IRQ_SAVE $(srcdir)/emultempl/spu_ovl.S spu_ovl.s; \
+	  ../gas/as-new -o spu_ovl.o spu_ovl.s; \
+	  ../binutils/bin2c <spu_ovl.o >$@; \
+	fi
+$(srcdir)/emultempl/spu_icache.o_c: @MAINT@ $(srcdir)/emultempl/spu_icache.S
+	if ../gas/as-new --version \
+		| grep 'target.*spu' >/dev/null 2>/dev/null; then \
+	  cpp -DOVLY_IRQ_SAVE $(srcdir)/emultempl/spu_icache.S spu_icache.s; \
+	  ../gas/as-new -o spu_icache.o spu_icache.s; \
+	  ../binutils/bin2c <spu_icache.o >$@; \
+	fi
+eelf32_i860.c: $(srcdir)/emulparams/elf32_i860.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_i860 "$(tdir_elf32_i860)"
+eelf32_i960.c: $(srcdir)/emulparams/elf32_i960.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_i960 "$(tdir_elf32_i960)"
+eelf32b4300.c: $(srcdir)/emulparams/elf32b4300.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32b4300 "$(tdir_elf32b4300)"
+eelf32cr16.c: $(srcdir)/emulparams/elf32cr16.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/cr16elf.em \
+  $(srcdir)/scripttempl/elf32cr16.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32cr16 "$(tdir_elf32crx)"
+eelf32cr16c.c: $(srcdir)/emulparams/elf32cr16c.sh \
+  $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf32cr16c.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32cr16c "$(tdir_elf32cr16c)"
+eelf32bmip.c: $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32bmip "$(tdir_elf32bmip)"
+eelf32bsmip.c: $(srcdir)/emulparams/elf32bsmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) $(srcdir)/emultempl/irix.em \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32bsmip "$(tdir_elf32bsmip)"
+eelf32btsmip.c: $(srcdir)/emulparams/elf32btsmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32btsmip "$(tdir_elf32btsmip)"
+eelf32crx.c: $(srcdir)/emulparams/elf32crx.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/crxelf.em \
+  $(srcdir)/scripttempl/elf32crx.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32crx "$(tdir_elf32crx)"
+eelf32btsmipn32.c: $(srcdir)/emulparams/elf32btsmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32btsmipn32 "$(tdir_elf32btsmipn32)"
+eelf32ltsmip.c: $(srcdir)/emulparams/elf32ltsmip.sh \
+  $(srcdir)/emulparams/elf32btsmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ltsmip "$(tdir_elf32ltsmip)"
+eelf32ltsmipn32.c: $(srcdir)/emulparams/elf32ltsmipn32.sh \
+  $(srcdir)/emulparams/elf32btsmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ltsmipn32 "$(tdir_elf32ltsmipn32)"
+eelf32ebmip.c: $(srcdir)/emulparams/elf32ebmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ebmip "$(tdir_elf32ebmip)"
+eelf32ebmipvxworks.c: $(srcdir)/emulparams/elf32ebmipvxworks.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(srcdir)/emulparams/vxworks.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/emultempl/vxworks.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ebmipvxworks "$(tdir_elf32ebmipvxworks)"
+eelf32elmip.c: $(srcdir)/emulparams/elf32elmip.sh \
+  $(srcdir)/emulparams/elf32lmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32elmip "$(tdir_elf32elmip)"
+eelf32elmipvxworks.c: $(srcdir)/emulparams/elf32elmipvxworks.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(srcdir)/emulparams/vxworks.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/emultempl/vxworks.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32elmipvxworks "$(tdir_elf32elmipvxworks)"
+eelf32bmipn32.c: $(srcdir)/emulparams/elf32bmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/irix.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32bmipn32 "$(tdir_elf32bmipn32)"
+eelf32l4300.c: $(srcdir)/emulparams/elf32l4300.sh \
+  $(srcdir)/emulparams/elf32b4300.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32l4300 "$(tdir_elf32l4300)"
+eelf32lmip.c: $(srcdir)/emulparams/elf32lmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lmip "$(tdir_elf32lmip)"
+eelf32mb_linux.c: $(srcdir)/emulparams/elf32mb_linux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32mb_linux "$(tdir_microblaze)"
+ eelf32microblaze.c: $(srcdir)/emulparams/elf32microblaze.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elfmicroblaze.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32microblaze "$(tdir_microblaze)"
+eelf32mipswindiss.c: $(srcdir)/emulparams/elf32mipswindiss.sh $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32mipswindiss "$(tdir_elf32mipswindiss)"
+eelf32m32c.c: $(srcdir)/emulparams/elf32m32c.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32m32c "$(tdir_m32c)"
+eelf32mt.c: $(srcdir)/emulparams/elf32mt.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32mt "$(tdir_mt)"
+eelf32lppc.c: $(srcdir)/emulparams/elf32lppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emultempl/ppc32elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lppc "$(tdir_elf32lppc)"
+eelf32lppcnto.c: $(srcdir)/emulparams/elf32lppcnto.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em $(ELF_DEPS) \
+  ldemul-list.h \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lppcnto "$(tdir_elf32lppcnto)"
+eelf32lppcsim.c: $(srcdir)/emulparams/elf32lppcsim.sh \
+  $(srcdir)/emulparams/elf32lppc.sh $(srcdir)/emulparams/elf32ppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh $(srcdir)/emultempl/ppc32elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lppcsim "$(tdir_elf32lppcsim)"
+eelf32ppcnto.c: $(srcdir)/emulparams/elf32ppcnto.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em $(ELF_DEPS) \
+  ldemul-list.h \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppcnto "$(tdir_elf32ppcnto)"
+eelf32ppcwindiss.c: $(srcdir)/emulparams/elf32ppcwindiss.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppcwindiss "$(tdir_elf32ppcwindiss)"
+eelf32ppcvxworks.c: $(srcdir)/emulparams/elf32ppcvxworks.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh $(srcdir)/emulparams/vxworks.sh \
+  $(srcdir)/emultempl/vxworks.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppcvxworks "$(tdir_elf32ppcvxworks)"
+eelf32lsmip.c: $(srcdir)/emulparams/elf32lsmip.sh \
+  $(srcdir)/emulparams/elf32lmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lsmip "$(tdir_elf32lsmip)"
+eelf32openrisc.c: $(srcdir)/emulparams/elf32openrisc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32openrisc "$(tdir_openrisc)"
+eelf32ppc.c: $(srcdir)/emulparams/elf32ppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh $(srcdir)/emultempl/ppc32elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppc "$(tdir_elf32ppc)"
+eelf32ppc_fbsd.c: $(srcdir)/emulparams/elf32ppc_fbsd.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em $(ELF_DEPS) \
+  ldemul-list.h \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppc_fbsd "$(tdir_elf32ppc_fbsd)"
+eelf32ppcsim.c: $(srcdir)/emulparams/elf32ppcsim.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em $(ELF_DEPS) \
+  ldemul-list.h \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppcsim "$(tdir_elf32ppcsim)"
+eelf32ppclinux.c: $(srcdir)/emulparams/elf32ppclinux.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em $(ELF_DEPS) \
+  ldemul-list.h \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppclinux "$(tdir_elf32ppclinux)"
+eelf64ppc.c: $(srcdir)/emulparams/elf64ppc.sh $(srcdir)/emultempl/ppc64elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64ppc "$(tdir_elf64ppc)"
+eelf64lppc.c: $(srcdir)/emulparams/elf64lppc.sh \
+  $(srcdir)/emulparams/elf64ppc.sh $(srcdir)/emultempl/ppc64elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64lppc "$(tdir_elf64lppc)"
+eelf32i370.c: $(srcdir)/emulparams/elf32i370.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfi370.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32i370 "$(tdir_elf32i370)"
+eelf32ip2k.c: $(srcdir)/emulparams/elf32ip2k.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ip2k "$(tdir_ip2k)"
+eelf32iq2000.c: $(srcdir)/emulparams/elf32iq2000.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/iq2000.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32iq2000 "$(tdir_iq2000)"
+eelf32iq10.c: $(srcdir)/emulparams/elf32iq10.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/iq2000.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32iq10 "$(tdir_iq10)"
+eelf32lm32.c: $(srcdir)/emulparams/elf32lm32.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lm32 "$(tdir_elf32lm32)"
+eelf32lm32fd.c: $(srcdir)/emulparams/elf32lm32fd.sh \
+  $(srcdir)/emulparams/elf32lm32.sh $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS} 
+	${GENSCRIPTS} elf32lm32fd "$(tdir_elf32lm32fd)" 
+eelf64alpha.c: $(srcdir)/emulparams/elf64alpha.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64alpha "$(tdir_elf64alpha)"
+eelf64alpha_fbsd.c: $(srcdir)/emulparams/elf64alpha_fbsd.sh \
+  $(srcdir)/emulparams/elf64alpha.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64alpha_fbsd "$(tdir_elf64alpha_fbsd)"
+eelf64alpha_nbsd.c: $(srcdir)/emulparams/elf64alpha_nbsd.sh \
+  $(srcdir)/emulparams/elf64alpha.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64alpha_nbsd "$(tdir_elf64alpha_nbsd)"
+eelf64hppa.c: $(srcdir)/emulparams/elf64hppa.sh \
+  $(srcdir)/emulparams/hppa64linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64hppa "$(tdir_elf64hppa)"
+eelf64_aix.c: $(srcdir)/emulparams/elf64_aix.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_aix "$(tdir_elf64_aix)"
+eelf64_ia64.c: $(srcdir)/emulparams/elf64_ia64.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/ia64elf.em \
+  $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_ia64 "$(tdir_elf64_ia64)"
+eelf64_ia64_fbsd.c: $(srcdir)/emulparams/elf64_ia64_fbsd.sh \
+  $(srcdir)/emulparams/elf64_ia64.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/ia64elf.em \
+  $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_ia64_fbsd "$(tdir_elf64_ia64_fbsd)"
+eelf64_s390.c: $(srcdir)/emulparams/elf64_s390.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_s390 "$(tdir_elf64_s390)"
+eelf64_sparc.c: $(srcdir)/emulparams/elf64_sparc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_sparc "$(tdir_elf64_sparc)"
+eelf64_sparc_fbsd.c: $(srcdir)/emulparams/elf64_sparc_fbsd.sh \
+  $(srcdir)/emulparams/elf64_sparc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_sparc_fbsd "$(tdir_elf64_sparc_fbsd)"
+eelf64bmip.c: $(srcdir)/emulparams/elf64bmip.sh \
+  $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/irix.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64bmip "$(tdir_elf64bmip)"
+eelf64mmix.c: $(srcdir)/emulparams/elf64mmix.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mmix-elfnmmo.em \
+  $(srcdir)/emultempl/mmixelf.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64mmix "$(tdir_elf64mmix)"
+emmo.c: $(srcdir)/emulparams/mmo.sh $(srcdir)/emultempl/mmix-elfnmmo.em \
+  $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/elf-generic.em \
+  $(srcdir)/emultempl/mmo.em \
+  $(srcdir)/scripttempl/mmo.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mmo "$(tdir_mmo)"
+eelf64btsmip.c: $(srcdir)/emulparams/elf64btsmip.sh \
+  $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64btsmip "$(tdir_elf64btsmip)"
+eelf64ltsmip.c: $(srcdir)/emulparams/elf64ltsmip.sh \
+  $(srcdir)/emulparams/elf64btsmip.sh $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64ltsmip "$(tdir_elf64ltsmip)"
+eelf_i386.c: $(srcdir)/emulparams/elf_i386.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386 "$(tdir_elf_i386)"
+eelf_x86_64.c: $(srcdir)/emulparams/elf_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_x86_64 "$(tdir_elf_x86_64)"
+eelf_x86_64_fbsd.c: $(srcdir)/emulparams/elf_x86_64_fbsd.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_x86_64_fbsd "$(tdir_elf_x86_64_fbsd)"
+eelf_l1om.c: $(srcdir)/emulparams/elf_l1om.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_l1om "$(tdir_elf_l1om)"
+eelf_l1om_fbsd.c: $(srcdir)/emulparams/elf_l1om_fbsd.sh \
+  $(srcdir)/emulparams/elf_l1om.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_l1om_fbsd "$(tdir_elf_l1om_fbsd)"
+eelf_i386_be.c: $(srcdir)/emulparams/elf_i386_be.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386_be "$(tdir_elf_i386_be)"
+eelf_i386_chaos.c: $(srcdir)/emulparams/elf_i386_chaos.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf_chaos.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386_chaos "$(tdir_elf_i386_chaos)"
+eelf_i386_fbsd.c: $(srcdir)/emulparams/elf_i386_fbsd.sh \
+  $(srcdir)/emulparams/elf_i386.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386_fbsd "$(tdir_elf_i386_fbsd)"
+eelf_i386_ldso.c: $(srcdir)/emulparams/elf_i386_ldso.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386_ldso "$(tdir_elf_i386_ldso)"
+eelf_i386_vxworks.c: $(srcdir)/emulparams/elf_i386_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(srcdir)/emultempl/vxworks.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386_vxworks "$(tdir_elf_i386_vxworks)"
+eelf_s390.c: $(srcdir)/emulparams/elf_s390.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_s390 "$(tdir_elf_s390)"
+egld960.c: $(srcdir)/emulparams/gld960.sh \
+  $(srcdir)/emultempl/gld960.em $(srcdir)/scripttempl/i960.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} gld960 "$(tdir_gld960)"
+egld960coff.c: $(srcdir)/emulparams/gld960coff.sh \
+  $(srcdir)/emultempl/gld960c.em $(srcdir)/scripttempl/i960.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} gld960coff "$(tdir_gld960coff)"
+eh8300.c: $(srcdir)/emulparams/h8300.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300 "$(tdir_h8300)"
+eh8300h.c: $(srcdir)/emulparams/h8300h.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300h.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300h "$(tdir_h8300h)"
+eh8300s.c: $(srcdir)/emulparams/h8300s.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300s.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300s "$(tdir_h8300s)"
+eh8300hn.c: $(srcdir)/emulparams/h8300hn.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300hn.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300hn "$(tdir_h8300hn)"
+eh8300sn.c: $(srcdir)/emulparams/h8300sn.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300sn.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300sn "$(tdir_h8300sn)"
+eh8300sx.c: $(srcdir)/emulparams/h8300sx.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300sx.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300sx "$(tdir_h8300sx)"
+eh8300sxn.c: $(srcdir)/emulparams/h8300sxn.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300sxn.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300sxn "$(tdir_h8300sxn)"
+eh8300elf.c: $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300elf "$(tdir_h8300elf)"
+eh8300helf.c: $(srcdir)/emulparams/h8300helf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300helf "$(tdir_h8300helf)"
+eh8300self.c: $(srcdir)/emulparams/h8300self.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300self "$(tdir_h8300self)"
+eh8300hnelf.c: $(srcdir)/emulparams/h8300hnelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300hnelf "$(tdir_h8300hnelf)"
+eh8300snelf.c: $(srcdir)/emulparams/h8300snelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300snelf "$(tdir_h8300snelf)"
+eh8300sxelf.c: $(srcdir)/emulparams/h8300sxelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300sxelf "$(tdir_h8300sxelf)"
+eh8300sxnelf.c: $(srcdir)/emulparams/h8300sxnelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300sxnelf "$(tdir_h8300sxnelf)"
+eh8500.c: $(srcdir)/emulparams/h8500.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8500 "$(tdir_h8500)"
+eh8500b.c: $(srcdir)/emulparams/h8500b.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500b.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8500b "$(tdir_h8500b)"
+eh8500c.c: $(srcdir)/emulparams/h8500c.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500c.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8500c "$(tdir_h8500c)"
+eh8500m.c: $(srcdir)/emulparams/h8500m.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500m.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8500m "$(tdir_h8500m)"
+eh8500s.c: $(srcdir)/emulparams/h8500s.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500s.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8500s "$(tdir_h8500s)"
+ehp300bsd.c: $(srcdir)/emulparams/hp300bsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hp300bsd "$(tdir_hp300bsd)"
+ehp3hpux.c: $(srcdir)/emulparams/hp3hpux.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hp3hpux "$(tdir_hp3hpux)"
+ehppaelf.c: $(srcdir)/emulparams/hppaelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/hppaelf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hppaelf "$(tdir_hppaelf)"
+ehppalinux.c: $(srcdir)/emulparams/hppalinux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hppalinux "$(tdir_hppalinux)"
+ehppanbsd.c: $(srcdir)/emulparams/hppanbsd.sh \
+  $(srcdir)/emulparams/hppaelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hppanbsd "$(tdir_hppanbsd)"
+ehppaobsd.c: $(srcdir)/emulparams/hppaobsd.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hppaobsd "$(tdir_hppaobsd)"
+ehppa64linux.c: $(srcdir)/emulparams/hppa64linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hppa64linux "$(tdir_hppa64linux)"
+ei386aout.c: $(srcdir)/emulparams/i386aout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386aout "$(tdir_i386aout)"
+ei386beos.c: $(srcdir)/emulparams/i386beos.sh \
+  $(srcdir)/emultempl/beos.em $(srcdir)/scripttempl/i386beos.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386beos "$(tdir_i386beos)"
+ei386bsd.c: $(srcdir)/emulparams/i386bsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386bsd "$(tdir_i386bsd)"
+ei386coff.c: $(srcdir)/emulparams/i386coff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386coff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386coff "$(tdir_i386coff)"
+ei386go32.c: $(srcdir)/emulparams/i386go32.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386go32.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386go32 "$(tdir_i386go32)"
+ei386linux.c: $(srcdir)/emulparams/i386linux.sh \
+  $(srcdir)/emultempl/linux.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386linux "$(tdir_i386linux)"
+ei386lynx.c: $(srcdir)/emulparams/i386lynx.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386lynx "$(tdir_i386lynx)"
+ei386mach.c: $(srcdir)/emulparams/i386mach.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386mach "$(tdir_i386mach)"
+ei386moss.c: $(srcdir)/emulparams/i386moss.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386moss "$(tdir_i386moss)"
+ei386msdos.c: $(srcdir)/emulparams/i386msdos.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386msdos.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386msdos "$(tdir_i386msdos)"
+ei386nbsd.c:	$(srcdir)/emulparams/i386nbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386nbsd "$(tdir_i386nbsd)"
+ei386nto.c:	$(srcdir)/emulparams/i386nto.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386nto "$(tdir_i386nto)"
+ei386nw.c:	$(srcdir)/emulparams/i386nw.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/nw.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386nw "$(tdir_i386nw)"
+ei386pe.c: $(srcdir)/emulparams/i386pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386pe "$(tdir_i386pe)"
+ei386pe_posix.c: $(srcdir)/emulparams/i386pe_posix.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386pe_posix "$(tdir_i386pe_posix)"
+ei386pep.c: $(srcdir)/emulparams/i386pep.sh \
+  $(srcdir)/emultempl/pep.em $(srcdir)/scripttempl/pep.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386pep "$(tdir_i386pe)"
+elnk960.c: $(srcdir)/emulparams/lnk960.sh \
+  $(srcdir)/emultempl/lnk960.em $(srcdir)/scripttempl/i960.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} lnk960 "$(tdir_lnk960)"
+em68hc11elf.c: $(srcdir)/emulparams/m68hc11elf.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc11.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68hc11elf "$(tdir_m68hc11)"
+em68hc11elfb.c: $(srcdir)/emulparams/m68hc11elfb.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc11.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68hc11elfb "$(tdir_m68hc11b)"
+em68hc12elf.c: $(srcdir)/emulparams/m68hc12elf.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc12.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68hc12elf "$(tdir_m68hc12)"
+em68hc12elfb.c: $(srcdir)/emulparams/m68hc12elfb.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc12.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68hc12elfb "$(tdir_m68hc12b)"
+em68k4knbsd.c:	$(srcdir)/emulparams/m68k4knbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68k4knbsd "$(tdir_m68k4knbsd)"
+em68kaout.c: $(srcdir)/emulparams/m68kaout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kaout "$(tdir_m68kaout)"
+em68kaux.c: $(srcdir)/emulparams/m68kaux.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/m68kaux.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kaux "$(tdir_m68kaux)"
+em68kcoff.c: $(srcdir)/emulparams/m68kcoff.sh \
+  $(srcdir)/emultempl/m68kcoff.em $(srcdir)/scripttempl/m68kcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kcoff "$(tdir_m68kcoff)"
+em68kelf.c: $(srcdir)/emulparams/m68kelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/m68kelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kelf "$(tdir_m68kelf)"
+em68kelfnbsd.c: $(srcdir)/emulparams/m68kelfnbsd.sh \
+  $(srcdir)/emulparams/m68kelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/m68kelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kelfnbsd "$(tdir_m68kelfnbsd)"
+em68klinux.c: $(srcdir)/emulparams/m68klinux.sh \
+  $(srcdir)/emultempl/linux.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68klinux "$(tdir_m68klinux)"
+em68knbsd.c:	$(srcdir)/emulparams/m68knbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68knbsd "$(tdir_m68knbsd)"
+em68kpsos.c:	$(srcdir)/emulparams/m68kpsos.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/psos.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kpsos "$(tdir_m68kpsos)"
+em88kbcs.c: $(srcdir)/emulparams/m88kbcs.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/m88kbcs.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m88kbcs "$(tdir_m88kbcs)"
+emaxqcoff.c: $(srcdir)/emulparams/maxqcoff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/maxqcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} maxqcoff "$(tdir_maxqcoff)"
+emcorepe.c: $(srcdir)/emulparams/mcorepe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mcorepe "$(tdir_mcorepe)"
+emipsbig.c: $(srcdir)/emulparams/mipsbig.sh $(srcdir)/emultempl/generic.em \
+  $(srcdir)/scripttempl/mips.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mipsbig "$(tdir_mipsbig)"
+emipsbsd.c: $(srcdir)/emulparams/mipsbsd.sh $(srcdir)/emultempl/generic.em \
+  $(srcdir)/scripttempl/mipsbsd.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mipsbsd "$(tdir_mipsbsd)"
+emipsidt.c: $(srcdir)/emulparams/mipsidt.sh $(srcdir)/emultempl/generic.em \
+  $(srcdir)/emultempl/mipsecoff.em $(srcdir)/scripttempl/mips.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} mipsidt "$(tdir_mipsidt)"
+emipsidtl.c: $(srcdir)/emulparams/mipsidtl.sh $(srcdir)/emultempl/generic.em \
+  $(srcdir)/emultempl/mipsecoff.em $(srcdir)/scripttempl/mips.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} mipsidtl "$(tdir_mipsidtl)"
+emipslit.c: $(srcdir)/emulparams/mipslit.sh $(srcdir)/emultempl/generic.em \
+  $(srcdir)/scripttempl/mips.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mipslit "$(tdir_mipslit)"
+emipslnews.c: $(srcdir)/emulparams/mipslnews.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/mips.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mipslnews "$(tdir_mipslnews)"
+emipspe.c: $(srcdir)/emulparams/mipspe.sh $(srcdir)/emultempl/pe.em \
+  $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mipspe "$(tdir_mipspe)"
+emn10300.c: $(srcdir)/emulparams/mn10300.sh \
+  $(srcdir)/emulparams/mn10200.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mn10300 "$(tdir_mn10300)"
+emn10200.c: $(srcdir)/emulparams/mn10200.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mn10200 "$(tdir_mn10200)"
+emsp430x110.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x110 "$(tdir_msp430x110)" msp430all
+emsp430x112.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x112 "$(tdir_msp430x112)" msp430all
+emsp430x1101.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1101 "$(tdir_msp430x1101)" msp430all
+emsp430x1111.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1111 "$(tdir_msp430x1111)" msp430all
+emsp430x1121.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1121 "$(tdir_msp430x1121)" msp430all
+emsp430x1122.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1122 "$(tdir_msp430x1122)" msp430all
+emsp430x1132.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1132 "$(tdir_msp430x1132)" msp430all
+emsp430x122.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x122 "$(tdir_msp430x122)" msp430all
+emsp430x123.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x123 "$(tdir_msp430x123)" msp430all
+emsp430x1222.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1222 "$(tdir_msp430x1222)" msp430all
+emsp430x1232.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1232 "$(tdir_msp430x1232)" msp430all
+emsp430x133.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x133 "$(tdir_msp430x133)" msp430all
+emsp430x135.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x135 "$(tdir_msp430x135)" msp430all
+emsp430x1331.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1331 "$(tdir_msp430x1331)" msp430all
+emsp430x1351.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1351 "$(tdir_msp430x1351)" msp430all
+emsp430x147.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x147 "$(tdir_msp430x147)" msp430all
+emsp430x148.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x148 "$(tdir_msp430x148)" msp430all
+emsp430x149.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x149 "$(tdir_msp430x149)" msp430all
+emsp430x155.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x155 "$(tdir_msp430x155)" msp430all
+emsp430x156.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x156 "$(tdir_msp430x156)" msp430all
+emsp430x157.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x157 "$(tdir_msp430x157)" msp430all
+emsp430x167.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x167 "$(tdir_msp430x167)" msp430all
+emsp430x168.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x168 "$(tdir_msp430x168)" msp430all
+emsp430x169.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x169 "$(tdir_msp430x169)" msp430all
+emsp430x1610.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1610 "$(tdir_msp430x1610)" msp430all
+emsp430x1611.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1611 "$(tdir_msp430x1611)" msp430all
+emsp430x1612.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1612 "$(tdir_msp430x1612)" msp430all
+emsp430x2101.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2101 "$(tdir_msp430x2101)" msp430all
+emsp430x2111.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2111 "$(tdir_msp430x2111)" msp430all
+emsp430x2121.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2121 "$(tdir_msp430x2121)" msp430all
+emsp430x2131.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2131 "$(tdir_msp430x2131)" msp430all
+emsp430x311.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x311 "$(tdir_msp430x311)" msp430all
+emsp430x312.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x312 "$(tdir_msp430x312)" msp430all
+emsp430x313.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x313 "$(tdir_msp430x313)" msp430all
+emsp430x314.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x314 "$(tdir_msp430x314)" msp430all
+emsp430x315.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x315 "$(tdir_msp430x315)" msp430all
+emsp430x323.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x323 "$(tdir_msp430x323)" msp430all
+emsp430x325.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x325 "$(tdir_msp430x325)" msp430all
+emsp430x336.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x336 "$(tdir_msp430x336)" msp430all
+emsp430x337.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x337 "$(tdir_msp430x337)" msp430all
+emsp430x412.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x412 "$(tdir_msp430x412)" msp430all
+emsp430x413.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x413 "$(tdir_msp430x413)" msp430all
+emsp430x415.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x415 "$(tdir_msp430x415)" msp430all
+emsp430x417.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x417 "$(tdir_msp430x417)" msp430all
+emsp430xE423.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE423 "$(tdir_msp430xE423)" msp430all
+emsp430xE425.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE425 "$(tdir_msp430xE425)" msp430all
+emsp430xE427.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE427 "$(tdir_msp430xE427)" msp430all
+emsp430xW423.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xW423 "$(tdir_msp430xW423)" msp430all
+emsp430xW425.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xW425 "$(tdir_msp430xW425)" msp430all
+emsp430xW427.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xW427 "$(tdir_msp430xW427)" msp430all
+emsp430xG437.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG437 "$(tdir_msp430xG437)" msp430all
+emsp430xG438.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG438 "$(tdir_msp430xG438)" msp430all
+emsp430xG439.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG439 "$(tdir_msp430xG439)" msp430all
+emsp430x435.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x435 "$(tdir_msp430x435)" msp430all
+emsp430x436.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x436 "$(tdir_msp430x436)" msp430all
+emsp430x437.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x437 "$(tdir_msp430x437)" msp430all
+emsp430x447.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x447 "$(tdir_msp430x447)" msp430all
+emsp430x448.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x448 "$(tdir_msp430x448)" msp430all
+emsp430x449.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x449 "$(tdir_msp430x449)" msp430all
+enews.c: $(srcdir)/emulparams/news.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} news "$(tdir_news)"
+ens32knbsd.c:	$(srcdir)/emulparams/ns32knbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/netbsd.em \
+  $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} ns32knbsd "$(tdir_ns32knbsd)"
+eor32.c: $(srcdir)/emulparams/or32.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/or32.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} or32 "$(tdir_or32)"
+eor32elf.c: $(srcdir)/emulparams/or32elf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} or32elf "$(tdir_or32elf)"
+epc532macha.c: $(srcdir)/emulparams/pc532macha.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} pc532macha "$(tdir_pc532macha)"
+epdp11.c: $(srcdir)/emulparams/pdp11.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} pdp11 "$(tdir_pdp11)"
+epjelf.c: $(srcdir)/emulparams/pjelf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} pjelf "$(tdir_pjelf)"
+epjlelf.c: $(srcdir)/emulparams/pjlelf.sh $(srcdir)/emulparams/pjelf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} pjlelf "$(tdir_pjlelf)"
+eppcmacos.c:	$(srcdir)/emulparams/ppcmacos.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} ppcmacos "$(tdir_ppcmacos)"
+eppcnw.c:	$(srcdir)/emulparams/ppcnw.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/nw.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} ppcnw "$(tdir_ppcnw)"
+eppcpe.c: $(srcdir)/emulparams/ppcpe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/ppcpe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} ppcpe "$(tdir_ppcpe)"
+eppclynx.c: $(srcdir)/emulparams/ppclynx.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} ppclynx "$(tdir_ppclynx)"
+eriscix.c: $(srcdir)/emulparams/riscix.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} riscix "$(tdir_riscix)"
+escore3_elf.c: $(srcdir)/emulparams/scoreelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/scoreelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS} 
+	${GENSCRIPTS} score3_elf "$(tdir_score3_elf)" scoreelf 
+escore7_elf.c: $(srcdir)/emulparams/scoreelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/scoreelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS} 
+	${GENSCRIPTS} score7_elf "$(tdir_score7_elf)" scoreelf
+esh.c: $(srcdir)/emulparams/sh.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/sh.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sh "$(tdir_sh)"
+eshelf.c: $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf "$(tdir_shelf)"
+eshelf32.c: $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf32 "$(tdir_shelf32)"
+eshelf32_linux.c: $(srcdir)/emulparams/shelf32_linux.sh \
+  $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf32_linux "$(tdir_shelf32_linux)"
+eshelf32_nbsd.c: $(srcdir)/emulparams/shelf32_nbsd.sh \
+  $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf32_nbsd "$(tdir_shelf32_nbsd)"
+eshelf64.c: $(srcdir)/emulparams/shelf64.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf64 "$(tdir_shelf64)"
+eshelf64_nbsd.c: $(srcdir)/emulparams/shelf64_nbsd.sh \
+  $(srcdir)/emulparams/shelf32_nbsd.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf64_nbsd "$(tdir_shelf64_nbsd)"
+eshelf_linux.c: $(srcdir)/emulparams/shelf_linux.sh \
+  $(srcdir)/emulparams/shlelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf_linux "$(tdir_shelf_linux)"
+eshlelf_linux.c: $(srcdir)/emulparams/shlelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf_linux "$(tdir_shlelf_linux)"
+eshelf_nbsd.c: $(srcdir)/emulparams/shelf_nbsd.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf_nbsd "$(tdir_shelf_nbsd)"
+eshelf_nto.c: $(srcdir)/emulparams/shelf_nto.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf_nto "$(tdir_shelf_nto)"
+eshelf_vxworks.c: $(srcdir)/emulparams/shelf_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc \
+  $(srcdir)/emultempl/vxworks.em ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf_vxworks "$(tdir_shelf_vxworks)"
+eshlelf_nbsd.c: $(srcdir)/emulparams/shlelf_nbsd.sh \
+  $(srcdir)/emulparams/shelf_nbsd.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf_nbsd "$(tdir_shlelf_nbsd)"
+eshlelf_nto.c: $(srcdir)/emulparams/shlelf_nto.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf_nto "$(tdir_shlelf_nto)"
+eshlelf_vxworks.c: $(srcdir)/emulparams/shlelf_vxworks.sh \
+  $(srcdir)/emulparams/shelf_vxworks.sh $(srcdir)/emulparams/vxworks.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc $(srcdir)/emultempl/vxworks.em \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf_vxworks "$(tdir_shlelf_vxworks)"
+eshelf_uclinux.c: $(srcdir)/emulparams/shelf_uclinux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf_uclinux "$(tdir_shelf_uclinux)"
+eshlelf.c: $(srcdir)/emulparams/shlelf.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf "$(tdir_shlelf)"
+eshlsymbian.c: $(srcdir)/emulparams/shlsymbian.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf32sh-symbian.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlsymbian "$(tdir_shlelf)"
+eshlelf32.c: $(srcdir)/emulparams/shlelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h $(srcdir)/emulparams/shelf32.sh \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf32 "$(tdir_shlelf32)"
+eshlelf32_linux.c: $(srcdir)/emulparams/shlelf32_linux.sh \
+  $(srcdir)/emulparams/shelf32_linux.sh $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf32_linux "$(tdir_shlelf32_linux)"
+eshlelf32_nbsd.c: $(srcdir)/emulparams/shlelf32_nbsd.sh \
+  $(srcdir)/emulparams/shelf32_nbsd.sh $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf32_nbsd "$(tdir_shlelf32_nbsd)"
+eshlelf64.c: $(srcdir)/emulparams/shlelf64.sh \
+  $(srcdir)/emulparams/shelf64.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf64 "$(tdir_shlelf64)"
+eshlelf64_nbsd.c: $(srcdir)/emulparams/shlelf64_nbsd.sh \
+  $(srcdir)/emulparams/shelf64_nbsd.sh \
+  $(srcdir)/emulparams/shelf32_nbsd.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf64_nbsd "$(tdir_shlelf64_nbsd)"
+eshl.c: $(srcdir)/emulparams/shl.sh \
+  $(srcdir)/emulparams/sh.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/sh.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shl "$(tdir_shl)"
+eshpe.c: $(srcdir)/emulparams/shpe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shpe "$(tdir_shl)"
+esparcaout.c: $(srcdir)/emulparams/sparcaout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sparcaout "$(tdir_sparcaout)"
+esparclinux.c: $(srcdir)/emulparams/sparclinux.sh \
+  $(srcdir)/emultempl/linux.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sparclinux "$(tdir_sparclinux)"
+esparcnbsd.c:	$(srcdir)/emulparams/sparcnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sparcnbsd "$(tdir_sparcnbsd)"
+est2000.c: $(srcdir)/emulparams/st2000.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/st2000.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} st2000 "$(tdir_st2000)"
+esun3.c: $(srcdir)/emulparams/sun3.sh \
+  $(srcdir)/emultempl/sunos.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sun3 "$(tdir_sun3)"
+esun4.c: $(srcdir)/emulparams/sun4.sh \
+  $(srcdir)/emultempl/sunos.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sun4 "$(tdir_sun4)"
+etic30aout.c: $(srcdir)/emulparams/tic30aout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic30aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic30aout "$(tdir_tic30aout)"
+etic30coff.c: $(srcdir)/emulparams/tic30coff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic30coff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic30coff "$(tdir_tic30coff)"
+etic3xcoff.c: $(srcdir)/emulparams/tic3xcoff.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic4xcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic3xcoff "$(tdir_tic4xcoff)"
+etic3xcoff_onchip.c: $(srcdir)/emulparams/tic3xcoff_onchip.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic4xcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic3xcoff_onchip "$(tdir_tic4xcoff)"
+etic4xcoff.c: $(srcdir)/emulparams/tic4xcoff.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic4xcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic4xcoff "$(tdir_tic4xcoff)"
+etic54xcoff.c: $(srcdir)/emulparams/tic54xcoff.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic54xcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic54xcoff "$(tdir_tic54xcoff)"
+etic80coff.c: $(srcdir)/emulparams/tic80coff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic80coff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic80coff "$(tdir_tic80coff)"
+evanilla.c: $(srcdir)/emulparams/vanilla.sh \
+  $(srcdir)/emultempl/vanilla.em $(srcdir)/scripttempl/vanilla.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} vanilla "$(tdir_vanilla)"
+evax.c: $(srcdir)/emulparams/vax.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} vax "$(tdir_vax)"
+evaxnbsd.c: $(srcdir)/emulparams/vaxnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} vaxnbsd "$(tdir_vaxnbsd)"
+evsta.c: $(srcdir)/emulparams/vsta.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} vsta "$(tdir_vsta)"
+ev850.c: $(srcdir)/emulparams/v850.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/v850.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} v850 "$(tdir_v850)"
+ew65.c: $(srcdir)/emulparams/w65.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/w65.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} w65 "$(tdir_w65)"
+ez80.c: $(srcdir)/emulparams/z80.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/z80.em \
+  $(srcdir)/scripttempl/z80.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} z80 "$(tdir_z80)"
+ez8001.c: $(srcdir)/emulparams/z8001.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/z8000.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} z8001 "$(tdir_z8001)"
+ez8002.c: $(srcdir)/emulparams/z8002.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/z8000.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} z8002 "$(tdir_z8002)"
+
+# We need this for automake to use YLWRAP.
+EXTRA_ld_new_SOURCES = deffilep.y ldlex.l
+# Allow dependency tracking to work for these files, too.
+EXTRA_ld_new_SOURCES += pep-dll.c pe-dll.c
+
+ld_new_SOURCES = ldgram.y ldlex-wrapper.c lexsup.c ldlang.c mri.c ldctor.c ldmain.c \
+	ldwrite.c ldexp.c ldemul.c ldver.c ldmisc.c ldfile.c ldcref.c
+ld_new_DEPENDENCIES = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(LIBINTL_DEP)
+ld_new_LDADD = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(LIBINTL)
+
+# Dependency tracking for the generated emulation files.
+EXTRA_ld_new_SOURCES += $(ALL_EMULATIONS:.o=.c) $(ALL_64_EMULATIONS:.o=.c)
+
+# This is the real libbfd.a created by libtool.
+TESTBFDLIB = @TESTBFDLIB@
+
+check-DEJAGNU: site.exp
+	srcroot=`cd $(srcdir) && pwd`; export srcroot; \
+	r=`pwd`; export r; \
+	LC_COLLATE=; LC_ALL=; LANG=; export LC_COLLATE LC_ALL LANG; \
+	EXPECT=$(EXPECT); export EXPECT; \
+	runtest=$(RUNTEST); \
+	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
+	  $$runtest --tool $(DEJATOOL) --srcdir $${srcroot}/testsuite \
+		CC="$(CC_FOR_TARGET)" CFLAGS="$(CFLAGS)" \
+		CXX="$(CXX_FOR_TARGET)" CXXFLAGS="$(CXXFLAGS)" \
+		CC_FOR_HOST="$(CC)" CFLAGS_FOR_HOST="$(CFLAGS)" \
+		OFILES="$(OFILES)" BFDLIB="$(TESTBFDLIB)" \
+		LIBIBERTY="$(LIBIBERTY) $(LIBINTL)" LIBS="$(LIBS)" \
+		DO_COMPARE="`echo '$(do_compare)' | sed -e 's,\\$$,,g'`" \
+		$(RUNTESTFLAGS); \
+	else echo "WARNING: could not find \`runtest'" 1>&2; :;\
+	fi
+
+# Rules for testing by relinking ld itself.
+# A similar test is in the testsuite.  This target is for ease of use
+# when porting ld.
+
+ld-partial.o: ld-new$(EXEEXT)
+	./ld-new$(EXEEXT) $(HOSTING_EMU) -o ld-partial.o -r $(OFILES)
+ld1$(EXEEXT): ld-partial.o
+	./ld-new$(EXEEXT) $(HOSTING_EMU) -o ld1$(EXEEXT) $(HOSTING_CRT0) ld-partial.o $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+ld1-full$(EXEEXT): ld-new
+	./ld-new$(EXEEXT) $(HOSTING_EMU) -o ld1-full$(EXEEXT) $(HOSTING_CRT0) $(OFILES) $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+ld2$(EXEEXT): ld1$(EXEEXT)
+	./ld1$(EXEEXT) $(HOSTING_EMU) -o ld2$(EXEEXT) $(HOSTING_CRT0) $(OFILES) $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+ld3$(EXEEXT): ld2$(EXEEXT)
+	./ld2$(EXEEXT) $(HOSTING_EMU) -o ld3$(EXEEXT) $(HOSTING_CRT0) $(OFILES) $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+bootstrap: ld3$(EXEEXT)
+	cmp ld2$(EXEEXT) ld3$(EXEEXT)
+
+.PHONY: bootstrap
+
+# A test program for C++ constructors and destructors.
+# This test is now in the testsuite.
+#
+#cdtest: cdtest-main.o cdtest-bar.o cdtest-foo.o ld.new
+#	./ld.new $(HOSTING_EMU) -o cdtest $(HOSTING_CRT0) \
+#	  cdtest-main.o cdtest-bar.o cdtest-foo.o $(HOSTING_LIBS)
+#
+#cdtest.out: cdtest
+#	./cdtest > cdtest.tmp
+#	mv cdtest.tmp cdtest.out
+#
+#cdtest-ur.o: cdtest-main.o cdtest-bar.o cdtest-foo.o ld.new
+#	./ld.new $(HOSTING_EMU) -o cdtest-ur.o -Ur cdtest-main.o \
+#	  cdtest-bar.o cdtest-foo.o
+#
+#cdtest-ur: cdtest-ur.o
+#	./ld.new $(HOSTING_EMU) -o cdtest-ur $(HOSTING_CRT0) cdtest-ur.o \
+#	  $(HOSTING_LIBS)
+#
+#cdtest-ur.out: cdtest-ur
+#	./cdtest-ur > cdtest-ur.tmp
+#	mv cdtest-ur.tmp cdtest-ur.out
+#
+#check-cdtest: cdtest.out cdtest-ur.out $(srcdir)/cdtest.exp
+#	diff $(srcdir)/cdtest.exp cdtest.out
+#	diff $(srcdir)/cdtest.exp cdtest-ur.out
+#
+#.PHONY: check-cdtest
+
+# END OF CHECK TARGETS
+
+# DOCUMENTATION TARGETS
+# Manual configuration file; not usually attached to normal configuration,
+# because almost all configs use "gen" version of manual.
+#  Set DOCVER above to change.
+configdoc.texi:	${DOCVER}-doc.texi
+	cp ${srcdir}/${DOCVER}-doc.texi ./configdoc.texi
+	chmod u+w ./configdoc.texi
+
+# Build the man page from the texinfo file
+# The sed command removes the no-adjust Nroff command so that
+# the man output looks standard.
+ld.1: $(srcdir)/ld.texinfo configdoc.texi
+	touch $@
+	-$(TEXI2POD) $(MANCONF) < $(srcdir)/ld.texinfo > ld.pod
+	-($(POD2MAN) ld.pod | \
+	        sed -e '/^.if n .na/d' > $@.T$$$$ && \
+	        mv -f $@.T$$$$ $@) || \
+	        (rm -f $@.T$$$$ && exit 1)
+	rm -f ld.pod
+
+MAINTAINERCLEANFILES = configdoc.texi ld.1
+
+# We want to reconfigure if configure.host or configure.tgt changes.  We
+# extract version from bfd/configure.in, so we must depend on that also.
+CONFIG_STATUS_DEPENDENCIES = $(srcdir)/configure.host $(srcdir)/configure.tgt \
+	$(srcdir)/../bfd/configure.in
+
+MOSTLYCLEANFILES = $(STAGESTUFF) ld1$(EXEEXT) ld2$(EXEEXT) ld3$(EXEEXT) \
+	ldemul-list.h crtbegin.o crtend.o ld.log ld.sum
+mostlyclean-local:
+	-rm -rf tmpdir
+CLEANFILES = dep.sed DEP DEPA DEP1 DEP2 spu_ovl.s spu_ovl.o spu_icache.s spu_icache.o
+
+.PHONY: install-exec-local install-data-local
+
+install-exec-local: ld-new$(EXEEXT)
+	$(mkinstalldirs) $(DESTDIR)$(tooldir)/bin
+	n=`echo ld | sed '$(transform)'`; \
+	if [ "$(bindir)/$$n$(EXEEXT)" != "$(tooldir)/bin/ld$(EXEEXT)" ]; then \
+	  rm -f $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT); \
+	  ln $(DESTDIR)$(bindir)/$$n$(EXEEXT) $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT) >/dev/null 2>/dev/null \
+	  || $(LIBTOOL) --mode=install $(INSTALL_PROGRAM) ld-new$(EXEEXT) $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT); \
+	fi
+
+install-data-local:
+	$(mkinstalldirs) $(DESTDIR)$(scriptdir)/ldscripts
+	for f in ldscripts/*; do \
+	  $(INSTALL_DATA) $$f $(DESTDIR)$(scriptdir)/$$f ; \
+	done
+
+# Stuff that should be included in a distribution.  The diststuff
+# target is run by the taz target in ../Makefile.in.
+EXTRA_DIST = ldgram.c ldgram.h ldlex.c emultempl/spu_ovl.o_c \
+	     emultempl/spu_icache.o_c deffilep.c deffilep.h $(man_MANS)
+diststuff: info $(EXTRA_DIST)
+
+# Both info (ld.info) and ld.1 depend on configdoc.texi.
+# But info isn't a direct target. Make info-recursive to depend on
+# ld.1 to support parallel build.
+info-recursive: ld.1
+
+DISTCLEANFILES = tdirs site.exp site.bak stringify.sed
+distclean-local:
+	rm -rf ldscripts
+
+MAINTAINERCLEANFILES += ld.info
+
+# Automake 1.9 will only build info files in the objdir if they are
+# mentioned in DISTCLEANFILES.  It doesn't have to be unconditional,
+# though, so we use a bogus condition.
+if GENINSRC_NEVER
+DISTCLEANFILES += ld.info
+endif
diff -urN binutils-2.20.1.old/ld/Makefile.in binutils-2.20.1/ld/Makefile.in
--- binutils-2.20.1.old/ld/Makefile.in	2010-03-03 08:06:21.000000000 -0600
+++ binutils-2.20.1/ld/Makefile.in	2010-04-13 09:49:42.345947864 -0500
@@ -434,6 +434,13 @@
 	eavr5.o \
 	eavr51.o \
 	eavr6.o \
+	eavrxmega1.o \
+	eavrxmega2.o \
+	eavrxmega3.o \
+	eavrxmega4.o \
+	eavrxmega5.o \
+	eavrxmega6.o \
+	eavrxmega7.o \
 	ecoff_i860.o \
 	ecoff_sparc.o \
 	eelf32_spu.o \
@@ -2069,6 +2076,34 @@
   $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} avr6 "$(tdir_avr2)"
+eavrxmega1.c: $(srcdir)/emulparams/avrxmega1.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega1 "$(tdir_avr2)"
+eavrxmega2.c: $(srcdir)/emulparams/avrxmega2.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega2 "$(tdir_avr2)"
+eavrxmega3.c: $(srcdir)/emulparams/avrxmega3.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega3 "$(tdir_avr2)"
+eavrxmega4.c: $(srcdir)/emulparams/avrxmega4.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega4 "$(tdir_avr2)"
+eavrxmega5.c: $(srcdir)/emulparams/avrxmega5.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega5 "$(tdir_avr2)"
+eavrxmega6.c: $(srcdir)/emulparams/avrxmega6.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega6 "$(tdir_avr2)"
+eavrxmega7.c: $(srcdir)/emulparams/avrxmega7.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrxmega7 "$(tdir_avr2)"
 ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} coff_i860 "$(tdir_coff_i860)"
diff -urN binutils-2.20.1.old/ld/Makefile.in.orig binutils-2.20.1/ld/Makefile.in.orig
--- binutils-2.20.1.old/ld/Makefile.in.orig	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/ld/Makefile.in.orig	2010-03-03 08:06:21.000000000 -0600
@@ -0,0 +1,3298 @@
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+bin_PROGRAMS = ld-new$(EXEEXT)
+
+# Automake 1.9 will only build info files in the objdir if they are
+# mentioned in DISTCLEANFILES.  It doesn't have to be unconditional,
+# though, so we use a bogus condition.
+@GENINSRC_NEVER_TRUE@am__append_1 = ld.info
+subdir = .
+DIST_COMMON = NEWS README ChangeLog $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/configure \
+	$(am__configure_deps) $(srcdir)/config.in \
+	$(srcdir)/../mkinstalldirs $(top_srcdir)/po/Make-in ldgram.h \
+	ldgram.c deffilep.h deffilep.c ldlex.c $(srcdir)/../depcomp \
+	$(srcdir)/../ylwrap $(ld_TEXINFOS)
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/../bfd/acinclude.m4 \
+	$(top_srcdir)/../bfd/warning.m4 $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/depstand.m4 \
+	$(top_srcdir)/../config/gettext-sister.m4 \
+	$(top_srcdir)/../config/lead-dot.m4 \
+	$(top_srcdir)/../config/nls.m4 \
+	$(top_srcdir)/../config/override.m4 \
+	$(top_srcdir)/../config/po.m4 \
+	$(top_srcdir)/../config/progtest.m4 \
+	$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \
+	$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \
+	$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs
+CONFIG_HEADER = config.h
+CONFIG_CLEAN_FILES = po/Makefile.in
+CONFIG_CLEAN_VPATH_FILES =
+am__installdirs = "$(DESTDIR)$(bindir)" "$(DESTDIR)$(infodir)" \
+	"$(DESTDIR)$(man1dir)"
+PROGRAMS = $(bin_PROGRAMS)
+am_ld_new_OBJECTS = ldgram.$(OBJEXT) ldlex-wrapper.$(OBJEXT) \
+	lexsup.$(OBJEXT) ldlang.$(OBJEXT) mri.$(OBJEXT) \
+	ldctor.$(OBJEXT) ldmain.$(OBJEXT) ldwrite.$(OBJEXT) \
+	ldexp.$(OBJEXT) ldemul.$(OBJEXT) ldver.$(OBJEXT) \
+	ldmisc.$(OBJEXT) ldfile.$(OBJEXT) ldcref.$(OBJEXT)
+ld_new_OBJECTS = $(am_ld_new_OBJECTS)
+am__DEPENDENCIES_1 =
+DEFAULT_INCLUDES = -I.@am__isrc@
+depcomp = $(SHELL) $(top_srcdir)/../depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+@MAINTAINER_MODE_FALSE@am__skiplex = test -f $@ ||
+LEXCOMPILE = $(LEX) $(LFLAGS) $(AM_LFLAGS)
+LTLEXCOMPILE = $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(LEX) $(LFLAGS) $(AM_LFLAGS)
+YLWRAP = $(top_srcdir)/../ylwrap
+@MAINTAINER_MODE_FALSE@am__skipyacc = test -f $@ ||
+YACCCOMPILE = $(YACC) $(YFLAGS) $(AM_YFLAGS)
+LTYACCCOMPILE = $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(YACC) $(YFLAGS) $(AM_YFLAGS)
+SOURCES = $(ld_new_SOURCES) $(EXTRA_ld_new_SOURCES)
+INFO_DEPS = ld.info
+am__TEXINFO_TEX_DIR = $(srcdir)/$(top_srcdir)/../texinfo
+DVIS = ld.dvi
+PDFS = ld.pdf
+PSS = ld.ps
+HTMLS = ld.html
+TEXINFOS = ld.texinfo
+TEXI2PDF = $(TEXI2DVI) --pdf --batch
+MAKEINFOHTML = $(MAKEINFO) --html
+AM_MAKEINFOHTMLFLAGS = $(AM_MAKEINFOFLAGS)
+DVIPS = dvips
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+man1dir = $(mandir)/man1
+NROFF = nroff
+MANS = $(man_MANS)
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
+	$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS
+ETAGS = etags
+CTAGS = ctags
+DEJATOOL = $(PACKAGE)
+RUNTESTDEFAULTFLAGS = --tool $$tool --srcdir $$srcdir
+DIST_SUBDIRS = $(SUBDIRS)
+transform = s/^ld-new$$/ld/;@program_transform_name@
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CATALOGS = @CATALOGS@
+CATOBJEXT = @CATOBJEXT@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EMUL = @EMUL@
+EMULATION_LIBPATH = @EMULATION_LIBPATH@
+EMULATION_OFILES = @EMULATION_OFILES@
+EMUL_EXTRA_OFILES = @EMUL_EXTRA_OFILES@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GENCAT = @GENCAT@
+GMSGFMT = @GMSGFMT@
+GREP = @GREP@
+HDEFINES = @HDEFINES@
+
+#stuff for self hosting (can be overridden in config file).
+HOSTING_CRT0 = @HOSTING_CRT0@
+HOSTING_LIBS = @HOSTING_LIBS@
+INCINTL = @INCINTL@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LEX = `if [ -f ../flex/flex ]; then echo ../flex/flex; else echo @LEX@; fi`
+LEXLIB = @LEXLIB@
+LEX_OUTPUT_ROOT = @LEX_OUTPUT_ROOT@
+LIBINTL = @LIBINTL@
+LIBINTL_DEP = @LIBINTL_DEP@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+
+# Search path to override the default search path for -lfoo libraries.
+# If LIB_PATH is empty, the ones in the script (if any) are left alone.
+# (The default is usually /lib:/usr/lib:/usr/local/lib, unless building
+# a cross-linker, in which case the default is empty.  See genscripts.sh.)
+# Otherwise, they are replaced with the ones given in LIB_PATH,
+# which may have the form: LIB_PATH=/lib:/usr/local/lib.  This can be set
+# when the linker is configured via the --with-lib-path configure switch.
+LIB_PATH = @LIB_PATH@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
+NATIVE_LIB_DIRS = @NATIVE_LIB_DIRS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+NO_WERROR = @NO_WERROR@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+POSUB = @POSUB@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRINGIFY = @STRINGIFY@
+STRIP = @STRIP@
+TARGET_SYSTEM_ROOT = @TARGET_SYSTEM_ROOT@
+TARGET_SYSTEM_ROOT_DEFINE = @TARGET_SYSTEM_ROOT_DEFINE@
+
+# This is the real libbfd.a created by libtool.
+TESTBFDLIB = @TESTBFDLIB@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+WARN_CFLAGS = @WARN_CFLAGS@
+XGETTEXT = @XGETTEXT@
+YACC = `if [ -f ../bison/bison ]; then echo ../bison/bison -y -L$(srcdir)/../bison/; else echo @YACC@; fi`
+YFLAGS = -d
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+do_compare = @do_compare@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+use_sysroot = @use_sysroot@
+AUTOMAKE_OPTIONS = dejagnu no-texinfo.tex no-dist foreign
+ACLOCAL_AMFLAGS = -I .. -I ../config -I ../bfd
+TEXINFO_TEX = $(top_srcdir)/../texinfo/texinfo.tex
+SUBDIRS = po
+tooldir = $(exec_prefix)/$(target_alias)
+
+# Automake 1.10+ disables lex and yacc output file regeneration if
+# maintainer mode is disabled.  Avoid this.
+am__skiplex = 
+am__skipyacc = 
+AM_CFLAGS = $(WARN_CFLAGS)
+
+# We put the scripts in the directory $(scriptdir)/ldscripts.
+# We can't put the scripts in $(datadir) because the SEARCH_DIR
+# directives need to be different for native and cross linkers.
+scriptdir = $(tooldir)/lib
+BASEDIR = $(srcdir)/..
+BFDDIR = $(BASEDIR)/bfd
+INCDIR = $(BASEDIR)/include
+
+# What version of the manual to build
+DOCVER = gen
+
+# Options to extract the man page from ld.texinfo
+MANCONF = -Dman
+TEXI2POD = perl $(BASEDIR)/etc/texi2pod.pl $(AM_MAKEINFOFLAGS)
+POD2MAN = pod2man --center="GNU Development Tools" \
+	--release="binutils-$(VERSION)" --section=1
+
+HOSTING_EMU = -m $(EMUL)
+
+# Setup the testing framework, if you have one
+EXPECT = expect
+RUNTEST = runtest
+RUNTESTFLAGS = 
+CC_FOR_TARGET = ` \
+  if [ -f $$r/../gcc/xgcc ] ; then \
+    if [ -f $$r/../newlib/Makefile ] ; then \
+      echo $$r/../gcc/xgcc -B$$r/../gcc/ -idirafter $$r/../newlib/targ-include -idirafter $${srcroot}/../newlib/libc/include -nostdinc; \
+    else \
+      echo $$r/../gcc/xgcc -B$$r/../gcc/; \
+    fi; \
+  else \
+    if [ "@host@" = "@target@" ] ; then \
+      echo $(CC); \
+    else \
+      echo gcc | sed '$(transform)'; \
+    fi; \
+  fi`
+
+CXX = g++
+CXX_FOR_TARGET = ` \
+  if [ -f $$r/../gcc/g++ ] ; then \
+    if [ -f $$r/../newlib/Makefile ] ; then \
+      echo $$r/../gcc/g++ -B$$r/../gcc/ -idirafter $$r/../newlib/targ-include -idirafter $${srcroot}/../newlib/libc/include -nostdinc; \
+    else \
+      echo $$r/../gcc/g++ -B$$r/../gcc/; \
+    fi; \
+  else \
+    if [ "@host@" = "@target@" ] ; then \
+      echo $(CXX); \
+    else \
+      echo g++ | sed '$(transform)'; \
+    fi; \
+  fi`
+
+info_TEXINFOS = ld.texinfo
+ld_TEXINFOS = configdoc.texi
+noinst_TEXINFOS = ldint.texinfo
+man_MANS = ld.1
+AM_MAKEINFOFLAGS = -I $(srcdir) -I $(BFDDIR)/doc -I ../bfd/doc \
+		   -I $(top_srcdir)/../libiberty
+
+TEXI2DVI = texi2dvi -I $(srcdir) -I $(BFDDIR)/doc -I ../bfd/doc \
+		    -I $(top_srcdir)/../libiberty
+
+AM_CPPFLAGS = -I. -I$(srcdir) -I../bfd -I$(BFDDIR) -I$(INCDIR) \
+	@INCINTL@ $(HDEFINES) $(CFLAGS) \
+	-DLOCALEDIR="\"$(datadir)/locale\""
+
+BFDLIB = ../bfd/libbfd.la
+LIBIBERTY = ../libiberty/libiberty.a
+ALL_EMULATIONS = \
+	eaixppc.o \
+	eaixrs6.o \
+	ealpha.o \
+	earcelf.o \
+	earm_epoc_pe.o \
+	earm_wince_pe.o \
+	earmaoutb.o \
+	earmaoutl.o \
+	earmcoff.o \
+	earmelf.o \
+	earmelfb.o \
+	earmelf_fbsd.o \
+	earmelf_linux.o \
+	earmelf_linux_eabi.o \
+	earmelfb_linux.o \
+	earmelfb_linux_eabi.o \
+	earmelf_nbsd.o \
+	earmelfb_nbsd.o \
+	earmelf_vxworks.o \
+	earmnto.o \
+	earmnbsd.o \
+	earmpe.o \
+	earmsymbian.o \
+	eavr2.o \
+	eavr1.o \
+	eavr25.o \
+	eavr3.o \
+	eavr31.o \
+	eavr35.o \
+	eavr4.o \
+	eavr5.o \
+	eavr51.o \
+	eavr6.o \
+	ecoff_i860.o \
+	ecoff_sparc.o \
+	eelf32_spu.o \
+	ecrisaout.o \
+	ecriself.o \
+	ecrislinux.o \
+	ed10velf.o \
+	ed30v_e.o \
+	ed30v_o.o \
+	ed30velf.o \
+	edelta68.o \
+	eelf32_dlx.o \
+	eelf32_i960.o \
+	eelf32_i860.o \
+	eelf32_sparc.o \
+	eelf32_sparc_vxworks.o \
+	eelf32b4300.o \
+	eelf32bfin.o \
+	eelf32bfinfd.o \
+	eelf32cr16.o \
+	eelf32cr16c.o \
+	eelf32bmip.o \
+	eelf32bmipn32.o \
+	eelf32btsmip.o \
+	eelf32crx.o \
+	eelf32btsmipn32.o \
+	eelf32ltsmip.o \
+	eelf32ltsmipn32.o \
+	eelf32ebmip.o \
+	eelf32ebmipvxworks.o \
+	eelf32elmip.o \
+	eelf32elmipvxworks.o \
+	eelf32fr30.o \
+	eelf32frv.o \
+	eelf32moxie.o \
+	eelf32i370.o \
+	eelf32ip2k.o \
+	eelf32iq2000.o \
+	eelf32iq10.o \
+	eelf32lm32.o \
+	eelf32lm32fd.o \
+	eelf32l4300.o \
+	eelf32lmip.o \
+	eelf32lppc.o \
+	eelf32lppcnto.o \
+	eelf32lppcsim.o \
+	eelf32m32c.o \
+	eelf32mcore.o \
+	eelf32mep.o \
+	eelf32mb_linux.o \
+ 	eelf32microblaze.o \
+	eelf32mipswindiss.o \
+	eelf32mt.o \
+	eelf32openrisc.o \
+	eelf32ppc.o \
+	eelf32ppc_fbsd.o \
+	eelf32ppclinux.o \
+	eelf32ppcnto.o \
+	eelf32ppcsim.o \
+	eelf32ppcwindiss.o \
+	eelf32ppcvxworks.o \
+	eelf32vax.o \
+        eelf32xc16x.o \
+        eelf32xc16xl.o \
+        eelf32xc16xs.o \
+	eelf32xstormy16.o \
+	eelf32xtensa.o \
+	eelf_i386.o \
+	eelf_i386_be.o \
+	eelf_i386_chaos.o \
+	eelf_i386_fbsd.o \
+	eelf_i386_ldso.o \
+	eelf_i386_vxworks.o \
+	eelf_s390.o \
+	egld960.o \
+	egld960coff.o \
+	eh8300.o \
+	eh8300h.o \
+	eh8300s.o \
+	eh8300elf.o \
+	eh8300hn.o \
+	eh8300sn.o \
+	eh8300sx.o \
+	eh8300helf.o \
+	eh8300self.o \
+	eh8300hnelf.o \
+	eh8300snelf.o \
+	eh8300sxelf.o \
+	eh8300sxn.o \
+	eh8300sxnelf.o \
+	eh8500.o \
+	eh8500b.o \
+	eh8500c.o \
+	eh8500m.o \
+	eh8500s.o \
+	ehp300bsd.o \
+	ehp3hpux.o \
+	ehppaelf.o \
+	ehppalinux.o \
+	ehppanbsd.o \
+	ehppaobsd.o \
+	ei386aout.o \
+	ei386beos.o \
+	ei386bsd.o \
+	ei386coff.o \
+	ei386go32.o \
+	ei386linux.o \
+	ei386lynx.o \
+	ei386mach.o \
+	ei386moss.o \
+	ei386msdos.o \
+	ei386nbsd.o \
+	ei386nto.o \
+	ei386nw.o \
+	ei386pe.o \
+	ei386pe_posix.o \
+	ei386pep.o \
+	elnk960.o \
+	em32relf.o \
+	em32rlelf.o \
+	em32relf_linux.o \
+	em32rlelf_linux.o \
+	em68hc11elf.o \
+	em68hc11elfb.o \
+	em68hc12elf.o \
+	em68hc12elfb.o \
+	em68k4knbsd.o \
+	em68kaout.o \
+	em68kaux.o \
+	em68kcoff.o \
+	em68kelf.o \
+	em68kelfnbsd.o \
+	em68klinux.o \
+	em68knbsd.o \
+	em68kpsos.o \
+	em88kbcs.o \
+	emaxqcoff.o \
+	emcorepe.o \
+	emipsbig.o \
+	emipsbsd.o \
+	emipsidt.o \
+	emipsidtl.o \
+	emipslit.o \
+	emipslnews.o \
+	emipspe.o \
+	emsp430x110.o \
+	emsp430x112.o \
+	emsp430x1101.o \
+	emsp430x1111.o \
+	emsp430x1121.o \
+	emsp430x1122.o \
+	emsp430x1132.o \
+	emsp430x122.o \
+	emsp430x123.o \
+	emsp430x1222.o \
+	emsp430x1232.o \
+	emsp430x133.o \
+	emsp430x135.o \
+	emsp430x1331.o \
+	emsp430x1351.o \
+	emsp430x147.o \
+	emsp430x148.o \
+	emsp430x149.o \
+	emsp430x155.o \
+	emsp430x156.o \
+	emsp430x157.o \
+	emsp430x167.o \
+	emsp430x168.o \
+	emsp430x169.o \
+	emsp430x1610.o \
+	emsp430x1611.o \
+	emsp430x1612.o \
+	emsp430x2101.o \
+	emsp430x2111.o \
+	emsp430x2121.o \
+	emsp430x2131.o \
+	emsp430x311.o \
+	emsp430x312.o \
+	emsp430x313.o \
+	emsp430x314.o \
+	emsp430x315.o \
+	emsp430x323.o \
+	emsp430x325.o \
+	emsp430x336.o \
+	emsp430x337.o \
+	emsp430x412.o \
+	emsp430x413.o \
+	emsp430x415.o \
+	emsp430x417.o \
+	emsp430xE423.o \
+	emsp430xE425.o \
+	emsp430xE427.o \
+	emsp430xW423.o \
+	emsp430xW425.o \
+	emsp430xW427.o \
+	emsp430xG437.o \
+	emsp430xG438.o \
+	emsp430xG439.o \
+	emsp430x435.o \
+	emsp430x436.o \
+	emsp430x437.o \
+	emsp430x447.o \
+	emsp430x448.o \
+	emsp430x449.o \
+	enews.o \
+	ens32knbsd.o \
+	eor32.o \
+	eor32elf.o \
+	epc532macha.o \
+	epdp11.o \
+	epjelf.o \
+	epjlelf.o \
+	eppcmacos.o \
+	eppcnw.o \
+	eppcpe.o \
+	eppclynx.o \
+	eriscix.o \
+	escore3_elf.o \
+	escore7_elf.o \
+	esh.o \
+	eshelf32.o \
+	eshlelf32.o \
+	eshelf32_linux.o \
+	eshlelf32_linux.o \
+	eshelf32_nbsd.o \
+	eshlelf32_nbsd.o \
+	eshelf.o \
+	eshelf_linux.o \
+	eshlelf_linux.o \
+	eshelf_nbsd.o \
+	eshlelf_nbsd.o \
+	eshelf_nto.o \
+	eshlelf_nto.o \
+	eshelf_uclinux.o \
+	eshelf_vxworks.o \
+	eshlelf_vxworks.o \
+	eshl.o \
+	eshlelf.o \
+	eshlsymbian.o \
+	eshpe.o \
+	esparcaout.o \
+	esparclinux.o \
+	esparcnbsd.o \
+	est2000.o \
+	esun3.o \
+	esun4.o \
+	etic30aout.o \
+	etic30coff.o \
+	etic3xcoff.o \
+	etic3xcoff_onchip.o \
+	etic4xcoff.o \
+	etic54xcoff.o \
+	etic80coff.o \
+	evanilla.o \
+	evax.o \
+	evaxnbsd.o \
+	evsta.o \
+	ew65.o \
+	ez8001.o \
+	eelf32frvfd.o \
+	ez80.o \
+	ez8002.o
+
+ALL_64_EMULATIONS = \
+	eelf64_aix.o \
+	eelf64_ia64.o \
+	eelf64_ia64_fbsd.o \
+	eshelf64.o \
+	eshlelf64.o \
+	eshelf64_nbsd.o \
+	eshlelf64_nbsd.o \
+	eelf_x86_64.o \
+	eelf_x86_64_fbsd.o \
+	eelf_l1om.o \
+	eelf_l1om_fbsd.o \
+	eelf64_s390.o \
+	eelf64_sparc.o \
+	eelf64_sparc_fbsd.o \
+	eelf64alpha.o \
+	eelf64alpha_fbsd.o \
+	eelf64alpha_nbsd.o \
+	eelf64bmip.o \
+	eelf64btsmip.o \
+	eelf64ltsmip.o \
+	eelf64hppa.o \
+	eelf64mmix.o \
+	emmo.o \
+	eelf64ppc.o \
+	eelf64lppc.o \
+	ehppa64linux.o
+
+ALL_EMUL_EXTRA_OFILES = \
+	deffilep.o \
+	pe-dll.o \
+	pep-dll.o
+
+CFILES = ldctor.c ldemul.c ldexp.c ldfile.c ldlang.c \
+	ldmain.c ldmisc.c ldver.c ldwrite.c lexsup.c \
+	mri.c ldcref.c pe-dll.c pep-dll.c ldlex-wrapper.c
+
+HFILES = ld.h ldctor.h ldemul.h ldexp.h ldfile.h \
+	ldlang.h ldlex.h ldmain.h ldmisc.h ldver.h \
+	ldwrite.h mri.h deffile.h pe-dll.h pep-dll.h elf-hints-local.h
+
+GENERATED_CFILES = ldgram.c ldlex.c deffilep.c
+GENERATED_HFILES = ldgram.h ldemul-list.h deffilep.h
+
+# Require an early dependency on the generated headers, as the dependency
+# tracking will not cause them to be built beforehand.
+BUILT_SOURCES = $(GENERATED_HFILES)
+OFILES = ldgram.o ldlex-wrapper.o lexsup.o ldlang.o mri.o ldctor.o ldmain.o \
+	ldwrite.o ldexp.o  ldemul.o ldver.o ldmisc.o \
+	ldfile.o ldcref.o ${EMULATION_OFILES} ${EMUL_EXTRA_OFILES}
+
+STAGESTUFF = *.o ldscripts/* e*.c
+
+# At the moment this is just a list of those emulation template files
+# that contain internationalised strings.
+EMULATION_FILES = emultempl/pe.em emultempl/armcoff.em
+POTFILES = $(CFILES) $(HFILES) $(EMULATION_FILES)
+
+# These all start with e so 'make clean' can find them.
+GENSCRIPTS = LIB_PATH='${LIB_PATH}' $(SHELL) $(srcdir)/genscripts.sh "${srcdir}" "${libdir}" "${prefix}" "${exec_prefix}" @host@ @target@ @target_alias@ "@EMULATION_LIBPATH@" "@NATIVE_LIB_DIRS@" @use_sysroot@
+GEN_DEPENDS = $(srcdir)/genscripts.sh stringify.sed
+ELF_DEPS = $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/elf-generic.em
+ELF_GEN_DEPS = $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/elf-generic.em $(srcdir)/emultempl/genelf.em
+
+# We need this for automake to use YLWRAP.
+# Allow dependency tracking to work for these files, too.
+
+# Dependency tracking for the generated emulation files.
+EXTRA_ld_new_SOURCES = deffilep.y ldlex.l pep-dll.c pe-dll.c \
+	$(ALL_EMULATIONS:.o=.c) $(ALL_64_EMULATIONS:.o=.c)
+ld_new_SOURCES = ldgram.y ldlex-wrapper.c lexsup.c ldlang.c mri.c ldctor.c ldmain.c \
+	ldwrite.c ldexp.c ldemul.c ldver.c ldmisc.c ldfile.c ldcref.c
+
+ld_new_DEPENDENCIES = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(LIBINTL_DEP)
+ld_new_LDADD = $(EMULATION_OFILES) $(EMUL_EXTRA_OFILES) $(BFDLIB) $(LIBIBERTY) $(LIBINTL)
+MAINTAINERCLEANFILES = configdoc.texi ld.1 ld.info
+
+# We want to reconfigure if configure.host or configure.tgt changes.  We
+# extract version from bfd/configure.in, so we must depend on that also.
+CONFIG_STATUS_DEPENDENCIES = $(srcdir)/configure.host $(srcdir)/configure.tgt \
+	$(srcdir)/../bfd/configure.in
+
+MOSTLYCLEANFILES = $(STAGESTUFF) ld1$(EXEEXT) ld2$(EXEEXT) ld3$(EXEEXT) \
+	ldemul-list.h crtbegin.o crtend.o ld.log ld.sum
+
+CLEANFILES = dep.sed DEP DEPA DEP1 DEP2 spu_ovl.s spu_ovl.o spu_icache.s spu_icache.o
+
+# Stuff that should be included in a distribution.  The diststuff
+# target is run by the taz target in ../Makefile.in.
+EXTRA_DIST = ldgram.c ldgram.h ldlex.c emultempl/spu_ovl.o_c \
+	     emultempl/spu_icache.o_c deffilep.c deffilep.h $(man_MANS)
+
+DISTCLEANFILES = tdirs site.exp site.bak stringify.sed $(am__append_1)
+all: $(BUILT_SOURCES) config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-recursive
+
+.SUFFIXES:
+.SUFFIXES: .c .dvi .l .lo .o .obj .ps .y
+am--refresh:
+	@:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \
+	      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	$(am__cd) $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+$(am__aclocal_m4_deps):
+
+config.h: stamp-h1
+	@if test ! -f $@; then \
+	  rm -f stamp-h1; \
+	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
+	else :; fi
+
+stamp-h1: $(srcdir)/config.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status config.h
+$(srcdir)/config.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) 
+	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
+	rm -f stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f config.h stamp-h1
+po/Makefile.in: $(top_builddir)/config.status $(top_srcdir)/po/Make-in
+	cd $(top_builddir) && $(SHELL) ./config.status $@
+install-binPROGRAMS: $(bin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(bindir)" || $(MKDIR_P) "$(DESTDIR)$(bindir)"
+	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
+	for p in $$list; do echo "$$p $$p"; done | \
+	sed 's/$(EXEEXT)$$//' | \
+	while read p p1; do if test -f $$p || test -f $$p1; \
+	  then echo "$$p"; echo "$$p"; else :; fi; \
+	done | \
+	sed -e 'p;s,.*/,,;n;h' -e 's|.*|.|' \
+	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
+	sed 'N;N;N;s,\n, ,g' | \
+	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
+	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
+	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
+	    else { print "f", $$3 "/" $$4, $$1; } } \
+	  END { for (d in files) print "f", d, files[d] }' | \
+	while read type dir files; do \
+	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
+	    test -z "$$files" || { \
+	    echo " $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(bindir)$$dir'"; \
+	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
+	    } \
+	; done
+
+uninstall-binPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
+	files=`for p in $$list; do echo "$$p"; done | \
+	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
+	      -e 's/$$/$(EXEEXT)/' `; \
+	test -n "$$list" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(bindir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(bindir)" && rm -f $$files
+
+clean-binPROGRAMS:
+	@list='$(bin_PROGRAMS)'; test -n "$$list" || exit 0; \
+	echo " rm -f" $$list; \
+	rm -f $$list || exit $$?; \
+	test -n "$(EXEEXT)" || exit 0; \
+	list=`for p in $$list; do echo "$$p"; done | sed 's/$(EXEEXT)$$//'`; \
+	echo " rm -f" $$list; \
+	rm -f $$list
+ldgram.h: ldgram.c
+	@if test ! -f $@; then \
+	  rm -f ldgram.c; \
+	  $(MAKE) $(AM_MAKEFLAGS) ldgram.c; \
+	else :; fi
+deffilep.h: deffilep.c
+	@if test ! -f $@; then \
+	  rm -f deffilep.c; \
+	  $(MAKE) $(AM_MAKEFLAGS) deffilep.c; \
+	else :; fi
+ld-new$(EXEEXT): $(ld_new_OBJECTS) $(ld_new_DEPENDENCIES) 
+	@rm -f ld-new$(EXEEXT)
+	$(LINK) $(ld_new_OBJECTS) $(ld_new_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/deffilep.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaixppc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eaixrs6.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ealpha.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earcelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earm_epoc_pe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earm_wince_pe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmaoutb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmaoutl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmcoff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf_linux_eabi.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelf_vxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelfb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelfb_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelfb_linux_eabi.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmelfb_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmnbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmnto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmpe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/earmsymbian.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr1.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr2.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr25.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr3.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr31.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr35.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr4.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr5.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr51.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr6.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecoff_i860.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecoff_sparc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecrisaout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecriself.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ecrislinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ed10velf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ed30v_e.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ed30v_o.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ed30velf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/edelta68.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_dlx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_i860.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_i960.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_sparc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_sparc_vxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32_spu.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32b4300.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32bfin.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32bfinfd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32bmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32bmipn32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32btsmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32btsmipn32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32cr16.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32cr16c.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32crx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ebmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ebmipvxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32elmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32elmipvxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32fr30.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32frv.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32frvfd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32i370.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ip2k.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32iq10.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32iq2000.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32l4300.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lm32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lm32fd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lppc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lppcnto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32lppcsim.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ltsmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ltsmipn32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32m32c.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mb_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mcore.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mep.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32microblaze.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mipswindiss.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32moxie.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mt.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32openrisc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppc_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppclinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppcnto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppcsim.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppcvxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppcwindiss.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32vax.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xc16x.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xc16xl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xc16xs.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xstormy16.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32xtensa.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_aix.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_ia64.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_ia64_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_s390.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_sparc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64_sparc_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64alpha.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64alpha_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64alpha_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64bmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64btsmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64hppa.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64lppc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ltsmip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64mmix.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf64ppc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386_be.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386_chaos.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386_ldso.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_i386_vxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_l1om.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_l1om_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_s390.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_x86_64.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf_x86_64_fbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/egld960.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/egld960coff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300h.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300helf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300hn.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300hnelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300s.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300self.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300sn.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300snelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300sx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300sxelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300sxn.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8300sxnelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8500.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8500b.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8500c.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8500m.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh8500s.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehp300bsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehp3hpux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehppa64linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehppaelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehppalinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehppanbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ehppaobsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386aout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386beos.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386bsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386coff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386go32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386lynx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386mach.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386moss.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386msdos.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386nto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386nw.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386pe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386pe_posix.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ei386pep.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elnk960.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em32relf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em32relf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em32rlelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em32rlelf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68hc11elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68hc11elfb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68hc12elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68hc12elfb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68k4knbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kaout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kaux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kcoff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kelfnbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68klinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68knbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em68kpsos.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/em88kbcs.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emaxqcoff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emcorepe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emipsbig.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emipsbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emipsidt.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emipsidtl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emipslit.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emipslnews.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emipspe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emmo.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x110.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x1101.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x1111.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x112.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x1121.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x1122.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x1132.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x122.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x1222.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x123.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x1232.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x133.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x1331.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x135.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x1351.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x147.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x148.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x149.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x155.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x156.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x157.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x1610.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x1611.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x1612.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x167.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x168.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x169.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x2101.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x2111.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x2121.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x2131.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x311.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x312.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x313.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x314.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x315.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x323.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x325.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x336.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x337.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x412.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x413.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x415.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x417.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x435.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x436.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x437.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x447.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x448.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430x449.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430xE423.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430xE425.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430xE427.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430xG437.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430xG438.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430xG439.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430xW423.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430xW425.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430xW427.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/enews.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ens32knbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eor32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eor32elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epc532macha.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epdp11.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epjelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epjlelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppclynx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppcmacos.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppcnw.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppcpe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eriscix.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/escore3_elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/escore7_elf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/esh.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf32_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf32_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf64.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf64_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf_nto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf_uclinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshelf_vxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshl.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf32_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf32_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf64.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf64_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf_nbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf_nto.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlelf_vxworks.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshlsymbian.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eshpe.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/esparcaout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/esparclinux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/esparcnbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/est2000.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/esun3.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/esun4.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic30aout.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic30coff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic3xcoff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic3xcoff_onchip.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic4xcoff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic54xcoff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/etic80coff.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evanilla.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evax.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evaxnbsd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/evsta.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ew65.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ez80.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ez8001.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ez8002.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldcref.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldctor.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldemul.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldexp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldfile.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldgram.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldlang.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldlex-wrapper.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldlex.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldmain.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldmisc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldver.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ldwrite.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lexsup.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mri.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pe-dll.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pep-dll.Po@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+.l.c:
+	$(am__skiplex) $(SHELL) $(YLWRAP) $< $(LEX_OUTPUT_ROOT).c $@ -- $(LEXCOMPILE)
+
+.y.c:
+	$(am__skipyacc) $(SHELL) $(YLWRAP) $< y.tab.c $@ y.tab.h $*.h y.output $*.output -- $(YACCCOMPILE)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool config.lt
+
+ld.info: ld.texinfo $(ld_TEXINFOS)
+	restore=: && backupdir="$(am__leading_dot)am$$$$" && \
+	rm -rf $$backupdir && mkdir $$backupdir && \
+	if ($(MAKEINFO) --version) >/dev/null 2>&1; then \
+	  for f in $@ $@-[0-9] $@-[0-9][0-9] $(@:.info=).i[0-9] $(@:.info=).i[0-9][0-9]; do \
+	    if test -f $$f; then mv $$f $$backupdir; restore=mv; else :; fi; \
+	  done; \
+	else :; fi && \
+	if $(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir) \
+	 -o $@ `test -f 'ld.texinfo' || echo '$(srcdir)/'`ld.texinfo; \
+	then \
+	  rc=0; \
+	else \
+	  rc=$$?; \
+	  $$restore $$backupdir/* `echo "./$@" | sed 's|[^/]*$$||'`; \
+	fi; \
+	rm -rf $$backupdir; exit $$rc
+
+ld.dvi: ld.texinfo $(ld_TEXINFOS) 
+	TEXINPUTS="$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS" \
+	MAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)' \
+	$(TEXI2DVI) -o $@ `test -f 'ld.texinfo' || echo '$(srcdir)/'`ld.texinfo
+
+ld.pdf: ld.texinfo $(ld_TEXINFOS) 
+	TEXINPUTS="$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS" \
+	MAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)' \
+	$(TEXI2PDF) -o $@ `test -f 'ld.texinfo' || echo '$(srcdir)/'`ld.texinfo
+
+ld.html: ld.texinfo $(ld_TEXINFOS) 
+	rm -rf $(@:.html=.htp)
+	if $(MAKEINFOHTML) $(AM_MAKEINFOHTMLFLAGS) $(MAKEINFOFLAGS) -I $(srcdir) \
+	 -o $(@:.html=.htp) `test -f 'ld.texinfo' || echo '$(srcdir)/'`ld.texinfo; \
+	then \
+	  rm -rf $@; \
+	  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \
+	    mv $(@:.html=) $@; else mv $(@:.html=.htp) $@; fi; \
+	else \
+	  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \
+	    rm -rf $(@:.html=); else rm -Rf $(@:.html=.htp) $@; fi; \
+	  exit 1; \
+	fi
+.dvi.ps:
+	TEXINPUTS="$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS" \
+	$(DVIPS) -o $@ $<
+
+uninstall-dvi-am:
+	@$(NORMAL_UNINSTALL)
+	@list='$(DVIS)'; test -n "$(dvidir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(dvidir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(dvidir)/$$f"; \
+	done
+
+uninstall-html-am:
+	@$(NORMAL_UNINSTALL)
+	@list='$(HTMLS)'; test -n "$(htmldir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " rm -rf '$(DESTDIR)$(htmldir)/$$f'"; \
+	  rm -rf "$(DESTDIR)$(htmldir)/$$f"; \
+	done
+
+uninstall-info-am:
+	@$(PRE_UNINSTALL)
+	@if test -d '$(DESTDIR)$(infodir)' && \
+	    (install-info --version && \
+	     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \
+	  list='$(INFO_DEPS)'; \
+	  for file in $$list; do \
+	    relfile=`echo "$$file" | sed 's|^.*/||'`; \
+	    echo " install-info --info-dir='$(DESTDIR)$(infodir)' --remove '$(DESTDIR)$(infodir)/$$relfile'"; \
+	    if install-info --info-dir="$(DESTDIR)$(infodir)" --remove "$(DESTDIR)$(infodir)/$$relfile"; \
+	    then :; else test ! -f "$(DESTDIR)$(infodir)/$$relfile" || exit 1; fi; \
+	  done; \
+	else :; fi
+	@$(NORMAL_UNINSTALL)
+	@list='$(INFO_DEPS)'; \
+	for file in $$list; do \
+	  relfile=`echo "$$file" | sed 's|^.*/||'`; \
+	  relfile_i=`echo "$$relfile" | sed 's|\.info$$||;s|$$|.i|'`; \
+	  (if test -d "$(DESTDIR)$(infodir)" && cd "$(DESTDIR)$(infodir)"; then \
+	     echo " cd '$(DESTDIR)$(infodir)' && rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]"; \
+	     rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]; \
+	   else :; fi); \
+	done
+
+uninstall-pdf-am:
+	@$(NORMAL_UNINSTALL)
+	@list='$(PDFS)'; test -n "$(pdfdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(pdfdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(pdfdir)/$$f"; \
+	done
+
+uninstall-ps-am:
+	@$(NORMAL_UNINSTALL)
+	@list='$(PSS)'; test -n "$(psdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(psdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(psdir)/$$f"; \
+	done
+
+dist-info: $(INFO_DEPS)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	list='$(INFO_DEPS)'; \
+	for base in $$list; do \
+	  case $$base in \
+	    $(srcdir)/*) base=`echo "$$base" | sed "s|^$$srcdirstrip/||"`;; \
+	  esac; \
+	  if test -f $$base; then d=.; else d=$(srcdir); fi; \
+	  base_i=`echo "$$base" | sed 's|\.info$$||;s|$$|.i|'`; \
+	  for file in $$d/$$base $$d/$$base-[0-9] $$d/$$base-[0-9][0-9] $$d/$$base_i[0-9] $$d/$$base_i[0-9][0-9]; do \
+	    if test -f $$file; then \
+	      relfile=`expr "$$file" : "$$d/\(.*\)"`; \
+	      test -f "$(distdir)/$$relfile" || \
+		cp -p $$file "$(distdir)/$$relfile"; \
+	    else :; fi; \
+	  done; \
+	done
+
+mostlyclean-aminfo:
+	-rm -rf ld.aux ld.cp ld.cps ld.fn ld.fns ld.ky ld.log ld.pg ld.pgs ld.tmp \
+	  ld.toc ld.tp ld.tps ld.vr ld.vrs
+
+clean-aminfo:
+	-test -z "ld.dvi ld.pdf ld.ps ld.html" \
+	|| rm -rf ld.dvi ld.pdf ld.ps ld.html
+
+maintainer-clean-aminfo:
+	@list='$(INFO_DEPS)'; for i in $$list; do \
+	  i_i=`echo "$$i" | sed 's|\.info$$||;s|$$|.i|'`; \
+	  echo " rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]"; \
+	  rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]; \
+	done
+install-man1: $(man_MANS)
+	@$(NORMAL_INSTALL)
+	test -z "$(man1dir)" || $(MKDIR_P) "$(DESTDIR)$(man1dir)"
+	@list=''; test -n "$(man1dir)" || exit 0; \
+	{ for i in $$list; do echo "$$i"; done; \
+	l2='$(man_MANS)'; for i in $$l2; do echo "$$i"; done | \
+	  sed -n '/\.1[a-z]*$$/p'; \
+	} | while read p; do \
+	  if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; echo "$$p"; \
+	done | \
+	sed -e 'n;s,.*/,,;p;h;s,.*\.,,;s,^[^1][0-9a-z]*$$,1,;x' \
+	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,' | \
+	sed 'N;N;s,\n, ,g' | { \
+	list=; while read file base inst; do \
+	  if test "$$base" = "$$inst"; then list="$$list $$file"; else \
+	    echo " $(INSTALL_DATA) '$$file' '$(DESTDIR)$(man1dir)/$$inst'"; \
+	    $(INSTALL_DATA) "$$file" "$(DESTDIR)$(man1dir)/$$inst" || exit $$?; \
+	  fi; \
+	done; \
+	for i in $$list; do echo "$$i"; done | $(am__base_list) | \
+	while read files; do \
+	  test -z "$$files" || { \
+	    echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(man1dir)'"; \
+	    $(INSTALL_DATA) $$files "$(DESTDIR)$(man1dir)" || exit $$?; }; \
+	done; }
+
+uninstall-man1:
+	@$(NORMAL_UNINSTALL)
+	@list=''; test -n "$(man1dir)" || exit 0; \
+	files=`{ for i in $$list; do echo "$$i"; done; \
+	l2='$(man_MANS)'; for i in $$l2; do echo "$$i"; done | \
+	  sed -n '/\.1[a-z]*$$/p'; \
+	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^1][0-9a-z]*$$,1,;x' \
+	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,'`; \
+	test -z "$$files" || { \
+	  echo " ( cd '$(DESTDIR)$(man1dir)' && rm -f" $$files ")"; \
+	  cd "$(DESTDIR)$(man1dir)" && rm -f $$files; }
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@fail= failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@fail= failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES) config.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS) config.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS) config.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+site.exp: Makefile
+	@echo 'Making a new site.exp file...'
+	@echo '## these variables are automatically generated by make ##' >site.tmp
+	@echo '# Do not edit here.  If you wish to override these values' >>site.tmp
+	@echo '# edit the last section' >>site.tmp
+	@echo 'set srcdir $(srcdir)' >>site.tmp
+	@echo "set objdir `pwd`" >>site.tmp
+	@echo 'set build_alias "$(build_alias)"' >>site.tmp
+	@echo 'set build_triplet $(build_triplet)' >>site.tmp
+	@echo 'set host_alias "$(host_alias)"' >>site.tmp
+	@echo 'set host_triplet $(host_triplet)' >>site.tmp
+	@echo 'set target_alias "$(target_alias)"' >>site.tmp
+	@echo 'set target_triplet $(target_triplet)' >>site.tmp
+	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
+	@test ! -f site.exp || \
+	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
+	@-rm -f site.bak
+	@test ! -f site.exp || mv site.exp site.bak
+	@mv site.tmp site.exp
+
+distclean-DEJAGNU:
+	-rm -f site.exp site.bak
+	-l='$(DEJATOOL)'; for tool in $$l; do \
+	  rm -f $$tool.sum $$tool.log; \
+	done
+check-am: all-am
+	$(MAKE) $(AM_MAKEFLAGS) check-DEJAGNU
+check: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) check-recursive
+all-am: Makefile $(INFO_DEPS) $(PROGRAMS) $(MANS) config.h
+installdirs: installdirs-recursive
+installdirs-am:
+	for dir in "$(DESTDIR)$(bindir)" "$(DESTDIR)$(infodir)" "$(DESTDIR)$(man1dir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+	-test -z "$(DISTCLEANFILES)" || rm -f $(DISTCLEANFILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+	-rm -f deffilep.c
+	-rm -f deffilep.h
+	-rm -f ldgram.c
+	-rm -f ldgram.h
+	-rm -f ldlex.c
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+clean: clean-recursive
+
+clean-am: clean-aminfo clean-binPROGRAMS clean-generic clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-DEJAGNU distclean-compile \
+	distclean-generic distclean-hdr distclean-libtool \
+	distclean-local distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am: $(DVIS)
+
+html: html-recursive
+
+html-am: $(HTMLS)
+
+info: info-recursive
+
+info-am: $(INFO_DEPS)
+
+install-data-am: install-data-local install-info-am install-man
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am: $(DVIS)
+	@$(NORMAL_INSTALL)
+	test -z "$(dvidir)" || $(MKDIR_P) "$(DESTDIR)$(dvidir)"
+	@list='$(DVIS)'; test -n "$(dvidir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(dvidir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(dvidir)" || exit $$?; \
+	done
+install-exec-am: install-binPROGRAMS install-exec-local
+
+install-html: install-html-recursive
+
+install-html-am: $(HTMLS)
+	@$(NORMAL_INSTALL)
+	test -z "$(htmldir)" || $(MKDIR_P) "$(DESTDIR)$(htmldir)"
+	@list='$(HTMLS)'; list2=; test -n "$(htmldir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p" || test -d "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  $(am__strip_dir) \
+	  if test -d "$$d$$p"; then \
+	    echo " $(MKDIR_P) '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(MKDIR_P) "$(DESTDIR)$(htmldir)/$$f" || exit 1; \
+	    echo " $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d$$p"/* "$(DESTDIR)$(htmldir)/$$f" || exit $$?; \
+	  else \
+	    list2="$$list2 $$d$$p"; \
+	  fi; \
+	done; \
+	test -z "$$list2" || { echo "$$list2" | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(htmldir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(htmldir)" || exit $$?; \
+	done; }
+install-info: install-info-recursive
+
+install-info-am: $(INFO_DEPS)
+	@$(NORMAL_INSTALL)
+	test -z "$(infodir)" || $(MKDIR_P) "$(DESTDIR)$(infodir)"
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	list='$(INFO_DEPS)'; test -n "$(infodir)" || list=; \
+	for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	  esac; \
+	  if test -f $$file; then d=.; else d=$(srcdir); fi; \
+	  file_i=`echo "$$file" | sed 's|\.info$$||;s|$$|.i|'`; \
+	  for ifile in $$d/$$file $$d/$$file-[0-9] $$d/$$file-[0-9][0-9] \
+	               $$d/$$file_i[0-9] $$d/$$file_i[0-9][0-9] ; do \
+	    if test -f $$ifile; then \
+	      echo "$$ifile"; \
+	    else : ; fi; \
+	  done; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(infodir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(infodir)" || exit $$?; done
+	@$(POST_INSTALL)
+	@if (install-info --version && \
+	     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \
+	  list='$(INFO_DEPS)'; test -n "$(infodir)" || list=; \
+	  for file in $$list; do \
+	    relfile=`echo "$$file" | sed 's|^.*/||'`; \
+	    echo " install-info --info-dir='$(DESTDIR)$(infodir)' '$(DESTDIR)$(infodir)/$$relfile'";\
+	    install-info --info-dir="$(DESTDIR)$(infodir)" "$(DESTDIR)$(infodir)/$$relfile" || :;\
+	  done; \
+	else : ; fi
+install-man: install-man1
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am: $(PDFS)
+	@$(NORMAL_INSTALL)
+	test -z "$(pdfdir)" || $(MKDIR_P) "$(DESTDIR)$(pdfdir)"
+	@list='$(PDFS)'; test -n "$(pdfdir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(pdfdir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(pdfdir)" || exit $$?; done
+install-ps: install-ps-recursive
+
+install-ps-am: $(PSS)
+	@$(NORMAL_INSTALL)
+	test -z "$(psdir)" || $(MKDIR_P) "$(DESTDIR)$(psdir)"
+	@list='$(PSS)'; test -n "$(psdir)" || list=; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(psdir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(psdir)" || exit $$?; done
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-aminfo \
+	maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-aminfo mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool mostlyclean-local
+
+pdf: pdf-recursive
+
+pdf-am: $(PDFS)
+
+ps: ps-recursive
+
+ps-am: $(PSS)
+
+uninstall-am: uninstall-binPROGRAMS uninstall-dvi-am uninstall-html-am \
+	uninstall-info-am uninstall-man uninstall-pdf-am \
+	uninstall-ps-am
+
+uninstall-man: uninstall-man1
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all check \
+	check-am ctags-recursive install install-am install-strip \
+	tags-recursive
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am am--refresh check check-DEJAGNU check-am clean \
+	clean-aminfo clean-binPROGRAMS clean-generic clean-libtool \
+	ctags ctags-recursive dist-info distclean distclean-DEJAGNU \
+	distclean-compile distclean-generic distclean-hdr \
+	distclean-libtool distclean-local distclean-tags dvi dvi-am \
+	html html-am info info-am install install-am \
+	install-binPROGRAMS install-data install-data-am \
+	install-data-local install-dvi install-dvi-am install-exec \
+	install-exec-am install-exec-local install-html \
+	install-html-am install-info install-info-am install-man \
+	install-man1 install-pdf install-pdf-am install-ps \
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs installdirs-am maintainer-clean \
+	maintainer-clean-aminfo maintainer-clean-generic mostlyclean \
+	mostlyclean-aminfo mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool mostlyclean-local pdf pdf-am ps ps-am tags \
+	tags-recursive uninstall uninstall-am uninstall-binPROGRAMS \
+	uninstall-dvi-am uninstall-html-am uninstall-info-am \
+	uninstall-man uninstall-man1 uninstall-pdf-am uninstall-ps-am
+
+
+# Disable -Werror, if it has been enabled, since old versions of bison/
+# yacc will produce working code which contain compile time warnings.
+ldgram.o: ldgram.c
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `test -f ldgram.c || echo $(srcdir)/`ldgram.c $(NO_WERROR)
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ldgram.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `test -f ldgram.c || echo $(srcdir)/`ldgram.c $(NO_WERROR)
+
+ldlex-wrapper.o: ldlex-wrapper.c ldlex.c
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $(srcdir)/ldlex-wrapper.c $(NO_WERROR)
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ldlex-wrapper.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $(srcdir)/ldlex-wrapper.c $(NO_WERROR)
+
+deffilep.o: deffilep.c
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `test -f deffilep.c || echo $(srcdir)/`deffilep.c $(NO_WERROR)
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='deffilep.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `test -f deffilep.c || echo $(srcdir)/`deffilep.c $(NO_WERROR)
+
+po/POTFILES.in: @MAINT@ Makefile
+	for f in $(POTFILES); do echo $$f; done | LC_ALL=C sort > tmp \
+	  && mv tmp $(srcdir)/po/POTFILES.in
+
+ldmain.o: ldmain.c config.status
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ \
+@am__fastdepCC_TRUE@	  -DDEFAULT_EMULATION='"$(EMUL)"' \
+@am__fastdepCC_TRUE@	  -DBINDIR='"$(bindir)"' -DTOOLBINDIR='"$(tooldir)/bin"' \
+@am__fastdepCC_TRUE@	  -DTARGET='"@target@"' @TARGET_SYSTEM_ROOT_DEFINE@ \
+@am__fastdepCC_TRUE@	  $(srcdir)/ldmain.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ldmain.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c -DDEFAULT_EMULATION='"$(EMUL)"' \
+@am__fastdepCC_FALSE@	  -DBINDIR='"$(bindir)"' -DTOOLBINDIR='"$(tooldir)/bin"' \
+@am__fastdepCC_FALSE@	  -DTARGET='"@target@"' @TARGET_SYSTEM_ROOT_DEFINE@ \
+@am__fastdepCC_FALSE@	  $(srcdir)/ldmain.c
+
+ldfile.o: ldfile.c config.status
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ \
+@am__fastdepCC_TRUE@	-DSCRIPTDIR='"$(scriptdir)"' -DBINDIR='"$(bindir)"' -DTOOLBINDIR='"$(tooldir)/bin"' \
+@am__fastdepCC_TRUE@	 $(srcdir)/ldfile.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='ldfile.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c -DSCRIPTDIR='"$(scriptdir)"' -DBINDIR='"$(bindir)"' \
+@am__fastdepCC_FALSE@	  -DTOOLBINDIR='"$(tooldir)/bin"' \
+@am__fastdepCC_FALSE@	  $(srcdir)/ldfile.c
+
+eelf32_spu.o: eelf32_spu.c
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ \
+@am__fastdepCC_TRUE@	  -DEMBEDSPU="\"`echo embedspu | sed '$(transform)'`\"" eelf32_spu.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='eelf32_spu.c' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c -DEMBEDSPU="\"`echo embedspu | sed '$(transform)'`\"" \
+@am__fastdepCC_FALSE@	  eelf32_spu.c
+
+ldemul-list.h: Makefile
+	(echo "/* This file is automatically generated.  DO NOT EDIT! */";\
+	for f in `echo " " ${EMULATION_OFILES} "" \
+	 | sed -e 's/ e/ ld/g' -e 's/ ld/ /g' -e 's/[.]o//g'`; do \
+	    echo "extern ld_emulation_xfer_type ld_$${f}_emulation;"; \
+	done;\
+	echo "";\
+	echo "#define EMULATION_LIST \\";\
+	for f in `echo " " ${EMULATION_OFILES} "" \
+	 | sed -e 's/ e/ ld/g' -e 's/ ld/ /g' -e 's/[.]o//g'`; do \
+	    echo "  &ld_$${f}_emulation, \\"; \
+	done;\
+	echo "  0") >ldemul-tmp.h
+	mv ldemul-tmp.h ldemul-list.h
+
+stringify.sed: ${srcdir}/emultempl/$(STRINGIFY)
+	  cp ${srcdir}/emultempl/$(STRINGIFY) stringify.sed
+
+@TDIRS@
+
+eaix5ppc.c: $(srcdir)/emulparams/aix5ppc.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} aix5ppc "$(tdir_aixppc)"
+eaix5rs6.c: $(srcdir)/emulparams/aix5rs6.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} aix5rs6 "$(tdir_aixrs6)"
+eaixppc.c: $(srcdir)/emulparams/aixppc.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} aixppc "$(tdir_aixppc)"
+eaixrs6.c: $(srcdir)/emulparams/aixrs6.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} aixrs6 "$(tdir_aixrs6)"
+ealpha.c: $(srcdir)/emulparams/alpha.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/alpha.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} alpha "$(tdir_alpha)"
+earcelf.c: $(srcdir)/emulparams/arcelf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} arcelf "$(tdir_arcelf)"
+earmelf.c: $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf "$(tdir_armelf)"
+earmelfb.c: $(srcdir)/emulparams/armelfb.sh $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelfb "$(tdir_armelfb)"
+earmelf_fbsd.c: $(srcdir)/emulparams/armelf_fbsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf_fbsd "$(tdir_armelf_fbsd)"
+earmelf_linux.c: $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf_linux "$(tdir_armelf_linux)"
+earmelf_linux_eabi.c: $(srcdir)/emulparams/armelf_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf_linux_eabi "$(tdir_armelf_linux_abi)"
+earmelfb_linux.c: $(srcdir)/emulparams/armelfb_linux.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelfb_linux "$(tdir_armelfb_linux)"
+earmelfb_linux_eabi.c: $(srcdir)/emulparams/armelfb_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux_eabi.sh \
+  $(srcdir)/emulparams/armelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelfb_linux_eabi "$(tdir_armelfb_linux_abi)"
+earmelf_nbsd.c: $(srcdir)/emulparams/armelf_nbsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf_nbsd "$(tdir_armelf_nbsd)"
+earmelfb_nbsd.c: $(srcdir)/emulparams/armelfb_nbsd.sh \
+  $(srcdir)/emulparams/armelf_nbsd.sh \
+  $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armelfb_nbsd "$(tdir_armelfb_nbsd)"
+earmelf_vxworks.c: $(srcdir)/emulparams/armelf_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(srcdir)/emulparams/armelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/vxworks.em \
+  $(srcdir)/emultempl/armelf.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} armelf_vxworks "$(tdir_armelf)"
+earmaoutb.c:	$(srcdir)/emulparams/armaoutb.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armaoutb "$(tdir_armaoutb)"
+earmaoutl.c:	$(srcdir)/emulparams/armaoutl.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/armaout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armaoutl "$(tdir_armaoutl)"
+earmcoff.c:	$(srcdir)/emulparams/armcoff.sh \
+  $(srcdir)/emultempl/armcoff.em $(srcdir)/scripttempl/armcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armcoff "$(tdir_armcoff)"
+earmnbsd.c:	$(srcdir)/emulparams/armnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armnbsd "$(tdir_armnbsd)"
+earmnto.c: $(srcdir)/emulparams/armnto.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/armelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armnto "$(tdir_armnto)"
+earm_epoc_pe.c: $(srcdir)/emulparams/arm_epoc_pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/epocpe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} arm_epoc_pe "$(tdir_armpe)"
+earm_wince_pe.c: $(srcdir)/emulparams/arm_wince_pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} arm_wince_pe "$(tdir_armpe)"
+earmpe.c: $(srcdir)/emulparams/armpe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} armpe "$(tdir_armpe)"
+earmsymbian.c: $(srcdir)/emulparams/armsymbian.sh \
+  $(srcdir)/emulparams/armelf.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/armelf.em $(srcdir)/scripttempl/armbpabi.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} armsymbian "$(tdir_armelf)"
+eavr2.c: $(srcdir)/emulparams/avr2.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr2 "$(tdir_avr2)"
+eavr1.c: $(srcdir)/emulparams/avr1.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr1 "$(tdir_avr2)"
+eavr25.c: $(srcdir)/emulparams/avr25.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr25 "$(tdir_avr2)"
+eavr3.c: $(srcdir)/emulparams/avr3.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr3 "$(tdir_avr2)"
+eavr31.c: $(srcdir)/emulparams/avr31.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr31 "$(tdir_avr2)"
+eavr35.c: $(srcdir)/emulparams/avr35.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr35 "$(tdir_avr2)"
+eavr4.c: $(srcdir)/emulparams/avr4.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr4 "$(tdir_avr2)"
+eavr5.c: $(srcdir)/emulparams/avr5.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr5 "$(tdir_avr2)"
+eavr51.c: $(srcdir)/emulparams/avr51.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr51 "$(tdir_avr2)"
+eavr6.c: $(srcdir)/emulparams/avr6.sh $(srcdir)/emultempl/avrelf.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr6 "$(tdir_avr2)"
+ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} coff_i860 "$(tdir_coff_i860)"
+ecoff_sparc.c: $(srcdir)/emulparams/coff_sparc.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/sparccoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} coff_sparc "$(tdir_coff_sparc)"
+ecrisaout.c: $(srcdir)/emulparams/crisaout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/crisaout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} crisaout "$(tdir_cris)"
+ecriself.c: $(srcdir)/emulparams/criself.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} criself "$(tdir_cris)"
+ecrislinux.c: $(srcdir)/emulparams/crislinux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} crislinux "$(tdir_cris)"
+ed10velf.c: $(srcdir)/emulparams/d10velf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfd10v.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} d10velf "$(tdir_d10v)"
+ed30velf.c: $(srcdir)/emulparams/d30velf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elfd30v.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} d30velf "$(tdir_d30v)"
+ed30v_o.c: $(srcdir)/emulparams/d30v_o.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elfd30v.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} d30v_o "$(tdir_d30v)"
+ed30v_e.c: $(srcdir)/emulparams/d30v_e.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elfd30v.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} d30v_e "$(tdir_d30v)"
+edelta68.c: $(srcdir)/emulparams/delta68.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/delta68.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} delta68 "$(tdir_delta68)"
+eelf32bfin.c: $(srcdir)/emulparams/bfin.sh \
+  $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32bfin "$(tdir_elf32bfin)" bfin
+eelf32bfinfd.c: $(srcdir)/emulparams/elf32bfinfd.sh $(srcdir)/emulparams/bfin.sh \
+  $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32bfinfd "$(tdir_elf32bfinfd)" elf32bfinfd
+eelf32_dlx.c: $(srcdir)/emulparams/elf32_dlx.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/dlx.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_dlx "$(tdir_elf32_dlx)"
+eelf32xc16x.c: $(srcdir)/emulparams/elf32xc16x.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32xc16x "$(tdir_xc16x)"
+eelf32xc16xl.c: $(srcdir)/emulparams/elf32xc16xl.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32xc16xl "$(tdir_xc16xl)"
+eelf32xc16xs.c: $(srcdir)/emulparams/elf32xc16xs.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32xc16xs "$(tdir_xc16xs)"
+eelf32xstormy16.c: $(srcdir)/emulparams/elf32xstormy16.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/xstormy16.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32xstormy16 "$(tdir_xstormy16)"
+eelf32am33lin.c: $(srcdir)/emulparams/elf32am33lin.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32am33lin "$(tdir_mn10300)"
+eelf32vax.c: $(srcdir)/emulparams/elf32vax.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32vax "$(tdir_elf32vax)"
+eelf32xtensa.c: $(srcdir)/emulparams/elf32xtensa.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/xtensaelf.em $(INCDIR)/xtensa-config.h \
+  $(BFDDIR)/elf-bfd.h $(BFDDIR)/libbfd.h $(INCDIR)/elf/xtensa.h \
+  $(srcdir)/scripttempl/elfxtensa.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32xtensa "$(tdir_elf32xtensa)"
+eelf32fr30.c: $(srcdir)/emulparams/elf32fr30.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32fr30 "$(tdir_fr30)"
+eelf32frv.c: $(srcdir)/emulparams/elf32frv.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32frv "$(tdir_frv)"
+eelf32frvfd.c: $(srcdir)/emulparams/elf32frvfd.sh \
+  $(srcdir)/emulparams/elf32frv.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32frvfd "$(tdir_frv)"
+eelf32moxie.c: $(srcdir)/emulparams/elf32moxie.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32moxie "$(tdir_moxie)"
+eelf32mcore.c: $(srcdir)/emulparams/elf32mcore.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32mcore "$(tdir_mcore)"
+eelf32mep.c: $(srcdir)/emulparams/elf32mep.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/mep.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32mep "$(tdir_mep)"
+em32relf.c: $(srcdir)/emulparams/m32relf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m32relf "$(tdir_m32r)"
+em32rlelf.c: $(srcdir)/emulparams/m32rlelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m32rlelf "$(tdir_m32rlelf)"
+em32relf_linux.c: $(srcdir)/emulparams/m32relf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m32relf_linux "$(tdir_m32relf_linux)"
+em32rlelf_linux.c: $(srcdir)/emulparams/m32rlelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m32rlelf_linux "$(tdir_m32rlelf_linux)"
+eelf32_sparc.c: $(srcdir)/emulparams/elf32_sparc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_sparc "$(tdir_elf32_sparc)"
+eelf32_sparc_vxworks.c: $(srcdir)/emulparams/elf32_sparc_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(srcdir)/emulparams/elf32_sparc.sh \
+  $(srcdir)/emultempl/vxworks.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_sparc_vxworks "$(tdir_elf32_sparc_vxworks)"
+eelf32_spu.c: $(srcdir)/emulparams/elf32_spu.sh $(srcdir)/emultempl/spuelf.em \
+  $(srcdir)/emultempl/spu_ovl.o_c $(srcdir)/emultempl/spu_icache.o_c \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_spu "$(tdir_elf32_spu)"
+$(srcdir)/emultempl/spu_ovl.o_c: @MAINT@ $(srcdir)/emultempl/spu_ovl.S
+	if ../gas/as-new --version \
+		| grep 'target.*spu' >/dev/null 2>/dev/null; then \
+	  cpp -DOVLY_IRQ_SAVE $(srcdir)/emultempl/spu_ovl.S spu_ovl.s; \
+	  ../gas/as-new -o spu_ovl.o spu_ovl.s; \
+	  ../binutils/bin2c <spu_ovl.o >$@; \
+	fi
+$(srcdir)/emultempl/spu_icache.o_c: @MAINT@ $(srcdir)/emultempl/spu_icache.S
+	if ../gas/as-new --version \
+		| grep 'target.*spu' >/dev/null 2>/dev/null; then \
+	  cpp -DOVLY_IRQ_SAVE $(srcdir)/emultempl/spu_icache.S spu_icache.s; \
+	  ../gas/as-new -o spu_icache.o spu_icache.s; \
+	  ../binutils/bin2c <spu_icache.o >$@; \
+	fi
+eelf32_i860.c: $(srcdir)/emulparams/elf32_i860.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_i860 "$(tdir_elf32_i860)"
+eelf32_i960.c: $(srcdir)/emulparams/elf32_i960.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32_i960 "$(tdir_elf32_i960)"
+eelf32b4300.c: $(srcdir)/emulparams/elf32b4300.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32b4300 "$(tdir_elf32b4300)"
+eelf32cr16.c: $(srcdir)/emulparams/elf32cr16.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/emultempl/cr16elf.em \
+  $(srcdir)/scripttempl/elf32cr16.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32cr16 "$(tdir_elf32crx)"
+eelf32cr16c.c: $(srcdir)/emulparams/elf32cr16c.sh \
+  $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf32cr16c.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32cr16c "$(tdir_elf32cr16c)"
+eelf32bmip.c: $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32bmip "$(tdir_elf32bmip)"
+eelf32bsmip.c: $(srcdir)/emulparams/elf32bsmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) $(srcdir)/emultempl/irix.em \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32bsmip "$(tdir_elf32bsmip)"
+eelf32btsmip.c: $(srcdir)/emulparams/elf32btsmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32btsmip "$(tdir_elf32btsmip)"
+eelf32crx.c: $(srcdir)/emulparams/elf32crx.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/crxelf.em \
+  $(srcdir)/scripttempl/elf32crx.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32crx "$(tdir_elf32crx)"
+eelf32btsmipn32.c: $(srcdir)/emulparams/elf32btsmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32btsmipn32 "$(tdir_elf32btsmipn32)"
+eelf32ltsmip.c: $(srcdir)/emulparams/elf32ltsmip.sh \
+  $(srcdir)/emulparams/elf32btsmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ltsmip "$(tdir_elf32ltsmip)"
+eelf32ltsmipn32.c: $(srcdir)/emulparams/elf32ltsmipn32.sh \
+  $(srcdir)/emulparams/elf32btsmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ltsmipn32 "$(tdir_elf32ltsmipn32)"
+eelf32ebmip.c: $(srcdir)/emulparams/elf32ebmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ebmip "$(tdir_elf32ebmip)"
+eelf32ebmipvxworks.c: $(srcdir)/emulparams/elf32ebmipvxworks.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(srcdir)/emulparams/vxworks.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/emultempl/vxworks.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ebmipvxworks "$(tdir_elf32ebmipvxworks)"
+eelf32elmip.c: $(srcdir)/emulparams/elf32elmip.sh \
+  $(srcdir)/emulparams/elf32lmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32elmip "$(tdir_elf32elmip)"
+eelf32elmipvxworks.c: $(srcdir)/emulparams/elf32elmipvxworks.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(srcdir)/emulparams/vxworks.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/emultempl/vxworks.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32elmipvxworks "$(tdir_elf32elmipvxworks)"
+eelf32bmipn32.c: $(srcdir)/emulparams/elf32bmipn32.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/irix.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32bmipn32 "$(tdir_elf32bmipn32)"
+eelf32l4300.c: $(srcdir)/emulparams/elf32l4300.sh \
+  $(srcdir)/emulparams/elf32b4300.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32l4300 "$(tdir_elf32l4300)"
+eelf32lmip.c: $(srcdir)/emulparams/elf32lmip.sh \
+  $(srcdir)/emulparams/elf32bmip.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lmip "$(tdir_elf32lmip)"
+eelf32mb_linux.c: $(srcdir)/emulparams/elf32mb_linux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32mb_linux "$(tdir_microblaze)"
+ eelf32microblaze.c: $(srcdir)/emulparams/elf32microblaze.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elfmicroblaze.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32microblaze "$(tdir_microblaze)"
+eelf32mipswindiss.c: $(srcdir)/emulparams/elf32mipswindiss.sh $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32mipswindiss "$(tdir_elf32mipswindiss)"
+eelf32m32c.c: $(srcdir)/emulparams/elf32m32c.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32m32c "$(tdir_m32c)"
+eelf32mt.c: $(srcdir)/emulparams/elf32mt.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32mt "$(tdir_mt)"
+eelf32lppc.c: $(srcdir)/emulparams/elf32lppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emultempl/ppc32elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lppc "$(tdir_elf32lppc)"
+eelf32lppcnto.c: $(srcdir)/emulparams/elf32lppcnto.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em $(ELF_DEPS) \
+  ldemul-list.h \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lppcnto "$(tdir_elf32lppcnto)"
+eelf32lppcsim.c: $(srcdir)/emulparams/elf32lppcsim.sh \
+  $(srcdir)/emulparams/elf32lppc.sh $(srcdir)/emulparams/elf32ppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh $(srcdir)/emultempl/ppc32elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lppcsim "$(tdir_elf32lppcsim)"
+eelf32ppcnto.c: $(srcdir)/emulparams/elf32ppcnto.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em $(ELF_DEPS) \
+  ldemul-list.h \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppcnto "$(tdir_elf32ppcnto)"
+eelf32ppcwindiss.c: $(srcdir)/emulparams/elf32ppcwindiss.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppcwindiss "$(tdir_elf32ppcwindiss)"
+eelf32ppcvxworks.c: $(srcdir)/emulparams/elf32ppcvxworks.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh $(srcdir)/emulparams/vxworks.sh \
+  $(srcdir)/emultempl/vxworks.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppcvxworks "$(tdir_elf32ppcvxworks)"
+eelf32lsmip.c: $(srcdir)/emulparams/elf32lsmip.sh \
+  $(srcdir)/emulparams/elf32lmip.sh $(srcdir)/emulparams/elf32bmip.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lsmip "$(tdir_elf32lsmip)"
+eelf32openrisc.c: $(srcdir)/emulparams/elf32openrisc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32openrisc "$(tdir_openrisc)"
+eelf32ppc.c: $(srcdir)/emulparams/elf32ppc.sh \
+  $(srcdir)/emulparams/elf32ppccommon.sh $(srcdir)/emultempl/ppc32elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppc "$(tdir_elf32ppc)"
+eelf32ppc_fbsd.c: $(srcdir)/emulparams/elf32ppc_fbsd.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em $(ELF_DEPS) \
+  ldemul-list.h \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppc_fbsd "$(tdir_elf32ppc_fbsd)"
+eelf32ppcsim.c: $(srcdir)/emulparams/elf32ppcsim.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em $(ELF_DEPS) \
+  ldemul-list.h \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppcsim "$(tdir_elf32ppcsim)"
+eelf32ppclinux.c: $(srcdir)/emulparams/elf32ppclinux.sh \
+  $(srcdir)/emulparams/elf32ppc.sh $(srcdir)/emulparams/elf32ppccommon.sh \
+  $(srcdir)/emultempl/ppc32elf.em $(ELF_DEPS) \
+  ldemul-list.h \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ppclinux "$(tdir_elf32ppclinux)"
+eelf64ppc.c: $(srcdir)/emulparams/elf64ppc.sh $(srcdir)/emultempl/ppc64elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64ppc "$(tdir_elf64ppc)"
+eelf64lppc.c: $(srcdir)/emulparams/elf64lppc.sh \
+  $(srcdir)/emulparams/elf64ppc.sh $(srcdir)/emultempl/ppc64elf.em \
+  ldemul-list.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64lppc "$(tdir_elf64lppc)"
+eelf32i370.c: $(srcdir)/emulparams/elf32i370.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elfi370.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32i370 "$(tdir_elf32i370)"
+eelf32ip2k.c: $(srcdir)/emulparams/elf32ip2k.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32ip2k "$(tdir_ip2k)"
+eelf32iq2000.c: $(srcdir)/emulparams/elf32iq2000.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/iq2000.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32iq2000 "$(tdir_iq2000)"
+eelf32iq10.c: $(srcdir)/emulparams/elf32iq10.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/iq2000.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32iq10 "$(tdir_iq10)"
+eelf32lm32.c: $(srcdir)/emulparams/elf32lm32.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32lm32 "$(tdir_elf32lm32)"
+eelf32lm32fd.c: $(srcdir)/emulparams/elf32lm32fd.sh \
+  $(srcdir)/emulparams/elf32lm32.sh $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS} 
+	${GENSCRIPTS} elf32lm32fd "$(tdir_elf32lm32fd)" 
+eelf64alpha.c: $(srcdir)/emulparams/elf64alpha.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64alpha "$(tdir_elf64alpha)"
+eelf64alpha_fbsd.c: $(srcdir)/emulparams/elf64alpha_fbsd.sh \
+  $(srcdir)/emulparams/elf64alpha.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64alpha_fbsd "$(tdir_elf64alpha_fbsd)"
+eelf64alpha_nbsd.c: $(srcdir)/emulparams/elf64alpha_nbsd.sh \
+  $(srcdir)/emulparams/elf64alpha.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/alphaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64alpha_nbsd "$(tdir_elf64alpha_nbsd)"
+eelf64hppa.c: $(srcdir)/emulparams/elf64hppa.sh \
+  $(srcdir)/emulparams/hppa64linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64hppa "$(tdir_elf64hppa)"
+eelf64_aix.c: $(srcdir)/emulparams/elf64_aix.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_aix "$(tdir_elf64_aix)"
+eelf64_ia64.c: $(srcdir)/emulparams/elf64_ia64.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/ia64elf.em \
+  $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_ia64 "$(tdir_elf64_ia64)"
+eelf64_ia64_fbsd.c: $(srcdir)/emulparams/elf64_ia64_fbsd.sh \
+  $(srcdir)/emulparams/elf64_ia64.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/ia64elf.em \
+  $(srcdir)/emultempl/needrelax.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_ia64_fbsd "$(tdir_elf64_ia64_fbsd)"
+eelf64_s390.c: $(srcdir)/emulparams/elf64_s390.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_s390 "$(tdir_elf64_s390)"
+eelf64_sparc.c: $(srcdir)/emulparams/elf64_sparc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_sparc "$(tdir_elf64_sparc)"
+eelf64_sparc_fbsd.c: $(srcdir)/emulparams/elf64_sparc_fbsd.sh \
+  $(srcdir)/emulparams/elf64_sparc.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64_sparc_fbsd "$(tdir_elf64_sparc_fbsd)"
+eelf64bmip.c: $(srcdir)/emulparams/elf64bmip.sh \
+  $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/irix.em $(srcdir)/emultempl/mipself.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64bmip "$(tdir_elf64bmip)"
+eelf64mmix.c: $(srcdir)/emulparams/elf64mmix.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/mmix-elfnmmo.em \
+  $(srcdir)/emultempl/mmixelf.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64mmix "$(tdir_elf64mmix)"
+emmo.c: $(srcdir)/emulparams/mmo.sh $(srcdir)/emultempl/mmix-elfnmmo.em \
+  $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/elf-generic.em \
+  $(srcdir)/emultempl/mmo.em \
+  $(srcdir)/scripttempl/mmo.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mmo "$(tdir_mmo)"
+eelf64btsmip.c: $(srcdir)/emulparams/elf64btsmip.sh \
+  $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64btsmip "$(tdir_elf64btsmip)"
+eelf64ltsmip.c: $(srcdir)/emulparams/elf64ltsmip.sh \
+  $(srcdir)/emulparams/elf64btsmip.sh $(srcdir)/emulparams/elf64bmip-defs.sh \
+  $(srcdir)/emulparams/elf32bmipn32-defs.sh $(ELF_DEPS) \
+  $(srcdir)/emultempl/mipself.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf64ltsmip "$(tdir_elf64ltsmip)"
+eelf_i386.c: $(srcdir)/emulparams/elf_i386.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386 "$(tdir_elf_i386)"
+eelf_x86_64.c: $(srcdir)/emulparams/elf_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_x86_64 "$(tdir_elf_x86_64)"
+eelf_x86_64_fbsd.c: $(srcdir)/emulparams/elf_x86_64_fbsd.sh \
+  $(srcdir)/emulparams/elf_x86_64.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_x86_64_fbsd "$(tdir_elf_x86_64_fbsd)"
+eelf_l1om.c: $(srcdir)/emulparams/elf_l1om.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_l1om "$(tdir_elf_l1om)"
+eelf_l1om_fbsd.c: $(srcdir)/emulparams/elf_l1om_fbsd.sh \
+  $(srcdir)/emulparams/elf_l1om.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_l1om_fbsd "$(tdir_elf_l1om_fbsd)"
+eelf_i386_be.c: $(srcdir)/emulparams/elf_i386_be.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386_be "$(tdir_elf_i386_be)"
+eelf_i386_chaos.c: $(srcdir)/emulparams/elf_i386_chaos.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf_chaos.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386_chaos "$(tdir_elf_i386_chaos)"
+eelf_i386_fbsd.c: $(srcdir)/emulparams/elf_i386_fbsd.sh \
+  $(srcdir)/emulparams/elf_i386.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386_fbsd "$(tdir_elf_i386_fbsd)"
+eelf_i386_ldso.c: $(srcdir)/emulparams/elf_i386_ldso.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386_ldso "$(tdir_elf_i386_ldso)"
+eelf_i386_vxworks.c: $(srcdir)/emulparams/elf_i386_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(srcdir)/emultempl/vxworks.em \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_i386_vxworks "$(tdir_elf_i386_vxworks)"
+eelf_s390.c: $(srcdir)/emulparams/elf_s390.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_s390 "$(tdir_elf_s390)"
+egld960.c: $(srcdir)/emulparams/gld960.sh \
+  $(srcdir)/emultempl/gld960.em $(srcdir)/scripttempl/i960.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} gld960 "$(tdir_gld960)"
+egld960coff.c: $(srcdir)/emulparams/gld960coff.sh \
+  $(srcdir)/emultempl/gld960c.em $(srcdir)/scripttempl/i960.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} gld960coff "$(tdir_gld960coff)"
+eh8300.c: $(srcdir)/emulparams/h8300.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300 "$(tdir_h8300)"
+eh8300h.c: $(srcdir)/emulparams/h8300h.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300h.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300h "$(tdir_h8300h)"
+eh8300s.c: $(srcdir)/emulparams/h8300s.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300s.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300s "$(tdir_h8300s)"
+eh8300hn.c: $(srcdir)/emulparams/h8300hn.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300hn.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300hn "$(tdir_h8300hn)"
+eh8300sn.c: $(srcdir)/emulparams/h8300sn.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300sn.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300sn "$(tdir_h8300sn)"
+eh8300sx.c: $(srcdir)/emulparams/h8300sx.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300sx.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300sx "$(tdir_h8300sx)"
+eh8300sxn.c: $(srcdir)/emulparams/h8300sxn.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8300sxn.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300sxn "$(tdir_h8300sxn)"
+eh8300elf.c: $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300elf "$(tdir_h8300elf)"
+eh8300helf.c: $(srcdir)/emulparams/h8300helf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300helf "$(tdir_h8300helf)"
+eh8300self.c: $(srcdir)/emulparams/h8300self.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300self "$(tdir_h8300self)"
+eh8300hnelf.c: $(srcdir)/emulparams/h8300hnelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300hnelf "$(tdir_h8300hnelf)"
+eh8300snelf.c: $(srcdir)/emulparams/h8300snelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300snelf "$(tdir_h8300snelf)"
+eh8300sxelf.c: $(srcdir)/emulparams/h8300sxelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300sxelf "$(tdir_h8300sxelf)"
+eh8300sxnelf.c: $(srcdir)/emulparams/h8300sxnelf.sh \
+  $(srcdir)/emulparams/h8300elf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8300sxnelf "$(tdir_h8300sxnelf)"
+eh8500.c: $(srcdir)/emulparams/h8500.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8500 "$(tdir_h8500)"
+eh8500b.c: $(srcdir)/emulparams/h8500b.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500b.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8500b "$(tdir_h8500b)"
+eh8500c.c: $(srcdir)/emulparams/h8500c.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500c.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8500c "$(tdir_h8500c)"
+eh8500m.c: $(srcdir)/emulparams/h8500m.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500m.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8500m "$(tdir_h8500m)"
+eh8500s.c: $(srcdir)/emulparams/h8500s.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/h8500s.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} h8500s "$(tdir_h8500s)"
+ehp300bsd.c: $(srcdir)/emulparams/hp300bsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hp300bsd "$(tdir_hp300bsd)"
+ehp3hpux.c: $(srcdir)/emulparams/hp3hpux.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hp3hpux "$(tdir_hp3hpux)"
+ehppaelf.c: $(srcdir)/emulparams/hppaelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/hppaelf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hppaelf "$(tdir_hppaelf)"
+ehppalinux.c: $(srcdir)/emulparams/hppalinux.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hppalinux "$(tdir_hppalinux)"
+ehppanbsd.c: $(srcdir)/emulparams/hppanbsd.sh \
+  $(srcdir)/emulparams/hppaelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hppanbsd "$(tdir_hppanbsd)"
+ehppaobsd.c: $(srcdir)/emulparams/hppaobsd.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/hppaelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hppaobsd "$(tdir_hppaobsd)"
+ehppa64linux.c: $(srcdir)/emulparams/hppa64linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} hppa64linux "$(tdir_hppa64linux)"
+ei386aout.c: $(srcdir)/emulparams/i386aout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386aout "$(tdir_i386aout)"
+ei386beos.c: $(srcdir)/emulparams/i386beos.sh \
+  $(srcdir)/emultempl/beos.em $(srcdir)/scripttempl/i386beos.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386beos "$(tdir_i386beos)"
+ei386bsd.c: $(srcdir)/emulparams/i386bsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386bsd "$(tdir_i386bsd)"
+ei386coff.c: $(srcdir)/emulparams/i386coff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386coff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386coff "$(tdir_i386coff)"
+ei386go32.c: $(srcdir)/emulparams/i386go32.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386go32.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386go32 "$(tdir_i386go32)"
+ei386linux.c: $(srcdir)/emulparams/i386linux.sh \
+  $(srcdir)/emultempl/linux.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386linux "$(tdir_i386linux)"
+ei386lynx.c: $(srcdir)/emulparams/i386lynx.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386lynx "$(tdir_i386lynx)"
+ei386mach.c: $(srcdir)/emulparams/i386mach.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386mach "$(tdir_i386mach)"
+ei386moss.c: $(srcdir)/emulparams/i386moss.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386moss "$(tdir_i386moss)"
+ei386msdos.c: $(srcdir)/emulparams/i386msdos.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i386msdos.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386msdos "$(tdir_i386msdos)"
+ei386nbsd.c:	$(srcdir)/emulparams/i386nbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386nbsd "$(tdir_i386nbsd)"
+ei386nto.c:	$(srcdir)/emulparams/i386nto.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386nto "$(tdir_i386nto)"
+ei386nw.c:	$(srcdir)/emulparams/i386nw.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/nw.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386nw "$(tdir_i386nw)"
+ei386pe.c: $(srcdir)/emulparams/i386pe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386pe "$(tdir_i386pe)"
+ei386pe_posix.c: $(srcdir)/emulparams/i386pe_posix.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386pe_posix "$(tdir_i386pe_posix)"
+ei386pep.c: $(srcdir)/emulparams/i386pep.sh \
+  $(srcdir)/emultempl/pep.em $(srcdir)/scripttempl/pep.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} i386pep "$(tdir_i386pe)"
+elnk960.c: $(srcdir)/emulparams/lnk960.sh \
+  $(srcdir)/emultempl/lnk960.em $(srcdir)/scripttempl/i960.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} lnk960 "$(tdir_lnk960)"
+em68hc11elf.c: $(srcdir)/emulparams/m68hc11elf.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc11.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68hc11elf "$(tdir_m68hc11)"
+em68hc11elfb.c: $(srcdir)/emulparams/m68hc11elfb.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc11.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68hc11elfb "$(tdir_m68hc11b)"
+em68hc12elf.c: $(srcdir)/emulparams/m68hc12elf.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc12.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68hc12elf "$(tdir_m68hc12)"
+em68hc12elfb.c: $(srcdir)/emulparams/m68hc12elfb.sh \
+  $(srcdir)/emultempl/m68hc1xelf.em $(ELF_DEPS) \
+  $(srcdir)/scripttempl/elfm68hc12.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68hc12elfb "$(tdir_m68hc12b)"
+em68k4knbsd.c:	$(srcdir)/emulparams/m68k4knbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68k4knbsd "$(tdir_m68k4knbsd)"
+em68kaout.c: $(srcdir)/emulparams/m68kaout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kaout "$(tdir_m68kaout)"
+em68kaux.c: $(srcdir)/emulparams/m68kaux.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/m68kaux.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kaux "$(tdir_m68kaux)"
+em68kcoff.c: $(srcdir)/emulparams/m68kcoff.sh \
+  $(srcdir)/emultempl/m68kcoff.em $(srcdir)/scripttempl/m68kcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kcoff "$(tdir_m68kcoff)"
+em68kelf.c: $(srcdir)/emulparams/m68kelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/m68kelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kelf "$(tdir_m68kelf)"
+em68kelfnbsd.c: $(srcdir)/emulparams/m68kelfnbsd.sh \
+  $(srcdir)/emulparams/m68kelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/m68kelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kelfnbsd "$(tdir_m68kelfnbsd)"
+em68klinux.c: $(srcdir)/emulparams/m68klinux.sh \
+  $(srcdir)/emultempl/linux.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68klinux "$(tdir_m68klinux)"
+em68knbsd.c:	$(srcdir)/emulparams/m68knbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68knbsd "$(tdir_m68knbsd)"
+em68kpsos.c:	$(srcdir)/emulparams/m68kpsos.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/psos.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m68kpsos "$(tdir_m68kpsos)"
+em88kbcs.c: $(srcdir)/emulparams/m88kbcs.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/m88kbcs.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} m88kbcs "$(tdir_m88kbcs)"
+emaxqcoff.c: $(srcdir)/emulparams/maxqcoff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/maxqcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} maxqcoff "$(tdir_maxqcoff)"
+emcorepe.c: $(srcdir)/emulparams/mcorepe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mcorepe "$(tdir_mcorepe)"
+emipsbig.c: $(srcdir)/emulparams/mipsbig.sh $(srcdir)/emultempl/generic.em \
+  $(srcdir)/scripttempl/mips.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mipsbig "$(tdir_mipsbig)"
+emipsbsd.c: $(srcdir)/emulparams/mipsbsd.sh $(srcdir)/emultempl/generic.em \
+  $(srcdir)/scripttempl/mipsbsd.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mipsbsd "$(tdir_mipsbsd)"
+emipsidt.c: $(srcdir)/emulparams/mipsidt.sh $(srcdir)/emultempl/generic.em \
+  $(srcdir)/emultempl/mipsecoff.em $(srcdir)/scripttempl/mips.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} mipsidt "$(tdir_mipsidt)"
+emipsidtl.c: $(srcdir)/emulparams/mipsidtl.sh $(srcdir)/emultempl/generic.em \
+  $(srcdir)/emultempl/mipsecoff.em $(srcdir)/scripttempl/mips.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} mipsidtl "$(tdir_mipsidtl)"
+emipslit.c: $(srcdir)/emulparams/mipslit.sh $(srcdir)/emultempl/generic.em \
+  $(srcdir)/scripttempl/mips.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mipslit "$(tdir_mipslit)"
+emipslnews.c: $(srcdir)/emulparams/mipslnews.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/mips.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mipslnews "$(tdir_mipslnews)"
+emipspe.c: $(srcdir)/emulparams/mipspe.sh $(srcdir)/emultempl/pe.em \
+  $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mipspe "$(tdir_mipspe)"
+emn10300.c: $(srcdir)/emulparams/mn10300.sh \
+  $(srcdir)/emulparams/mn10200.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mn10300 "$(tdir_mn10300)"
+emn10200.c: $(srcdir)/emulparams/mn10200.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} mn10200 "$(tdir_mn10200)"
+emsp430x110.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x110 "$(tdir_msp430x110)" msp430all
+emsp430x112.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x112 "$(tdir_msp430x112)" msp430all
+emsp430x1101.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1101 "$(tdir_msp430x1101)" msp430all
+emsp430x1111.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1111 "$(tdir_msp430x1111)" msp430all
+emsp430x1121.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1121 "$(tdir_msp430x1121)" msp430all
+emsp430x1122.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1122 "$(tdir_msp430x1122)" msp430all
+emsp430x1132.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1132 "$(tdir_msp430x1132)" msp430all
+emsp430x122.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x122 "$(tdir_msp430x122)" msp430all
+emsp430x123.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x123 "$(tdir_msp430x123)" msp430all
+emsp430x1222.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1222 "$(tdir_msp430x1222)" msp430all
+emsp430x1232.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1232 "$(tdir_msp430x1232)" msp430all
+emsp430x133.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x133 "$(tdir_msp430x133)" msp430all
+emsp430x135.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x135 "$(tdir_msp430x135)" msp430all
+emsp430x1331.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1331 "$(tdir_msp430x1331)" msp430all
+emsp430x1351.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1351 "$(tdir_msp430x1351)" msp430all
+emsp430x147.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x147 "$(tdir_msp430x147)" msp430all
+emsp430x148.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x148 "$(tdir_msp430x148)" msp430all
+emsp430x149.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x149 "$(tdir_msp430x149)" msp430all
+emsp430x155.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x155 "$(tdir_msp430x155)" msp430all
+emsp430x156.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x156 "$(tdir_msp430x156)" msp430all
+emsp430x157.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x157 "$(tdir_msp430x157)" msp430all
+emsp430x167.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x167 "$(tdir_msp430x167)" msp430all
+emsp430x168.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x168 "$(tdir_msp430x168)" msp430all
+emsp430x169.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x169 "$(tdir_msp430x169)" msp430all
+emsp430x1610.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1610 "$(tdir_msp430x1610)" msp430all
+emsp430x1611.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1611 "$(tdir_msp430x1611)" msp430all
+emsp430x1612.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x1612 "$(tdir_msp430x1612)" msp430all
+emsp430x2101.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2101 "$(tdir_msp430x2101)" msp430all
+emsp430x2111.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2111 "$(tdir_msp430x2111)" msp430all
+emsp430x2121.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2121 "$(tdir_msp430x2121)" msp430all
+emsp430x2131.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x2131 "$(tdir_msp430x2131)" msp430all
+emsp430x311.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x311 "$(tdir_msp430x311)" msp430all
+emsp430x312.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x312 "$(tdir_msp430x312)" msp430all
+emsp430x313.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x313 "$(tdir_msp430x313)" msp430all
+emsp430x314.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x314 "$(tdir_msp430x314)" msp430all
+emsp430x315.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x315 "$(tdir_msp430x315)" msp430all
+emsp430x323.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x323 "$(tdir_msp430x323)" msp430all
+emsp430x325.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x325 "$(tdir_msp430x325)" msp430all
+emsp430x336.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x336 "$(tdir_msp430x336)" msp430all
+emsp430x337.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430_3.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x337 "$(tdir_msp430x337)" msp430all
+emsp430x412.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x412 "$(tdir_msp430x412)" msp430all
+emsp430x413.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x413 "$(tdir_msp430x413)" msp430all
+emsp430x415.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x415 "$(tdir_msp430x415)" msp430all
+emsp430x417.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x417 "$(tdir_msp430x417)" msp430all
+emsp430xE423.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE423 "$(tdir_msp430xE423)" msp430all
+emsp430xE425.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE425 "$(tdir_msp430xE425)" msp430all
+emsp430xE427.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xE427 "$(tdir_msp430xE427)" msp430all
+emsp430xW423.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xW423 "$(tdir_msp430xW423)" msp430all
+emsp430xW425.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xW425 "$(tdir_msp430xW425)" msp430all
+emsp430xW427.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xW427 "$(tdir_msp430xW427)" msp430all
+emsp430xG437.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG437 "$(tdir_msp430xG437)" msp430all
+emsp430xG438.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG438 "$(tdir_msp430xG438)" msp430all
+emsp430xG439.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430xG439 "$(tdir_msp430xG439)" msp430all
+emsp430x435.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x435 "$(tdir_msp430x435)" msp430all
+emsp430x436.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x436 "$(tdir_msp430x436)" msp430all
+emsp430x437.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x437 "$(tdir_msp430x437)" msp430all
+emsp430x447.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x447 "$(tdir_msp430x447)" msp430all
+emsp430x448.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x448 "$(tdir_msp430x448)" msp430all
+emsp430x449.c: $(srcdir)/emulparams/msp430all.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf32msp430.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} msp430x449 "$(tdir_msp430x449)" msp430all
+enews.c: $(srcdir)/emulparams/news.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} news "$(tdir_news)"
+ens32knbsd.c:	$(srcdir)/emulparams/ns32knbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/netbsd.em \
+  $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} ns32knbsd "$(tdir_ns32knbsd)"
+eor32.c: $(srcdir)/emulparams/or32.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/or32.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} or32 "$(tdir_or32)"
+eor32elf.c: $(srcdir)/emulparams/or32elf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} or32elf "$(tdir_or32elf)"
+epc532macha.c: $(srcdir)/emulparams/pc532macha.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} pc532macha "$(tdir_pc532macha)"
+epdp11.c: $(srcdir)/emulparams/pdp11.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} pdp11 "$(tdir_pdp11)"
+epjelf.c: $(srcdir)/emulparams/pjelf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} pjelf "$(tdir_pjelf)"
+epjlelf.c: $(srcdir)/emulparams/pjlelf.sh $(srcdir)/emulparams/pjelf.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} pjlelf "$(tdir_pjlelf)"
+eppcmacos.c:	$(srcdir)/emulparams/ppcmacos.sh \
+  $(srcdir)/emultempl/aix.em $(srcdir)/scripttempl/aix.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} ppcmacos "$(tdir_ppcmacos)"
+eppcnw.c:	$(srcdir)/emulparams/ppcnw.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/nw.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} ppcnw "$(tdir_ppcnw)"
+eppcpe.c: $(srcdir)/emulparams/ppcpe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/ppcpe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} ppcpe "$(tdir_ppcpe)"
+eppclynx.c: $(srcdir)/emulparams/ppclynx.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} ppclynx "$(tdir_ppclynx)"
+eriscix.c: $(srcdir)/emulparams/riscix.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} riscix "$(tdir_riscix)"
+escore3_elf.c: $(srcdir)/emulparams/scoreelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/scoreelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS} 
+	${GENSCRIPTS} score3_elf "$(tdir_score3_elf)" scoreelf 
+escore7_elf.c: $(srcdir)/emulparams/scoreelf.sh \
+  $(ELF_DEPS) $(srcdir)/emultempl/scoreelf.em \
+  $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS} 
+	${GENSCRIPTS} score7_elf "$(tdir_score7_elf)" scoreelf
+esh.c: $(srcdir)/emulparams/sh.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/sh.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sh "$(tdir_sh)"
+eshelf.c: $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf "$(tdir_shelf)"
+eshelf32.c: $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf32 "$(tdir_shelf32)"
+eshelf32_linux.c: $(srcdir)/emulparams/shelf32_linux.sh \
+  $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf32_linux "$(tdir_shelf32_linux)"
+eshelf32_nbsd.c: $(srcdir)/emulparams/shelf32_nbsd.sh \
+  $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf32_nbsd "$(tdir_shelf32_nbsd)"
+eshelf64.c: $(srcdir)/emulparams/shelf64.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf64 "$(tdir_shelf64)"
+eshelf64_nbsd.c: $(srcdir)/emulparams/shelf64_nbsd.sh \
+  $(srcdir)/emulparams/shelf32_nbsd.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf64_nbsd "$(tdir_shelf64_nbsd)"
+eshelf_linux.c: $(srcdir)/emulparams/shelf_linux.sh \
+  $(srcdir)/emulparams/shlelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf_linux "$(tdir_shelf_linux)"
+eshlelf_linux.c: $(srcdir)/emulparams/shlelf_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf_linux "$(tdir_shlelf_linux)"
+eshelf_nbsd.c: $(srcdir)/emulparams/shelf_nbsd.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf_nbsd "$(tdir_shelf_nbsd)"
+eshelf_nto.c: $(srcdir)/emulparams/shelf_nto.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf_nto "$(tdir_shelf_nto)"
+eshelf_vxworks.c: $(srcdir)/emulparams/shelf_vxworks.sh \
+  $(srcdir)/emulparams/vxworks.sh $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc \
+  $(srcdir)/emultempl/vxworks.em ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf_vxworks "$(tdir_shelf_vxworks)"
+eshlelf_nbsd.c: $(srcdir)/emulparams/shlelf_nbsd.sh \
+  $(srcdir)/emulparams/shelf_nbsd.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf_nbsd "$(tdir_shlelf_nbsd)"
+eshlelf_nto.c: $(srcdir)/emulparams/shlelf_nto.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf_nto "$(tdir_shlelf_nto)"
+eshlelf_vxworks.c: $(srcdir)/emulparams/shlelf_vxworks.sh \
+  $(srcdir)/emulparams/shelf_vxworks.sh $(srcdir)/emulparams/vxworks.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc $(srcdir)/emultempl/vxworks.em \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf_vxworks "$(tdir_shlelf_vxworks)"
+eshelf_uclinux.c: $(srcdir)/emulparams/shelf_uclinux.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shelf_uclinux "$(tdir_shelf_uclinux)"
+eshlelf.c: $(srcdir)/emulparams/shlelf.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf "$(tdir_shlelf)"
+eshlsymbian.c: $(srcdir)/emulparams/shlsymbian.sh \
+  $(srcdir)/emulparams/shelf.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf32sh-symbian.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlsymbian "$(tdir_shlelf)"
+eshlelf32.c: $(srcdir)/emulparams/shlelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h $(srcdir)/emulparams/shelf32.sh \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf32 "$(tdir_shlelf32)"
+eshlelf32_linux.c: $(srcdir)/emulparams/shlelf32_linux.sh \
+  $(srcdir)/emulparams/shelf32_linux.sh $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf32_linux "$(tdir_shlelf32_linux)"
+eshlelf32_nbsd.c: $(srcdir)/emulparams/shlelf32_nbsd.sh \
+  $(srcdir)/emulparams/shelf32_nbsd.sh $(srcdir)/emulparams/shelf32.sh \
+  $(BFDDIR)/libbfd.h $(INCDIR)/libiberty.h \
+  $(srcdir)/emultempl/sh64elf.em $(INCDIR)/elf/sh.h $(BFDDIR)/elf-bfd.h \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf32_nbsd "$(tdir_shlelf32_nbsd)"
+eshlelf64.c: $(srcdir)/emulparams/shlelf64.sh \
+  $(srcdir)/emulparams/shelf64.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf64 "$(tdir_shlelf64)"
+eshlelf64_nbsd.c: $(srcdir)/emulparams/shlelf64_nbsd.sh \
+  $(srcdir)/emulparams/shelf64_nbsd.sh \
+  $(srcdir)/emulparams/shelf32_nbsd.sh $(srcdir)/emulparams/shelf32.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shlelf64_nbsd "$(tdir_shlelf64_nbsd)"
+eshl.c: $(srcdir)/emulparams/shl.sh \
+  $(srcdir)/emulparams/sh.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/sh.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shl "$(tdir_shl)"
+eshpe.c: $(srcdir)/emulparams/shpe.sh \
+  $(srcdir)/emultempl/pe.em $(srcdir)/scripttempl/pe.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} shpe "$(tdir_shl)"
+esparcaout.c: $(srcdir)/emulparams/sparcaout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sparcaout "$(tdir_sparcaout)"
+esparclinux.c: $(srcdir)/emulparams/sparclinux.sh \
+  $(srcdir)/emultempl/linux.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sparclinux "$(tdir_sparclinux)"
+esparcnbsd.c:	$(srcdir)/emulparams/sparcnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sparcnbsd "$(tdir_sparcnbsd)"
+est2000.c: $(srcdir)/emulparams/st2000.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/st2000.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} st2000 "$(tdir_st2000)"
+esun3.c: $(srcdir)/emulparams/sun3.sh \
+  $(srcdir)/emultempl/sunos.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sun3 "$(tdir_sun3)"
+esun4.c: $(srcdir)/emulparams/sun4.sh \
+  $(srcdir)/emultempl/sunos.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} sun4 "$(tdir_sun4)"
+etic30aout.c: $(srcdir)/emulparams/tic30aout.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic30aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic30aout "$(tdir_tic30aout)"
+etic30coff.c: $(srcdir)/emulparams/tic30coff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic30coff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic30coff "$(tdir_tic30coff)"
+etic3xcoff.c: $(srcdir)/emulparams/tic3xcoff.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic4xcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic3xcoff "$(tdir_tic4xcoff)"
+etic3xcoff_onchip.c: $(srcdir)/emulparams/tic3xcoff_onchip.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic4xcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic3xcoff_onchip "$(tdir_tic4xcoff)"
+etic4xcoff.c: $(srcdir)/emulparams/tic4xcoff.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic4xcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic4xcoff "$(tdir_tic4xcoff)"
+etic54xcoff.c: $(srcdir)/emulparams/tic54xcoff.sh \
+  $(srcdir)/emultempl/ticoff.em $(srcdir)/scripttempl/tic54xcoff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic54xcoff "$(tdir_tic54xcoff)"
+etic80coff.c: $(srcdir)/emulparams/tic80coff.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/tic80coff.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} tic80coff "$(tdir_tic80coff)"
+evanilla.c: $(srcdir)/emulparams/vanilla.sh \
+  $(srcdir)/emultempl/vanilla.em $(srcdir)/scripttempl/vanilla.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} vanilla "$(tdir_vanilla)"
+evax.c: $(srcdir)/emulparams/vax.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} vax "$(tdir_vax)"
+evaxnbsd.c: $(srcdir)/emulparams/vaxnbsd.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} vaxnbsd "$(tdir_vaxnbsd)"
+evsta.c: $(srcdir)/emulparams/vsta.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} vsta "$(tdir_vsta)"
+ev850.c: $(srcdir)/emulparams/v850.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/v850.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} v850 "$(tdir_v850)"
+ew65.c: $(srcdir)/emulparams/w65.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/w65.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} w65 "$(tdir_w65)"
+ez80.c: $(srcdir)/emulparams/z80.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/emultempl/z80.em \
+  $(srcdir)/scripttempl/z80.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} z80 "$(tdir_z80)"
+ez8001.c: $(srcdir)/emulparams/z8001.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/z8000.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} z8001 "$(tdir_z8001)"
+ez8002.c: $(srcdir)/emulparams/z8002.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/z8000.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} z8002 "$(tdir_z8002)"
+
+check-DEJAGNU: site.exp
+	srcroot=`cd $(srcdir) && pwd`; export srcroot; \
+	r=`pwd`; export r; \
+	LC_COLLATE=; LC_ALL=; LANG=; export LC_COLLATE LC_ALL LANG; \
+	EXPECT=$(EXPECT); export EXPECT; \
+	runtest=$(RUNTEST); \
+	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
+	  $$runtest --tool $(DEJATOOL) --srcdir $${srcroot}/testsuite \
+		CC="$(CC_FOR_TARGET)" CFLAGS="$(CFLAGS)" \
+		CXX="$(CXX_FOR_TARGET)" CXXFLAGS="$(CXXFLAGS)" \
+		CC_FOR_HOST="$(CC)" CFLAGS_FOR_HOST="$(CFLAGS)" \
+		OFILES="$(OFILES)" BFDLIB="$(TESTBFDLIB)" \
+		LIBIBERTY="$(LIBIBERTY) $(LIBINTL)" LIBS="$(LIBS)" \
+		DO_COMPARE="`echo '$(do_compare)' | sed -e 's,\\$$,,g'`" \
+		$(RUNTESTFLAGS); \
+	else echo "WARNING: could not find \`runtest'" 1>&2; :;\
+	fi
+
+# Rules for testing by relinking ld itself.
+# A similar test is in the testsuite.  This target is for ease of use
+# when porting ld.
+
+ld-partial.o: ld-new$(EXEEXT)
+	./ld-new$(EXEEXT) $(HOSTING_EMU) -o ld-partial.o -r $(OFILES)
+ld1$(EXEEXT): ld-partial.o
+	./ld-new$(EXEEXT) $(HOSTING_EMU) -o ld1$(EXEEXT) $(HOSTING_CRT0) ld-partial.o $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+ld1-full$(EXEEXT): ld-new
+	./ld-new$(EXEEXT) $(HOSTING_EMU) -o ld1-full$(EXEEXT) $(HOSTING_CRT0) $(OFILES) $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+ld2$(EXEEXT): ld1$(EXEEXT)
+	./ld1$(EXEEXT) $(HOSTING_EMU) -o ld2$(EXEEXT) $(HOSTING_CRT0) $(OFILES) $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+ld3$(EXEEXT): ld2$(EXEEXT)
+	./ld2$(EXEEXT) $(HOSTING_EMU) -o ld3$(EXEEXT) $(HOSTING_CRT0) $(OFILES) $(TESTBFDLIB) $(LIBIBERTY) $(HOSTING_LIBS) $(LIBS)
+
+bootstrap: ld3$(EXEEXT)
+	cmp ld2$(EXEEXT) ld3$(EXEEXT)
+
+.PHONY: bootstrap
+
+# A test program for C++ constructors and destructors.
+# This test is now in the testsuite.
+#
+#cdtest: cdtest-main.o cdtest-bar.o cdtest-foo.o ld.new
+#	./ld.new $(HOSTING_EMU) -o cdtest $(HOSTING_CRT0) \
+#	  cdtest-main.o cdtest-bar.o cdtest-foo.o $(HOSTING_LIBS)
+#
+#cdtest.out: cdtest
+#	./cdtest > cdtest.tmp
+#	mv cdtest.tmp cdtest.out
+#
+#cdtest-ur.o: cdtest-main.o cdtest-bar.o cdtest-foo.o ld.new
+#	./ld.new $(HOSTING_EMU) -o cdtest-ur.o -Ur cdtest-main.o \
+#	  cdtest-bar.o cdtest-foo.o
+#
+#cdtest-ur: cdtest-ur.o
+#	./ld.new $(HOSTING_EMU) -o cdtest-ur $(HOSTING_CRT0) cdtest-ur.o \
+#	  $(HOSTING_LIBS)
+#
+#cdtest-ur.out: cdtest-ur
+#	./cdtest-ur > cdtest-ur.tmp
+#	mv cdtest-ur.tmp cdtest-ur.out
+#
+#check-cdtest: cdtest.out cdtest-ur.out $(srcdir)/cdtest.exp
+#	diff $(srcdir)/cdtest.exp cdtest.out
+#	diff $(srcdir)/cdtest.exp cdtest-ur.out
+#
+#.PHONY: check-cdtest
+
+# END OF CHECK TARGETS
+
+# DOCUMENTATION TARGETS
+# Manual configuration file; not usually attached to normal configuration,
+# because almost all configs use "gen" version of manual.
+#  Set DOCVER above to change.
+configdoc.texi:	${DOCVER}-doc.texi
+	cp ${srcdir}/${DOCVER}-doc.texi ./configdoc.texi
+	chmod u+w ./configdoc.texi
+
+# Build the man page from the texinfo file
+# The sed command removes the no-adjust Nroff command so that
+# the man output looks standard.
+ld.1: $(srcdir)/ld.texinfo configdoc.texi
+	touch $@
+	-$(TEXI2POD) $(MANCONF) < $(srcdir)/ld.texinfo > ld.pod
+	-($(POD2MAN) ld.pod | \
+	        sed -e '/^.if n .na/d' > $@.T$$$$ && \
+	        mv -f $@.T$$$$ $@) || \
+	        (rm -f $@.T$$$$ && exit 1)
+	rm -f ld.pod
+mostlyclean-local:
+	-rm -rf tmpdir
+
+.PHONY: install-exec-local install-data-local
+
+install-exec-local: ld-new$(EXEEXT)
+	$(mkinstalldirs) $(DESTDIR)$(tooldir)/bin
+	n=`echo ld | sed '$(transform)'`; \
+	if [ "$(bindir)/$$n$(EXEEXT)" != "$(tooldir)/bin/ld$(EXEEXT)" ]; then \
+	  rm -f $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT); \
+	  ln $(DESTDIR)$(bindir)/$$n$(EXEEXT) $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT) >/dev/null 2>/dev/null \
+	  || $(LIBTOOL) --mode=install $(INSTALL_PROGRAM) ld-new$(EXEEXT) $(DESTDIR)$(tooldir)/bin/ld$(EXEEXT); \
+	fi
+
+install-data-local:
+	$(mkinstalldirs) $(DESTDIR)$(scriptdir)/ldscripts
+	for f in ldscripts/*; do \
+	  $(INSTALL_DATA) $$f $(DESTDIR)$(scriptdir)/$$f ; \
+	done
+diststuff: info $(EXTRA_DIST)
+
+# Both info (ld.info) and ld.1 depend on configdoc.texi.
+# But info isn't a direct target. Make info-recursive to depend on
+# ld.1 to support parallel build.
+info-recursive: ld.1
+distclean-local:
+	rm -rf ldscripts
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN binutils-2.20.1.old/ld/configure.tgt binutils-2.20.1/ld/configure.tgt
--- binutils-2.20.1.old/ld/configure.tgt	2009-08-06 12:38:03.000000000 -0500
+++ binutils-2.20.1/ld/configure.tgt	2010-04-13 09:49:42.345947864 -0500
@@ -110,7 +110,7 @@
 xscale-*-elf)		targ_emul=armelf
 			;;
 avr-*-*)		targ_emul=avr2
-			targ_extra_emuls="avr1 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6"
+			targ_extra_emuls="avr1 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega1 avrxmega2 avrxmega3 avrxmega4 avrxmega5 avrxmega6 avrxmega7"
 			;;
 bfin-*-elf)		targ_emul=elf32bfin;
 			targ_extra_emuls="elf32bfinfd"
diff -urN binutils-2.20.1.old/ld/configure.tgt.orig binutils-2.20.1/ld/configure.tgt.orig
--- binutils-2.20.1.old/ld/configure.tgt.orig	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/ld/configure.tgt.orig	2009-08-06 12:38:03.000000000 -0500
@@ -0,0 +1,713 @@
+# This is the linker target specific file.  This is invoked by the
+# autoconf generated configure script.  Putting it in a separate shell
+# file lets us skip running autoconf when modifying target specific
+# information.
+
+# This file switches on the shell variable ${targ}, and sets the
+# following shell variables:
+#  targ_emul		name of linker emulation to use
+#  targ_extra_emuls	additional linker emulations to provide
+#  targ_extra_libpath	additional linker emulations using LIB_PATH
+#  targ_extra_ofiles	additional objects needed by the emulation
+#  targ64_extra_emuls	additional linker emulations to provide if
+#  			--enable-64-bit-bfd is given or if host is 64 bit.
+#  targ64_extra_libpath	additional linker emulations using LIB_PATH if
+#  			--enable-64-bit-bfd is given or if host is 64 bit.
+#  NATIVE_LIB_DIRS	library directories to search on this host
+#			(if we are a native or sysrooted linker)
+
+targ_extra_emuls=
+targ_extra_libpath=
+targ_extra_ofiles=
+targ64_extra_emuls=
+targ64_extra_libpath=
+
+# Please try to keep this table in alphabetic order - it makes it
+# much easier to lookup a specific archictecture.  Naturally any
+# architecture variants should be kept together even if their names
+# break the alpha sorting.
+case "${targ}" in
+alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu)
+		        targ_emul=elf64alpha_fbsd
+			targ_extra_emuls="elf64alpha alpha"
+			tdir_alpha=`echo ${targ_alias} | sed -e 's/freebsd/freebsdecoff/'` ;;
+alpha*-*-linuxecoff*)	targ_emul=alpha targ_extra_emuls=elf64alpha
+			tdir_elf64alpha=`echo ${targ_alias} | sed -e 's/ecoff//'` ;;
+alpha*-*-linux-*)	targ_emul=elf64alpha targ_extra_emuls=alpha
+			tdir_alpha=`echo ${targ_alias} | sed -e 's/linux/linuxecoff/'` ;;
+alpha*-*-osf*)		targ_emul=alpha ;;
+alpha*-*-gnu*)		targ_emul=elf64alpha ;;
+alpha*-*-netware*)	targ_emul=alpha ;;
+alpha*-*-netbsd*)	targ_emul=elf64alpha_nbsd ;;
+alpha*-*-openbsd*)	targ_emul=elf64alpha
+			;;
+arc-*-elf*)		targ_emul=arcelf
+			;;
+arm-epoc-pe)		targ_emul=arm_epoc_pe ;	targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+arm*-*-cegcc*)		targ_emul=arm_wince_pe ; targ_extra_ofiles="deffilep.o pe-dll.o"
+			LIB_PATH='${tooldir}/lib/w32api' ;;
+arm-wince-pe | arm-*-wince | arm*-*-mingw32ce*)
+			targ_emul=arm_wince_pe ; targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+arm-*-pe)		targ_emul=armpe ; targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+arm-*-aout | armel-*-aout) targ_emul=armaoutl ;;
+armeb-*-aout)		targ_emul=armaoutb ;;
+arm-*-coff)		targ_emul=armcoff ;;
+arm-*-freebsd* | arm-*-kfreebsd*-gnu)
+	       		targ_emul=armelf_fbsd
+			targ_extra_emuls="armelf" ;;
+armeb-*-netbsdelf*)	targ_emul=armelfb_nbsd;
+			targ_extra_emuls="armelf_nbsd armelf armnbsd" ;;
+arm-*-netbsdelf*)	targ_emul=armelf_nbsd;
+			targ_extra_emuls="armelfb_nbsd armelf armnbsd" ;;
+arm-*-netbsd*)		targ_emul=armnbsd;
+			targ_extra_emuls="armelf armelf_nbsd armelfb_nbsd"  ;;
+arm-*-nto*)		targ_emul=armnto ;;
+arm-*-openbsd*)		targ_emul=armnbsd ;;
+arm-*-rtems*)		targ_emul=armelf ;;
+armeb-*-elf)		targ_emul=armelfb ;;
+arm-*-elf | arm*-*-eabi*)
+	  		targ_emul=armelf ;;
+arm*-*-symbianelf*)     targ_emul=armsymbian;;
+arm-*-kaos*)		targ_emul=armelf ;;
+arm9e-*-elf)		targ_emul=armelf ;;
+arm*b-*-linux-*eabi)	targ_emul=armelfb_linux_eabi
+			targ_extra_emuls=armelf_linux_eabi
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+arm*b-*-linux-*)	targ_emul=armelfb_linux
+			targ_extra_emuls="armelfb armelf armelf_linux"
+			targ_extra_libpath="armelf_linux"
+			;;
+arm*-*-linux-*eabi)	targ_emul=armelf_linux_eabi
+			targ_extra_emuls=armelfb_linux_eabi
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+arm*-*-linux-*)	        targ_emul=armelf_linux
+			targ_extra_emuls="armelf armelfb armelfb_linux"
+			targ_extra_libpath="armelfb_linux"
+			;;
+arm*-*-uclinux*eabi)	targ_emul=armelf_linux_eabi
+			targ_extra_emuls=armelfb_linux_eabi
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+arm*-*-uclinux*)	targ_emul=armelf_linux
+			targ_extra_emuls="armelf armelfb armelfb_linux"
+			targ_extra_libpath="armelfb_linux"
+			;;
+arm-*-vxworks)		targ_emul=armelf_vxworks ;;
+arm*-*-conix*)		targ_emul=armelf ;;
+thumb-*-linux-* | thumb-*-uclinux*)	targ_emul=armelf_linux; targ_extra_emuls=armelf ;;
+strongarm-*-coff)	targ_emul=armcoff ;;
+strongarm-*-elf)	targ_emul=armelf ;;
+strongarm-*-kaos*)	targ_emul=armelf ;;
+thumb-*-coff)		targ_emul=armcoff ;;
+thumb-*-elf)		targ_emul=armelf ;;
+thumb-epoc-pe)		targ_emul=arm_epoc_pe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+thumb-*-pe)		targ_emul=armpe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+xscale-*-coff)		targ_emul=armcoff ;;
+xscale-*-elf)		targ_emul=armelf
+			;;
+avr-*-*)		targ_emul=avr2
+			targ_extra_emuls="avr1 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6"
+			;;
+bfin-*-elf)		targ_emul=elf32bfin;
+			targ_extra_emuls="elf32bfinfd"
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+bfin-*-rtems*)		targ_emul=elf32bfin;
+			targ_extra_emuls="elf32bfinfd"
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+bfin-*-uclinux*)	targ_emul=elf32bfin;
+			targ_extra_emuls="elf32bfinfd"
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+bfin-*-linux-uclibc*)	targ_emul=elf32bfinfd;
+			targ_extra_emuls="elf32bfin"
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+cr16-*-elf*)            targ_emul=elf32cr16 ;;
+cr16c-*-elf*)           targ_emul=elf32cr16c
+			;;
+cris-*-*aout*)		targ_emul=crisaout
+			targ_extra_emuls="criself crislinux"
+			targ_extra_libpath=$targ_extra_emuls ;;
+cris-*-linux-* | crisv32-*-linux-*)
+			targ_emul=crislinux ;;
+cris-*-* | crisv32-*-*)	targ_emul=criself
+			targ_extra_emuls="crisaout crislinux"
+			targ_extra_libpath=$targ_extra_emuls
+			;;
+crx-*-elf*)		targ_emul=elf32crx
+			;;
+d10v-*-*)		targ_emul=d10velf ;;
+d30v-*-*ext*)		targ_emul=d30v_e; targ_extra_emuls="d30velf d30v_o" ;;
+d30v-*-*onchip*)	targ_emul=d30v_o; targ_extra_emuls="d30velf d30v_e" ;;
+d30v-*-*)		targ_emul=d30velf; targ_extra_emuls="d30v_e d30v_o"
+			;;
+dlx-*-elf*)		targ_emul=elf32_dlx
+			;;
+fido*-*-elf*)		targ_emul=m68kelf ;;
+fr30-*-*)		targ_emul=elf32fr30
+			;;
+frv-*-*linux*)		targ_emul=elf32frvfd ;;
+frv-*-*)		targ_emul=elf32frv ; targ_extra_emuls="elf32frvfd"
+			;;
+moxie-*-*)		targ_emul=elf32moxie 
+			;;
+h8300-*-hms* | h8300-*-coff* | h8300-*-rtemscoff*)
+			targ_emul=h8300; targ_extra_emuls="h8300h h8300s h8300hn h8300sn h8300sx h8300sxn" ;;
+h8300-*-elf* | h8300-*-rtems*)
+			targ_emul=h8300elf;
+			targ_extra_emuls="h8300helf h8300self h8300hnelf h8300snelf h8300sxelf h8300sxnelf" ;;
+h8500-*-hms* | h8500-*-coff* | h8500-*-rtems*)
+			targ_emul=h8500
+			targ_extra_emuls="h8500s h8500b h8500m h8500c"
+			;;
+hppa*64*-*-linux-*)	targ_emul=hppa64linux ;;
+hppa*64*-hpux*)		targ_emul=elf64hppa ;;
+hppa*-*-linux-*)	targ_emul=hppalinux ;;
+hppa*-*-*elf*)		targ_emul=hppaelf ;;
+hppa*-*-lites*)		targ_emul=hppaelf ;;
+hppa*-*-netbsd*)	targ_emul=hppanbsd ;;
+hppa*-*-openbsd*)	targ_emul=hppaobsd
+			;;
+i370-*-elf* | i370-*-linux-*) targ_emul=elf32i370
+			;;
+i[3-7]86-*-nto-qnx*)	targ_emul=i386nto ;;
+i[3-7]86-*-vsta)	targ_emul=vsta ;;
+i[3-7]86-*-go32)	targ_emul=i386go32 ;;
+i[3-7]86-*-msdosdjgpp*) targ_emul=i386go32 ;;
+i[3-7]86-*-aix*)	targ_emul=i386coff ;;
+i[3-7]86-*-sco*)	targ_emul=i386coff ;;
+i[3-7]86-*-isc*)	targ_emul=i386coff ;;
+i[3-7]86-*-lynxos*)	targ_emul=i386lynx ;;
+i[3-7]86-*-coff)	targ_emul=i386coff ;;
+i[3-7]86-*-rtems*)	targ_emul=elf_i386 ;;
+i[3-7]86-*-aros*)	targ_emul=elf_i386 ;;
+i[3-7]86-*-rdos*)	targ_emul=elf_i386 ;;
+i[3-7]86-*-bsd)		targ_emul=i386bsd ;;
+i[3-7]86-*-bsd386)	targ_emul=i386bsd ;;
+i[3-7]86-*-bsdi*)	targ_emul=i386bsd ;;
+i[3-7]86-*-aout)	targ_emul=i386aout ;;
+i[3-7]86-*-linux*aout*)	targ_emul=i386linux
+			targ_extra_emuls=elf_i386
+			tdir_elf_i386=`echo ${targ_alias} | sed -e 's/aout//'` ;;
+i[3-7]86-*-linux*oldld)	targ_emul=i386linux; targ_extra_emuls=elf_i386 ;;
+i[3-7]86-*-linux-*)	targ_emul=elf_i386
+			targ_extra_emuls=i386linux
+			targ64_extra_emuls="elf_x86_64 elf_l1om"
+			targ64_extra_libpath=elf_x86_64
+			tdir_i386linux=${targ_alias}aout ;;
+x86_64-*-linux-*)	targ_emul=elf_x86_64
+			targ_extra_emuls="elf_i386 i386linux elf_l1om"
+			targ_extra_libpath=elf_i386
+			tdir_i386linux=`echo ${targ_alias}aout | sed -e 's/x86_64/i386/'`
+			tdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/'` ;;
+i[3-7]86-*-sysv[45]*)	targ_emul=elf_i386 ;;
+i[3-7]86-*-solaris2*)	targ_emul=elf_i386_ldso
+                        targ_extra_emuls="elf_i386 elf_x86_64 elf_l1om"
+			targ_extra_libpath=$targ_extra_emuls
+                        ;;
+x86_64-*-solaris2*)
+			targ_emul=elf_x86_64
+			targ_extra_emuls="elf_i386 elf_i386_ldso elf_l1om"
+			targ_extra_libpath=elf_i386
+			tdir_elf_i386=`echo ${targ_alias} | sed -e 's/x86_64/i386/'` ;;
+i[3-7]86-*-unixware)	targ_emul=elf_i386 ;;
+i[3-7]86-*-solaris*)	targ_emul=elf_i386_ldso
+                        targ_extra_emuls="elf_i386"
+			targ_extra_libpath=$targ_extra_emuls
+                        ;;
+i[3-7]86-*-netbsdelf* | \
+i[3-7]86-*-netbsd*-gnu* | \
+i[3-7]86-*-knetbsd*-gnu)
+			targ_emul=elf_i386
+			targ_extra_emuls=i386nbsd ;;
+i[3-7]86-*-netbsdpe*)	targ_emul=i386pe
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+i[3-7]86-*-netbsd*)	targ_emul=i386nbsd
+			targ_extra_emuls=elf_i386 ;;
+x86_64-*-netbsd*)	targ_emul=elf_x86_64
+			targ_extra_emuls="elf_i386 i386nbsd elf_l1om"
+			tdir_elf_i386=`echo ${targ_alias} | \
+			    sed -e 's/x86_64/i386/'`
+			case "${tdir_elf_i386}" in
+			*-netbsdelf*)   ;;
+			*)		tdir_elf_i386=`echo ${tdir_elf_i386} | \
+				        sed -e 's/netbsd/netbsdelf/'`;;
+			esac ;;
+i[3-7]86-*-netware)	targ_emul=i386nw ;;
+i[3-7]86-*-elf*)	targ_emul=elf_i386 ;;
+x86_64-*-elf*)		targ_emul=elf_x86_64
+			targ_extra_emuls="elf_i386 elf_l1om"
+			;;
+i[3-7]86-*-kaos*)	targ_emul=elf_i386 ;;
+i[3-7]86-*-freebsdaout* | i[3-7]86-*-freebsd[12].* | i[3-7]86-*-freebsd[12])
+			targ_emul=i386bsd ;;
+i[3-7]86-*-freebsd* | i[3-7]86-*-kfreebsd*-gnu | i[3-7]86-*-dragonfly*)
+		        targ_emul=elf_i386_fbsd
+			targ_extra_emuls="elf_i386 i386bsd" ;;
+x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
+			targ_emul=elf_x86_64_fbsd
+			targ_extra_emuls="elf_i386_fbsd elf_x86_64 elf_i386 elf_l1om elf_l1om_fbsd"
+			targ_extra_libpath="elf_i386_fbsd"
+			tdir_elf_i386_fbsd=`echo ${targ_alias} \
+			    | sed -e 's/x86_64/i386/'`
+			tdir_elf_i386=`echo ${targ_alias} \
+			    | sed -e 's/x86_64/i386/'` ;;
+i[3-7]86-*-sysv*)	targ_emul=i386coff ;;
+i[3-7]86-*-ptx*)	targ_emul=i386coff ;;
+i[3-7]86-*-mach*)	targ_emul=i386mach ;;
+i[3-7]86-*-gnu*)	targ_emul=elf_i386 ;;
+i[3-7]86-*-msdos*)	targ_emul=i386msdos; targ_extra_emuls=i386aout ;;
+i[3-7]86-*-moss*)	targ_emul=i386moss; targ_extra_emuls=i386msdos ;;
+i[3-7]86-*-winnt*)	targ_emul=i386pe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+i[3-7]86-*-pe)		targ_emul=i386pe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+i[3-7]86-*-cygwin*)	targ_emul=i386pe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o"
+			test "$targ" != "$host" && LIB_PATH='${tooldir}/lib/w32api' ;;
+i[3-7]86-*-mingw32*)	targ_emul=i386pe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+x86_64-*-mingw*)	targ_emul=i386pep ;
+			targ_extra_ofiles="deffilep.o pep-dll.o" ;;
+i[3-7]86-*-interix*)	targ_emul=i386pe_posix;
+ 			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+i[3-7]86-*-beospe*)	targ_emul=i386beos ;;
+i[3-7]86-*-beos*)	targ_emul=elf_i386_be ;;
+i[3-7]86-*-vxworks*)	targ_emul=elf_i386_vxworks ;;
+i[3-7]86-*-chaos)	targ_emul=elf_i386_chaos
+			;;
+i860-*-coff)		targ_emul=coff_i860 ;;
+i860-stardent-sysv4* | i860-stardent-elf*)
+			targ_emul=elf32_i860
+			;;
+i960-wrs-vxworks5.0*)	targ_emul=gld960 ;;
+i960-wrs-vxworks5*)	targ_emul=gld960coff ;;
+i960-wrs-vxworks*)	targ_emul=gld960 ;;
+i960-*-coff)		targ_emul=gld960coff ;;
+i960-intel-nindy)	targ_emul=gld960 ;;
+i960-*-rtems*)		targ_emul=gld960coff ;;
+i960-*-elf*)		targ_emul=elf32_i960
+			;;
+ia64-*-elf*)		targ_emul=elf64_ia64 ;;
+ia64-*-freebsd* | ia64-*-kfreebsd*-gnu)
+		        targ_emul=elf64_ia64_fbsd
+			targ_extra_emuls="elf64_ia64" ;;
+ia64-*-netbsd*)		targ_emul=elf64_ia64 ;;
+ia64-*-linux*)		targ_emul=elf64_ia64 ;;
+ia64-*-aix*)		targ_emul=elf64_aix
+			;;
+ip2k-*-elf)		targ_emul=elf32ip2k
+			;;
+iq2000-*-elf)           targ_emul=elf32iq2000 ; targ_extra_emuls="elf32iq10"
+			;;
+lm32-*-*linux*)         targ_emul=elf32lm32fd ;;
+lm32-*-*)               targ_emul=elf32lm32 ; targ_extra_emuls="elf32lm32fd" 
+                        ;;
+m32c-*-elf | m32c-*-rtems*)
+			targ_emul=elf32m32c
+			;;
+m32r*le-*-elf*)         targ_emul=m32rlelf ;;
+m32r*-*-elf* | m32r*-*-rtems*)
+			targ_emul=m32relf ;;
+m32r*le-*-linux-*)      targ_emul=m32rlelf_linux ;;
+m32r*-*-linux-*)        targ_emul=m32relf_linux
+			;;
+m68hc11-*-*|m6811-*-*)	targ_emul=m68hc11elf 
+			targ_extra_emuls="m68hc11elfb m68hc12elf m68hc12elfb" ;;
+m68hc12-*-*|m6812-*-*)	targ_emul=m68hc12elf 
+			targ_extra_emuls="m68hc12elfb m68hc11elf m68hc11elfb" ;;
+m68*-sun-sunos[34]*)	targ_emul=sun3 ;;
+m68*-wrs-vxworks*)	targ_emul=sun3 ;;
+m68*-ericsson-ose)	targ_emul=sun3 ;;
+m68*-apple-aux*)	targ_emul=m68kaux ;;
+m68k-sony-*)		targ_emul=news ;;
+m68k-hp-bsd*)		targ_emul=hp300bsd ;;
+m68*-motorola-sysv*)	targ_emul=delta68 ;;
+m68*-*-aout)		targ_emul=m68kaout ;;
+m68*-*-coff)		targ_emul=m68kcoff ;;
+m68*-*-elf)		targ_emul=m68kelf ;;
+m68*-*-hpux*)		targ_emul=hp3hpux ;;
+m68k-*-linux*aout*)	targ_emul=m68klinux
+			targ_extra_emuls=m68kelf
+			tdir_m68kelf=`echo ${targ_alias} | sed -e 's/aout//'` ;;
+m68k-*-linux-*) 	targ_emul=m68kelf
+			targ_extra_emuls=m68klinux
+			tdir_m68klinux=`echo ${targ_alias} | sed -e 's/linux/linuxaout/'` ;;
+m68k-*-uclinux*)	targ_emul=m68kelf ;;
+m68*-*-gnu*)		targ_emul=m68kelf ;;
+m68*-*-netbsd*4k*)	targ_emul=m68k4knbsd
+			targ_extra_emuls="m68knbsd m68kelfnbsd" ;;
+m68*-*-netbsdelf*)	targ_emul=m68kelfnbsd
+			targ_extra_emuls="m68knbsd m68k4knbsd" ;;
+m68*-*-netbsdaout* | m68*-*-netbsd*)
+			targ_emul=m68knbsd
+			targ_extra_emuls="m68kelfnbsd m68k4knbsd" ;;
+m68*-*-psos*)		targ_emul=m68kpsos ;;
+m68*-*-rtemscoff*)	targ_emul=m68kcoff ;;
+m68*-*-rtems*)		targ_emul=m68kelf
+			;;
+m8*-*-*)		targ_emul=m88kbcs
+			;;
+maxq-*-coff)            targ_emul=maxqcoff
+			;;
+mcore-*-pe)		targ_emul=mcorepe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+mcore-*-elf)		targ_emul=elf32mcore
+			;;
+mep-*-elf)		targ_emul=elf32mep ;;
+microblaze*-linux*)
+			targ_emul="elf32mb_linux" ;;
+microblaze*)		targ_emul=elf32microblaze ;;
+mips*-*-pe)		targ_emul=mipspe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+mips*-dec-ultrix*)	targ_emul=mipslit ;;
+mips*-dec-osf*)		targ_emul=mipslit ;;
+mips*-sgi-irix5*)	targ_emul=elf32bsmip ;;
+mips*-sgi-irix6*)	targ_emul=elf32bmipn32
+	                targ_extra_emuls="elf32bsmip elf64bmip"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips*-sgi-irix*)	targ_emul=mipsbig ;;
+mips*el-*-ecoff*)	targ_emul=mipsidtl ;;
+mips*-*-ecoff*)		targ_emul=mipsidt ;;
+mips*el-*-netbsd*)	targ_emul=elf32ltsmip
+			targ_extra_emuls="elf32btsmip elf64ltsmip elf64btsmip"
+			;;
+mips*-*-netbsd*)	targ_emul=elf32btsmip
+			targ_extra_emuls="elf32ltsmip elf64btsmip elf64ltsmip"
+  			;;
+mips*-*-bsd*)		targ_emul=mipsbig ;;
+mips*vr4300el-*-elf*)	targ_emul=elf32l4300 ;;
+mips*vr4300-*-elf*)	targ_emul=elf32b4300 ;;
+mips*vr4100el-*-elf*)	targ_emul=elf32l4300 ;;
+mips*vr4100-*-elf*)	targ_emul=elf32b4300 ;;
+mips*vr5000el-*-elf*)	targ_emul=elf32l4300 ;;
+mips*vr5000-*-elf*)	targ_emul=elf32b4300 ;;
+mips*el-sde-elf*)	targ_emul=elf32ltsmip
+			targ_extra_emuls="elf32btsmip elf32ltsmipn32 elf64ltsmip elf32btsmipn32 elf64btsmip" ;;
+mips*-sde-elf*)		targ_emul=elf32btsmip
+			targ_extra_emuls="elf32ltsmip elf32btsmipn32 elf64btsmip elf32ltsmipn32 elf64ltsmip" ;;
+mips*el-*-elf*)		targ_emul=elf32elmip ;;
+mips*-*-elf*)		targ_emul=elf32ebmip ;;
+mips*-*-rtems*)		targ_emul=elf32ebmip ;;
+mips*el-*-vxworks*)	targ_emul=elf32elmipvxworks
+			targ_extra_emuls="elf32ebmipvxworks" ;;
+mips*-*-vxworks*)	targ_emul=elf32ebmipvxworks
+		        targ_extra_emuls="elf32elmipvxworks" ;;
+mips*-*-windiss)	targ_emul=elf32mipswindiss ;;
+mips64*el-*-linux-*)	targ_emul=elf32ltsmipn32
+			targ_extra_emuls="elf32btsmipn32 elf32ltsmip elf32btsmip elf64ltsmip elf64btsmip"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips64*-*-linux-*)	targ_emul=elf32btsmipn32
+			targ_extra_emuls="elf32ltsmipn32 elf32btsmip elf32ltsmip elf64btsmip elf64ltsmip"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips*el-*-linux-*)	targ_emul=elf32ltsmip
+			targ_extra_emuls="elf32btsmip elf32ltsmipn32 elf64ltsmip elf32btsmipn32 elf64btsmip"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips*-*-linux-*)	targ_emul=elf32btsmip
+			targ_extra_emuls="elf32ltsmip elf32btsmipn32 elf64btsmip elf32ltsmipn32 elf64ltsmip"
+			targ_extra_libpath=$targ_extra_emuls ;;
+mips*-*-lnews*)		targ_emul=mipslnews ;;
+mips*-*-sysv4*)         targ_emul=elf32btsmip
+			;;
+mmix-*-*)		targ_emul=mmo
+			targ_extra_emuls=elf64mmix
+			;;
+am34-*-linux*)		targ_emul=elf32am33lin ;;
+am33_2.0-*-linux*)	targ_emul=elf32am33lin ;;
+mn10200-*-*)		targ_emul=mn10200 ;;
+mn10300-*-*)		targ_emul=mn10300
+			;;
+mt-*elf)                targ_emul=elf32mt
+			;;
+msp430-*-*)             targ_emul=msp430x110
+                        targ_extra_emuls="msp430x112 msp430x1101 msp430x1111 msp430x1121 msp430x1122 msp430x1132 msp430x122 msp430x123 msp430x1222 msp430x1232 msp430x133 msp430x135 msp430x1331 msp430x1351 msp430x147 msp430x148 msp430x149 msp430x155 msp430x156 msp430x157 msp430x167 msp430x168 msp430x169 msp430x1610 msp430x1611 msp430x1612 msp430x2101 msp430x2111 msp430x2121 msp430x2131 msp430x311 msp430x312 msp430x313 msp430x314 msp430x315 msp430x323 msp430x325 msp430x336 msp430x337 msp430x412 msp430x413 msp430x415 msp430x417 msp430xE423 msp430xE425 msp430xE427 msp430xW423 msp430xW425 msp430xW427 msp430xG437 msp430xG438 msp430xG439 msp430x435 msp430x436 msp430x437 msp430x447 msp430x448 msp430x449"
+			;;
+ns32k-pc532-mach* | ns32k-pc532-ux*)  targ_emul=pc532macha ;;
+ns32k-*-netbsd* | ns32k-pc532-lites*) targ_emul=ns32knbsd
+			;;
+openrisc-*-*)		targ_emul=elf32openrisc ;;
+or32-*-coff)		targ_emul=or32 ;;
+or32-*-elf)		targ_emul=or32elf ;;
+or32-*-rtems*)          targ_emul=or32elf
+			;;
+pdp11-*-*)		targ_emul=pdp11
+			;;
+pjl*-*-*)	        targ_emul=pjlelf ; targ_extra_emuls="elf_i386" ;;
+pj*-*-*)	        targ_emul=pjelf
+			;;
+powerpc-*-freebsd* | powerpc-*-kfreebsd*-gnu)
+			targ_emul=elf32ppc_fbsd;
+			targ_extra_emuls="elf32ppc elf32ppcsim";
+			targ_extra_libpath=elf32ppc;
+			tdir_elf32ppcsim=`echo ${targ_alias} | sed -e 's/ppc/ppcsim/'` ;;
+powerpc*-*-linux*)	case "${targ}" in
+			*64*)	targ_emul=elf64ppc
+				targ_extra_emuls="elf32ppclinux elf32ppc elf32ppcsim"
+				targ_extra_libpath="elf32ppclinux elf32ppc"
+				tdir_elf32ppc=`echo "${targ_alias}" | sed -e 's/64//'`
+				tdir_elf32ppclinux=$tdir_elf32ppc
+				tdir_elf32ppcsim=$tdir_elf32ppc
+				;;
+			*)	targ_emul=elf32ppclinux
+				targ_extra_emuls="elf32ppc elf32ppcsim"
+				targ_extra_libpath=elf32ppc
+				targ64_extra_emuls=elf64ppc
+				targ64_extra_libpath=elf64ppc
+				;;
+			esac ;;
+powerpc*le-*-elf* | powerpc*le-*-eabi* | powerpc*le-*-solaris* \
+  | powerpc*le-*-sysv* | powerpc*le-*-vxworks*)
+		       case "${targ}" in
+		       *64*)	targ_emul=elf64lppc
+		       		targ_extra_emuls="elf32lppc elf32lppcsim"
+				tdir_elf32lppc=`echo "${targ_alias}" | sed -e 's/64//'`
+				tdir_elf32lppcsim=$tdir_elf32lppc
+				;;
+			*)	targ_emul=elf32lppc
+				targ_extra_emuls="elf32ppcsim" ;;
+			esac ;;
+powerpc*-*-elf* | powerpc*-*-eabi* | powerpc*-*-sysv* \
+  | powerpc*-*-netbsd* | powerpc-*-openbsd* | powerpc*-*-kaos*)
+  		       case "${targ}" in
+		       *64*)	targ_emul=elf64ppc
+		       		targ_extra_emuls="elf32ppc elf32ppclinux elf32ppcsim"
+				tdir_elf32ppc=`echo "${targ_alias}" | sed -e 's/64//'`
+				tdir_elf32ppclinux=$tdir_elf32ppc
+				tdir_elf32ppcsim=$tdir_elf32ppc
+				;;
+			*)	targ_emul=elf32ppc
+				targ_extra_emuls="elf32ppclinux elf32ppcsim" ;;
+			esac ;;
+powerpc-*-vxworks*)
+			targ_emul=elf32ppcvxworks
+			targ_extra_emuls="elf32ppc elf32ppclinux elf32ppcsim" ;;
+powerpc-*-nto*)         targ_emul=elf32ppcnto ;;
+powerpcle-*-nto*)       targ_emul=elf32lppcnto ;;
+powerpc-*-rtems*)	targ_emul=elf32ppc ;;
+powerpc-*-macos*)	targ_emul=ppcmacos ;;
+powerpc-*-netware*)	targ_emul=ppcnw ;;
+powerpcle-*-pe)         targ_emul=ppcpe ;;
+powerpcle-*-winnt*)     targ_emul=ppcpe ;;
+powerpcle-*-cygwin*)    targ_emul=ppcpe ;;
+powerpc-*-aix[5-9]*)	targ_emul=aix5ppc ;;
+powerpc-*-aix*)		targ_emul=aixppc ;;
+powerpc-*-beos*)	targ_emul=aixppc ;;
+powerpc-*-windiss*)	targ_emul=elf32ppcwindiss ;;
+powerpc-*-lynxos*)	targ_emul=ppclynx ;;
+rs6000-*-aix[5-9]*)	targ_emul=aix5rs6 ;;
+rs6000-*-aix*)		targ_emul=aixrs6
+			;;
+s390x-*-linux*)         targ_emul=elf64_s390
+			targ_extra_emuls=elf_s390
+			targ_extra_libpath=$targ_extra_emuls
+			tdir_elf_s390=`echo ${targ_alias} | sed -e 's/s390x/s390/'` ;;
+s390x-*-tpf*)		targ_emul=elf64_s390
+			tdir_elf_s390=`echo ${targ_alias} | sed -e 's/s390x/s390/'` ;;
+s390-*-linux*)          targ_emul=elf_s390
+			targ64_extra_emuls=elf64_s390
+			targ64_extra_libpath=elf64_s390
+			tdir_elf64_s390=`echo ${targ_alias} | sed -e 's/s390/s390x/'`
+			;;
+score-*-elf)            targ_emul=score7_elf
+			targ_extra_emuls=score3_elf ;;
+sh-*-linux*)		targ_emul=shlelf_linux
+			targ_extra_emuls=shelf_linux
+			targ_extra_libpath=shelf_linux ;;
+sh64eb-*-linux*)	targ_emul=shelf32_linux
+			targ_extra_emuls="shlelf32_linux" ;;
+sh64-*-linux*)		targ_emul=shlelf32_linux
+			targ_extra_emuls="shelf32_linux"
+			targ_extra_libpath=shelf32_linux ;;
+sh*eb-*-linux*)		targ_emul=shelf_linux ;;
+sh*-*-linux*)		targ_emul=shlelf_linux ;;
+sh5le-*-netbsd*)	targ_emul=shlelf32_nbsd
+			targ_extra_emuls="shelf32_nbsd shelf64_nbsd shlelf64_nbsd shelf_nbsd shlelf_nbsd" ;;
+sh5-*-netbsd*)		targ_emul=shelf32_nbsd
+			targ_extra_emuls="shlelf32_nbsd shelf64_nbsd shlelf64_nbsd shelf_nbsd shlelf_nbsd" ;;
+sh64le-*-netbsd*)	targ_emul=shlelf64_nbsd
+			targ_extra_emuls="shelf64_nbsd shelf32_nbsd shlelf32_nbsd shelf_nbsd shlelf_nbsd" ;;
+sh64-*-netbsd*)		targ_emul=shelf64_nbsd
+			targ_extra_emuls="shlelf64_nbsd shelf32_nbsd shlelf32_nbsd shelf_nbsd shlelf_nbsd" ;;
+sh*l*-*-netbsdelf*)	targ_emul=shlelf_nbsd
+			targ_extra_emuls=shelf_nbsd ;;
+sh*-*-netbsdelf*)	targ_emul=shelf_nbsd
+			targ_extra_emuls=shlelf_nbsd ;;
+sh*-*-symbianelf*)	targ_emul=shlsymbian ;;
+shle*-*-elf* | sh[1234]*le*-*-elf | shle*-*-kaos*)
+			targ_emul=shlelf
+			targ_extra_emuls="shelf shl sh"	;;
+sh-*-rtemscoff*)	targ_emul=sh; targ_extra_emuls=shl ;;
+sh-*-elf* | sh[1234]*-*-elf | sh-*-rtems* | sh-*-kaos*)
+			targ_emul=shelf
+			targ_extra_emuls="shlelf sh shl" ;;
+sh-*-uclinux* | sh[12]-*-uclinux*)
+			targ_emul=shelf_uclinux
+			targ_extra_emuls="shelf shlelf sh shl" ;;
+sh-*-vxworks)		targ_emul=shelf_vxworks
+			targ_extra_emuls=shlelf_vxworks ;;
+sh-*-nto*)		targ_emul=shelf_nto
+			targ_extra_emuls=shlelf_nto ;;
+sh-*-pe)		targ_emul=shpe ;
+			targ_extra_ofiles="deffilep.o pe-dll.o" ;;
+sh-*-*)			targ_emul=sh; targ_extra_emuls=shl ;;
+sh64le-*-elf*)		targ_emul=shlelf
+			targ_extra_emuls="shelf shlelf32 shelf32 shlelf64 shelf64"
+			targ_extra_libpath=$targ_extra_emuls ;;
+sh64-*-elf*)		targ_emul=shelf
+			targ_extra_emuls="shlelf shelf32 shlelf32 shelf64 shlelf64"
+			targ_extra_libpath=$targ_extra_emuls ;;
+sparc64-*-aout*)	targ_emul=sparcaout ;;
+sparc64-*-elf*)		targ_emul=elf64_sparc ;;
+sparc-sun-sunos4*) 	targ_emul=sun4 ;;
+sparclite*-*-elf)	targ_emul=elf32_sparc ;;
+sparclite*-*-coff)	targ_emul=coff_sparc ;;
+sparclite*-fujitsu-*)	targ_emul=sparcaout ;;
+sparc*-*-aout)		targ_emul=sparcaout ;;
+sparc*-*-coff)		targ_emul=coff_sparc ;;
+sparc*-*-elf)		targ_emul=elf32_sparc ;;
+sparc*-*-sysv4*)	targ_emul=elf32_sparc ;;
+sparc*-*-vxworks*)	targ_emul=elf32_sparc_vxworks ;;
+sparc64-*-freebsd* | sparcv9-*-freebsd* | sparc64-*-kfreebsd*-gnu | sparcv9-*-kfreebsd*-gnu)
+			targ_emul=elf64_sparc_fbsd
+			targ_extra_emuls="elf64_sparc elf32_sparc"
+			targ_extra_libpath=$targ_extra_emuls
+			tdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/64//'`	;;
+sparc*-*-linux*aout*)	targ_emul=sparclinux
+			targ_extra_emuls="elf32_sparc sun4"
+			tdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/aout//'`
+			tdir_sun4=sparc-sun-sunos4 ;;
+sparc64-*-linux-*)	targ_emul=elf64_sparc
+			targ_extra_emuls="elf32_sparc sparclinux sun4"
+			targ_extra_libpath=elf32_sparc
+			tdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/64//'`
+			tdir_sparclinux=${tdir_elf32_sparc}aout
+			tdir_sun4=sparc-sun-sunos4 ;;
+sparc*-*-linux-*)	targ_emul=elf32_sparc
+			targ_extra_emuls="sparclinux elf64_sparc sun4"
+			targ_extra_libpath=elf64_sparc
+			tdir_sparclinux=${targ_alias}aout
+			tdir_elf64_sparc=`echo ${targ_alias} | sed -e 's/32//'`
+			tdir_sun4=sparc-sun-sunos4 ;;
+sparc64-*-netbsd* | sparc64-*-openbsd*)
+			targ_emul=elf64_sparc
+			targ_extra_emuls="elf32_sparc" ;;
+sparc*-*-netbsd*elf*)	targ_emul=elf32_sparc ;;
+sparc*-*-netbsd*)	targ_emul=sparcnbsd ;;
+sparc-*-solaris2.[0-6] | sparc-*-solaris2.[0-6].*)
+			targ_emul=elf32_sparc ;;
+sparc-*-solaris2*)	targ_emul=elf32_sparc
+			targ_extra_emuls="elf64_sparc"
+			targ_extra_libpath=$targ_extra_emuls
+			tdir_elf64_sparc=`echo ${targ_alias} | sed -e 's/32//'`	;;
+sparcv9-*-solaris2* | sparc64-*-solaris2*)
+			targ_emul=elf64_sparc
+			targ_extra_emuls="elf32_sparc"
+			targ_extra_libpath=$targ_extra_emuls
+			tdir_elf32_sparc=`echo ${targ_alias} | sed -e 's/64//'` ;;
+sparc*-*-solaris2*)	targ_emul=elf32_sparc ;;
+sparc*-wrs-vxworks*)	targ_emul=sparcaout ;;
+sparc*-*-rtems*)        targ_emul=elf32_sparc
+			;;
+spu-*-elf*)		targ_emul=elf32_spu ;;
+tic30-*-*aout*)		targ_emul=tic30aout ;;
+tic30-*-*coff*)		targ_emul=tic30coff ;;
+tic4x-*-* | c4x-*-*)    targ_emul=tic4xcoff ; targ_extra_emuls="tic3xcoff tic3xcoff_onchip" ;;
+tic54x-*-* | c54x*-*-*)	targ_emul=tic54xcoff ;;
+tic80-*-*)		targ_emul=tic80coff
+			;;
+v850-*-*)		targ_emul=v850 ;;
+v850e-*-*)		targ_emul=v850 ;;
+v850ea-*-*)		targ_emul=v850
+			;;
+vax-dec-ultrix* | vax-dec-bsd*) targ_emul=vax ;;
+vax-*-netbsdelf*)	targ_emul=elf32vax
+			targ_extra_emuls=vaxnbsd ;;
+vax-*-netbsdaout* | vax-*-netbsd*)
+			targ_emul=vaxnbsd
+			targ_extra_emuls=elf32vax ;;
+vax-*-linux-*)  	targ_emul=elf32vax
+			;;
+w65-*-*)		targ_emul=w65
+			;;
+xc16x-*-elf)		targ_emul=elf32xc16x 
+                        targ_extra_emuls="elf32xc16xl elf32xc16xs"
+                        ;;
+xstormy16-*-*)		targ_emul=elf32xstormy16
+			;;
+xtensa*-*-*)		targ_emul=elf32xtensa
+			;;
+z80-*-coff)		targ_emul=z80
+			;;
+z8k-*-coff) 		targ_emul=z8002; targ_extra_emuls=z8001
+			;;
+*-*-ieee*)		targ_emul=vanilla
+			;;
+*-tandem-none)		targ_emul=st2000
+			;;
+*)
+  echo 2>&1 "*** ld does not support target ${targ}"
+  echo 2>&1 "*** see ld/configure.tgt for supported targets"
+  exit 1
+
+esac
+
+NATIVE_LIB_DIRS='/usr/local/lib /lib /usr/lib'
+case "${target}" in
+
+*-*-freebsd* | *-*-dragonfly*)
+  NATIVE_LIB_DIRS='/lib /usr/lib /usr/local/lib'
+  ;;
+
+hppa*64*-*-hpux11*)
+  NATIVE_LIB_DIRS=/usr/lib/pa20_64
+  ;;
+
+i[3-7]86-*-sysv4*)
+  NATIVE_LIB_DIRS='/usr/local/lib /usr/ccs/lib /lib /usr/lib'
+  ;;
+
+i[3-7]86-*-solaris*)
+  NATIVE_LIB_DIRS='/usr/local/lib /usr/ccs/lib /lib /usr/lib'
+  ;;
+
+i[3-7]86-pc-interix*)
+  NATIVE_LIB_DIRS='/usr/local/lib $$INTERIX_ROOT/usr/lib /lib /usr/lib'
+  ;;
+
+ia64-*-aix*)
+  NATIVE_LIB_DIRS='/usr/local/lib /usr/lib/ia64l64 /lib /usr/lib'
+  ;;
+
+sparc*-*-solaris2*)
+  NATIVE_LIB_DIRS='/usr/local/lib /usr/ccs/lib /lib /usr/lib'
+  ;;
+
+spu-*-elf*)
+  # This allows to build a pair of PPU/SPU toolchains with common sysroot.
+  NATIVE_LIB_DIRS='/lib'
+  ;;
+
+i[03-9x]86-*-cygwin*)
+  NATIVE_LIB_DIRS='/usr/lib /usr/lib/w32api'
+  ;;
+
+*-*-linux*)
+  ;;
+
+*-*-freebsd* | *-*-dragonfly*)
+  ;;
+
+*-*-netbsd*)
+  ;;
+
+alpha*-*-*)
+  NATIVE_LIB_DIRS='/usr/local/lib /usr/ccs/lib /lib /usr/lib'
+  ;;
+
+esac
diff -urN binutils-2.20.1.old/ld/emulparams/avrxmega1.sh binutils-2.20.1/ld/emulparams/avrxmega1.sh
--- binutils-2.20.1.old/ld/emulparams/avrxmega1.sh	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/ld/emulparams/avrxmega1.sh	2010-04-13 09:49:42.345947864 -0500
@@ -0,0 +1,12 @@
+ARCH=avr:101
+MACHINE=
+SCRIPT_NAME=avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
+
+TEXT_LENGTH=1024K
+DATA_ORIGIN=0x802000
+DATA_LENGTH=0xffa0
+EXTRA_EM_FILE=avrelf
diff -urN binutils-2.20.1.old/ld/emulparams/avrxmega2.sh binutils-2.20.1/ld/emulparams/avrxmega2.sh
--- binutils-2.20.1.old/ld/emulparams/avrxmega2.sh	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/ld/emulparams/avrxmega2.sh	2010-04-13 09:49:42.345947864 -0500
@@ -0,0 +1,12 @@
+ARCH=avr:102
+MACHINE=
+SCRIPT_NAME=avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
+
+TEXT_LENGTH=1024K
+DATA_ORIGIN=0x802000
+DATA_LENGTH=0xffa0
+EXTRA_EM_FILE=avrelf
diff -urN binutils-2.20.1.old/ld/emulparams/avrxmega3.sh binutils-2.20.1/ld/emulparams/avrxmega3.sh
--- binutils-2.20.1.old/ld/emulparams/avrxmega3.sh	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/ld/emulparams/avrxmega3.sh	2010-04-13 09:49:42.345947864 -0500
@@ -0,0 +1,12 @@
+ARCH=avr:103
+MACHINE=
+SCRIPT_NAME=avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
+
+TEXT_LENGTH=1024K
+DATA_ORIGIN=0x802000
+DATA_LENGTH=0xffa0
+EXTRA_EM_FILE=avrelf
diff -urN binutils-2.20.1.old/ld/emulparams/avrxmega4.sh binutils-2.20.1/ld/emulparams/avrxmega4.sh
--- binutils-2.20.1.old/ld/emulparams/avrxmega4.sh	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/ld/emulparams/avrxmega4.sh	2010-04-13 09:49:42.345947864 -0500
@@ -0,0 +1,12 @@
+ARCH=avr:104
+MACHINE=
+SCRIPT_NAME=avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
+
+TEXT_LENGTH=1024K
+DATA_ORIGIN=0x802000
+DATA_LENGTH=0xffa0
+EXTRA_EM_FILE=avrelf
diff -urN binutils-2.20.1.old/ld/emulparams/avrxmega5.sh binutils-2.20.1/ld/emulparams/avrxmega5.sh
--- binutils-2.20.1.old/ld/emulparams/avrxmega5.sh	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/ld/emulparams/avrxmega5.sh	2010-04-13 09:49:42.345947864 -0500
@@ -0,0 +1,12 @@
+ARCH=avr:105
+MACHINE=
+SCRIPT_NAME=avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
+
+TEXT_LENGTH=1024K
+DATA_ORIGIN=0x802000
+DATA_LENGTH=0xffa0
+EXTRA_EM_FILE=avrelf
diff -urN binutils-2.20.1.old/ld/emulparams/avrxmega6.sh binutils-2.20.1/ld/emulparams/avrxmega6.sh
--- binutils-2.20.1.old/ld/emulparams/avrxmega6.sh	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/ld/emulparams/avrxmega6.sh	2010-04-13 09:49:42.345947864 -0500
@@ -0,0 +1,12 @@
+ARCH=avr:106
+MACHINE=
+SCRIPT_NAME=avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
+
+TEXT_LENGTH=1024K
+DATA_ORIGIN=0x802000
+DATA_LENGTH=0xffa0
+EXTRA_EM_FILE=avrelf
diff -urN binutils-2.20.1.old/ld/emulparams/avrxmega7.sh binutils-2.20.1/ld/emulparams/avrxmega7.sh
--- binutils-2.20.1.old/ld/emulparams/avrxmega7.sh	1969-12-31 18:00:00.000000000 -0600
+++ binutils-2.20.1/ld/emulparams/avrxmega7.sh	2010-04-13 09:49:42.345947864 -0500
@@ -0,0 +1,12 @@
+ARCH=avr:107
+MACHINE=
+SCRIPT_NAME=avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
+
+TEXT_LENGTH=1024K
+DATA_ORIGIN=0x802000
+DATA_LENGTH=0xffa0
+EXTRA_EM_FILE=avrelf
diff -urN binutils-2.20.1.old/ld/emultempl/avrelf.em binutils-2.20.1/ld/emultempl/avrelf.em
--- binutils-2.20.1.old/ld/emultempl/avrelf.em	2009-09-02 02:25:35.000000000 -0500
+++ binutils-2.20.1/ld/emultempl/avrelf.em	2010-04-13 09:49:42.345947864 -0500
@@ -71,8 +71,10 @@
 
   gld${EMULATION_NAME}_before_allocation ();
 
-  /* We only need stubs for the avr6 family.  */
-  if (strcmp ("${EMULATION_NAME}","avr6"))
+  /* We only need stubs for avr6, avrxmega6, and avrxmega7. */
+  if (strcmp ("${EMULATION_NAME}","avr6") 
+      && strcmp ("${EMULATION_NAME}","avrxmega6")
+      && strcmp ("${EMULATION_NAME}","avrxmega7") )
     avr_no_stubs = TRUE;
 
   avr_elf_set_global_bfd_parameters ();
diff -urN binutils-2.20.1.old/opcodes/avr-dis.c binutils-2.20.1/opcodes/avr-dis.c
--- binutils-2.20.1.old/opcodes/avr-dis.c	2008-11-06 06:03:24.000000000 -0600
+++ binutils-2.20.1/opcodes/avr-dis.c	2010-04-13 09:49:42.345947864 -0500
@@ -50,7 +50,7 @@
 
 static int
 avr_operand (unsigned int insn, unsigned int insn2, unsigned int pc, int constraint,
-             char *buf, char *comment, int regs, int *sym, bfd_vma *sym_addr)
+             char *opcode_str, char *buf, char *comment, int regs, int *sym, bfd_vma *sym_addr)
 {
   int ok = 1;
   *sym = 0;
@@ -118,8 +118,18 @@
 
     case 'z':
       *buf++ = 'Z';
-      if (insn & 0x1)
-	*buf++ = '+';
+
+      /* Check for post-increment. */
+      char *s;
+      for (s = opcode_str; *s; ++s)
+        {
+          if (*s == '+')
+            {
+              *buf++ = '+';
+              break;
+            }
+        }
+
       *buf = '\0';
       if (AVR_UNDEF_P (insn))
 	sprintf (comment, _("undefined"));
@@ -226,6 +236,10 @@
 	sprintf (comment, "%d", x);
       }
       break;
+
+    case 'E':
+      sprintf (buf, "%d", (insn >> 4) & 15);
+      break;
       
     case '?':
       *buf = '\0';
@@ -331,7 +345,8 @@
 
   if (opcode->name)
     {
-      char *op = opcode->constraints;
+      char *constraints = opcode->constraints;
+      char *opcode_str = opcode->opcode;
 
       insn2 = 0;
       ok = 1;
@@ -342,14 +357,14 @@
 	  cmd_len = 4;
 	}
 
-      if (*op && *op != '?')
+      if (*constraints && *constraints != '?')
 	{
-	  int regs = REGISTER_P (*op);
+	  int regs = REGISTER_P (*constraints);
 
-	  ok = avr_operand (insn, insn2, addr, *op, op1, comment1, 0, &sym_op1, &sym_addr1);
+	  ok = avr_operand (insn, insn2, addr, *constraints, opcode_str, op1, comment1, 0, &sym_op1, &sym_addr1);
 
-	  if (ok && *(++op) == ',')
-	    ok = avr_operand (insn, insn2, addr, *(++op), op2,
+	  if (ok && *(++constraints) == ',')
+	    ok = avr_operand (insn, insn2, addr, *(++constraints), opcode_str, op2,
 			      *comment1 ? comment2 : comment1, regs, &sym_op2, &sym_addr2);
 	}
     }
